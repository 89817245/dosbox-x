<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/hardware/vga_memory.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/hardware/vga_memory.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  Copyright (C) 2002-2020  The DOSBox Team</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  This program is free software; you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment"> *  (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *  This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment"> *  GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  You should have received a copy of the GNU General Public License along</span>
<a name="l00015"></a>00015 <span class="comment"> *  with this program; if not, write to the Free Software Foundation, Inc.,</span>
<a name="l00016"></a>00016 <span class="comment"> *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;dosbox.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;mem.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;vga.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;paging.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;pic.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;inout.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;setup.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;pc98_cg.h&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;pc98_gdc.h&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;zipfile.h&quot;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pc98_pegc_mmio[0x200] = {0}; <span class="comment">/* PC-98 memory-mapped PEGC registers at E0000h */</span>
<a name="l00037"></a>00037 uint32_t pc98_pegc_banks[2] = {0x0000,0x0000}; <span class="comment">/* bank switching offsets */</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="keyword">extern</span> <span class="keywordtype">bool</span> non_cga_ignore_oddeven;
<a name="l00040"></a>00040 <span class="keyword">extern</span> <span class="keywordtype">bool</span> non_cga_ignore_oddeven_engage;
<a name="l00041"></a>00041 <span class="keyword">extern</span> <span class="keywordtype">bool</span> enable_pc98_256color_planar;
<a name="l00042"></a>00042 <span class="keyword">extern</span> <span class="keywordtype">bool</span> enable_pc98_256color;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="preprocessor">#ifndef C_VGARAM_CHECKED</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#define C_VGARAM_CHECKED 1</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span>
<a name="l00048"></a>00048 <span class="preprocessor">#if C_VGARAM_CHECKED</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="comment">// Checked linear offset</span>
<a name="l00050"></a>00050 <span class="preprocessor">#define CHECKED(v) ((v)&amp;vga.mem.memmask)</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="comment">// Checked planar offset (latched access)</span>
<a name="l00052"></a>00052 <span class="preprocessor">#define CHECKED2(v) ((v)&amp;(vga.mem.memmask&gt;&gt;2))</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#define CHECKED(v) (v)</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#define CHECKED2(v) (v)</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>
<a name="l00058"></a>00058 <span class="preprocessor">#define CHECKED3(v) ((v)&amp;vga.mem.memmask)</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">#define CHECKED4(v) ((v)&amp;(vga.mem.memmask&gt;&gt;2))</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span>
<a name="l00061"></a>00061 <span class="preprocessor">#define TANDY_VIDBASE(_X_)  &amp;MemBase[ 0x80000 + (_X_)]</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>
<a name="l00063"></a>00063 <span class="comment">/* how much delay to add to VGA memory I/O in nanoseconds */</span>
<a name="l00064"></a>00064 <span class="keywordtype">int</span> vga_memio_delay_ns = 1000;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="keywordtype">void</span> VGAMEM_USEC_read_delay() {
<a name="l00067"></a>00067         <span class="keywordflow">if</span> (vga_memio_delay_ns &gt; 0) {
<a name="l00068"></a>00068                 Bits delaycyc = (CPU_CycleMax * vga_memio_delay_ns) / 1000000;
<a name="l00069"></a>00069 <span class="comment">//              if(GCC_UNLIKELY(CPU_Cycles &lt; 3*delaycyc)) delaycyc = 0; //Else port acces will set cycles to 0. which might trigger problem with games which read 16 bit values</span>
<a name="l00070"></a>00070                 CPU_Cycles -= delaycyc;
<a name="l00071"></a>00071                 CPU_IODelayRemoved += delaycyc;
<a name="l00072"></a>00072         }
<a name="l00073"></a>00073 }
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="keywordtype">void</span> VGAMEM_USEC_write_delay() {
<a name="l00076"></a>00076         <span class="keywordflow">if</span> (vga_memio_delay_ns &gt; 0) {
<a name="l00077"></a>00077                 Bits delaycyc = (CPU_CycleMax * vga_memio_delay_ns * 3) / (1000000 * 4);
<a name="l00078"></a>00078 <span class="comment">//              if(GCC_UNLIKELY(CPU_Cycles &lt; 3*delaycyc)) delaycyc = 0; //Else port acces will set cycles to 0. which might trigger problem with games which read 16 bit values</span>
<a name="l00079"></a>00079                 CPU_Cycles -= delaycyc;
<a name="l00080"></a>00080                 CPU_IODelayRemoved += delaycyc;
<a name="l00081"></a>00081         }
<a name="l00082"></a>00082 }
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Size&gt;
<a name="l00085"></a>00085 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> hostWrite(HostPt off, Bitu val) {
<a name="l00086"></a>00086         <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 1)
<a name="l00087"></a>00087                 host_writeb( off, (Bit8u)val );
<a name="l00088"></a>00088         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 2)
<a name="l00089"></a>00089                 host_writew( off, (Bit16u)val );
<a name="l00090"></a>00090         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 4)
<a name="l00091"></a>00091                 host_writed( off, (Bit32u)val );
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Size&gt;
<a name="l00095"></a>00095 <span class="keyword">static</span> INLINE Bitu  hostRead(HostPt off ) {
<a name="l00096"></a>00096         <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 1)
<a name="l00097"></a>00097                 <span class="keywordflow">return</span> host_readb( off );
<a name="l00098"></a>00098         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 2)
<a name="l00099"></a>00099                 <span class="keywordflow">return</span> host_readw( off );
<a name="l00100"></a>00100         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 4)
<a name="l00101"></a>00101                 <span class="keywordflow">return</span> host_readd( off );
<a name="l00102"></a>00102         <span class="keywordflow">return</span> 0;
<a name="l00103"></a>00103 }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="keywordtype">void</span> VGA_MapMMIO(<span class="keywordtype">void</span>);
<a name="l00107"></a>00107 <span class="comment">//Nice one from DosEmu</span>
<a name="l00108"></a>00108 INLINE <span class="keyword">static</span> Bit32u RasterOp(Bit32u input,Bit32u mask) {
<a name="l00109"></a>00109         <span class="keywordflow">switch</span> (vga.config.raster_op) {
<a name="l00110"></a>00110         <span class="keywordflow">case</span> 0x00:      <span class="comment">/* None */</span>
<a name="l00111"></a>00111                 <span class="keywordflow">return</span> (input &amp; mask) | (vga.latch.d &amp; ~mask);
<a name="l00112"></a>00112         <span class="keywordflow">case</span> 0x01:      <span class="comment">/* AND */</span>
<a name="l00113"></a>00113                 <span class="keywordflow">return</span> (input | ~mask) &amp; vga.latch.d;
<a name="l00114"></a>00114         <span class="keywordflow">case</span> 0x02:      <span class="comment">/* OR */</span>
<a name="l00115"></a>00115                 <span class="keywordflow">return</span> (input &amp; mask) | vga.latch.d;
<a name="l00116"></a>00116         <span class="keywordflow">case</span> 0x03:      <span class="comment">/* XOR */</span>
<a name="l00117"></a>00117                 <span class="keywordflow">return</span> (input &amp; mask) ^ vga.latch.d;
<a name="l00118"></a>00118         }
<a name="l00119"></a>00119         <span class="keywordflow">return</span> 0;
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 INLINE <span class="keyword">static</span> Bit32u ModeOperation(Bit8u val) {
<a name="l00123"></a>00123         Bit32u full;
<a name="l00124"></a>00124         <span class="keywordflow">switch</span> (vga.config.write_mode) {
<a name="l00125"></a>00125         <span class="keywordflow">case</span> 0x00:
<a name="l00126"></a>00126                 <span class="comment">// Write Mode 0: In this mode, the host data is first rotated as per the Rotate Count field, then the Enable Set/Reset mechanism selects data from this or the Set/Reset field. Then the selected Logical Operation is performed on the resulting data and the data in the latch register. Then the Bit Mask field is used to select which bits come from the resulting data and which come from the latch register. Finally, only the bit planes enabled by the Memory Plane Write Enable field are written to memory. </span>
<a name="l00127"></a>00127                 val=((val &gt;&gt; vga.config.data_rotate) | (val &lt;&lt; (8-vga.config.data_rotate)));
<a name="l00128"></a>00128                 full=ExpandTable[val];
<a name="l00129"></a>00129                 full=(full &amp; vga.config.full_not_enable_set_reset) | vga.config.full_enable_and_set_reset; 
<a name="l00130"></a>00130                 full=RasterOp(full,vga.config.full_bit_mask);
<a name="l00131"></a>00131                 <span class="keywordflow">break</span>;
<a name="l00132"></a>00132         <span class="keywordflow">case</span> 0x01:
<a name="l00133"></a>00133                 <span class="comment">// Write Mode 1: In this mode, data is transferred directly from the 32 bit latch register to display memory, affected only by the Memory Plane Write Enable field. The host data is not used in this mode. </span>
<a name="l00134"></a>00134                 full=vga.latch.d;
<a name="l00135"></a>00135                 <span class="keywordflow">break</span>;
<a name="l00136"></a>00136         <span class="keywordflow">case</span> 0x02:
<a name="l00137"></a>00137                 <span class="comment">//Write Mode 2: In this mode, the bits 3-0 of the host data are replicated across all 8 bits of their respective planes. Then the selected Logical Operation is performed on the resulting data and the data in the latch register. Then the Bit Mask field is used to select which bits come from the resulting data and which come from the latch register. Finally, only the bit planes enabled by the Memory Plane Write Enable field are written to memory. </span>
<a name="l00138"></a>00138                 full=RasterOp(FillTable[val&amp;0xF],vga.config.full_bit_mask);
<a name="l00139"></a>00139                 <span class="keywordflow">break</span>;
<a name="l00140"></a>00140         <span class="keywordflow">case</span> 0x03:
<a name="l00141"></a>00141                 <span class="comment">// Write Mode 3: In this mode, the data in the Set/Reset field is used as if the Enable Set/Reset field were set to 1111b. Then the host data is first rotated as per the Rotate Count field, then logical ANDed with the value of the Bit Mask field. The resulting value is used on the data obtained from the Set/Reset field in the same way that the Bit Mask field would ordinarily be used. to select which bits come from the expansion of the Set/Reset field and which come from the latch register. Finally, only the bit planes enabled by the Memory Plane Write Enable field are written to memory.</span>
<a name="l00142"></a>00142                 val=((val &gt;&gt; vga.config.data_rotate) | (val &lt;&lt; (8-vga.config.data_rotate)));
<a name="l00143"></a>00143                 full=RasterOp(vga.config.full_set_reset,ExpandTable[val] &amp; vga.config.full_bit_mask);
<a name="l00144"></a>00144                 <span class="keywordflow">break</span>;
<a name="l00145"></a>00145         <span class="keywordflow">default</span>:
<a name="l00146"></a>00146                 <a class="code" href="classLOG.html">LOG</a>(LOG_VGAMISC,LOG_NORMAL)(<span class="stringliteral">&quot;VGA:Unsupported write mode %d&quot;</span>,vga.config.write_mode);
<a name="l00147"></a>00147                 full=0;
<a name="l00148"></a>00148                 <span class="keywordflow">break</span>;
<a name="l00149"></a>00149         }
<a name="l00150"></a>00150         <span class="keywordflow">return</span> full;
<a name="l00151"></a>00151 }
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="keywordtype">bool</span> pc98_pegc_linear_framebuffer_enabled(<span class="keywordtype">void</span>) {
<a name="l00154"></a>00154     <span class="keywordflow">return</span> !!(pc98_pegc_mmio[0x102] &amp; 1);
<a name="l00155"></a>00155 }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="comment">// TODO: This code may have to handle 16-bit MMIO reads</span>
<a name="l00158"></a>00158 Bit8u pc98_pegc_mmio_read(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> reg) {
<a name="l00159"></a>00159     <span class="keywordflow">if</span> (reg &gt;= 0x200)
<a name="l00160"></a>00160         <span class="keywordflow">return</span> 0x00;
<a name="l00161"></a>00161 
<a name="l00162"></a>00162     <span class="keywordflow">return</span> pc98_pegc_mmio[reg];
<a name="l00163"></a>00163 }
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="comment">// TODO: This code may have to handle 16-bit MMIO writes</span>
<a name="l00166"></a>00166 <span class="keywordtype">void</span> pc98_pegc_mmio_write(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> reg,Bit8u val) {
<a name="l00167"></a>00167     <span class="keywordflow">if</span> (reg &gt;= 0x200)
<a name="l00168"></a>00168         <span class="keywordflow">return</span>;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170     Bit8u pval = pc98_pegc_mmio[reg];
<a name="l00171"></a>00171 
<a name="l00172"></a>00172     <span class="keywordflow">switch</span> (reg) {
<a name="l00173"></a>00173         <span class="keywordflow">case</span> 0x004: <span class="comment">// bank 0</span>
<a name="l00174"></a>00174             pc98_pegc_banks[0] = (val &amp; 0xFu) &lt;&lt; 15u;
<a name="l00175"></a>00175             pc98_pegc_mmio[reg] = val;
<a name="l00176"></a>00176             <span class="keywordflow">break</span>;
<a name="l00177"></a>00177         <span class="keywordflow">case</span> 0x005: <span class="comment">// unknown (WORD size write seen by bank switched (battle skin) and LFB (DOOM, DOOM2) games)</span>
<a name="l00178"></a>00178             <span class="comment">// ignore</span>
<a name="l00179"></a>00179             <span class="keywordflow">break</span>;
<a name="l00180"></a>00180         <span class="keywordflow">case</span> 0x006: <span class="comment">// bank 1</span>
<a name="l00181"></a>00181             pc98_pegc_banks[1] = (val &amp; 0xFu) &lt;&lt; 15u;
<a name="l00182"></a>00182             pc98_pegc_mmio[reg] = val;
<a name="l00183"></a>00183             <span class="keywordflow">break</span>;
<a name="l00184"></a>00184         <span class="keywordflow">case</span> 0x007: <span class="comment">// unknown (WORD size write seen by bank switched (battle skin) and LFB (DOOM, DOOM2) games)</span>
<a name="l00185"></a>00185             <span class="comment">// ignore</span>
<a name="l00186"></a>00186             <span class="keywordflow">break</span>;
<a name="l00187"></a>00187         <span class="keywordflow">case</span> 0x100: <span class="comment">// 256-color memory access  (0=packed  1=planar)</span>
<a name="l00188"></a>00188             <span class="comment">// WE DO NOT SUPPORT 256-planar MEMORY ACCESS AT THIS TIME!</span>
<a name="l00189"></a>00189             <span class="comment">// FUTURE SUPPORT IS PLANNED.</span>
<a name="l00190"></a>00190             <span class="comment">// ignore</span>
<a name="l00191"></a>00191             <span class="keywordflow">if</span> (enable_pc98_256color_planar) {
<a name="l00192"></a>00192                 val &amp;= 1;
<a name="l00193"></a>00193                 <span class="keywordflow">if</span> (val &amp; 1) {
<a name="l00194"></a>00194                     pc98_gdc_vramop |= (1 &lt;&lt; VOPBIT_PEGC_PLANAR);
<a name="l00195"></a>00195                     LOG_MSG(<span class="stringliteral">&quot;PC-98 PEGC warning: Guest application/OS attempted to enable &quot;</span>
<a name="l00196"></a>00196                             <span class="stringliteral">&quot;256-color planar mode, which is not yet fully functional&quot;</span>);
<a name="l00197"></a>00197                 }
<a name="l00198"></a>00198                 <span class="keywordflow">else</span> {
<a name="l00199"></a>00199                     pc98_gdc_vramop &amp;= ~(1 &lt;&lt; VOPBIT_PEGC_PLANAR);
<a name="l00200"></a>00200                 }
<a name="l00201"></a>00201             }
<a name="l00202"></a>00202             <span class="keywordflow">else</span> {
<a name="l00203"></a>00203                 <span class="keywordflow">if</span> (val &amp; 1)
<a name="l00204"></a>00204                     LOG_MSG(<span class="stringliteral">&quot;PC-98 PEGC warning: Guest application/OS attempted to enable &quot;</span>
<a name="l00205"></a>00205                             <span class="stringliteral">&quot;256-color planar mode, which is not enabled in your configuration&quot;</span>);
<a name="l00206"></a>00206  
<a name="l00207"></a>00207                 val = 0;
<a name="l00208"></a>00208             }
<a name="l00209"></a>00209             pc98_pegc_mmio[reg] = val;
<a name="l00210"></a>00210             <span class="keywordflow">if</span> ((val^pval)&amp;1<span class="comment">/*if bit 0 changed*/</span>)
<a name="l00211"></a>00211                 VGA_SetupHandlers();
<a name="l00212"></a>00212             <span class="keywordflow">break</span>;
<a name="l00213"></a>00213         <span class="keywordflow">case</span> 0x102: <span class="comment">// linear framebuffer (at F00000-F7FFFFh) enable/disable</span>
<a name="l00214"></a>00214             val &amp;= 1; <span class="comment">// as seen on real hardware: only bit 0 can be changed</span>
<a name="l00215"></a>00215             pc98_pegc_mmio[reg] = val;
<a name="l00216"></a>00216             <span class="keywordflow">if</span> ((val^pval)&amp;1<span class="comment">/*if bit 0 changed*/</span>)
<a name="l00217"></a>00217                 VGA_SetupHandlers();
<a name="l00218"></a>00218             <span class="comment">// FIXME: One PC-9821 laptop seems to allow bit 0 and bit 1 to be set.</span>
<a name="l00219"></a>00219             <span class="comment">//        What does bit 1 control?</span>
<a name="l00220"></a>00220             <span class="keywordflow">break</span>;
<a name="l00221"></a>00221         <span class="keywordflow">default</span>:
<a name="l00222"></a>00222             LOG_MSG(<span class="stringliteral">&quot;PC-98 PEGC warning: Unhandled write to %xh val %xh&quot;</span>,reg+0xE0000u,val);
<a name="l00223"></a>00223             <span class="keywordflow">break</span>;
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225 }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="comment">/* Gonna assume that whoever maps vga memory, maps it on 32/64kb boundary */</span>
<a name="l00228"></a>00228 
<a name="l00229"></a>00229 <span class="preprocessor">#define VGA_PAGES               (128/4)</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span><span class="preprocessor">#define VGA_PAGE_A0             (0xA0000/4096)</span>
<a name="l00231"></a>00231 <span class="preprocessor"></span><span class="preprocessor">#define VGA_PAGE_B0             (0xB0000/4096)</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span><span class="preprocessor">#define VGA_PAGE_B8             (0xB8000/4096)</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span>
<a name="l00234"></a>00234 <span class="keyword">static</span> <span class="keyword">struct </span>{
<a name="l00235"></a>00235         Bitu base, mask;
<a name="l00236"></a>00236 } vgapages;
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="keyword">static</span> <span class="keyword">inline</span> Bitu VGA_Generic_Read_Handler(PhysPt planeaddr,PhysPt rawaddr,<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> plane) {
<a name="l00239"></a>00239     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hobit_n = (vga.seq.memory_mode&amp;2<span class="comment">/*Extended Memory*/</span>) ? 16u : 14u;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241     <span class="comment">/* Sequencer Memory Mode Register (04h)</span>
<a name="l00242"></a>00242 <span class="comment">     * bits[3:3] = Chain 4 enable</span>
<a name="l00243"></a>00243 <span class="comment">     * bits[2:2] = Odd/Even Host Memory Write Addressing Disable</span>
<a name="l00244"></a>00244 <span class="comment">     * bits[1:1] = Extended memory (when EGA cards have &gt; 64KB of RAM)</span>
<a name="l00245"></a>00245 <span class="comment">     * </span>
<a name="l00246"></a>00246 <span class="comment">     * NTS: Real hardware experience says that despite the name, the Odd/Even bit affects reading as well */</span>
<a name="l00247"></a>00247     <span class="keywordflow">if</span> (!(vga.seq.memory_mode&amp;4) &amp;&amp; !non_cga_ignore_oddeven_engage)<span class="comment">/* Odd Even Host Memory Write Addressing Disable (is not set) */</span>
<a name="l00248"></a>00248         plane = (plane &amp; ~1u) + (rawaddr &amp; 1u);
<a name="l00249"></a>00249 
<a name="l00250"></a>00250     <span class="comment">/* Graphics Controller: Miscellaneous Graphics Register register (06h)</span>
<a name="l00251"></a>00251 <span class="comment">     * bits[3:2] = memory map select</span>
<a name="l00252"></a>00252 <span class="comment">     * bits[1:1] = Chain Odd/Even Enable</span>
<a name="l00253"></a>00253 <span class="comment">     * bits[0:0] = Alphanumeric Mode Disable</span>
<a name="l00254"></a>00254 <span class="comment">     *</span>
<a name="l00255"></a>00255 <span class="comment">     * http://www.osdever.net/FreeVGA/vga/graphreg.htm</span>
<a name="l00256"></a>00256 <span class="comment">     *</span>
<a name="l00257"></a>00257 <span class="comment">     * When enabled, address bit A0 (bit 0) becomes bit 0 of the plane index.</span>
<a name="l00258"></a>00258 <span class="comment">     * Then when addressing VRAM A0 is replaced by a &quot;higher order bit&quot;, which is</span>
<a name="l00259"></a>00259 <span class="comment">     * probably A14 or A16 depending on Extended Memory bit 1 in Sequencer register 04h memory mode */</span>
<a name="l00260"></a>00260     <span class="keywordflow">if</span> ((vga.gfx.miscellaneous&amp;2) &amp;&amp; !non_cga_ignore_oddeven_engage) {<span class="comment">/* Odd/Even enable */</span>
<a name="l00261"></a>00261         <span class="keyword">const</span> PhysPt mask = (vga.config.compatible_chain4 ? 0u : ~0xFFFFu) + (1u &lt;&lt; hobit_n) - 2u;
<a name="l00262"></a>00262         <span class="keyword">const</span> PhysPt hobit = (planeaddr &gt;&gt; hobit_n) &amp; 1u;
<a name="l00263"></a>00263         <span class="comment">/* 1 &lt;&lt; 14 =     0x4000</span>
<a name="l00264"></a>00264 <span class="comment">         * 1 &lt;&lt; 14 - 1 = 0x3FFF</span>
<a name="l00265"></a>00265 <span class="comment">         * 1 &lt;&lt; 14 - 2 = 0x3FFE</span>
<a name="l00266"></a>00266 <span class="comment">         * The point is to mask upper bit AND the LSB */</span>
<a name="l00267"></a>00267         planeaddr = (planeaddr &amp; mask &amp; (vga.mem.memmask &gt;&gt; 2u)) + hobit;
<a name="l00268"></a>00268     }
<a name="l00269"></a>00269     <span class="keywordflow">else</span> {
<a name="l00270"></a>00270         <span class="keyword">const</span> PhysPt mask = (vga.config.compatible_chain4 ? 0u : ~0xFFFFu) + (1u &lt;&lt; hobit_n) - 1u;
<a name="l00271"></a>00271         planeaddr &amp;= mask &amp; (vga.mem.memmask &gt;&gt; 2u);
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274     vga.latch.d=((Bit32u*)vga.mem.linear)[planeaddr];
<a name="l00275"></a>00275     <span class="keywordflow">switch</span> (vga.config.read_mode) {
<a name="l00276"></a>00276         <span class="keywordflow">case</span> 0:
<a name="l00277"></a>00277             <span class="keywordflow">return</span> (vga.latch.b[plane]);
<a name="l00278"></a>00278         <span class="keywordflow">case</span> 1:
<a name="l00279"></a>00279             <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> templatch;
<a name="l00280"></a>00280             templatch.d=(vga.latch.d &amp; FillTable[vga.config.color_dont_care]) ^ FillTable[vga.config.color_compare &amp; vga.config.color_dont_care];
<a name="l00281"></a>00281             return (Bit8u)~(templatch.b[0] | templatch.b[1] | templatch.b[2] | templatch.b[3]);
<a name="l00282"></a>00282     }
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     <span class="keywordflow">return</span> 0;
<a name="l00285"></a>00285 }
<a name="l00286"></a>00286 
<a name="l00287"></a>00287 <span class="keyword">template</span> &lt;const <span class="keywordtype">bool</span> chained&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> VGA_Generic_Write_Handler(PhysPt planeaddr,PhysPt rawaddr,Bit8u val) {
<a name="l00288"></a>00288     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hobit_n = (vga.seq.memory_mode&amp;2<span class="comment">/*Extended Memory*/</span>) ? 16u : 14u;
<a name="l00289"></a>00289     Bit32u mask = vga.config.full_map_mask;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291     <span class="comment">/* Sequencer Memory Mode Register (04h)</span>
<a name="l00292"></a>00292 <span class="comment">     * bits[3:3] = Chain 4 enable</span>
<a name="l00293"></a>00293 <span class="comment">     * bits[2:2] = Odd/Even Host Memory Write Addressing Disable</span>
<a name="l00294"></a>00294 <span class="comment">     * bits[1:1] = Extended memory (when EGA cards have &gt; 64KB of RAM)</span>
<a name="l00295"></a>00295 <span class="comment">     * </span>
<a name="l00296"></a>00296 <span class="comment">     * NTS: Real hardware experience says that despite the name, the Odd/Even bit affects reading as well */</span>
<a name="l00297"></a>00297     <span class="keywordflow">if</span> (chained) {
<a name="l00298"></a>00298         <span class="keywordflow">if</span> (!(vga.seq.memory_mode&amp;4) &amp;&amp; !non_cga_ignore_oddeven_engage)<span class="comment">/* Odd Even Host Memory Write Addressing Disable (is not set) */</span>
<a name="l00299"></a>00299             mask &amp;= 0xFF00FFu &lt;&lt; ((rawaddr &amp; 1u) * 8u);
<a name="l00300"></a>00300         <span class="keywordflow">else</span>
<a name="l00301"></a>00301             mask &amp;= 0xFFu &lt;&lt; ((rawaddr &amp; 3u) * 8u);
<a name="l00302"></a>00302     }
<a name="l00303"></a>00303     <span class="keywordflow">else</span> {
<a name="l00304"></a>00304         <span class="keywordflow">if</span> (!(vga.seq.memory_mode&amp;4) &amp;&amp; !non_cga_ignore_oddeven_engage)<span class="comment">/* Odd Even Host Memory Write Addressing Disable (is not set) */</span>
<a name="l00305"></a>00305             mask &amp;= 0xFF00FFu &lt;&lt; ((rawaddr &amp; 1u) * 8u);
<a name="l00306"></a>00306     }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     <span class="comment">/* Graphics Controller: Miscellaneous Graphics Register register (06h)</span>
<a name="l00309"></a>00309 <span class="comment">     * bits[3:2] = memory map select</span>
<a name="l00310"></a>00310 <span class="comment">     * bits[1:1] = Chain Odd/Even Enable</span>
<a name="l00311"></a>00311 <span class="comment">     * bits[0:0] = Alphanumeric Mode Disable</span>
<a name="l00312"></a>00312 <span class="comment">     *</span>
<a name="l00313"></a>00313 <span class="comment">     * http://www.osdever.net/FreeVGA/vga/graphreg.htm</span>
<a name="l00314"></a>00314 <span class="comment">     *</span>
<a name="l00315"></a>00315 <span class="comment">     * When enabled, address bit A0 (bit 0) becomes bit 0 of the plane index.</span>
<a name="l00316"></a>00316 <span class="comment">     * Then when addressing VRAM A0 is replaced by a &quot;higher order bit&quot;, which is</span>
<a name="l00317"></a>00317 <span class="comment">     * probably A14 or A16 depending on Extended Memory bit 1 in Sequencer register 04h memory mode */</span>
<a name="l00318"></a>00318     <span class="keywordflow">if</span> ((vga.gfx.miscellaneous&amp;2) &amp;&amp; !non_cga_ignore_oddeven_engage) {<span class="comment">/* Odd/Even enable */</span>
<a name="l00319"></a>00319         <span class="keyword">const</span> PhysPt mask = (vga.config.compatible_chain4 ? 0u : ~0xFFFFu) + (1u &lt;&lt; hobit_n) - 2u;
<a name="l00320"></a>00320         <span class="keyword">const</span> PhysPt hobit = (planeaddr &gt;&gt; hobit_n) &amp; 1u;
<a name="l00321"></a>00321         <span class="comment">/* 1 &lt;&lt; 14 =     0x4000</span>
<a name="l00322"></a>00322 <span class="comment">         * 1 &lt;&lt; 14 - 1 = 0x3FFF</span>
<a name="l00323"></a>00323 <span class="comment">         * 1 &lt;&lt; 14 - 2 = 0x3FFE</span>
<a name="l00324"></a>00324 <span class="comment">         * The point is to mask upper bit AND the LSB */</span>
<a name="l00325"></a>00325         planeaddr = (planeaddr &amp; mask &amp; (vga.mem.memmask &gt;&gt; 2u)) + hobit;
<a name="l00326"></a>00326     }
<a name="l00327"></a>00327     <span class="keywordflow">else</span> {
<a name="l00328"></a>00328         <span class="keyword">const</span> PhysPt mask = (vga.config.compatible_chain4 ? 0u : ~0xFFFFu) + (1u &lt;&lt; hobit_n) - 1u;
<a name="l00329"></a>00329         planeaddr &amp;= mask &amp; (vga.mem.memmask &gt;&gt; 2u);
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332     Bit32u data=ModeOperation(val);
<a name="l00333"></a>00333     <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> pixels;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     pixels.d =((Bit32u*)vga.mem.linear)[planeaddr];
<a name="l00336"></a>00336     pixels.d&amp;=~mask;
<a name="l00337"></a>00337     pixels.d|=(data &amp; mask);
<a name="l00338"></a>00338 
<a name="l00339"></a>00339     <span class="comment">/* FIXME: A better method (I think) is to have the VGA text drawing code</span>
<a name="l00340"></a>00340 <span class="comment">     *        directly reference the font data in bitplane #2 instead of</span>
<a name="l00341"></a>00341 <span class="comment">     *        this hack */</span>
<a name="l00342"></a>00342     vga.draw.font[planeaddr] = pixels.b[2];
<a name="l00343"></a>00343 
<a name="l00344"></a>00344     ((Bit32u*)vga.mem.linear)[planeaddr]=pixels.d;
<a name="l00345"></a>00345 }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="comment">// Slow accurate emulation.</span>
<a name="l00348"></a>00348 <span class="comment">// This version takes the Graphics Controller bitmask and ROPs into account.</span>
<a name="l00349"></a>00349 <span class="comment">// This is needed for demos that use the bitmask to do color combination or bitplane &quot;page flipping&quot; tricks.</span>
<a name="l00350"></a>00350 <span class="comment">// This code will kick in if running in a chained VGA mode and the graphics controller bitmask register is</span>
<a name="l00351"></a>00351 <span class="comment">// changed to anything other than 0xFF.</span>
<a name="l00352"></a>00352 <span class="comment">//</span>
<a name="l00353"></a>00353 <span class="comment">// Impact Studios &quot;Legend&quot;</span>
<a name="l00354"></a>00354 <span class="comment">//  - The rotating objects, rendered as dots, needs this hack because it uses a combination of masking off</span>
<a name="l00355"></a>00355 <span class="comment">//    bitplanes using the VGA DAC pel mask and drawing on the hidden bitplane using the Graphics Controller</span>
<a name="l00356"></a>00356 <span class="comment">//    bitmask. It also relies on loading the VGA latches with zeros as a form of &quot;overdraw&quot;. Without this</span>
<a name="l00357"></a>00357 <span class="comment">//    version the effect will instead become a glowing ball of flickering yellow/red.</span>
<a name="l00358"></a><a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">00358</a> <span class="keyword">class </span><a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">VGA_ChainedVGA_Slow_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00359"></a>00359 <span class="keyword">public</span>:
<a name="l00360"></a>00360         <a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">VGA_ChainedVGA_Slow_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00361"></a>00361         <span class="keyword">static</span> INLINE Bitu readHandler8(PhysPt addr ) {
<a name="l00362"></a>00362         <span class="comment">// planar byte offset = addr &amp; ~3u      (discard low 2 bits)</span>
<a name="l00363"></a>00363         <span class="comment">// planer index = addr &amp; 3u             (use low 2 bits as plane index)</span>
<a name="l00364"></a>00364         <span class="comment">// FIXME: Does chained mode use the lower 2 bits of the CPU address or does it use the read mode select???</span>
<a name="l00365"></a>00365         <span class="keywordflow">return</span> VGA_Generic_Read_Handler(addr&amp;~3u, addr, (Bit8u)(addr&amp;3u));
<a name="l00366"></a>00366         }
<a name="l00367"></a>00367         <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> writeHandler8(PhysPt addr, Bitu val) {
<a name="l00368"></a>00368         <span class="comment">// planar byte offset = addr &amp; ~3u      (discard low 2 bits)</span>
<a name="l00369"></a>00369         <span class="comment">// planer index = addr &amp; 3u             (use low 2 bits as plane index)</span>
<a name="l00370"></a>00370         <span class="keywordflow">return</span> VGA_Generic_Write_Handler&lt;<span class="keyword">true</span><span class="comment">/*chained*/</span>&gt;(addr&amp;~3u, addr, (Bit8u)val);
<a name="l00371"></a>00371         }
<a name="l00372"></a>00372         Bit8u readb(PhysPt addr ) {
<a name="l00373"></a>00373                 VGAMEM_USEC_read_delay();
<a name="l00374"></a>00374                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00375"></a>00375                 addr += (PhysPt)vga.svga.bank_read_full;
<a name="l00376"></a>00376 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00377"></a>00377                 return (Bit8u)readHandler8( addr );
<a name="l00378"></a>00378         }
<a name="l00379"></a>00379         Bit16u readw(PhysPt addr ) {
<a name="l00380"></a>00380                 VGAMEM_USEC_read_delay();
<a name="l00381"></a>00381                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00382"></a>00382                 addr += (PhysPt)vga.svga.bank_read_full;
<a name="l00383"></a>00383 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00384"></a>00384                 Bit16u ret = (Bit16u)(readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00385"></a>00385                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00386"></a>00386                 <span class="keywordflow">return</span> ret;
<a name="l00387"></a>00387         }
<a name="l00388"></a>00388         Bit32u readd(PhysPt addr ) {
<a name="l00389"></a>00389                 VGAMEM_USEC_read_delay();
<a name="l00390"></a>00390                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00391"></a>00391                 addr += (PhysPt)vga.svga.bank_read_full;
<a name="l00392"></a>00392 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00393"></a>00393                 Bit32u ret = (Bit32u)(readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00394"></a>00394                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00395"></a>00395                 ret     |= (readHandler8( addr+2 ) &lt;&lt; 16 );
<a name="l00396"></a>00396                 ret     |= (readHandler8( addr+3 ) &lt;&lt; 24 );
<a name="l00397"></a>00397                 <span class="keywordflow">return</span> ret;
<a name="l00398"></a>00398         }
<a name="l00399"></a>00399         <span class="keywordtype">void</span> writeb(PhysPt addr, Bit8u val ) {
<a name="l00400"></a>00400                 VGAMEM_USEC_write_delay();
<a name="l00401"></a>00401                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00402"></a>00402                 addr += (PhysPt)vga.svga.bank_write_full;
<a name="l00403"></a>00403 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00404"></a>00404                 writeHandler8( addr, val );
<a name="l00405"></a>00405         }
<a name="l00406"></a>00406         <span class="keywordtype">void</span> writew(PhysPt addr,Bit16u val) {
<a name="l00407"></a>00407                 VGAMEM_USEC_write_delay();
<a name="l00408"></a>00408                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00409"></a>00409                 addr += (PhysPt)vga.svga.bank_write_full;
<a name="l00410"></a>00410 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00411"></a>00411                 writeHandler8( addr+0, (Bit8u)(val &gt;&gt; 0u) );
<a name="l00412"></a>00412                 writeHandler8( addr+1, (Bit8u)(val &gt;&gt; 8u) );
<a name="l00413"></a>00413         }
<a name="l00414"></a>00414         <span class="keywordtype">void</span> writed(PhysPt addr,Bit32u val) {
<a name="l00415"></a>00415                 VGAMEM_USEC_write_delay();
<a name="l00416"></a>00416                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00417"></a>00417                 addr += (PhysPt)vga.svga.bank_write_full;
<a name="l00418"></a>00418 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00419"></a>00419                 writeHandler8( addr+0, (Bit8u)(val &gt;&gt; 0u) );
<a name="l00420"></a>00420                 writeHandler8( addr+1, (Bit8u)(val &gt;&gt; 8u) );
<a name="l00421"></a>00421                 writeHandler8( addr+2, (Bit8u)(val &gt;&gt; 16u) );
<a name="l00422"></a>00422                 writeHandler8( addr+3, (Bit8u)(val &gt;&gt; 24u) );
<a name="l00423"></a>00423         }
<a name="l00424"></a>00424 };
<a name="l00425"></a>00425 
<a name="l00426"></a><a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">00426</a> <span class="keyword">class </span><a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">VGA_ET4000_ChainedVGA_Slow_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00427"></a>00427 <span class="keyword">public</span>:
<a name="l00428"></a>00428         <a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">VGA_ET4000_ChainedVGA_Slow_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00429"></a>00429         <span class="keyword">static</span> INLINE Bitu readHandler8(PhysPt addr ) {
<a name="l00430"></a>00430         <span class="comment">// planar byte offset = addr &gt;&gt; 2       (shift 2 bits to the right)</span>
<a name="l00431"></a>00431         <span class="comment">// planer index = addr &amp; 3u             (use low 2 bits as plane index)</span>
<a name="l00432"></a>00432         <span class="keywordflow">return</span> VGA_Generic_Read_Handler(addr&gt;&gt;2u, addr, (Bit8u)(addr&amp;3u));
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434         <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> writeHandler8(PhysPt addr, Bitu val) {
<a name="l00435"></a>00435         <span class="comment">// planar byte offset = addr &gt;&gt; 2       (shift 2 bits to the right)</span>
<a name="l00436"></a>00436         <span class="comment">// planer index = addr &amp; 3u             (use low 2 bits as plane index)</span>
<a name="l00437"></a>00437         <span class="keywordflow">return</span> VGA_Generic_Write_Handler&lt;<span class="keyword">true</span><span class="comment">/*chained*/</span>&gt;(addr&gt;&gt;2u, addr, (Bit8u)val);
<a name="l00438"></a>00438         }
<a name="l00439"></a>00439         Bit8u readb(PhysPt addr ) {
<a name="l00440"></a>00440                 VGAMEM_USEC_read_delay();
<a name="l00441"></a>00441                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00442"></a>00442                 addr += (PhysPt)vga.svga.bank_read_full;
<a name="l00443"></a>00443 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00444"></a>00444                 return (Bit8u)readHandler8( addr );
<a name="l00445"></a>00445         }
<a name="l00446"></a>00446         Bit16u readw(PhysPt addr ) {
<a name="l00447"></a>00447                 VGAMEM_USEC_read_delay();
<a name="l00448"></a>00448                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00449"></a>00449                 addr += (PhysPt)vga.svga.bank_read_full;
<a name="l00450"></a>00450 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00451"></a>00451                 Bit16u ret = (Bit16u)(readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00452"></a>00452                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00453"></a>00453                 <span class="keywordflow">return</span> ret;
<a name="l00454"></a>00454         }
<a name="l00455"></a>00455         Bit32u readd(PhysPt addr ) {
<a name="l00456"></a>00456                 VGAMEM_USEC_read_delay();
<a name="l00457"></a>00457                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00458"></a>00458                 addr += (PhysPt)vga.svga.bank_read_full;
<a name="l00459"></a>00459 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00460"></a>00460                 Bit32u ret = (Bit32u)(readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00461"></a>00461                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00462"></a>00462                 ret     |= (readHandler8( addr+2 ) &lt;&lt; 16 );
<a name="l00463"></a>00463                 ret     |= (readHandler8( addr+3 ) &lt;&lt; 24 );
<a name="l00464"></a>00464                 <span class="keywordflow">return</span> ret;
<a name="l00465"></a>00465         }
<a name="l00466"></a>00466         <span class="keywordtype">void</span> writeb(PhysPt addr, Bit8u val ) {
<a name="l00467"></a>00467                 VGAMEM_USEC_write_delay();
<a name="l00468"></a>00468                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00469"></a>00469                 addr += (PhysPt)vga.svga.bank_write_full;
<a name="l00470"></a>00470 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00471"></a>00471                 writeHandler8( addr, val );
<a name="l00472"></a>00472         }
<a name="l00473"></a>00473         <span class="keywordtype">void</span> writew(PhysPt addr,Bit16u val) {
<a name="l00474"></a>00474                 VGAMEM_USEC_write_delay();
<a name="l00475"></a>00475                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00476"></a>00476                 addr += (PhysPt)vga.svga.bank_write_full;
<a name="l00477"></a>00477 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00478"></a>00478                 writeHandler8( addr+0, (Bit8u)(val &gt;&gt; 0u) );
<a name="l00479"></a>00479                 writeHandler8( addr+1, (Bit8u)(val &gt;&gt; 8u) );
<a name="l00480"></a>00480         }
<a name="l00481"></a>00481         <span class="keywordtype">void</span> writed(PhysPt addr,Bit32u val) {
<a name="l00482"></a>00482                 VGAMEM_USEC_write_delay();
<a name="l00483"></a>00483                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00484"></a>00484                 addr += (PhysPt)vga.svga.bank_write_full;
<a name="l00485"></a>00485 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00486"></a>00486                 writeHandler8( addr+0, (Bit8u)(val &gt;&gt; 0u) );
<a name="l00487"></a>00487                 writeHandler8( addr+1, (Bit8u)(val &gt;&gt; 8u) );
<a name="l00488"></a>00488                 writeHandler8( addr+2, (Bit8u)(val &gt;&gt; 16u) );
<a name="l00489"></a>00489                 writeHandler8( addr+3, (Bit8u)(val &gt;&gt; 24u) );
<a name="l00490"></a>00490         }
<a name="l00491"></a>00491 };
<a name="l00492"></a>00492 
<a name="l00493"></a><a class="code" href="classVGA__UnchainedVGA__Handler.html">00493</a> <span class="keyword">class </span><a class="code" href="classVGA__UnchainedVGA__Handler.html">VGA_UnchainedVGA_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00494"></a>00494 <span class="keyword">public</span>:
<a name="l00495"></a>00495         Bitu readHandler(PhysPt start) {
<a name="l00496"></a>00496         <span class="keywordflow">return</span> VGA_Generic_Read_Handler(start, start, vga.config.read_map_select);
<a name="l00497"></a>00497         }
<a name="l00498"></a>00498 <span class="keyword">public</span>:
<a name="l00499"></a>00499         Bit8u readb(PhysPt addr) {
<a name="l00500"></a>00500                 VGAMEM_USEC_read_delay();
<a name="l00501"></a>00501                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00502"></a>00502                 addr += (PhysPt)vga.svga.bank_read_full;
<a name="l00503"></a>00503 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00504"></a>00504                 return (Bit8u)readHandler(addr);
<a name="l00505"></a>00505         }
<a name="l00506"></a>00506         Bit16u readw(PhysPt addr) {
<a name="l00507"></a>00507                 VGAMEM_USEC_read_delay();
<a name="l00508"></a>00508                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00509"></a>00509                 addr += (PhysPt)vga.svga.bank_read_full;
<a name="l00510"></a>00510 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00511"></a>00511                 Bit16u ret = (Bit16u)(readHandler(addr+0) &lt;&lt; 0);
<a name="l00512"></a>00512                 ret     |= (readHandler(addr+1) &lt;&lt; 8);
<a name="l00513"></a>00513                 <span class="keywordflow">return</span>  ret;
<a name="l00514"></a>00514         }
<a name="l00515"></a>00515         Bit32u readd(PhysPt addr) {
<a name="l00516"></a>00516                 VGAMEM_USEC_read_delay();
<a name="l00517"></a>00517                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00518"></a>00518                 addr += (PhysPt)vga.svga.bank_read_full;
<a name="l00519"></a>00519 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00520"></a>00520                 Bit32u ret = (Bit32u)(readHandler(addr+0) &lt;&lt; 0);
<a name="l00521"></a>00521                 ret     |= (readHandler(addr+1) &lt;&lt; 8);
<a name="l00522"></a>00522                 ret     |= (readHandler(addr+2) &lt;&lt; 16);
<a name="l00523"></a>00523                 ret     |= (readHandler(addr+3) &lt;&lt; 24);
<a name="l00524"></a>00524                 <span class="keywordflow">return</span> ret;
<a name="l00525"></a>00525         }
<a name="l00526"></a>00526 <span class="keyword">public</span>:
<a name="l00527"></a>00527         <span class="keywordtype">void</span> writeHandler(PhysPt start, Bit8u val) {
<a name="l00528"></a>00528         VGA_Generic_Write_Handler&lt;<span class="keyword">false</span><span class="comment">/*chained*/</span>&gt;(start, start, val);
<a name="l00529"></a>00529         }
<a name="l00530"></a>00530 <span class="keyword">public</span>:
<a name="l00531"></a>00531         <a class="code" href="classVGA__UnchainedVGA__Handler.html">VGA_UnchainedVGA_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00532"></a>00532         <span class="keywordtype">void</span> writeb(PhysPt addr,Bit8u val) {
<a name="l00533"></a>00533                 VGAMEM_USEC_write_delay();
<a name="l00534"></a>00534                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00535"></a>00535                 addr += (PhysPt)vga.svga.bank_write_full;
<a name="l00536"></a>00536 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00537"></a>00537                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00538"></a>00538         }
<a name="l00539"></a>00539         <span class="keywordtype">void</span> writew(PhysPt addr,Bit16u val) {
<a name="l00540"></a>00540                 VGAMEM_USEC_write_delay();
<a name="l00541"></a>00541                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00542"></a>00542                 addr += (PhysPt)vga.svga.bank_write_full;
<a name="l00543"></a>00543 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00544"></a>00544                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00545"></a>00545                 writeHandler(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l00546"></a>00546         }
<a name="l00547"></a>00547         <span class="keywordtype">void</span> writed(PhysPt addr,Bit32u val) {
<a name="l00548"></a>00548                 VGAMEM_USEC_write_delay();
<a name="l00549"></a>00549                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00550"></a>00550                 addr += (PhysPt)vga.svga.bank_write_full;
<a name="l00551"></a>00551 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00552"></a>00552                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00553"></a>00553                 writeHandler(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l00554"></a>00554                 writeHandler(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l00555"></a>00555                 writeHandler(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l00556"></a>00556         }
<a name="l00557"></a>00557 };
<a name="l00558"></a>00558 
<a name="l00559"></a>00559 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00560"></a>00560 
<a name="l00561"></a><a class="code" href="classVGA__CGATEXT__PageHandler.html">00561</a> <span class="keyword">class </span><a class="code" href="classVGA__CGATEXT__PageHandler.html">VGA_CGATEXT_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00562"></a>00562 <span class="keyword">public</span>:
<a name="l00563"></a>00563         <a class="code" href="classVGA__CGATEXT__PageHandler.html">VGA_CGATEXT_PageHandler</a>() {
<a name="l00564"></a>00564                 flags=PFLAG_NOCODE;
<a name="l00565"></a>00565         }
<a name="l00566"></a>00566         Bit8u readb(PhysPt addr) {
<a name="l00567"></a>00567                 addr = PAGING_GetPhysicalAddress(addr) &amp; 0x3FFF;
<a name="l00568"></a>00568                 VGAMEM_USEC_read_delay();
<a name="l00569"></a>00569                 <span class="keywordflow">return</span> vga.tandy.mem_base[addr];
<a name="l00570"></a>00570         }
<a name="l00571"></a>00571         <span class="keywordtype">void</span> writeb(PhysPt addr,Bit8u val){
<a name="l00572"></a>00572                 VGAMEM_USEC_write_delay();
<a name="l00573"></a>00573 
<a name="l00574"></a>00574                 <span class="keywordflow">if</span> (enableCGASnow) {
<a name="l00575"></a>00575                         <span class="comment">/* NTS: We can&#39;t use PIC_FullIndex() exclusively because it&#39;s not precise enough</span>
<a name="l00576"></a>00576 <span class="comment">                         *      with respect to when DOSBox CPU emulation is writing. We have to use other</span>
<a name="l00577"></a>00577 <span class="comment">                         *      variables like CPU_Cycles to gain additional precision */</span>
<a name="l00578"></a>00578                         <span class="keywordtype">double</span> timeInFrame = PIC_FullIndex()-vga.draw.delay.framestart;
<a name="l00579"></a>00579                         <span class="keywordtype">double</span> timeInLine = fmod(timeInFrame,vga.draw.delay.htotal);
<a name="l00580"></a>00580 
<a name="l00581"></a>00581                         <span class="comment">/* we&#39;re in active area. which column should the snow show up on? */</span>
<a name="l00582"></a>00582                         Bit32u x = (Bit32u)((timeInLine * 80) / vga.draw.delay.hblkstart);
<a name="l00583"></a>00583                         <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span>)x &lt; 80) vga.draw.cga_snow[x] = val;
<a name="l00584"></a>00584                 }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586                 addr = PAGING_GetPhysicalAddress(addr) &amp; 0x3FFF;
<a name="l00587"></a>00587                 vga.tandy.mem_base[addr] = val;
<a name="l00588"></a>00588         }
<a name="l00589"></a>00589 };
<a name="l00590"></a>00590 
<a name="l00591"></a><a class="code" href="classVGA__MCGATEXT__PageHandler.html">00591</a> <span class="keyword">class </span><a class="code" href="classVGA__MCGATEXT__PageHandler.html">VGA_MCGATEXT_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00592"></a>00592 <span class="keyword">public</span>:
<a name="l00593"></a>00593         <a class="code" href="classVGA__MCGATEXT__PageHandler.html">VGA_MCGATEXT_PageHandler</a>() {
<a name="l00594"></a>00594                 flags=PFLAG_NOCODE;
<a name="l00595"></a>00595         }
<a name="l00596"></a>00596         Bit8u readb(PhysPt addr) {
<a name="l00597"></a>00597                 addr = PAGING_GetPhysicalAddress(addr) &amp; 0xFFFF;
<a name="l00598"></a>00598                 VGAMEM_USEC_read_delay();
<a name="l00599"></a>00599                 <span class="keywordflow">return</span> vga.tandy.mem_base[addr];
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601         <span class="keywordtype">void</span> writeb(PhysPt addr,Bit8u val){
<a name="l00602"></a>00602                 VGAMEM_USEC_write_delay();
<a name="l00603"></a>00603 
<a name="l00604"></a>00604                 addr = PAGING_GetPhysicalAddress(addr) &amp; 0xFFFF;
<a name="l00605"></a>00605                 vga.tandy.mem_base[addr] = val;
<a name="l00606"></a>00606         }
<a name="l00607"></a>00607 };
<a name="l00608"></a>00608 
<a name="l00609"></a>00609 <span class="keyword">extern</span> uint8_t pc98_egc_srcmask[2]; <span class="comment">/* host given (Neko: egc.srcmask) */</span>
<a name="l00610"></a>00610 <span class="keyword">extern</span> uint8_t pc98_egc_maskef[2]; <span class="comment">/* effective (Neko: egc.mask2) */</span>
<a name="l00611"></a>00611 <span class="keyword">extern</span> uint8_t pc98_egc_mask[2]; <span class="comment">/* host given (Neko: egc.mask) */</span>
<a name="l00612"></a>00612 <span class="keyword">extern</span> uint8_t pc98_egc_access;
<a name="l00613"></a>00613 <span class="keyword">extern</span> uint8_t pc98_egc_fgc;
<a name="l00614"></a>00614 <span class="keyword">extern</span> uint8_t pc98_egc_foreground_color;
<a name="l00615"></a>00615 <span class="keyword">extern</span> uint8_t pc98_egc_background_color;
<a name="l00616"></a>00616 <span class="keyword">extern</span> uint8_t pc98_egc_lead_plane;
<a name="l00617"></a>00617 <span class="keyword">extern</span> uint8_t pc98_egc_compare_lead;
<a name="l00618"></a>00618 <span class="keyword">extern</span> uint8_t pc98_egc_lightsource;
<a name="l00619"></a>00619 <span class="keyword">extern</span> uint8_t pc98_egc_shiftinput;
<a name="l00620"></a>00620 <span class="keyword">extern</span> uint8_t pc98_egc_regload;
<a name="l00621"></a>00621 <span class="keyword">extern</span> uint8_t pc98_egc_rop;
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 <span class="keyword">extern</span> <span class="keywordtype">bool</span> pc98_egc_shift_descend;
<a name="l00624"></a>00624 <span class="keyword">extern</span> uint8_t pc98_egc_shift_destbit;
<a name="l00625"></a>00625 <span class="keyword">extern</span> uint8_t pc98_egc_shift_srcbit;
<a name="l00626"></a>00626 <span class="keyword">extern</span> uint16_t pc98_egc_shift_length;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 <span class="comment">/* I don&#39;t think we necessarily need the full 4096 bit buffer</span>
<a name="l00629"></a>00629 <span class="comment"> * Neko Project II uses to render things, though that is</span>
<a name="l00630"></a>00630 <span class="comment"> * probably faster to execute. It makes it hard to make sense</span>
<a name="l00631"></a>00631 <span class="comment"> * of the code though. */</span>
<a name="l00632"></a><a class="code" href="structpc98__egc__shifter.html">00632</a> <span class="keyword">struct </span><a class="code" href="structpc98__egc__shifter.html">pc98_egc_shifter</a> {
<a name="l00633"></a>00633     <a class="code" href="structpc98__egc__shifter.html">pc98_egc_shifter</a>() : decrement(<span class="keyword">false</span>), remain(0x10), srcbit(0), dstbit(0) { }
<a name="l00634"></a>00634 
<a name="l00635"></a>00635     <span class="keywordtype">void</span> reinit(<span class="keywordtype">void</span>) { <span class="comment">/* from global vars set by guest */</span>
<a name="l00636"></a>00636         decrement = pc98_egc_shift_descend;
<a name="l00637"></a>00637         remain = pc98_egc_shift_length + 1; <span class="comment">/* the register is length - 1 apparently */</span>
<a name="l00638"></a>00638         dstbit = pc98_egc_shift_destbit;
<a name="l00639"></a>00639         srcbit = pc98_egc_shift_srcbit;
<a name="l00640"></a>00640         bufi = bufo = decrement ? (<span class="keyword">sizeof</span>(buffer) + 3 - (4*4)) : 0;
<a name="l00641"></a>00641 
<a name="l00642"></a>00642         <span class="keywordflow">if</span> ((srcbit&amp;7) &lt; (dstbit&amp;7)) {
<a name="l00643"></a>00643             shft8bitr = (dstbit&amp;7) - (srcbit&amp;7);
<a name="l00644"></a>00644             shft8bitl = 8 - shft8bitr;
<a name="l00645"></a>00645         }
<a name="l00646"></a>00646         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((srcbit&amp;7) &gt; (dstbit&amp;7)) {
<a name="l00647"></a>00647             shft8bitl = (srcbit&amp;7) - (dstbit&amp;7);
<a name="l00648"></a>00648             shft8bitr = 8 - shft8bitl;
<a name="l00649"></a>00649         }
<a name="l00650"></a>00650         <span class="keywordflow">else</span> {
<a name="l00651"></a>00651             shft8bitr = 0;
<a name="l00652"></a>00652             shft8bitl = 0;
<a name="l00653"></a>00653         }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655         shft8load = 0;
<a name="l00656"></a>00656         o_srcbit = srcbit &amp; 7;
<a name="l00657"></a>00657         o_dstbit = dstbit &amp; 7;
<a name="l00658"></a>00658     }
<a name="l00659"></a>00659 
<a name="l00660"></a>00660     <span class="keywordtype">bool</span>                decrement;
<a name="l00661"></a>00661     uint16_t            remain;
<a name="l00662"></a>00662     uint16_t            srcbit;
<a name="l00663"></a>00663     uint16_t            dstbit;
<a name="l00664"></a>00664     uint16_t            o_srcbit = 0;
<a name="l00665"></a>00665     uint16_t            o_dstbit = 0;
<a name="l00666"></a>00666 
<a name="l00667"></a>00667     uint8_t             buffer[512] = {}; <span class="comment">/* 4096/8 = 512 */</span>
<a name="l00668"></a>00668     uint16_t            bufi = 0, bufo = 0;
<a name="l00669"></a>00669 
<a name="l00670"></a>00670     uint8_t             shft8load = 0;
<a name="l00671"></a>00671     uint8_t             shft8bitr = 0;
<a name="l00672"></a>00672     uint8_t             shft8bitl = 0;
<a name="l00673"></a>00673 
<a name="l00674"></a>00674     std::string debug_status(<span class="keywordtype">void</span>) {
<a name="l00675"></a>00675         <span class="keywordtype">char</span> tmp[512];
<a name="l00676"></a>00676 
<a name="l00677"></a>00677         sprintf(tmp,<span class="stringliteral">&quot;decrement=%u remain=%u srcbit=%u dstbit=%u shf8l=%u shf8br=%u shf8bl=%u&quot;</span>,
<a name="l00678"></a>00678             decrement?1:0,
<a name="l00679"></a>00679             remain,
<a name="l00680"></a>00680             srcbit,
<a name="l00681"></a>00681             dstbit,
<a name="l00682"></a>00682             shft8load,
<a name="l00683"></a>00683             shft8bitr,
<a name="l00684"></a>00684             shft8bitl);
<a name="l00685"></a>00685 
<a name="l00686"></a>00686         <span class="keywordflow">return</span> std::string(tmp);
<a name="l00687"></a>00687     }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> bi(<span class="keyword">const</span> uint16_t ofs,<span class="keyword">const</span> AWT val) {
<a name="l00690"></a>00690         <span class="keywordtype">size_t</span> ip = (bufi + ofs) &amp; (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00691"></a>00691 
<a name="l00692"></a>00692         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; <span class="keyword">sizeof</span>(AWT);) {
<a name="l00693"></a>00693             buffer[ip] = (uint8_t)(val &gt;&gt; ((AWT)(i * 8U)));
<a name="l00694"></a>00694             <span class="keywordflow">if</span> ((++ip) == <span class="keyword">sizeof</span>(buffer)) ip = 0;
<a name="l00695"></a>00695             i++;
<a name="l00696"></a>00696         }
<a name="l00697"></a>00697     }
<a name="l00698"></a>00698 
<a name="l00699"></a>00699     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> bi_adv(<span class="keywordtype">void</span>) {
<a name="l00700"></a>00700         bufi += pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) - <span class="keyword">sizeof</span>(AWT)) : <span class="keyword">sizeof</span>(AWT);
<a name="l00701"></a>00701         bufi &amp;= (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00702"></a>00702     }
<a name="l00703"></a>00703 
<a name="l00704"></a>00704     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> AWT bo(<span class="keyword">const</span> uint16_t ofs) {
<a name="l00705"></a>00705         <span class="keywordtype">size_t</span> op = (bufo + ofs) &amp; (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00706"></a>00706         AWT ret = 0;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; <span class="keyword">sizeof</span>(AWT);) {
<a name="l00709"></a>00709             ret += ((AWT)buffer[op]) &lt;&lt; ((AWT)(i * 8U));
<a name="l00710"></a>00710             <span class="keywordflow">if</span> ((++op) == <span class="keyword">sizeof</span>(buffer)) op = 0;
<a name="l00711"></a>00711             i++;
<a name="l00712"></a>00712         }
<a name="l00713"></a>00713 
<a name="l00714"></a>00714         <span class="keywordflow">return</span> ret;
<a name="l00715"></a>00715     }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> bo_adv(<span class="keywordtype">void</span>) {
<a name="l00718"></a>00718         bufo += pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) - <span class="keyword">sizeof</span>(AWT)) : <span class="keyword">sizeof</span>(AWT);
<a name="l00719"></a>00719         bufo &amp;= (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00720"></a>00720     }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> input(<span class="keyword">const</span> AWT a,<span class="keyword">const</span> AWT b,<span class="keyword">const</span> AWT c,<span class="keyword">const</span> AWT d,uint8_t odd) {
<a name="l00723"></a>00723         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 0,a);
<a name="l00724"></a>00724         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 4,b);
<a name="l00725"></a>00725         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 8,c);
<a name="l00726"></a>00726         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 12,d);
<a name="l00727"></a>00727 
<a name="l00728"></a>00728         <span class="keywordflow">if</span> (shft8load &lt;= 16) {
<a name="l00729"></a>00729             bi_adv&lt;AWT&gt;();
<a name="l00730"></a>00730 
<a name="l00731"></a>00731             <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) == 2) {
<a name="l00732"></a>00732                 <span class="keywordflow">if</span> (srcbit &gt;= 8) bo_adv&lt;uint8_t&gt;();
<a name="l00733"></a>00733                 shft8load += (16 - srcbit);
<a name="l00734"></a>00734                 srcbit = 0;
<a name="l00735"></a>00735             }
<a name="l00736"></a>00736             <span class="keywordflow">else</span> {
<a name="l00737"></a>00737                 <span class="keywordflow">if</span> (srcbit &gt;= 8)
<a name="l00738"></a>00738                     srcbit -= 8;
<a name="l00739"></a>00739                 <span class="keywordflow">else</span> {
<a name="l00740"></a>00740                     shft8load += (8 - srcbit);
<a name="l00741"></a>00741                     srcbit = 0;
<a name="l00742"></a>00742                 }
<a name="l00743"></a>00743             }
<a name="l00744"></a>00744         }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746         *((AWT*)(pc98_egc_srcmask+odd)) = (AWT)(~0ull);
<a name="l00747"></a>00747     }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     <span class="keyword">inline</span> uint8_t dstbit_mask(<span class="keywordtype">void</span>) {
<a name="l00750"></a>00750         uint8_t mb;
<a name="l00751"></a>00751 
<a name="l00752"></a>00752         <span class="comment">/* assume remain &gt; 0 */</span>
<a name="l00753"></a>00753         <span class="keywordflow">if</span> (remain &gt;= 8)
<a name="l00754"></a>00754             mb = 0xFF;
<a name="l00755"></a>00755         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pc98_egc_shift_descend)
<a name="l00756"></a>00756             mb = 0xFF &lt;&lt; (uint8_t)(8 - remain); <span class="comment">/* 0x80 0xC0 0xE0 0xF0 ... */</span>
<a name="l00757"></a>00757         <span class="keywordflow">else</span>
<a name="l00758"></a>00758             mb = 0xFF &gt;&gt; (uint8_t)(8 - remain); <span class="comment">/* 0x01 0x03 0x07 0x0F ... */</span>
<a name="l00759"></a>00759 
<a name="l00760"></a>00760         <span class="comment">/* assume dstbit &lt; 8 */</span>
<a name="l00761"></a>00761         <span class="keywordflow">if</span> (!pc98_egc_shift_descend)
<a name="l00762"></a>00762             <span class="keywordflow">return</span> mb &gt;&gt; (uint8_t)dstbit; <span class="comment">/* 0xFF 0x7F 0x3F 0x1F ... */</span>
<a name="l00763"></a>00763         <span class="keywordflow">else</span>
<a name="l00764"></a>00764             <span class="keywordflow">return</span> mb &lt;&lt; (uint8_t)dstbit; <span class="comment">/* 0xFF 0xFE 0xFC 0xF8 ... */</span>
<a name="l00765"></a>00765     }
<a name="l00766"></a>00766 
<a name="l00767"></a>00767     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> output(AWT &amp;a,AWT &amp;b,AWT &amp;c,AWT &amp;d,uint8_t odd,<span class="keywordtype">bool</span> recursive=<span class="keyword">false</span>) {
<a name="l00768"></a>00768         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) == 2) {
<a name="l00769"></a>00769             <span class="keywordflow">if</span> (shft8load &lt; (16 - dstbit)) {
<a name="l00770"></a>00770                 *((AWT*)(pc98_egc_srcmask+odd)) = 0;
<a name="l00771"></a>00771                 <span class="keywordflow">return</span>;
<a name="l00772"></a>00772             }
<a name="l00773"></a>00773             shft8load -= (16 - dstbit);
<a name="l00774"></a>00774 
<a name="l00775"></a>00775             <span class="comment">/* assume odd == false and output is to even byte offset */</span>
<a name="l00776"></a>00776             <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00777"></a>00777                 output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[1],((uint8_t*)(&amp;b))[1],((uint8_t*)(&amp;c))[1],((uint8_t*)(&amp;d))[1],1,<span class="keyword">true</span>);
<a name="l00778"></a>00778                 <span class="keywordflow">if</span> (remain != 0) output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[0],((uint8_t*)(&amp;b))[0],((uint8_t*)(&amp;c))[0],((uint8_t*)(&amp;d))[0],0,<span class="keyword">true</span>);
<a name="l00779"></a>00779                 <span class="keywordflow">else</span> pc98_egc_srcmask[0] = 0;
<a name="l00780"></a>00780             }
<a name="l00781"></a>00781             <span class="keywordflow">else</span> {
<a name="l00782"></a>00782                 output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[0],((uint8_t*)(&amp;b))[0],((uint8_t*)(&amp;c))[0],((uint8_t*)(&amp;d))[0],0,<span class="keyword">true</span>);
<a name="l00783"></a>00783                 <span class="keywordflow">if</span> (remain != 0) output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[1],((uint8_t*)(&amp;b))[1],((uint8_t*)(&amp;c))[1],((uint8_t*)(&amp;d))[1],1,<span class="keyword">true</span>);
<a name="l00784"></a>00784                 <span class="keywordflow">else</span> pc98_egc_srcmask[1] = 0;
<a name="l00785"></a>00785             }
<a name="l00786"></a>00786 
<a name="l00787"></a>00787             <span class="keywordflow">if</span> (remain == 0)
<a name="l00788"></a>00788                 reinit();
<a name="l00789"></a>00789 
<a name="l00790"></a>00790             <span class="keywordflow">return</span>;
<a name="l00791"></a>00791         }
<a name="l00792"></a>00792 
<a name="l00793"></a>00793         <span class="keywordflow">if</span> (!recursive) {
<a name="l00794"></a>00794             <span class="keywordflow">if</span> (shft8load &lt; (8 - dstbit)) {
<a name="l00795"></a>00795                 *((AWT*)(pc98_egc_srcmask+odd)) = 0;
<a name="l00796"></a>00796                 <span class="keywordflow">return</span>;
<a name="l00797"></a>00797             }
<a name="l00798"></a>00798             shft8load -= (8 - dstbit);
<a name="l00799"></a>00799         }
<a name="l00800"></a>00800 
<a name="l00801"></a>00801         <span class="keywordflow">if</span> (dstbit &gt;= 8) {
<a name="l00802"></a>00802             dstbit -= 8;
<a name="l00803"></a>00803             *((AWT*)(pc98_egc_srcmask+odd)) = 0;
<a name="l00804"></a>00804             <span class="keywordflow">return</span>;
<a name="l00805"></a>00805         }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807         *((AWT*)(pc98_egc_srcmask+odd)) = dstbit_mask();
<a name="l00808"></a>00808 
<a name="l00809"></a>00809         <span class="keywordflow">if</span> (dstbit &gt; 0) {
<a name="l00810"></a>00810             <span class="keyword">const</span> uint8_t bc = 8 - dstbit;
<a name="l00811"></a>00811 
<a name="l00812"></a>00812             <span class="keywordflow">if</span> (remain &gt;= bc)
<a name="l00813"></a>00813                 remain -= bc;
<a name="l00814"></a>00814             <span class="keywordflow">else</span>
<a name="l00815"></a>00815                 remain = 0;
<a name="l00816"></a>00816         }
<a name="l00817"></a>00817         <span class="keywordflow">else</span> {
<a name="l00818"></a>00818             <span class="keywordflow">if</span> (remain &gt;= 8)
<a name="l00819"></a>00819                 remain -= 8;
<a name="l00820"></a>00820             <span class="keywordflow">else</span>
<a name="l00821"></a>00821                 remain = 0;
<a name="l00822"></a>00822         }
<a name="l00823"></a>00823 
<a name="l00824"></a>00824         <span class="keywordflow">if</span> (o_srcbit &lt; o_dstbit) {
<a name="l00825"></a>00825             <span class="keywordflow">if</span> (dstbit != 0) {
<a name="l00826"></a>00826                 <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00827"></a>00827                     a = bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitr;
<a name="l00828"></a>00828                     b = bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitr;
<a name="l00829"></a>00829                     c = bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitr;
<a name="l00830"></a>00830                     d = bo&lt;AWT&gt;(12) &lt;&lt; shft8bitr;
<a name="l00831"></a>00831                 }
<a name="l00832"></a>00832                 <span class="keywordflow">else</span> {
<a name="l00833"></a>00833                     a = bo&lt;AWT&gt;( 0) &gt;&gt; shft8bitr;
<a name="l00834"></a>00834                     b = bo&lt;AWT&gt;( 4) &gt;&gt; shft8bitr;
<a name="l00835"></a>00835                     c = bo&lt;AWT&gt;( 8) &gt;&gt; shft8bitr;
<a name="l00836"></a>00836                     d = bo&lt;AWT&gt;(12) &gt;&gt; shft8bitr;
<a name="l00837"></a>00837                 }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839                 dstbit = 0;
<a name="l00840"></a>00840             }
<a name="l00841"></a>00841             <span class="keywordflow">else</span> {
<a name="l00842"></a>00842                 <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00843"></a>00843                     bo_adv&lt;AWT&gt;();
<a name="l00844"></a>00844                     a = (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitr);
<a name="l00845"></a>00845                     b = (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitr);
<a name="l00846"></a>00846                     c = (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitr);
<a name="l00847"></a>00847                     d = (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitr);
<a name="l00848"></a>00848                 }
<a name="l00849"></a>00849                 <span class="keywordflow">else</span> {
<a name="l00850"></a>00850                     a = (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitr);
<a name="l00851"></a>00851                     b = (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitr);
<a name="l00852"></a>00852                     c = (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitr);
<a name="l00853"></a>00853                     d = (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitr);
<a name="l00854"></a>00854                     bo_adv&lt;AWT&gt;();
<a name="l00855"></a>00855                 }
<a name="l00856"></a>00856             }
<a name="l00857"></a>00857         }
<a name="l00858"></a>00858         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (o_srcbit &gt; o_dstbit) {
<a name="l00859"></a>00859             dstbit = 0;
<a name="l00860"></a>00860 
<a name="l00861"></a>00861             <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00862"></a>00862                 bo_adv&lt;AWT&gt;();
<a name="l00863"></a>00863                 a = (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitr);
<a name="l00864"></a>00864                 b = (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitr);
<a name="l00865"></a>00865                 c = (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitr);
<a name="l00866"></a>00866                 d = (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitr);
<a name="l00867"></a>00867             }
<a name="l00868"></a>00868             <span class="keywordflow">else</span> {
<a name="l00869"></a>00869                 a = (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitr);
<a name="l00870"></a>00870                 b = (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitr);
<a name="l00871"></a>00871                 c = (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitr);
<a name="l00872"></a>00872                 d = (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitr);
<a name="l00873"></a>00873                 bo_adv&lt;AWT&gt;();
<a name="l00874"></a>00874             }
<a name="l00875"></a>00875         }
<a name="l00876"></a>00876         <span class="keywordflow">else</span> {
<a name="l00877"></a>00877             dstbit = 0;
<a name="l00878"></a>00878 
<a name="l00879"></a>00879             a = bo&lt;AWT&gt;( 0);
<a name="l00880"></a>00880             b = bo&lt;AWT&gt;( 4);
<a name="l00881"></a>00881             c = bo&lt;AWT&gt;( 8);
<a name="l00882"></a>00882             d = bo&lt;AWT&gt;(12);
<a name="l00883"></a>00883             bo_adv&lt;AWT&gt;();
<a name="l00884"></a>00884         }
<a name="l00885"></a>00885 
<a name="l00886"></a>00886         <span class="keywordflow">if</span> (!recursive &amp;&amp; remain == 0)
<a name="l00887"></a>00887             reinit();
<a name="l00888"></a>00888     }
<a name="l00889"></a>00889 };
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 egc_quad pc98_egc_src;
<a name="l00892"></a>00892 egc_quad pc98_egc_bgcm;
<a name="l00893"></a>00893 egc_quad pc98_egc_fgcm;
<a name="l00894"></a>00894 egc_quad pc98_egc_data;
<a name="l00895"></a>00895 egc_quad pc98_egc_last_vram;
<a name="l00896"></a>00896 
<a name="l00897"></a>00897 <a class="code" href="structpc98__egc__shifter.html">pc98_egc_shifter</a> pc98_egc_shift;
<a name="l00898"></a>00898 
<a name="l00899"></a>00899 std::string pc98_egc_shift_debug_status(<span class="keywordtype">void</span>) {
<a name="l00900"></a>00900     <span class="keywordflow">return</span> pc98_egc_shift.debug_status();
<a name="l00901"></a>00901 }
<a name="l00902"></a>00902 
<a name="l00903"></a>00903 <span class="keyword">typedef</span> egc_quad &amp; (*PC98_OPEFN)(uint8_t ope, <span class="keyword">const</span> PhysPt ad);
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 <span class="keywordtype">void</span> pc98_egc_shift_reinit() {
<a name="l00906"></a>00906     pc98_egc_shift.reinit();
<a name="l00907"></a>00907 }
<a name="l00908"></a>00908 
<a name="l00909"></a>00909 <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> egc_fetch_planar(egc_quad &amp;dst,<span class="keyword">const</span> PhysPt vramoff) {
<a name="l00910"></a>00910     dst[0].w = *((uint16_t*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(0)));
<a name="l00911"></a>00911     dst[1].w = *((uint16_t*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(1)));
<a name="l00912"></a>00912     dst[2].w = *((uint16_t*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(2)));
<a name="l00913"></a>00913     dst[3].w = *((uint16_t*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(3)));
<a name="l00914"></a>00914 }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 <span class="keyword">static</span> egc_quad &amp;ope_xx(uint8_t ope, <span class="keyword">const</span> PhysPt ad) {
<a name="l00917"></a>00917     (void)ad;<span class="comment">//UNUSED</span>
<a name="l00918"></a>00918     LOG_MSG(<span class="stringliteral">&quot;EGC ROP 0x%2x not impl&quot;</span>,ope);
<a name="l00919"></a>00919     <span class="keywordflow">return</span> pc98_egc_last_vram;
<a name="l00920"></a>00920 }
<a name="l00921"></a>00921 
<a name="l00922"></a>00922 <span class="keyword">static</span> egc_quad &amp;ope_00(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00923"></a>00923         (void)vramoff;
<a name="l00924"></a>00924         (void)ope;
<a name="l00925"></a>00925 
<a name="l00926"></a>00926         pc98_egc_data[0].w = 0;
<a name="l00927"></a>00927         pc98_egc_data[1].w = 0;
<a name="l00928"></a>00928         pc98_egc_data[2].w = 0;
<a name="l00929"></a>00929         pc98_egc_data[3].w = 0;
<a name="l00930"></a>00930 
<a name="l00931"></a>00931         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l00932"></a>00932 }
<a name="l00933"></a>00933 
<a name="l00934"></a>00934 <span class="keyword">static</span> egc_quad &amp;ope_0f(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00935"></a>00935         (void)vramoff;
<a name="l00936"></a>00936         (void)ope;
<a name="l00937"></a>00937 
<a name="l00938"></a>00938         pc98_egc_data[0].w = ~pc98_egc_src[0].w;
<a name="l00939"></a>00939         pc98_egc_data[1].w = ~pc98_egc_src[1].w;
<a name="l00940"></a>00940         pc98_egc_data[2].w = ~pc98_egc_src[2].w;
<a name="l00941"></a>00941         pc98_egc_data[3].w = ~pc98_egc_src[3].w;
<a name="l00942"></a>00942 
<a name="l00943"></a>00943         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l00944"></a>00944 }
<a name="l00945"></a>00945 
<a name="l00946"></a>00946 <span class="keyword">static</span> egc_quad &amp;ope_ff(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00947"></a>00947         (void)vramoff;
<a name="l00948"></a>00948         (void)ope;
<a name="l00949"></a>00949 
<a name="l00950"></a>00950         pc98_egc_data[0].w = (Bit16u)(~0u);
<a name="l00951"></a>00951         pc98_egc_data[1].w = (Bit16u)(~0u);
<a name="l00952"></a>00952         pc98_egc_data[2].w = (Bit16u)(~0u);
<a name="l00953"></a>00953         pc98_egc_data[3].w = (Bit16u)(~0u);
<a name="l00954"></a>00954 
<a name="l00955"></a>00955         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l00956"></a>00956 }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 <span class="keyword">static</span> egc_quad &amp;ope_np(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00959"></a>00959         egc_quad dst;
<a name="l00960"></a>00960 
<a name="l00961"></a>00961     egc_fetch_planar&lt;uint16_t&gt;(<span class="comment">/*&amp;*/</span>dst,vramoff);
<a name="l00962"></a>00962 
<a name="l00963"></a>00963         pc98_egc_data[0].w = 0;
<a name="l00964"></a>00964         pc98_egc_data[1].w = 0;
<a name="l00965"></a>00965         pc98_egc_data[2].w = 0;
<a name="l00966"></a>00966         pc98_egc_data[3].w = 0;
<a name="l00967"></a>00967 
<a name="l00968"></a>00968         <span class="keywordflow">if</span> (ope &amp; 0x80) {
<a name="l00969"></a>00969         pc98_egc_data[0].w |= (pc98_egc_src[0].w &amp; dst[0].w);
<a name="l00970"></a>00970         pc98_egc_data[1].w |= (pc98_egc_src[1].w &amp; dst[1].w);
<a name="l00971"></a>00971         pc98_egc_data[2].w |= (pc98_egc_src[2].w &amp; dst[2].w);
<a name="l00972"></a>00972         pc98_egc_data[3].w |= (pc98_egc_src[3].w &amp; dst[3].w);
<a name="l00973"></a>00973     }
<a name="l00974"></a>00974         <span class="keywordflow">if</span> (ope &amp; 0x20) {
<a name="l00975"></a>00975         pc98_egc_data[0].w |= (pc98_egc_src[0].w &amp; (~dst[0].w));
<a name="l00976"></a>00976         pc98_egc_data[1].w |= (pc98_egc_src[1].w &amp; (~dst[1].w));
<a name="l00977"></a>00977         pc98_egc_data[2].w |= (pc98_egc_src[2].w &amp; (~dst[2].w));
<a name="l00978"></a>00978         pc98_egc_data[3].w |= (pc98_egc_src[3].w &amp; (~dst[3].w));
<a name="l00979"></a>00979         }
<a name="l00980"></a>00980         <span class="keywordflow">if</span> (ope &amp; 0x08) {
<a name="l00981"></a>00981         pc98_egc_data[0].w |= ((~pc98_egc_src[0].w) &amp; dst[0].w);
<a name="l00982"></a>00982         pc98_egc_data[1].w |= ((~pc98_egc_src[1].w) &amp; dst[1].w);
<a name="l00983"></a>00983         pc98_egc_data[2].w |= ((~pc98_egc_src[2].w) &amp; dst[2].w);
<a name="l00984"></a>00984         pc98_egc_data[3].w |= ((~pc98_egc_src[3].w) &amp; dst[3].w);
<a name="l00985"></a>00985         }
<a name="l00986"></a>00986         <span class="keywordflow">if</span> (ope &amp; 0x02) {
<a name="l00987"></a>00987         pc98_egc_data[0].w |= ((~pc98_egc_src[0].w) &amp; (~dst[0].w));
<a name="l00988"></a>00988         pc98_egc_data[1].w |= ((~pc98_egc_src[1].w) &amp; (~dst[1].w));
<a name="l00989"></a>00989         pc98_egc_data[2].w |= ((~pc98_egc_src[2].w) &amp; (~dst[2].w));
<a name="l00990"></a>00990         pc98_egc_data[3].w |= ((~pc98_egc_src[3].w) &amp; (~dst[3].w));
<a name="l00991"></a>00991         }
<a name="l00992"></a>00992 
<a name="l00993"></a>00993         (void)ope;
<a name="l00994"></a>00994         (void)vramoff;
<a name="l00995"></a>00995         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l00996"></a>00996 }
<a name="l00997"></a>00997 
<a name="l00998"></a>00998 <span class="keyword">static</span> egc_quad &amp;ope_nd(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00999"></a>00999         egc_quad pat;
<a name="l01000"></a>01000 
<a name="l01001"></a>01001         <span class="keywordflow">switch</span>(pc98_egc_fgc) {
<a name="l01002"></a>01002                 <span class="keywordflow">case</span> 1:
<a name="l01003"></a>01003                         pat[0].w = pc98_egc_bgcm[0].w;
<a name="l01004"></a>01004                         pat[1].w = pc98_egc_bgcm[1].w;
<a name="l01005"></a>01005                         pat[2].w = pc98_egc_bgcm[2].w;
<a name="l01006"></a>01006                         pat[3].w = pc98_egc_bgcm[3].w;
<a name="l01007"></a>01007                         <span class="keywordflow">break</span>;
<a name="l01008"></a>01008 
<a name="l01009"></a>01009                 <span class="keywordflow">case</span> 2:
<a name="l01010"></a>01010                         pat[0].w = pc98_egc_fgcm[0].w;
<a name="l01011"></a>01011                         pat[1].w = pc98_egc_fgcm[1].w;
<a name="l01012"></a>01012                         pat[2].w = pc98_egc_fgcm[2].w;
<a name="l01013"></a>01013                         pat[3].w = pc98_egc_fgcm[3].w;
<a name="l01014"></a>01014                         <span class="keywordflow">break</span>;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016                 <span class="keywordflow">default</span>:
<a name="l01017"></a>01017                         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 1) {
<a name="l01018"></a>01018                                 pat[0].w = pc98_egc_src[0].w;
<a name="l01019"></a>01019                                 pat[1].w = pc98_egc_src[1].w;
<a name="l01020"></a>01020                                 pat[2].w = pc98_egc_src[2].w;
<a name="l01021"></a>01021                                 pat[3].w = pc98_egc_src[3].w;
<a name="l01022"></a>01022                         }
<a name="l01023"></a>01023                         <span class="keywordflow">else</span> {
<a name="l01024"></a>01024                                 pat[0].w = pc98_gdc_tiles[0].w;
<a name="l01025"></a>01025                                 pat[1].w = pc98_gdc_tiles[1].w;
<a name="l01026"></a>01026                                 pat[2].w = pc98_gdc_tiles[2].w;
<a name="l01027"></a>01027                                 pat[3].w = pc98_gdc_tiles[3].w;
<a name="l01028"></a>01028                         }
<a name="l01029"></a>01029                         <span class="keywordflow">break</span>;
<a name="l01030"></a>01030         }
<a name="l01031"></a>01031 
<a name="l01032"></a>01032         pc98_egc_data[0].w = 0;
<a name="l01033"></a>01033         pc98_egc_data[1].w = 0;
<a name="l01034"></a>01034         pc98_egc_data[2].w = 0;
<a name="l01035"></a>01035         pc98_egc_data[3].w = 0;
<a name="l01036"></a>01036 
<a name="l01037"></a>01037         <span class="keywordflow">if</span> (ope &amp; 0x80) {
<a name="l01038"></a>01038         pc98_egc_data[0].w |= (pat[0].w &amp; pc98_egc_src[0].w);
<a name="l01039"></a>01039         pc98_egc_data[1].w |= (pat[1].w &amp; pc98_egc_src[1].w);
<a name="l01040"></a>01040         pc98_egc_data[2].w |= (pat[2].w &amp; pc98_egc_src[2].w);
<a name="l01041"></a>01041         pc98_egc_data[3].w |= (pat[3].w &amp; pc98_egc_src[3].w);
<a name="l01042"></a>01042     }
<a name="l01043"></a>01043         <span class="keywordflow">if</span> (ope &amp; 0x40) {
<a name="l01044"></a>01044         pc98_egc_data[0].w |= ((~pat[0].w) &amp; pc98_egc_src[0].w);
<a name="l01045"></a>01045         pc98_egc_data[1].w |= ((~pat[1].w) &amp; pc98_egc_src[1].w);
<a name="l01046"></a>01046         pc98_egc_data[2].w |= ((~pat[2].w) &amp; pc98_egc_src[2].w);
<a name="l01047"></a>01047         pc98_egc_data[3].w |= ((~pat[3].w) &amp; pc98_egc_src[3].w);
<a name="l01048"></a>01048     }
<a name="l01049"></a>01049         <span class="keywordflow">if</span> (ope &amp; 0x08) {
<a name="l01050"></a>01050         pc98_egc_data[0].w |= (pat[0].w &amp; (~pc98_egc_src[0].w));
<a name="l01051"></a>01051         pc98_egc_data[1].w |= (pat[1].w &amp; (~pc98_egc_src[1].w));
<a name="l01052"></a>01052         pc98_egc_data[2].w |= (pat[2].w &amp; (~pc98_egc_src[2].w));
<a name="l01053"></a>01053         pc98_egc_data[3].w |= (pat[3].w &amp; (~pc98_egc_src[3].w));
<a name="l01054"></a>01054     }
<a name="l01055"></a>01055         <span class="keywordflow">if</span> (ope &amp; 0x04) {
<a name="l01056"></a>01056         pc98_egc_data[0].w |= ((~pat[0].w) &amp; (~pc98_egc_src[0].w));
<a name="l01057"></a>01057         pc98_egc_data[1].w |= ((~pat[1].w) &amp; (~pc98_egc_src[1].w));
<a name="l01058"></a>01058         pc98_egc_data[2].w |= ((~pat[2].w) &amp; (~pc98_egc_src[2].w));
<a name="l01059"></a>01059         pc98_egc_data[3].w |= ((~pat[3].w) &amp; (~pc98_egc_src[3].w));
<a name="l01060"></a>01060     }
<a name="l01061"></a>01061 
<a name="l01062"></a>01062         (void)ope;
<a name="l01063"></a>01063         (void)vramoff;
<a name="l01064"></a>01064         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01065"></a>01065 }
<a name="l01066"></a>01066 
<a name="l01067"></a>01067 <span class="keyword">static</span> egc_quad &amp;ope_c0(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l01068"></a>01068         egc_quad dst;
<a name="l01069"></a>01069 
<a name="l01070"></a>01070     <span class="comment">/* assume: ad is word aligned */</span>
<a name="l01071"></a>01071 
<a name="l01072"></a>01072     egc_fetch_planar&lt;uint16_t&gt;(<span class="comment">/*&amp;*/</span>dst,vramoff);
<a name="l01073"></a>01073 
<a name="l01074"></a>01074         pc98_egc_data[0].w = pc98_egc_src[0].w &amp; dst[0].w;
<a name="l01075"></a>01075         pc98_egc_data[1].w = pc98_egc_src[1].w &amp; dst[1].w;
<a name="l01076"></a>01076         pc98_egc_data[2].w = pc98_egc_src[2].w &amp; dst[2].w;
<a name="l01077"></a>01077         pc98_egc_data[3].w = pc98_egc_src[3].w &amp; dst[3].w;
<a name="l01078"></a>01078 
<a name="l01079"></a>01079         (void)ope;
<a name="l01080"></a>01080         (void)vramoff;
<a name="l01081"></a>01081         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01082"></a>01082 }
<a name="l01083"></a>01083 
<a name="l01084"></a>01084 <span class="keyword">static</span> egc_quad &amp;ope_f0(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l01085"></a>01085         (void)ope;
<a name="l01086"></a>01086         (void)vramoff;
<a name="l01087"></a>01087         <span class="keywordflow">return</span> pc98_egc_src;
<a name="l01088"></a>01088 }
<a name="l01089"></a>01089 
<a name="l01090"></a>01090 <span class="keyword">static</span> egc_quad &amp;ope_fc(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l01091"></a>01091         egc_quad dst;
<a name="l01092"></a>01092 
<a name="l01093"></a>01093     <span class="comment">/* assume: ad is word aligned */</span>
<a name="l01094"></a>01094 
<a name="l01095"></a>01095     egc_fetch_planar&lt;uint16_t&gt;(<span class="comment">/*&amp;*/</span>dst,vramoff);
<a name="l01096"></a>01096 
<a name="l01097"></a>01097         pc98_egc_data[0].w  =    pc98_egc_src[0].w;
<a name="l01098"></a>01098         pc98_egc_data[0].w |= ((~pc98_egc_src[0].w) &amp; dst[0].w);
<a name="l01099"></a>01099         pc98_egc_data[1].w  =    pc98_egc_src[1].w;
<a name="l01100"></a>01100         pc98_egc_data[1].w |= ((~pc98_egc_src[1].w) &amp; dst[1].w);
<a name="l01101"></a>01101         pc98_egc_data[2].w  =    pc98_egc_src[2].w;
<a name="l01102"></a>01102         pc98_egc_data[2].w |= ((~pc98_egc_src[2].w) &amp; dst[2].w);
<a name="l01103"></a>01103         pc98_egc_data[3].w  =    pc98_egc_src[3].w;
<a name="l01104"></a>01104         pc98_egc_data[3].w |= ((~pc98_egc_src[3].w) &amp; dst[3].w);
<a name="l01105"></a>01105 
<a name="l01106"></a>01106         (void)ope;
<a name="l01107"></a>01107         (void)vramoff;
<a name="l01108"></a>01108         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01109"></a>01109 }
<a name="l01110"></a>01110 
<a name="l01111"></a>01111 <span class="keyword">static</span> egc_quad &amp;ope_gg(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l01112"></a>01112     egc_quad pat,dst;
<a name="l01113"></a>01113 
<a name="l01114"></a>01114         <span class="keywordflow">switch</span>(pc98_egc_fgc) {
<a name="l01115"></a>01115                 <span class="keywordflow">case</span> 1:
<a name="l01116"></a>01116                         pat[0].w = pc98_egc_bgcm[0].w;
<a name="l01117"></a>01117                         pat[1].w = pc98_egc_bgcm[1].w;
<a name="l01118"></a>01118                         pat[2].w = pc98_egc_bgcm[2].w;
<a name="l01119"></a>01119                         pat[3].w = pc98_egc_bgcm[3].w;
<a name="l01120"></a>01120                         <span class="keywordflow">break</span>;
<a name="l01121"></a>01121 
<a name="l01122"></a>01122                 <span class="keywordflow">case</span> 2:
<a name="l01123"></a>01123                         pat[0].w = pc98_egc_fgcm[0].w;
<a name="l01124"></a>01124                         pat[1].w = pc98_egc_fgcm[1].w;
<a name="l01125"></a>01125                         pat[2].w = pc98_egc_fgcm[2].w;
<a name="l01126"></a>01126                         pat[3].w = pc98_egc_fgcm[3].w;
<a name="l01127"></a>01127                         <span class="keywordflow">break</span>;
<a name="l01128"></a>01128 
<a name="l01129"></a>01129                 <span class="keywordflow">default</span>:
<a name="l01130"></a>01130                         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 1) {
<a name="l01131"></a>01131                                 pat[0].w = pc98_egc_src[0].w;
<a name="l01132"></a>01132                                 pat[1].w = pc98_egc_src[1].w;
<a name="l01133"></a>01133                                 pat[2].w = pc98_egc_src[2].w;
<a name="l01134"></a>01134                                 pat[3].w = pc98_egc_src[3].w;
<a name="l01135"></a>01135                         }
<a name="l01136"></a>01136                         <span class="keywordflow">else</span> {
<a name="l01137"></a>01137                                 pat[0].w = pc98_gdc_tiles[0].w;
<a name="l01138"></a>01138                                 pat[1].w = pc98_gdc_tiles[1].w;
<a name="l01139"></a>01139                                 pat[2].w = pc98_gdc_tiles[2].w;
<a name="l01140"></a>01140                                 pat[3].w = pc98_gdc_tiles[3].w;
<a name="l01141"></a>01141                         }
<a name="l01142"></a>01142                         <span class="keywordflow">break</span>;
<a name="l01143"></a>01143         }
<a name="l01144"></a>01144 
<a name="l01145"></a>01145     egc_fetch_planar&lt;uint16_t&gt;(<span class="comment">/*&amp;*/</span>dst,vramoff);
<a name="l01146"></a>01146 
<a name="l01147"></a>01147         pc98_egc_data[0].w = 0;
<a name="l01148"></a>01148         pc98_egc_data[1].w = 0;
<a name="l01149"></a>01149         pc98_egc_data[2].w = 0;
<a name="l01150"></a>01150         pc98_egc_data[3].w = 0;
<a name="l01151"></a>01151 
<a name="l01152"></a>01152         <span class="keywordflow">if</span> (ope &amp; 0x80) {
<a name="l01153"></a>01153                 pc98_egc_data[0].w |=  ( pat[0].w  &amp;   pc98_egc_src[0].w &amp;    dst[0].w);
<a name="l01154"></a>01154                 pc98_egc_data[1].w |=  ( pat[1].w  &amp;   pc98_egc_src[1].w &amp;    dst[1].w);
<a name="l01155"></a>01155                 pc98_egc_data[2].w |=  ( pat[2].w  &amp;   pc98_egc_src[2].w &amp;    dst[2].w);
<a name="l01156"></a>01156                 pc98_egc_data[3].w |=  ( pat[3].w  &amp;   pc98_egc_src[3].w &amp;    dst[3].w);
<a name="l01157"></a>01157         }
<a name="l01158"></a>01158         <span class="keywordflow">if</span> (ope &amp; 0x40) {
<a name="l01159"></a>01159                 pc98_egc_data[0].w |= ((~pat[0].w) &amp;   pc98_egc_src[0].w &amp;    dst[0].w);
<a name="l01160"></a>01160                 pc98_egc_data[1].w |= ((~pat[1].w) &amp;   pc98_egc_src[1].w &amp;    dst[1].w);
<a name="l01161"></a>01161                 pc98_egc_data[2].w |= ((~pat[2].w) &amp;   pc98_egc_src[2].w &amp;    dst[2].w);
<a name="l01162"></a>01162                 pc98_egc_data[3].w |= ((~pat[3].w) &amp;   pc98_egc_src[3].w &amp;    dst[3].w);
<a name="l01163"></a>01163         }
<a name="l01164"></a>01164         <span class="keywordflow">if</span> (ope &amp; 0x20) {
<a name="l01165"></a>01165                 pc98_egc_data[0].w |= (  pat[0].w  &amp;   pc98_egc_src[0].w &amp;  (~dst[0].w));
<a name="l01166"></a>01166                 pc98_egc_data[1].w |= (  pat[1].w  &amp;   pc98_egc_src[1].w &amp;  (~dst[1].w));
<a name="l01167"></a>01167                 pc98_egc_data[2].w |= (  pat[2].w  &amp;   pc98_egc_src[2].w &amp;  (~dst[2].w));
<a name="l01168"></a>01168                 pc98_egc_data[3].w |= (  pat[3].w  &amp;   pc98_egc_src[3].w &amp;  (~dst[3].w));
<a name="l01169"></a>01169         }
<a name="l01170"></a>01170         <span class="keywordflow">if</span> (ope &amp; 0x10) {
<a name="l01171"></a>01171                 pc98_egc_data[0].w |= ((~pat[0].w) &amp;   pc98_egc_src[0].w &amp;  (~dst[0].w));
<a name="l01172"></a>01172                 pc98_egc_data[1].w |= ((~pat[1].w) &amp;   pc98_egc_src[1].w &amp;  (~dst[1].w));
<a name="l01173"></a>01173                 pc98_egc_data[2].w |= ((~pat[2].w) &amp;   pc98_egc_src[2].w &amp;  (~dst[2].w));
<a name="l01174"></a>01174                 pc98_egc_data[3].w |= ((~pat[3].w) &amp;   pc98_egc_src[3].w &amp;  (~dst[3].w));
<a name="l01175"></a>01175         }
<a name="l01176"></a>01176         <span class="keywordflow">if</span> (ope &amp; 0x08) {
<a name="l01177"></a>01177                 pc98_egc_data[0].w |= (  pat[0].w  &amp; (~pc98_egc_src[0].w) &amp;   dst[0].w);
<a name="l01178"></a>01178                 pc98_egc_data[1].w |= (  pat[1].w  &amp; (~pc98_egc_src[1].w) &amp;   dst[1].w);
<a name="l01179"></a>01179                 pc98_egc_data[2].w |= (  pat[2].w  &amp; (~pc98_egc_src[2].w) &amp;   dst[2].w);
<a name="l01180"></a>01180                 pc98_egc_data[3].w |= (  pat[3].w  &amp; (~pc98_egc_src[3].w) &amp;   dst[3].w);
<a name="l01181"></a>01181         }
<a name="l01182"></a>01182         <span class="keywordflow">if</span> (ope &amp; 0x04) {
<a name="l01183"></a>01183                 pc98_egc_data[0].w |= ((~pat[0].w) &amp; (~pc98_egc_src[0].w) &amp;   dst[0].w);
<a name="l01184"></a>01184                 pc98_egc_data[1].w |= ((~pat[1].w) &amp; (~pc98_egc_src[1].w) &amp;   dst[1].w);
<a name="l01185"></a>01185                 pc98_egc_data[2].w |= ((~pat[2].w) &amp; (~pc98_egc_src[2].w) &amp;   dst[2].w);
<a name="l01186"></a>01186                 pc98_egc_data[3].w |= ((~pat[3].w) &amp; (~pc98_egc_src[3].w) &amp;   dst[3].w);
<a name="l01187"></a>01187         }
<a name="l01188"></a>01188         <span class="keywordflow">if</span> (ope &amp; 0x02) {
<a name="l01189"></a>01189                 pc98_egc_data[0].w |= (  pat[0].w  &amp; (~pc98_egc_src[0].w) &amp; (~dst[0].w));
<a name="l01190"></a>01190                 pc98_egc_data[1].w |= (  pat[1].w  &amp; (~pc98_egc_src[1].w) &amp; (~dst[1].w));
<a name="l01191"></a>01191                 pc98_egc_data[2].w |= (  pat[2].w  &amp; (~pc98_egc_src[2].w) &amp; (~dst[2].w));
<a name="l01192"></a>01192                 pc98_egc_data[3].w |= (  pat[3].w  &amp; (~pc98_egc_src[3].w) &amp; (~dst[3].w));
<a name="l01193"></a>01193         }
<a name="l01194"></a>01194         <span class="keywordflow">if</span> (ope &amp; 0x01) {
<a name="l01195"></a>01195                 pc98_egc_data[0].w |= ((~pat[0].w) &amp; (~pc98_egc_src[0].w) &amp; (~dst[0].w));
<a name="l01196"></a>01196                 pc98_egc_data[1].w |= ((~pat[1].w) &amp; (~pc98_egc_src[1].w) &amp; (~dst[1].w));
<a name="l01197"></a>01197                 pc98_egc_data[2].w |= ((~pat[2].w) &amp; (~pc98_egc_src[2].w) &amp; (~dst[2].w));
<a name="l01198"></a>01198                 pc98_egc_data[3].w |= ((~pat[3].w) &amp; (~pc98_egc_src[3].w) &amp; (~dst[3].w));
<a name="l01199"></a>01199         }
<a name="l01200"></a>01200 
<a name="l01201"></a>01201         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01202"></a>01202 }
<a name="l01203"></a>01203 
<a name="l01204"></a>01204 <span class="keyword">static</span> <span class="keyword">const</span> PC98_OPEFN pc98_egc_opfn[256] = {
<a name="l01205"></a>01205                         ope_00, ope_xx, ope_xx, ope_np, ope_xx, ope_nd, ope_xx, ope_xx,
<a name="l01206"></a>01206                         ope_xx, ope_xx, ope_nd, ope_xx, ope_np, ope_xx, ope_xx, ope_0f,
<a name="l01207"></a>01207                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01208"></a>01208                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01209"></a>01209                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01210"></a>01210                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01211"></a>01211                         ope_np, ope_xx, ope_xx, ope_np, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01212"></a>01212                         ope_xx, ope_xx, ope_xx, ope_xx, ope_np, ope_xx, ope_xx, ope_np,
<a name="l01213"></a>01213                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01214"></a>01214                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01215"></a>01215                         ope_nd, ope_xx, ope_xx, ope_xx, ope_xx, ope_nd, ope_xx, ope_xx,
<a name="l01216"></a>01216                         ope_xx, ope_xx, ope_nd, ope_xx, ope_xx, ope_xx, ope_xx, ope_nd,
<a name="l01217"></a>01217                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_gg, ope_xx,
<a name="l01218"></a>01218                         ope_xx, ope_xx, ope_xx, ope_xx, ope_gg, ope_xx, ope_xx, ope_xx,
<a name="l01219"></a>01219                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01220"></a>01220                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01221"></a>01221                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01222"></a>01222                         ope_gg, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01223"></a>01223                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01224"></a>01224                         ope_xx, ope_xx, ope_xx, ope_xx, ope_gg, ope_xx, ope_xx, ope_xx,
<a name="l01225"></a>01225                         ope_nd, ope_xx, ope_xx, ope_xx, ope_xx, ope_nd, ope_xx, ope_xx,
<a name="l01226"></a>01226                         ope_xx, ope_xx, ope_nd, ope_xx, ope_gg, ope_xx, ope_xx, ope_nd,
<a name="l01227"></a>01227                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01228"></a>01228                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01229"></a>01229                         ope_c0, ope_xx, ope_xx, ope_np, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01230"></a>01230                         ope_gg, ope_xx, ope_gg, ope_xx, ope_np, ope_gg, ope_xx, ope_np,
<a name="l01231"></a>01231                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01232"></a>01232                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01233"></a>01233                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01234"></a>01234                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_gg, ope_xx,
<a name="l01235"></a>01235                         ope_f0, ope_xx, ope_xx, ope_np, ope_xx, ope_nd, ope_xx, ope_xx,
<a name="l01236"></a>01236                         ope_xx, ope_xx, ope_nd, ope_xx, ope_fc, ope_xx, ope_xx, ope_ff};
<a name="l01237"></a>01237 
<a name="l01238"></a>01238 <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> egc_quad &amp;egc_ope(<span class="keyword">const</span> PhysPt vramoff, <span class="keyword">const</span> AWT val) {
<a name="l01239"></a>01239     *((uint16_t*)pc98_egc_maskef) = *((uint16_t*)pc98_egc_mask);
<a name="l01240"></a>01240 
<a name="l01241"></a>01241     <span class="comment">/* 4A4h</span>
<a name="l01242"></a>01242 <span class="comment">     * bits [12:11] = light source</span>
<a name="l01243"></a>01243 <span class="comment">     *    11 = invalid</span>
<a name="l01244"></a>01244 <span class="comment">     *    10 = write the contents of the palette register</span>
<a name="l01245"></a>01245 <span class="comment">     *    01 = write the result of the raster operation</span>
<a name="l01246"></a>01246 <span class="comment">     *    00 = write CPU data</span>
<a name="l01247"></a>01247 <span class="comment">     *</span>
<a name="l01248"></a>01248 <span class="comment">     * 4A2h</span>
<a name="l01249"></a>01249 <span class="comment">     * bits [14:13] = foreground, background color</span>
<a name="l01250"></a>01250 <span class="comment">     *    11 = invalid</span>
<a name="l01251"></a>01251 <span class="comment">     *    10 = foreground color</span>
<a name="l01252"></a>01252 <span class="comment">     *    01 = background color</span>
<a name="l01253"></a>01253 <span class="comment">     *    00 = pattern register</span>
<a name="l01254"></a>01254 <span class="comment">     */</span>
<a name="l01255"></a>01255     <span class="keywordflow">switch</span> (pc98_egc_lightsource) {
<a name="l01256"></a>01256         <span class="keywordflow">case</span> 1: <span class="comment">/* 0x0800 */</span>
<a name="l01257"></a>01257             <span class="keywordflow">if</span> (pc98_egc_shiftinput) {
<a name="l01258"></a>01258                 pc98_egc_shift.input&lt;AWT&gt;(
<a name="l01259"></a>01259                     val,
<a name="l01260"></a>01260                     val,
<a name="l01261"></a>01261                     val,
<a name="l01262"></a>01262                     val,
<a name="l01263"></a>01263                     vramoff&amp;1);
<a name="l01264"></a>01264 
<a name="l01265"></a>01265                 pc98_egc_shift.output&lt;AWT&gt;(
<a name="l01266"></a>01266                     *((AWT*)(pc98_egc_src[0].b+(vramoff&amp;1))),
<a name="l01267"></a>01267                     *((AWT*)(pc98_egc_src[1].b+(vramoff&amp;1))),
<a name="l01268"></a>01268                     *((AWT*)(pc98_egc_src[2].b+(vramoff&amp;1))),
<a name="l01269"></a>01269                     *((AWT*)(pc98_egc_src[3].b+(vramoff&amp;1))),
<a name="l01270"></a>01270                     vramoff&amp;1);
<a name="l01271"></a>01271             }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273             *((uint16_t*)pc98_egc_maskef) &amp;= *((uint16_t*)pc98_egc_srcmask);
<a name="l01274"></a>01274             <span class="keywordflow">return</span> pc98_egc_opfn[pc98_egc_rop](pc98_egc_rop, vramoff &amp; (~1U));
<a name="l01275"></a>01275         <span class="keywordflow">case</span> 2: <span class="comment">/* 0x1000 */</span>
<a name="l01276"></a>01276             <span class="keywordflow">if</span> (pc98_egc_fgc == 1)
<a name="l01277"></a>01277                 <span class="keywordflow">return</span> pc98_egc_bgcm;
<a name="l01278"></a>01278             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pc98_egc_fgc == 2)
<a name="l01279"></a>01279                 <span class="keywordflow">return</span> pc98_egc_fgcm;
<a name="l01280"></a>01280 
<a name="l01281"></a>01281             <span class="keywordflow">if</span> (pc98_egc_shiftinput) {
<a name="l01282"></a>01282                 pc98_egc_shift.input&lt;AWT&gt;(
<a name="l01283"></a>01283                     val,
<a name="l01284"></a>01284                     val,
<a name="l01285"></a>01285                     val,
<a name="l01286"></a>01286                     val,
<a name="l01287"></a>01287                     vramoff&amp;1);
<a name="l01288"></a>01288 
<a name="l01289"></a>01289                 pc98_egc_shift.output&lt;AWT&gt;(
<a name="l01290"></a>01290                     *((AWT*)(pc98_egc_src[0].b+(vramoff&amp;1))),
<a name="l01291"></a>01291                     *((AWT*)(pc98_egc_src[1].b+(vramoff&amp;1))),
<a name="l01292"></a>01292                     *((AWT*)(pc98_egc_src[2].b+(vramoff&amp;1))),
<a name="l01293"></a>01293                     *((AWT*)(pc98_egc_src[3].b+(vramoff&amp;1))),
<a name="l01294"></a>01294                     vramoff&amp;1);
<a name="l01295"></a>01295             }
<a name="l01296"></a>01296  
<a name="l01297"></a>01297             *((uint16_t*)pc98_egc_maskef) &amp;= *((uint16_t*)pc98_egc_srcmask);
<a name="l01298"></a>01298             <span class="keywordflow">return</span> pc98_egc_src;
<a name="l01299"></a>01299         <span class="keywordflow">default</span>: {
<a name="l01300"></a>01300             uint16_t tmp = (uint16_t)val;
<a name="l01301"></a>01301 
<a name="l01302"></a>01302             <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &lt; 2) {
<a name="l01303"></a>01303                 tmp &amp;= 0xFFU;
<a name="l01304"></a>01304                 tmp |= tmp &lt;&lt; 8U;
<a name="l01305"></a>01305             }
<a name="l01306"></a>01306 
<a name="l01307"></a>01307             pc98_egc_data[0].w = tmp;
<a name="l01308"></a>01308             pc98_egc_data[1].w = tmp;
<a name="l01309"></a>01309             pc98_egc_data[2].w = tmp;
<a name="l01310"></a>01310             pc98_egc_data[3].w = tmp;
<a name="l01311"></a>01311             } <span class="keywordflow">break</span>;
<a name="l01312"></a>01312     }
<a name="l01313"></a>01313 
<a name="l01314"></a>01314     <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01315"></a>01315 }
<a name="l01316"></a>01316 
<a name="l01317"></a>01317 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pc98_mem_msw_m[8] = {0};
<a name="l01318"></a>01318 
<a name="l01319"></a>01319 <span class="keywordtype">void</span> pc98_msw3_set_ramsize(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b) {
<a name="l01320"></a>01320     pc98_mem_msw_m[2<span class="comment">/*MSW3*/</span>] = b;
<a name="l01321"></a>01321 }
<a name="l01322"></a>01322 
<a name="l01323"></a>01323 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pc98_mem_msw(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> which) {
<a name="l01324"></a>01324     <span class="keywordflow">return</span> pc98_mem_msw_m[which&amp;7];
<a name="l01325"></a>01325 }
<a name="l01326"></a>01326 
<a name="l01327"></a>01327 <span class="keywordtype">void</span> pc98_mem_msw_write(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> which,<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> val) {
<a name="l01328"></a>01328     LOG_MSG(<span class="stringliteral">&quot;WARNING: PC-98 NVRAM write to 0x%x value 0x%x, not implemented yet&quot;</span>,which,val);
<a name="l01329"></a>01329     <span class="comment">// TODO: Add code to write NVRAM.</span>
<a name="l01330"></a>01330     <span class="comment">//       According to documentation writing is only enabled if a register is written elsewhere to allow it.</span>
<a name="l01331"></a>01331 }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333 <span class="comment">/* The NEC display is documented to have:</span>
<a name="l01334"></a>01334 <span class="comment"> *</span>
<a name="l01335"></a>01335 <span class="comment"> * A0000-A3FFF      T-RAM (text) (8KB WORDs)</span>
<a name="l01336"></a>01336 <span class="comment"> *   A0000-A1FFF      Characters (4KB WORDs)</span>
<a name="l01337"></a>01337 <span class="comment"> *   A2000-A3FFF      Attributes (4KB WORDs). For each 16-bit WORD only the lower 8 bits are read/writeable.</span>
<a name="l01338"></a>01338 <span class="comment"> *   A4000-A5FFF      Unknown ?? (4KB WORDs)</span>
<a name="l01339"></a>01339 <span class="comment"> *   A6000-A7FFF      Not present (4KB WORDs)</span>
<a name="l01340"></a>01340 <span class="comment"> * A8000-BFFFF      G-RAM (graphics) (96KB)</span>
<a name="l01341"></a>01341 <span class="comment"> *</span>
<a name="l01342"></a>01342 <span class="comment"> * T-RAM character display RAM is 16-bits per character.</span>
<a name="l01343"></a>01343 <span class="comment"> * ASCII text has upper 8 bits zero.</span>
<a name="l01344"></a>01344 <span class="comment"> * SHIFT-JIS doublewide characters use the upper byte for non-ASCII. */</span>
<a name="l01345"></a>01345 
<a name="l01346"></a>01346 <span class="comment">/* A0000-A3FFF text character + attribute RAM */</span>
<a name="l01347"></a>01347 <span class="comment">/* </span>
<a name="l01348"></a>01348 <span class="comment"> * 0xA3FE2      MSW1</span>
<a name="l01349"></a>01349 <span class="comment"> * 0xA3FE6      MSW2</span>
<a name="l01350"></a>01350 <span class="comment"> * 0xA3FEA      MSW3</span>
<a name="l01351"></a>01351 <span class="comment"> * 0xA3FEE      MSW4</span>
<a name="l01352"></a>01352 <span class="comment"> * 0xA3FF2      MSW5</span>
<a name="l01353"></a>01353 <span class="comment"> * 0xA3FF6      MSW6</span>
<a name="l01354"></a>01354 <span class="comment"> * 0xA3FFA      MSW7</span>
<a name="l01355"></a>01355 <span class="comment"> * 0xA3FFE      MSW8</span>
<a name="l01356"></a>01356 <span class="comment"> *</span>
<a name="l01357"></a>01357 <span class="comment"> * TODO: Study real hardware to determine what the bytes between the NVRAM bytes are.</span>
<a name="l01358"></a>01358 <span class="comment"> *       Are they repeats of the MSW bytes, some other value, or just 0xFF?</span>
<a name="l01359"></a>01359 <span class="comment"> */</span>
<a name="l01360"></a><a class="code" href="classVGA__PC98__TEXT__PageHandler.html">01360</a> <span class="keyword">class </span><a class="code" href="classVGA__PC98__TEXT__PageHandler.html">VGA_PC98_TEXT_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01361"></a>01361 <span class="keyword">public</span>:
<a name="l01362"></a>01362         <a class="code" href="classVGA__PC98__TEXT__PageHandler.html">VGA_PC98_TEXT_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01363"></a>01363         Bit8u readb(PhysPt addr) {
<a name="l01364"></a>01364         addr &amp;= 0x3FFFu;
<a name="l01365"></a>01365 
<a name="l01366"></a>01366         <span class="keywordflow">if</span> (addr &gt;= 0x3FE0u)
<a name="l01367"></a>01367             <span class="keywordflow">return</span> pc98_mem_msw((addr &gt;&gt; 2u) &amp; 7u);
<a name="l01368"></a>01368         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((addr &amp; 0x2001u) == 0x2001u)
<a name="l01369"></a>01369             <span class="keywordflow">return</span> (Bit8u)(~0u); <span class="comment">/* Odd bytes of attribute RAM do not exist, apparently */</span>
<a name="l01370"></a>01370 
<a name="l01371"></a>01371         <span class="keywordflow">return</span> VRAM98_TEXT[addr];
<a name="l01372"></a>01372     }
<a name="l01373"></a>01373         <span class="keywordtype">void</span> writeb(PhysPt addr,Bit8u val) {
<a name="l01374"></a>01374         addr &amp;= 0x3FFFu;
<a name="l01375"></a>01375 
<a name="l01376"></a>01376         <span class="keywordflow">if</span> (addr &gt;= 0x3FE0u)
<a name="l01377"></a>01377             <span class="keywordflow">return</span> pc98_mem_msw_write((addr &gt;&gt; 2u) &amp; 7u,(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)val);
<a name="l01378"></a>01378         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((addr &amp; 0x2001u) == 0x2001u)
<a name="l01379"></a>01379             <span class="keywordflow">return</span>;             <span class="comment">/* Odd bytes of attribute RAM do not exist, apparently */</span>
<a name="l01380"></a>01380 
<a name="l01381"></a>01381         VRAM98_TEXT[addr] = (<span class="keywordtype">unsigned</span> char)val;
<a name="l01382"></a>01382     }
<a name="l01383"></a>01383 };
<a name="l01384"></a>01384 
<a name="l01385"></a>01385 <span class="keyword">extern</span> uint16_t a1_font_load_addr;
<a name="l01386"></a>01386 
<a name="l01387"></a>01387 <span class="comment">/* A4000-A4FFF character generator memory-mapped I/O */</span>
<a name="l01388"></a>01388 <span class="comment">/* 0xA4000-0xA4FFF is word-sized access to the character generator.</span>
<a name="l01389"></a>01389 <span class="comment"> *</span>
<a name="l01390"></a>01390 <span class="comment"> * Some games, though not many, appear to prefer this memory-mapped I/O</span>
<a name="l01391"></a>01391 <span class="comment"> * rather than the I/O ports.</span>
<a name="l01392"></a>01392 <span class="comment"> *</span>
<a name="l01393"></a>01393 <span class="comment"> * This fixes:</span>
<a name="l01394"></a>01394 <span class="comment"> *   - Eve Burst Error</span>
<a name="l01395"></a>01395 <span class="comment"> *</span>
<a name="l01396"></a>01396 <span class="comment"> * Also noted: Disassembling the CG functions of the BIOS on an actual</span>
<a name="l01397"></a>01397 <span class="comment"> *             PC9821 laptop reveals that the BIOS also uses this method,</span>
<a name="l01398"></a>01398 <span class="comment"> *             using REP MOVSW</span>
<a name="l01399"></a>01399 <span class="comment"> *</span>
<a name="l01400"></a>01400 <span class="comment"> * Also noted: On real hardware, A4000-A4FFF seems to latch to the CG.</span>
<a name="l01401"></a>01401 <span class="comment"> *             A5000-A5FFF seems to latch to nothing. */</span>
<a name="l01402"></a>01402 
<a name="l01403"></a>01403 <span class="comment">/* according to real hardware, memory address does not affect char offset (port 0xA5) */</span>
<a name="l01404"></a><a class="code" href="classVGA__PC98__CG__PageHandler.html">01404</a> <span class="keyword">class </span><a class="code" href="classVGA__PC98__CG__PageHandler.html">VGA_PC98_CG_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01405"></a>01405 <span class="keyword">public</span>:
<a name="l01406"></a>01406         <a class="code" href="classVGA__PC98__CG__PageHandler.html">VGA_PC98_CG_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01407"></a>01407         Bit8u readb(PhysPt addr) {
<a name="l01408"></a>01408         <span class="keywordflow">return</span> pc98_font_char_read(a1_font_load_addr,(addr &gt;&gt; 1) &amp; 0xF,addr &amp; 1);
<a name="l01409"></a>01409     }
<a name="l01410"></a>01410         <span class="keywordtype">void</span> writeb(PhysPt addr,Bit8u val) {
<a name="l01411"></a>01411         pc98_font_char_write(a1_font_load_addr,(addr &gt;&gt; 1) &amp; 0xF,addr &amp; 1,val);
<a name="l01412"></a>01412     }
<a name="l01413"></a>01413 };
<a name="l01414"></a>01414 
<a name="l01415"></a>01415 <span class="comment">/* 256-color control registers, memory mapped I/O */</span>
<a name="l01416"></a><a class="code" href="classVGA__PC98__256MMIO__PageHandler.html">01416</a> <span class="keyword">class </span><a class="code" href="classVGA__PC98__256MMIO__PageHandler.html">VGA_PC98_256MMIO_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01417"></a>01417 <span class="keyword">public</span>:
<a name="l01418"></a>01418         <a class="code" href="classVGA__PC98__256MMIO__PageHandler.html">VGA_PC98_256MMIO_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01419"></a>01419         Bit8u readb(PhysPt addr) {
<a name="l01420"></a>01420         <span class="keywordflow">return</span> pc98_pegc_mmio_read(addr &amp; 0x7FFFu);
<a name="l01421"></a>01421     }
<a name="l01422"></a>01422     <span class="keywordtype">void</span> writeb(PhysPt addr,Bit8u val) {
<a name="l01423"></a>01423         pc98_pegc_mmio_write(addr &amp; 0x7FFFu,val);
<a name="l01424"></a>01424     }
<a name="l01425"></a>01425 };
<a name="l01426"></a>01426 
<a name="l01427"></a>01427 <span class="comment">// A8000h-B7FFFh is 256-color planar (????)</span>
<a name="l01428"></a>01428 <span class="comment">// I don&#39;t THINK the bank switching registers have any effect. Not sure.</span>
<a name="l01429"></a>01429 <span class="comment">// However it makes sense to make it a 64KB region because 8 planes x 64KB = 512KB of RAM. Right?</span>
<a name="l01430"></a>01430 <span class="comment">// By the way real PEGC hardware seems to prefer WORD (16-bit) sized read/write aligned on WORD boundaries.</span>
<a name="l01431"></a>01431 <span class="comment">// In fact Windows 3.1&#39;s 256-color driver never uses byte-sized read/write in this planar mode.</span>
<a name="l01432"></a><a class="code" href="classVGA__PC98__256Planar__PageHandler.html">01432</a> <span class="keyword">class </span><a class="code" href="classVGA__PC98__256Planar__PageHandler.html">VGA_PC98_256Planar_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01433"></a>01433 <span class="keyword">public</span>:
<a name="l01434"></a>01434         <a class="code" href="classVGA__PC98__256Planar__PageHandler.html">VGA_PC98_256Planar_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01435"></a>01435         Bit8u readb(PhysPt addr) {
<a name="l01436"></a>01436         (void)addr;
<a name="l01437"></a>01437 
<a name="l01438"></a>01438 <span class="comment">//        LOG_MSG(&quot;PEGC 256-color planar warning: Readb from %lxh&quot;,(unsigned long)addr);</span>
<a name="l01439"></a>01439         <span class="keywordflow">return</span> (Bit8u)(~0);
<a name="l01440"></a>01440     }
<a name="l01441"></a>01441         <span class="keywordtype">void</span> writeb(PhysPt addr,Bit8u val) {
<a name="l01442"></a>01442         (void)addr;
<a name="l01443"></a>01443         (void)val;
<a name="l01444"></a>01444 
<a name="l01445"></a>01445 <span class="comment">//        LOG_MSG(&quot;PEGC 256-color planar warning: Writeb to %lxh val %02xh&quot;,(unsigned long)addr,(unsigned int)val);</span>
<a name="l01446"></a>01446     }
<a name="l01447"></a>01447         Bit16u readw(PhysPt addr) {
<a name="l01448"></a>01448         (void)addr;
<a name="l01449"></a>01449 
<a name="l01450"></a>01450 <span class="comment">//        LOG_MSG(&quot;PEGC 256-color planar warning: Readw from %lxh&quot;,(unsigned long)addr);</span>
<a name="l01451"></a>01451         <span class="keywordflow">return</span> (Bit16u)(~0);
<a name="l01452"></a>01452     }
<a name="l01453"></a>01453         <span class="keywordtype">void</span> writew(PhysPt addr,Bit16u val) {
<a name="l01454"></a>01454         (void)addr;
<a name="l01455"></a>01455         (void)val;
<a name="l01456"></a>01456 
<a name="l01457"></a>01457 <span class="comment">//        LOG_MSG(&quot;PEGC 256-color planar warning: Writew to %lxh val %04xh&quot;,(unsigned long)addr,(unsigned int)val);</span>
<a name="l01458"></a>01458     }
<a name="l01459"></a>01459 };
<a name="l01460"></a>01460 
<a name="l01461"></a>01461 <span class="comment">// A8000h is bank 0</span>
<a name="l01462"></a>01462 <span class="comment">// B0000h is bank 1</span>
<a name="l01463"></a><a class="code" href="classVGA__PC98__256BANK__PageHandler.html">01463</a> <span class="keyword">template</span> &lt;const <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bank&gt; <span class="keyword">class </span><a class="code" href="classVGA__PC98__256BANK__PageHandler.html">VGA_PC98_256BANK_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01464"></a>01464 <span class="keyword">public</span>:
<a name="l01465"></a>01465         <a class="code" href="classVGA__PC98__256BANK__PageHandler.html">VGA_PC98_256BANK_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01466"></a>01466         Bit8u readb(PhysPt addr) {
<a name="l01467"></a>01467         <span class="keywordflow">return</span> pc98_vram_256bank_from_window(bank)[addr &amp; 0x7FFFu];
<a name="l01468"></a>01468     }
<a name="l01469"></a>01469         <span class="keywordtype">void</span> writeb(PhysPt addr,Bit8u val) {
<a name="l01470"></a>01470         pc98_vram_256bank_from_window(bank)[addr &amp; 0x7FFFu] = val;
<a name="l01471"></a>01471     }
<a name="l01472"></a>01472 };
<a name="l01473"></a>01473 
<a name="l01474"></a>01474 <span class="keyword">namespace </span>pc98pgmio {
<a name="l01475"></a>01475 
<a name="l01476"></a>01476     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> check_align(<span class="keyword">const</span> PhysPt addr) {
<a name="l01477"></a>01477 <span class="preprocessor">#if 0</span>
<a name="l01478"></a>01478 <span class="preprocessor"></span>        <span class="comment">/* DEBUG: address must be aligned to datatype.</span>
<a name="l01479"></a>01479 <span class="comment">         *        Code that calls us must enforce that or subdivide</span>
<a name="l01480"></a>01480 <span class="comment">         *        to a small datatype that can follow this rule. */</span>
<a name="l01481"></a>01481         PhysPt chk = (1UL &lt;&lt; (<span class="keyword">sizeof</span>(AWT) - 1)) - 1;
<a name="l01482"></a>01482         <span class="comment">/* uint8_t:  chk = 0</span>
<a name="l01483"></a>01483 <span class="comment">         * uint16_t: chk = 1</span>
<a name="l01484"></a>01484 <span class="comment">         * TODO: Do you suppose later generation PC-9821&#39;s supported DWORD size bitplane transfers?</span>
<a name="l01485"></a>01485 <span class="comment">         *       Or did NEC just give up on anything past 16-bit and focus on the SVGA side of things? */</span>
<a name="l01486"></a>01486         assert((addr&amp;chk) == 0);
<a name="l01487"></a>01487 <span class="preprocessor">#else</span>
<a name="l01488"></a>01488 <span class="preprocessor"></span>        (void)addr;
<a name="l01489"></a>01489 <span class="preprocessor">#endif</span>
<a name="l01490"></a>01490 <span class="preprocessor"></span>    }
<a name="l01491"></a>01491 
<a name="l01492"></a>01492 }
<a name="l01493"></a>01493 
<a name="l01494"></a><a class="code" href="classVGA__PC98__PageHandler.html">01494</a> <span class="keyword">class </span><a class="code" href="classVGA__PC98__PageHandler.html">VGA_PC98_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01495"></a>01495 <span class="keyword">public</span>:
<a name="l01496"></a>01496         <a class="code" href="classVGA__PC98__PageHandler.html">VGA_PC98_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01497"></a>01497 
<a name="l01498"></a>01498     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> AWT mode8_r(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane,<span class="keyword">const</span> PhysPt vramoff) {
<a name="l01499"></a>01499         AWT r,b;
<a name="l01500"></a>01500 
<a name="l01501"></a>01501         b = *((AWT*)(pc98_pgraph_current_cpu_page + vramoff));
<a name="l01502"></a>01502         r = b ^ *((AWT*)pc98_gdc_tiles[plane].b);
<a name="l01503"></a>01503 
<a name="l01504"></a>01504         <span class="keywordflow">return</span> r;
<a name="l01505"></a>01505     }
<a name="l01506"></a>01506 
<a name="l01507"></a>01507     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> mode8_w(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane,<span class="keyword">const</span> PhysPt vramoff) {
<a name="l01508"></a>01508         AWT tb;
<a name="l01509"></a>01509 
<a name="l01510"></a>01510         <span class="comment">/* Neko Project II code suggests that the first byte is repeated. */</span>
<a name="l01511"></a>01511         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &gt; 1)
<a name="l01512"></a>01512             tb = pc98_gdc_tiles[plane].b[0] | (pc98_gdc_tiles[plane].b[0] &lt;&lt; 8u);
<a name="l01513"></a>01513         <span class="keywordflow">else</span>
<a name="l01514"></a>01514             tb = pc98_gdc_tiles[plane].b[0];
<a name="l01515"></a>01515 
<a name="l01516"></a>01516         *((AWT*)(pc98_pgraph_current_cpu_page + vramoff)) = tb;
<a name="l01517"></a>01517     }
<a name="l01518"></a>01518 
<a name="l01519"></a>01519     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> modeC_w(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane,<span class="keyword">const</span> PhysPt vramoff,<span class="keyword">const</span> AWT mask,<span class="keyword">const</span> AWT val) {
<a name="l01520"></a>01520         AWT t,tb;
<a name="l01521"></a>01521 
<a name="l01522"></a>01522         <span class="comment">/* Neko Project II code suggests that the first byte is repeated. */</span>
<a name="l01523"></a>01523         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &gt; 1)
<a name="l01524"></a>01524             tb = pc98_gdc_tiles[plane].b[0] | (pc98_gdc_tiles[plane].b[0] &lt;&lt; 8u);
<a name="l01525"></a>01525         <span class="keywordflow">else</span>
<a name="l01526"></a>01526             tb = pc98_gdc_tiles[plane].b[0];
<a name="l01527"></a>01527 
<a name="l01528"></a>01528         t  = *((AWT*)(pc98_pgraph_current_cpu_page + vramoff)) &amp; mask;
<a name="l01529"></a>01529         t |= val &amp; tb;
<a name="l01530"></a>01530         *((AWT*)(pc98_pgraph_current_cpu_page + vramoff)) = t;
<a name="l01531"></a>01531     }
<a name="l01532"></a>01532 
<a name="l01533"></a>01533     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> AWT modeEGC_r(<span class="keyword">const</span> PhysPt vramoff,<span class="keyword">const</span> PhysPt fulloff) {
<a name="l01534"></a>01534         <span class="comment">/* assume: vramoff is even IF AWT is 16-bit wide */</span>
<a name="l01535"></a>01535         *((AWT*)(pc98_egc_last_vram[0].b+(vramoff&amp;1))) = *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(0)));
<a name="l01536"></a>01536         *((AWT*)(pc98_egc_last_vram[1].b+(vramoff&amp;1))) = *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(1)));
<a name="l01537"></a>01537         *((AWT*)(pc98_egc_last_vram[2].b+(vramoff&amp;1))) = *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(2)));
<a name="l01538"></a>01538         *((AWT*)(pc98_egc_last_vram[3].b+(vramoff&amp;1))) = *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(3)));
<a name="l01539"></a>01539 
<a name="l01540"></a>01540         <span class="comment">/* bits [10:10] = read source</span>
<a name="l01541"></a>01541 <span class="comment">         *    1 = shifter input is CPU write data</span>
<a name="l01542"></a>01542 <span class="comment">         *    0 = shifter input is VRAM data */</span>
<a name="l01543"></a>01543         <span class="comment">/* Neko Project II: if ((egc.ope &amp; 0x0400) == 0) ... */</span>
<a name="l01544"></a>01544         <span class="keywordflow">if</span> (!pc98_egc_shiftinput) {
<a name="l01545"></a>01545             pc98_egc_shift.input&lt;AWT&gt;(
<a name="l01546"></a>01546                 *((AWT*)(pc98_egc_last_vram[0].b+(vramoff&amp;1))),
<a name="l01547"></a>01547                 *((AWT*)(pc98_egc_last_vram[1].b+(vramoff&amp;1))),
<a name="l01548"></a>01548                 *((AWT*)(pc98_egc_last_vram[2].b+(vramoff&amp;1))),
<a name="l01549"></a>01549                 *((AWT*)(pc98_egc_last_vram[3].b+(vramoff&amp;1))),
<a name="l01550"></a>01550                 vramoff&amp;1);
<a name="l01551"></a>01551 
<a name="l01552"></a>01552             pc98_egc_shift.output&lt;AWT&gt;(
<a name="l01553"></a>01553                 *((AWT*)(pc98_egc_src[0].b+(vramoff&amp;1))),
<a name="l01554"></a>01554                 *((AWT*)(pc98_egc_src[1].b+(vramoff&amp;1))),
<a name="l01555"></a>01555                 *((AWT*)(pc98_egc_src[2].b+(vramoff&amp;1))),
<a name="l01556"></a>01556                 *((AWT*)(pc98_egc_src[3].b+(vramoff&amp;1))),
<a name="l01557"></a>01557                 vramoff&amp;1);
<a name="l01558"></a>01558         }
<a name="l01559"></a>01559 
<a name="l01560"></a>01560         <span class="comment">/* 0x4A4:</span>
<a name="l01561"></a>01561 <span class="comment">         * ...</span>
<a name="l01562"></a>01562 <span class="comment">         * bits [9:8] = register load (pc98_egc_regload[1:0])</span>
<a name="l01563"></a>01563 <span class="comment">         *    11 = invalid</span>
<a name="l01564"></a>01564 <span class="comment">         *    10 = load VRAM data before writing on VRAM write</span>
<a name="l01565"></a>01565 <span class="comment">         *    01 = load VRAM data into pattern/tile register on VRAM read</span>
<a name="l01566"></a>01566 <span class="comment">         *    00 = Do not change pattern/tile register</span>
<a name="l01567"></a>01567 <span class="comment">         * ...</span>
<a name="l01568"></a>01568 <span class="comment">         *</span>
<a name="l01569"></a>01569 <span class="comment">         * pc98_egc_regload = (val &gt;&gt; 8) &amp; 3;</span>
<a name="l01570"></a>01570 <span class="comment">         */</span>
<a name="l01571"></a>01571         <span class="comment">/* Neko Project II: if ((egc.ope &amp; 0x0300) == 0x0100) ... */</span>
<a name="l01572"></a>01572         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 1) { <span class="comment">/* load VRAM data into pattern/tile... (or INVALID) */</span>
<a name="l01573"></a>01573             *((AWT*)(pc98_gdc_tiles[0].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[0].b+(vramoff&amp;1)));
<a name="l01574"></a>01574             *((AWT*)(pc98_gdc_tiles[1].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[1].b+(vramoff&amp;1)));
<a name="l01575"></a>01575             *((AWT*)(pc98_gdc_tiles[2].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[2].b+(vramoff&amp;1)));
<a name="l01576"></a>01576             *((AWT*)(pc98_gdc_tiles[3].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[3].b+(vramoff&amp;1)));
<a name="l01577"></a>01577         }
<a name="l01578"></a>01578 
<a name="l01579"></a>01579         <span class="comment">/* 0x4A4:</span>
<a name="l01580"></a>01580 <span class="comment">         * bits [13:13] = 0=compare lead plane  1=don&#39;t</span>
<a name="l01581"></a>01581 <span class="comment">         *</span>
<a name="l01582"></a>01582 <span class="comment">         * bits [10:10] = read source</span>
<a name="l01583"></a>01583 <span class="comment">         *    1 = shifter input is CPU write data</span>
<a name="l01584"></a>01584 <span class="comment">         *    0 = shifter input is VRAM data */</span>
<a name="l01585"></a>01585         <span class="keywordflow">if</span> (pc98_egc_compare_lead) {
<a name="l01586"></a>01586             <span class="keywordflow">if</span> (!pc98_egc_shiftinput)
<a name="l01587"></a>01587                 <span class="keywordflow">return</span> *((AWT*)(pc98_egc_src[pc98_egc_lead_plane&amp;3].b));
<a name="l01588"></a>01588             <span class="keywordflow">else</span>
<a name="l01589"></a>01589                 <span class="keywordflow">return</span> *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+((pc98_egc_lead_plane&amp;3)*PC98_VRAM_BITPLANE_SIZE)));
<a name="l01590"></a>01590         }
<a name="l01591"></a>01591 
<a name="l01592"></a>01592         <span class="keywordflow">return</span> *((AWT*)(pc98_pgraph_current_cpu_page+fulloff));
<a name="l01593"></a>01593     }
<a name="l01594"></a>01594 
<a name="l01595"></a>01595     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> modeEGC_w(<span class="keyword">const</span> PhysPt vramoff,<span class="keyword">const</span> AWT val) {
<a name="l01596"></a>01596         <span class="comment">/* assume: vramoff is even IF AWT is 16-bit wide */</span>
<a name="l01597"></a>01597 
<a name="l01598"></a>01598         <span class="comment">/* 0x4A4:</span>
<a name="l01599"></a>01599 <span class="comment">         * ...</span>
<a name="l01600"></a>01600 <span class="comment">         * bits [9:8] = register load (pc98_egc_regload[1:0])</span>
<a name="l01601"></a>01601 <span class="comment">         *    11 = invalid</span>
<a name="l01602"></a>01602 <span class="comment">         *    10 = load VRAM data before writing on VRAM write</span>
<a name="l01603"></a>01603 <span class="comment">         *    01 = load VRAM data into pattern/tile register on VRAM read</span>
<a name="l01604"></a>01604 <span class="comment">         *    00 = Do not change pattern/tile register</span>
<a name="l01605"></a>01605 <span class="comment">         * ...</span>
<a name="l01606"></a>01606 <span class="comment">         * pc98_egc_regload = (val &gt;&gt; 8) &amp; 3;</span>
<a name="l01607"></a>01607 <span class="comment">         */</span>
<a name="l01608"></a>01608         <span class="comment">/* Neko Project II: if ((egc.ope &amp; 0x0300) == 0x0200) ... */</span>
<a name="l01609"></a>01609         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 2) { <span class="comment">/* load VRAM data before writing on VRAM write (or INVALID) */</span>
<a name="l01610"></a>01610             *((AWT*)(pc98_gdc_tiles[0].b+(vramoff&amp;1))) = *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(0)));
<a name="l01611"></a>01611             *((AWT*)(pc98_gdc_tiles[1].b+(vramoff&amp;1))) = *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(1)));
<a name="l01612"></a>01612             *((AWT*)(pc98_gdc_tiles[2].b+(vramoff&amp;1))) = *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(2)));
<a name="l01613"></a>01613             *((AWT*)(pc98_gdc_tiles[3].b+(vramoff&amp;1))) = *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(3)));
<a name="l01614"></a>01614         }
<a name="l01615"></a>01615 
<a name="l01616"></a>01616         egc_quad &amp;ropdata = egc_ope&lt;AWT&gt;(vramoff, val);
<a name="l01617"></a>01617 
<a name="l01618"></a>01618         <span class="keyword">const</span> AWT accmask = *((AWT*)(pc98_egc_maskef+(vramoff&amp;1)));
<a name="l01619"></a>01619 
<a name="l01620"></a>01620         <span class="keywordflow">if</span> (accmask != 0) {
<a name="l01621"></a>01621             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 1)) {
<a name="l01622"></a>01622                 *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(0))) &amp;= ~accmask;
<a name="l01623"></a>01623                 *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(0))) |=  accmask &amp; *((AWT*)(ropdata[0].b+(vramoff&amp;1)));
<a name="l01624"></a>01624             }
<a name="l01625"></a>01625             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 2)) {
<a name="l01626"></a>01626                 *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(1))) &amp;= ~accmask;
<a name="l01627"></a>01627                 *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(1))) |=  accmask &amp; *((AWT*)(ropdata[1].b+(vramoff&amp;1)));
<a name="l01628"></a>01628             }
<a name="l01629"></a>01629             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 4)) {
<a name="l01630"></a>01630                 *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(2))) &amp;= ~accmask;
<a name="l01631"></a>01631                 *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(2))) |=  accmask &amp; *((AWT*)(ropdata[2].b+(vramoff&amp;1)));
<a name="l01632"></a>01632             }
<a name="l01633"></a>01633             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 8)) {
<a name="l01634"></a>01634                 *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(3))) &amp;= ~accmask;
<a name="l01635"></a>01635                 *((AWT*)(pc98_pgraph_current_cpu_page+vramoff+pc98_pgram_bitplane_offset(3))) |=  accmask &amp; *((AWT*)(ropdata[3].b+(vramoff&amp;1)));
<a name="l01636"></a>01636             }
<a name="l01637"></a>01637         }
<a name="l01638"></a>01638     }
<a name="l01639"></a>01639 
<a name="l01640"></a>01640     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; AWT readc(PhysPt addr) {
<a name="l01641"></a>01641         pc98pgmio::check_align&lt;AWT&gt;(addr);
<a name="l01642"></a>01642 
<a name="l01643"></a>01643         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane = ((addr &gt;&gt; 15u) + 3u) &amp; 3u;
<a name="l01644"></a>01644         addr &amp;= 0x7FFF;
<a name="l01645"></a>01645 
<a name="l01646"></a>01646         <span class="comment">/* reminder:</span>
<a name="l01647"></a>01647 <span class="comment">         *</span>
<a name="l01648"></a>01648 <span class="comment">         * bit 1: VOPBIT_EGC</span>
<a name="l01649"></a>01649 <span class="comment">         * bit 0: VOPBIT_ACCESS</span>
<a name="l01650"></a>01650 <span class="comment">         * From GRGC bits:</span>
<a name="l01651"></a>01651 <span class="comment">         * bit 3: VOPBIT_GRCG  1=GRGC active  0=GRGC invalid  (from bit 7)</span>
<a name="l01652"></a>01652 <span class="comment">         * bit 2: VOPBIT_GRCG  1=Read/Modify/Write when writing  0=TCR mode at read, TDW mode at write  (from bit 6) */</span>
<a name="l01653"></a>01653         <span class="keywordflow">switch</span> (pc98_gdc_vramop &amp; 0xF) {
<a name="l01654"></a>01654             <span class="keywordflow">case</span> 0x00:
<a name="l01655"></a>01655             <span class="keywordflow">case</span> 0x01:
<a name="l01656"></a>01656             <span class="keywordflow">case</span> 0x02:
<a name="l01657"></a>01657             <span class="keywordflow">case</span> 0x03:
<a name="l01658"></a>01658             <span class="keywordflow">case</span> 0x04:
<a name="l01659"></a>01659             <span class="keywordflow">case</span> 0x05:
<a name="l01660"></a>01660             <span class="keywordflow">case</span> 0x06:
<a name="l01661"></a>01661             <span class="keywordflow">case</span> 0x07:
<a name="l01662"></a>01662             <span class="keywordflow">case</span> 0x0C:
<a name="l01663"></a>01663             <span class="keywordflow">case</span> 0x0D:
<a name="l01664"></a>01664                 <span class="keywordflow">return</span> *((AWT*)(pc98_pgraph_current_cpu_page+addr+pc98_pgram_bitplane_offset(plane)));
<a name="l01665"></a>01665             <span class="keywordflow">case</span> 0x08: <span class="comment">/* TCR/TDW */</span>
<a name="l01666"></a>01666             <span class="keywordflow">case</span> 0x09:
<a name="l01667"></a>01667                 {
<a name="l01668"></a>01668                     AWT r = 0;
<a name="l01669"></a>01669 
<a name="l01670"></a>01670                     <span class="comment">/* this reads multiple bitplanes at once */</span>
<a name="l01671"></a>01671                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 1)) <span class="comment">// blue channel</span>
<a name="l01672"></a>01672                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>0,addr + pc98_pgram_bitplane_offset(0));
<a name="l01673"></a>01673 
<a name="l01674"></a>01674                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 2)) <span class="comment">// red channel</span>
<a name="l01675"></a>01675                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>1,addr + pc98_pgram_bitplane_offset(1));
<a name="l01676"></a>01676 
<a name="l01677"></a>01677                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 4)) <span class="comment">// green channel</span>
<a name="l01678"></a>01678                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>2,addr + pc98_pgram_bitplane_offset(2));
<a name="l01679"></a>01679 
<a name="l01680"></a>01680                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 8)) <span class="comment">// extended channel</span>
<a name="l01681"></a>01681                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>3,addr + pc98_pgram_bitplane_offset(3));
<a name="l01682"></a>01682 
<a name="l01683"></a>01683                     <span class="comment">/* NTS: Apparently returning this value correctly really matters to the</span>
<a name="l01684"></a>01684 <span class="comment">                     *      sprite engine in &quot;Edge&quot;, else visual errors occur. */</span>
<a name="l01685"></a>01685                     <span class="keywordflow">return</span> ~r;
<a name="l01686"></a>01686                 }
<a name="l01687"></a>01687             <span class="keywordflow">case</span> 0x0A: <span class="comment">/* EGC read */</span>
<a name="l01688"></a>01688             <span class="keywordflow">case</span> 0x0B:
<a name="l01689"></a>01689             <span class="keywordflow">case</span> 0x0E:
<a name="l01690"></a>01690             <span class="keywordflow">case</span> 0x0F:
<a name="l01691"></a>01691                 <span class="comment">/* this reads multiple bitplanes at once */</span>
<a name="l01692"></a>01692                 <span class="keywordflow">return</span> modeEGC_r&lt;AWT&gt;(addr,addr);
<a name="l01693"></a>01693             <span class="keywordflow">default</span>: <span class="comment">/* should not happen */</span>
<a name="l01694"></a>01694                 <span class="keywordflow">break</span>;
<a name="l01695"></a>01695         }
<a name="l01696"></a>01696 
<a name="l01697"></a>01697                 <span class="keywordflow">return</span> (AWT)(~0ull);
<a name="l01698"></a>01698         }
<a name="l01699"></a>01699 
<a name="l01700"></a>01700         <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keywordtype">void</span> writec(PhysPt addr,AWT val) {
<a name="l01701"></a>01701         pc98pgmio::check_align&lt;AWT&gt;(addr);
<a name="l01702"></a>01702 
<a name="l01703"></a>01703         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane = ((addr &gt;&gt; 15u) + 3u) &amp; 3u;
<a name="l01704"></a>01704         addr &amp;= 0x7FFF;
<a name="l01705"></a>01705 
<a name="l01706"></a>01706         <span class="comment">/* reminder:</span>
<a name="l01707"></a>01707 <span class="comment">         *</span>
<a name="l01708"></a>01708 <span class="comment">         * bit 1: VOPBIT_EGC</span>
<a name="l01709"></a>01709 <span class="comment">         * bit 0: VOPBIT_ACCESS</span>
<a name="l01710"></a>01710 <span class="comment">         * From GRGC bits:</span>
<a name="l01711"></a>01711 <span class="comment">         * bit 3: VOPBIT_GRCG  1=GRGC active  0=GRGC invalid  (from bit 7)</span>
<a name="l01712"></a>01712 <span class="comment">         * bit 2: VOPBIT_GRCG  1=Read/Modify/Write when writing  0=TCR mode at read, TDW mode at write  (from bit 6) */</span>
<a name="l01713"></a>01713         <span class="keywordflow">switch</span> (pc98_gdc_vramop &amp; 0xF) {
<a name="l01714"></a>01714             <span class="keywordflow">case</span> 0x00:
<a name="l01715"></a>01715             <span class="keywordflow">case</span> 0x01:
<a name="l01716"></a>01716             <span class="keywordflow">case</span> 0x02:
<a name="l01717"></a>01717             <span class="keywordflow">case</span> 0x03:
<a name="l01718"></a>01718             <span class="keywordflow">case</span> 0x04:
<a name="l01719"></a>01719             <span class="keywordflow">case</span> 0x05:
<a name="l01720"></a>01720             <span class="keywordflow">case</span> 0x06:
<a name="l01721"></a>01721             <span class="keywordflow">case</span> 0x07:
<a name="l01722"></a>01722                 *((AWT*)(pc98_pgraph_current_cpu_page+addr+pc98_pgram_bitplane_offset(plane))) = val;
<a name="l01723"></a>01723                 <span class="keywordflow">break</span>;
<a name="l01724"></a>01724             <span class="keywordflow">case</span> 0x08:  <span class="comment">/* TCR/TDW write tile data, no masking */</span>
<a name="l01725"></a>01725             <span class="keywordflow">case</span> 0x09:
<a name="l01726"></a>01726                 {
<a name="l01727"></a>01727                     <span class="comment">/* this writes to multiple bitplanes at once.</span>
<a name="l01728"></a>01728 <span class="comment">                     * notice that the value written has no meaning, only the tile data and memory address. */</span>
<a name="l01729"></a>01729                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 1)) <span class="comment">// blue channel</span>
<a name="l01730"></a>01730                         mode8_w&lt;AWT&gt;(0<span class="comment">/*plane*/</span>,addr + pc98_pgram_bitplane_offset(0));
<a name="l01731"></a>01731 
<a name="l01732"></a>01732                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 2)) <span class="comment">// red channel</span>
<a name="l01733"></a>01733                         mode8_w&lt;AWT&gt;(1<span class="comment">/*plane*/</span>,addr + pc98_pgram_bitplane_offset(1));
<a name="l01734"></a>01734 
<a name="l01735"></a>01735                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 4)) <span class="comment">// green channel</span>
<a name="l01736"></a>01736                         mode8_w&lt;AWT&gt;(2<span class="comment">/*plane*/</span>,addr + pc98_pgram_bitplane_offset(2));
<a name="l01737"></a>01737 
<a name="l01738"></a>01738                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 8)) <span class="comment">// extended channel</span>
<a name="l01739"></a>01739                         mode8_w&lt;AWT&gt;(3<span class="comment">/*plane*/</span>,addr + pc98_pgram_bitplane_offset(3));
<a name="l01740"></a>01740                 }
<a name="l01741"></a>01741                 <span class="keywordflow">break</span>;
<a name="l01742"></a>01742             <span class="keywordflow">case</span> 0x0C:  <span class="comment">/* read/modify/write from tile with masking */</span>
<a name="l01743"></a>01743             <span class="keywordflow">case</span> 0x0D:  <span class="comment">/* a lot of PC-98 games seem to rely on this for sprite rendering */</span>
<a name="l01744"></a>01744                 {
<a name="l01745"></a>01745                     <span class="keyword">const</span> AWT mask = ~val;
<a name="l01746"></a>01746 
<a name="l01747"></a>01747                     <span class="comment">/* this writes to multiple bitplanes at once */</span>
<a name="l01748"></a>01748                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 1)) <span class="comment">// blue channel</span>
<a name="l01749"></a>01749                         modeC_w&lt;AWT&gt;(0<span class="comment">/*plane*/</span>,addr + pc98_pgram_bitplane_offset(0),mask,val);
<a name="l01750"></a>01750 
<a name="l01751"></a>01751                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 2)) <span class="comment">// red channel</span>
<a name="l01752"></a>01752                         modeC_w&lt;AWT&gt;(1<span class="comment">/*plane*/</span>,addr + pc98_pgram_bitplane_offset(1),mask,val);
<a name="l01753"></a>01753 
<a name="l01754"></a>01754                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 4)) <span class="comment">// green channel</span>
<a name="l01755"></a>01755                         modeC_w&lt;AWT&gt;(2<span class="comment">/*plane*/</span>,addr + pc98_pgram_bitplane_offset(2),mask,val);
<a name="l01756"></a>01756 
<a name="l01757"></a>01757                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 8)) <span class="comment">// extended channel</span>
<a name="l01758"></a>01758                         modeC_w&lt;AWT&gt;(3<span class="comment">/*plane*/</span>,addr + pc98_pgram_bitplane_offset(3),mask,val);
<a name="l01759"></a>01759                 }
<a name="l01760"></a>01760                 <span class="keywordflow">break</span>;
<a name="l01761"></a>01761             <span class="keywordflow">case</span> 0x0A: <span class="comment">/* EGC write */</span>
<a name="l01762"></a>01762             <span class="keywordflow">case</span> 0x0B:
<a name="l01763"></a>01763             <span class="keywordflow">case</span> 0x0E:
<a name="l01764"></a>01764             <span class="keywordflow">case</span> 0x0F:
<a name="l01765"></a>01765                 <span class="comment">/* this reads multiple bitplanes at once */</span>
<a name="l01766"></a>01766                 modeEGC_w&lt;AWT&gt;(addr,val);
<a name="l01767"></a>01767                 <span class="keywordflow">break</span>;
<a name="l01768"></a>01768             <span class="keywordflow">default</span>: <span class="comment">/* Should not happen */</span>
<a name="l01769"></a>01769                 <span class="keywordflow">break</span>;
<a name="l01770"></a>01770         }
<a name="l01771"></a>01771         }
<a name="l01772"></a>01772 
<a name="l01773"></a>01773     <span class="comment">/* byte-wise */</span>
<a name="l01774"></a>01774         Bit8u readb(PhysPt addr) {
<a name="l01775"></a>01775         <span class="keywordflow">return</span> readc&lt;uint8_t&gt;( PAGING_GetPhysicalAddress(addr) );
<a name="l01776"></a>01776     }
<a name="l01777"></a>01777         <span class="keywordtype">void</span> writeb(PhysPt addr,Bit8u val) {
<a name="l01778"></a>01778         writec&lt;uint8_t&gt;( PAGING_GetPhysicalAddress(addr), val );
<a name="l01779"></a>01779     }
<a name="l01780"></a>01780 
<a name="l01781"></a>01781     <span class="comment">/* word-wise.</span>
<a name="l01782"></a>01782 <span class="comment">     * in the style of the 8086, non-word-aligned I/O is split into byte I/O */</span>
<a name="l01783"></a>01783         Bit16u readw(PhysPt addr) {
<a name="l01784"></a>01784         addr = PAGING_GetPhysicalAddress(addr);
<a name="l01785"></a>01785         <span class="keywordflow">if</span> (!(addr &amp; 1)) <span class="comment">/* if WORD aligned */</span>
<a name="l01786"></a>01786             <span class="keywordflow">return</span> readc&lt;uint16_t&gt;(addr);
<a name="l01787"></a>01787         <span class="keywordflow">else</span> {
<a name="l01788"></a>01788             <span class="keywordflow">return</span>   (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)readc&lt;uint8_t&gt;(addr+0U) +
<a name="l01789"></a>01789                     ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)readc&lt;uint8_t&gt;(addr+1U) &lt;&lt; 8u);
<a name="l01790"></a>01790         }
<a name="l01791"></a>01791     }
<a name="l01792"></a>01792         <span class="keywordtype">void</span> writew(PhysPt addr,Bit16u val) {
<a name="l01793"></a>01793         addr = PAGING_GetPhysicalAddress(addr);
<a name="l01794"></a>01794         <span class="keywordflow">if</span> (!(addr &amp; 1)) <span class="comment">/* if WORD aligned */</span>
<a name="l01795"></a>01795             writec&lt;uint16_t&gt;(addr,val);
<a name="l01796"></a>01796         <span class="keywordflow">else</span> {
<a name="l01797"></a>01797             writec&lt;uint8_t&gt;(addr+0,(uint8_t)val);
<a name="l01798"></a>01798             writec&lt;uint8_t&gt;(addr+1,(uint8_t)(val &gt;&gt; 8U));
<a name="l01799"></a>01799         }
<a name="l01800"></a>01800     }
<a name="l01801"></a>01801 };
<a name="l01802"></a>01802 
<a name="l01803"></a><a class="code" href="classVGA__PC98__LFB__Handler.html">01803</a> <span class="keyword">class </span><a class="code" href="classVGA__PC98__LFB__Handler.html">VGA_PC98_LFB_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01804"></a>01804 <span class="keyword">public</span>:
<a name="l01805"></a>01805         <a class="code" href="classVGA__PC98__LFB__Handler.html">VGA_PC98_LFB_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE|PFLAG_NOCODE) {}
<a name="l01806"></a>01806         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01807"></a>01807                 <span class="keywordflow">return</span> &amp;vga.mem.linear[(phys_page&amp;0x7F)*4096 + PC98_VRAM_GRAPHICS_OFFSET]; <span class="comment">/* 512KB mapping */</span>
<a name="l01808"></a>01808         }
<a name="l01809"></a>01809         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01810"></a>01810                 <span class="keywordflow">return</span> &amp;vga.mem.linear[(phys_page&amp;0x7F)*4096 + PC98_VRAM_GRAPHICS_OFFSET]; <span class="comment">/* 512KB mapping */</span>
<a name="l01811"></a>01811         }
<a name="l01812"></a>01812 };
<a name="l01813"></a>01813 
<a name="l01814"></a><a class="code" href="classVGA__Map__Handler.html">01814</a> <span class="keyword">class </span><a class="code" href="classVGA__Map__Handler.html">VGA_Map_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01815"></a>01815 <span class="keyword">public</span>:
<a name="l01816"></a>01816         <a class="code" href="classVGA__Map__Handler.html">VGA_Map_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE|PFLAG_NOCODE) {}
<a name="l01817"></a>01817         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01818"></a>01818                 phys_page-=vgapages.base;
<a name="l01819"></a>01819                 <span class="keywordflow">return</span> &amp;vga.mem.linear[CHECKED3(vga.svga.bank_read_full+phys_page*4096)];
<a name="l01820"></a>01820         }
<a name="l01821"></a>01821         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01822"></a>01822                 phys_page-=vgapages.base;
<a name="l01823"></a>01823                 <span class="keywordflow">return</span> &amp;vga.mem.linear[CHECKED3(vga.svga.bank_write_full+phys_page*4096)];
<a name="l01824"></a>01824         }
<a name="l01825"></a>01825 };
<a name="l01826"></a>01826 
<a name="l01827"></a><a class="code" href="classVGA__Slow__CGA__Handler.html">01827</a> <span class="keyword">class </span><a class="code" href="classVGA__Slow__CGA__Handler.html">VGA_Slow_CGA_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01828"></a>01828 <span class="keyword">public</span>:
<a name="l01829"></a>01829         <a class="code" href="classVGA__Slow__CGA__Handler.html">VGA_Slow_CGA_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01830"></a>01830         <span class="keywordtype">void</span> delay() {
<a name="l01831"></a>01831                 Bits delaycyc = (Bits)(CPU_CycleMax/((cpu_cycles_count_t)(1024/2.80)));
<a name="l01832"></a>01832                 <span class="keywordflow">if</span>(GCC_UNLIKELY(CPU_Cycles &lt; 3*delaycyc)) delaycyc=0;
<a name="l01833"></a>01833                 CPU_Cycles -= delaycyc;
<a name="l01834"></a>01834                 CPU_IODelayRemoved += delaycyc;
<a name="l01835"></a>01835         }
<a name="l01836"></a>01836 
<a name="l01837"></a>01837         Bit8u readb(PhysPt addr) {
<a name="l01838"></a>01838                 delay();
<a name="l01839"></a>01839                 <span class="keywordflow">return</span> vga.tandy.mem_base[(addr - 0xb8000) &amp; 0x3FFF];
<a name="l01840"></a>01840         }
<a name="l01841"></a>01841         <span class="keywordtype">void</span> writeb(PhysPt addr,Bit8u val){
<a name="l01842"></a>01842                 delay();
<a name="l01843"></a>01843                 vga.tandy.mem_base[(addr - 0xb8000) &amp; 0x3FFF] = val;
<a name="l01844"></a>01844         }
<a name="l01845"></a>01845         
<a name="l01846"></a>01846 };
<a name="l01847"></a>01847 
<a name="l01848"></a><a class="code" href="classVGA__LFB__Handler.html">01848</a> <span class="keyword">class </span><a class="code" href="classVGA__LFB__Handler.html">VGA_LFB_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01849"></a>01849 <span class="keyword">public</span>:
<a name="l01850"></a>01850         <a class="code" href="classVGA__LFB__Handler.html">VGA_LFB_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE|PFLAG_NOCODE) {}
<a name="l01851"></a>01851         HostPt GetHostReadPt( Bitu phys_page ) {
<a name="l01852"></a>01852                 phys_page -= vga.lfb.page;
<a name="l01853"></a>01853                 phys_page &amp;= (vga.mem.memsize &gt;&gt; 12) - 1;
<a name="l01854"></a>01854                 <span class="keywordflow">return</span> &amp;vga.mem.linear[CHECKED3(phys_page * 4096)];
<a name="l01855"></a>01855         }
<a name="l01856"></a>01856         HostPt GetHostWritePt( Bitu phys_page ) {
<a name="l01857"></a>01857                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01858"></a>01858         }
<a name="l01859"></a>01859 };
<a name="l01860"></a>01860 
<a name="l01861"></a>01861 <span class="keyword">extern</span> <span class="keywordtype">void</span> XGA_Write(Bitu port, Bitu val, Bitu len);
<a name="l01862"></a>01862 <span class="keyword">extern</span> Bitu XGA_Read(Bitu port, Bitu len);
<a name="l01863"></a>01863 
<a name="l01864"></a><a class="code" href="classVGA__MMIO__Handler.html">01864</a> <span class="keyword">class </span><a class="code" href="classVGA__MMIO__Handler.html">VGA_MMIO_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01865"></a>01865 <span class="keyword">public</span>:
<a name="l01866"></a>01866         <a class="code" href="classVGA__MMIO__Handler.html">VGA_MMIO_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01867"></a>01867         <span class="keywordtype">void</span> writeb(PhysPt addr,Bit8u val) {
<a name="l01868"></a>01868                 VGAMEM_USEC_write_delay();
<a name="l01869"></a>01869                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01870"></a>01870                 XGA_Write(port, val, 1);
<a name="l01871"></a>01871         }
<a name="l01872"></a>01872         <span class="keywordtype">void</span> writew(PhysPt addr,Bit16u val) {
<a name="l01873"></a>01873                 VGAMEM_USEC_write_delay();
<a name="l01874"></a>01874                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01875"></a>01875                 XGA_Write(port, val, 2);
<a name="l01876"></a>01876         }
<a name="l01877"></a>01877         <span class="keywordtype">void</span> writed(PhysPt addr,Bit32u val) {
<a name="l01878"></a>01878                 VGAMEM_USEC_write_delay();
<a name="l01879"></a>01879                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01880"></a>01880                 XGA_Write(port, val, 4);
<a name="l01881"></a>01881         }
<a name="l01882"></a>01882 
<a name="l01883"></a>01883         Bit8u readb(PhysPt addr) {
<a name="l01884"></a>01884                 VGAMEM_USEC_read_delay();
<a name="l01885"></a>01885                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01886"></a>01886                 <span class="keywordflow">return</span> (Bit8u)XGA_Read(port, 1);
<a name="l01887"></a>01887         }
<a name="l01888"></a>01888         Bit16u readw(PhysPt addr) {
<a name="l01889"></a>01889                 VGAMEM_USEC_read_delay();
<a name="l01890"></a>01890                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01891"></a>01891                 <span class="keywordflow">return</span> (Bit16u)XGA_Read(port, 2);
<a name="l01892"></a>01892         }
<a name="l01893"></a>01893         Bit32u readd(PhysPt addr) {
<a name="l01894"></a>01894                 VGAMEM_USEC_read_delay();
<a name="l01895"></a>01895                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01896"></a>01896                 <span class="keywordflow">return</span> (Bit32u)XGA_Read(port, 4);
<a name="l01897"></a>01897         }
<a name="l01898"></a>01898 };
<a name="l01899"></a>01899 
<a name="l01900"></a><a class="code" href="classVGA__TANDY__PageHandler.html">01900</a> <span class="keyword">class </span><a class="code" href="classVGA__TANDY__PageHandler.html">VGA_TANDY_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01901"></a>01901 <span class="keyword">public</span>:
<a name="l01902"></a>01902         <a class="code" href="classVGA__TANDY__PageHandler.html">VGA_TANDY_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE) {}
<a name="l01903"></a>01903         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01904"></a>01904                 <span class="comment">// Odd banks are limited to 16kB and repeated</span>
<a name="l01905"></a>01905                 <span class="keywordflow">if</span> (vga.tandy.mem_bank &amp; 1) 
<a name="l01906"></a>01906                         phys_page&amp;=0x03;
<a name="l01907"></a>01907                 <span class="keywordflow">else</span> 
<a name="l01908"></a>01908                         phys_page&amp;=0x07;
<a name="l01909"></a>01909                 <span class="keywordflow">return</span> vga.tandy.mem_base + (phys_page * 4096);
<a name="l01910"></a>01910         }
<a name="l01911"></a>01911         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01912"></a>01912                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01913"></a>01913         }
<a name="l01914"></a>01914 };
<a name="l01915"></a>01915 
<a name="l01916"></a>01916 
<a name="l01917"></a><a class="code" href="classVGA__PCJR__Handler.html">01917</a> <span class="keyword">class </span><a class="code" href="classVGA__PCJR__Handler.html">VGA_PCJR_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01918"></a>01918 <span class="keyword">public</span>:
<a name="l01919"></a>01919         <a class="code" href="classVGA__PCJR__Handler.html">VGA_PCJR_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE) {}
<a name="l01920"></a>01920         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01921"></a>01921                 phys_page-=0xb8;
<a name="l01922"></a>01922                 <span class="comment">// The 16kB map area is repeated in the 32kB range</span>
<a name="l01923"></a>01923                 <span class="comment">// On CGA CPU A14 is not decoded so it repeats there too</span>
<a name="l01924"></a>01924                 phys_page&amp;=0x03;
<a name="l01925"></a>01925                 <span class="keywordflow">return</span> vga.tandy.mem_base + (phys_page * 4096);
<a name="l01926"></a>01926         }
<a name="l01927"></a>01927         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01928"></a>01928                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01929"></a>01929         }
<a name="l01930"></a>01930 };
<a name="l01931"></a>01931 
<a name="l01932"></a><a class="code" href="classVGA__AMS__Handler.html">01932</a> <span class="keyword">class </span><a class="code" href="classVGA__AMS__Handler.html">VGA_AMS_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01933"></a>01933 <span class="keyword">public</span>:
<a name="l01934"></a>01934         <span class="keyword">template</span>&lt; <span class="keywordtype">bool</span> wrapping&gt;
<a name="l01935"></a>01935         <span class="keywordtype">void</span> writeHandler(PhysPt start, Bit8u val) {
<a name="l01936"></a>01936                 vga.tandy.mem_base[ start ] = val;
<a name="l01937"></a>01937 <span class="preprocessor">#ifdef DIJDIJD</span>
<a name="l01938"></a>01938 <span class="preprocessor"></span>                Bit32u data=ModeOperation(val);
<a name="l01939"></a>01939                 <span class="comment">/* Update video memory and the pixel buffer */</span>
<a name="l01940"></a>01940                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> pixels;
<a name="l01941"></a>01941                 pixels.d=((Bit32u*)vga.mem.linear)[start];
<a name="l01942"></a>01942                 pixels.d&amp;=vga.config.full_not_map_mask;
<a name="l01943"></a>01943                 pixels.d|=(data &amp; vga.config.full_map_mask);
<a name="l01944"></a>01944                 ((Bit32u*)vga.mem.linear)[start]=pixels.d;
<a name="l01945"></a>01945                 Bit8u * write_pixels=&amp;vga.mem.linear[VGA_CACHE_OFFSET+(start&lt;&lt;3)];
<a name="l01946"></a>01946 
<a name="l01947"></a>01947                 Bit32u colors0_3, colors4_7;
<a name="l01948"></a>01948                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> temp;temp.d=(pixels.d&gt;&gt;4) &amp; 0x0f0f0f0f;
<a name="l01949"></a>01949                         colors0_3 = 
<a name="l01950"></a>01950                         Expand16Table[0][temp.b[0]] |
<a name="l01951"></a>01951                         Expand16Table[1][temp.b[1]] |
<a name="l01952"></a>01952                         Expand16Table[2][temp.b[2]] |
<a name="l01953"></a>01953                         Expand16Table[3][temp.b[3]];
<a name="l01954"></a>01954                 *(Bit32u *)write_pixels=colors0_3;
<a name="l01955"></a>01955                 temp.d=pixels.d &amp; 0x0f0f0f0f;
<a name="l01956"></a>01956                 colors4_7 = 
<a name="l01957"></a>01957                         Expand16Table[0][temp.b[0]] |
<a name="l01958"></a>01958                         Expand16Table[1][temp.b[1]] |
<a name="l01959"></a>01959                         Expand16Table[2][temp.b[2]] |
<a name="l01960"></a>01960                         Expand16Table[3][temp.b[3]];
<a name="l01961"></a>01961                 *(Bit32u *)(write_pixels+4)=colors4_7;
<a name="l01962"></a>01962                 <span class="keywordflow">if</span> (wrapping &amp;&amp; GCC_UNLIKELY( start &lt; 512)) {
<a name="l01963"></a>01963                         *(Bit32u *)(write_pixels+512*1024)=colors0_3;
<a name="l01964"></a>01964                         *(Bit32u *)(write_pixels+512*1024+4)=colors4_7;
<a name="l01965"></a>01965                 }
<a name="l01966"></a>01966 <span class="preprocessor">#endif</span>
<a name="l01967"></a>01967 <span class="preprocessor"></span>        }
<a name="l01968"></a>01968 <span class="comment">//      template&lt; bool wrapping&gt;</span>
<a name="l01969"></a>01969         Bit8u readHandler(PhysPt start) {
<a name="l01970"></a>01970                 <span class="keywordflow">return</span> vga.tandy.mem_base[ start ];
<a name="l01971"></a>01971         }
<a name="l01972"></a>01972 
<a name="l01973"></a>01973 <span class="keyword">public</span>:
<a name="l01974"></a>01974         <a class="code" href="classVGA__AMS__Handler.html">VGA_AMS_Handler</a>() {
<a name="l01975"></a>01975                 <span class="comment">//flags=PFLAG_READABLE|PFLAG_WRITEABLE;</span>
<a name="l01976"></a>01976                 flags=PFLAG_NOCODE;
<a name="l01977"></a>01977         }
<a name="l01978"></a>01978         <span class="keyword">inline</span> PhysPt wrAddr( PhysPt addr )
<a name="l01979"></a>01979         {
<a name="l01980"></a>01980                 <span class="keywordflow">if</span>( vga.mode != M_AMSTRAD )
<a name="l01981"></a>01981                 {
<a name="l01982"></a>01982                         addr -= 0xb8000;
<a name="l01983"></a>01983                         PhysPt phys_page = addr &gt;&gt; 12;
<a name="l01984"></a>01984                         <span class="comment">//test for a unaliged bank, then replicate 2x16kb</span>
<a name="l01985"></a>01985                         <span class="keywordflow">if</span> (vga.tandy.mem_bank &amp; 1) 
<a name="l01986"></a>01986                                 phys_page&amp;=0x03;
<a name="l01987"></a>01987                         <span class="keywordflow">return</span> ( phys_page * 4096 ) + ( addr &amp; 0x0FFF );
<a name="l01988"></a>01988                 }
<a name="l01989"></a>01989                 <span class="keywordflow">return</span> ( (PAGING_GetPhysicalAddress(addr) &amp; 0xffff) - 0x8000 ) &amp; ( 32*1024-1 );
<a name="l01990"></a>01990         }
<a name="l01991"></a>01991 
<a name="l01992"></a>01992         <span class="keywordtype">void</span> writeb(PhysPt addr,Bit8u val) {
<a name="l01993"></a>01993                 VGAMEM_USEC_write_delay();
<a name="l01994"></a>01994                 addr = wrAddr( addr );
<a name="l01995"></a>01995                 Bitu plane = vga.mode==M_AMSTRAD ? vga.amstrad.write_plane : 0x01; <span class="comment">// 0x0F?</span>
<a name="l01996"></a>01996                 <span class="keywordflow">if</span>( plane &amp; 0x08 ) writeHandler&lt;false&gt;(addr+49152,(Bit8u)(val &gt;&gt; 0));
<a name="l01997"></a>01997                 <span class="keywordflow">if</span>( plane &amp; 0x04 ) writeHandler&lt;false&gt;(addr+32768,(Bit8u)(val &gt;&gt; 0));
<a name="l01998"></a>01998                 <span class="keywordflow">if</span>( plane &amp; 0x02 ) writeHandler&lt;false&gt;(addr+16384,(Bit8u)(val &gt;&gt; 0));
<a name="l01999"></a>01999                 <span class="keywordflow">if</span>( plane &amp; 0x01 ) writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02000"></a>02000         }
<a name="l02001"></a>02001         <span class="keywordtype">void</span> writew(PhysPt addr,Bit16u val) {
<a name="l02002"></a>02002                 VGAMEM_USEC_write_delay();
<a name="l02003"></a>02003                 addr = wrAddr( addr );
<a name="l02004"></a>02004                 Bitu plane = vga.mode==M_AMSTRAD ? vga.amstrad.write_plane : 0x01; <span class="comment">// 0x0F?</span>
<a name="l02005"></a>02005                 <span class="keywordflow">if</span>( plane &amp; 0x01 )
<a name="l02006"></a>02006                 {
<a name="l02007"></a>02007                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02008"></a>02008                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02009"></a>02009                 }
<a name="l02010"></a>02010                 addr += 16384;
<a name="l02011"></a>02011                 <span class="keywordflow">if</span>( plane &amp; 0x02 )
<a name="l02012"></a>02012                 {
<a name="l02013"></a>02013                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02014"></a>02014                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02015"></a>02015                 }
<a name="l02016"></a>02016                 addr += 16384;
<a name="l02017"></a>02017                 <span class="keywordflow">if</span>( plane &amp; 0x04 )
<a name="l02018"></a>02018                 {
<a name="l02019"></a>02019                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02020"></a>02020                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02021"></a>02021                 }
<a name="l02022"></a>02022                 addr += 16384;
<a name="l02023"></a>02023                 <span class="keywordflow">if</span>( plane &amp; 0x08 )
<a name="l02024"></a>02024                 {
<a name="l02025"></a>02025                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02026"></a>02026                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02027"></a>02027                 }
<a name="l02028"></a>02028 
<a name="l02029"></a>02029         }
<a name="l02030"></a>02030         <span class="keywordtype">void</span> writed(PhysPt addr,Bit32u val) {
<a name="l02031"></a>02031                 VGAMEM_USEC_write_delay();
<a name="l02032"></a>02032                 addr = wrAddr( addr );
<a name="l02033"></a>02033                 Bitu plane = vga.mode==M_AMSTRAD ? vga.amstrad.write_plane : 0x01; <span class="comment">// 0x0F?</span>
<a name="l02034"></a>02034                 <span class="keywordflow">if</span>( plane &amp; 0x01 )
<a name="l02035"></a>02035                 {
<a name="l02036"></a>02036                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02037"></a>02037                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02038"></a>02038                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l02039"></a>02039                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l02040"></a>02040                 }
<a name="l02041"></a>02041                 addr += 16384;
<a name="l02042"></a>02042                 <span class="keywordflow">if</span>( plane &amp; 0x02 )
<a name="l02043"></a>02043                 {
<a name="l02044"></a>02044                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02045"></a>02045                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02046"></a>02046                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l02047"></a>02047                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l02048"></a>02048                 }
<a name="l02049"></a>02049                 addr += 16384;
<a name="l02050"></a>02050                 <span class="keywordflow">if</span>( plane &amp; 0x04 )
<a name="l02051"></a>02051                 {
<a name="l02052"></a>02052                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02053"></a>02053                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02054"></a>02054                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l02055"></a>02055                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l02056"></a>02056                 }
<a name="l02057"></a>02057                 addr += 16384;
<a name="l02058"></a>02058                 <span class="keywordflow">if</span>( plane &amp; 0x08 )
<a name="l02059"></a>02059                 {
<a name="l02060"></a>02060                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02061"></a>02061                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02062"></a>02062                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l02063"></a>02063                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l02064"></a>02064                 }
<a name="l02065"></a>02065 
<a name="l02066"></a>02066         }
<a name="l02067"></a>02067         Bit8u readb(PhysPt addr) {
<a name="l02068"></a>02068                 VGAMEM_USEC_read_delay();
<a name="l02069"></a>02069                 addr = wrAddr( addr ) + ( vga.amstrad.read_plane * 16384u );
<a name="l02070"></a>02070                 addr &amp;= (64u*1024u-1u);
<a name="l02071"></a>02071                 <span class="keywordflow">return</span> readHandler(addr);
<a name="l02072"></a>02072         }
<a name="l02073"></a>02073         Bit16u readw(PhysPt addr) {
<a name="l02074"></a>02074                 VGAMEM_USEC_read_delay();
<a name="l02075"></a>02075                 addr = wrAddr( addr ) + ( vga.amstrad.read_plane * 16384u );
<a name="l02076"></a>02076                 addr &amp;= (64u*1024u-1u);
<a name="l02077"></a>02077                 <span class="keywordflow">return</span> 
<a name="l02078"></a>02078                         (readHandler(addr+0) &lt;&lt; 0u) |
<a name="l02079"></a>02079                         (readHandler(addr+1) &lt;&lt; 8u);
<a name="l02080"></a>02080         }
<a name="l02081"></a>02081         Bit32u readd(PhysPt addr) {
<a name="l02082"></a>02082                 VGAMEM_USEC_read_delay();
<a name="l02083"></a>02083                 addr = wrAddr( addr ) + ( vga.amstrad.read_plane * 16384u );
<a name="l02084"></a>02084                 addr &amp;= (64u*1024u-1u);
<a name="l02085"></a>02085                 <span class="keywordflow">return</span> 
<a name="l02086"></a>02086                         (Bit32u)(readHandler(addr+0) &lt;&lt; 0u)  |
<a name="l02087"></a>02087                         (Bit32u)(readHandler(addr+1) &lt;&lt; 8u)  |
<a name="l02088"></a>02088                         (Bit32u)(readHandler(addr+2) &lt;&lt; 16u) |
<a name="l02089"></a>02089                         (Bit32u)(readHandler(addr+3) &lt;&lt; 24u);
<a name="l02090"></a>02090         }
<a name="l02091"></a>02091 
<a name="l02092"></a>02092 <span class="comment">/*</span>
<a name="l02093"></a>02093 <span class="comment">        HostPt GetHostReadPt(Bitu phys_page)</span>
<a name="l02094"></a>02094 <span class="comment">        {</span>
<a name="l02095"></a>02095 <span class="comment">                if( vga.mode!=M_AMSTRAD )</span>
<a name="l02096"></a>02096 <span class="comment">                {</span>
<a name="l02097"></a>02097 <span class="comment">                        phys_page-=0xb8;</span>
<a name="l02098"></a>02098 <span class="comment">                        //test for a unaliged bank, then replicate 2x16kb</span>
<a name="l02099"></a>02099 <span class="comment">                        if (vga.tandy.mem_bank &amp; 1) </span>
<a name="l02100"></a>02100 <span class="comment">                                phys_page&amp;=0x03;</span>
<a name="l02101"></a>02101 <span class="comment">                        return vga.tandy.mem_base + (phys_page * 4096);</span>
<a name="l02102"></a>02102 <span class="comment">                }</span>
<a name="l02103"></a>02103 <span class="comment">                phys_page-=0xb8;</span>
<a name="l02104"></a>02104 <span class="comment">                return vga.tandy.mem_base + (phys_page*4096) + (vga.amstrad.read_plane * 16384) ;</span>
<a name="l02105"></a>02105 <span class="comment">        }</span>
<a name="l02106"></a>02106 <span class="comment">*/</span>
<a name="l02107"></a>02107 <span class="comment">/*</span>
<a name="l02108"></a>02108 <span class="comment">        HostPt GetHostWritePt(Bitu phys_page) {</span>
<a name="l02109"></a>02109 <span class="comment">                return GetHostReadPt( phys_page );</span>
<a name="l02110"></a>02110 <span class="comment">        }</span>
<a name="l02111"></a>02111 <span class="comment">*/</span>
<a name="l02112"></a>02112 };
<a name="l02113"></a>02113 
<a name="l02114"></a><a class="code" href="classVGA__HERC__Handler.html">02114</a> <span class="keyword">class </span><a class="code" href="classVGA__HERC__Handler.html">VGA_HERC_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l02115"></a>02115 <span class="keyword">public</span>:
<a name="l02116"></a>02116         <a class="code" href="classVGA__HERC__Handler.html">VGA_HERC_Handler</a>() {
<a name="l02117"></a>02117                 flags=PFLAG_READABLE|PFLAG_WRITEABLE;
<a name="l02118"></a>02118         }
<a name="l02119"></a>02119         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l02120"></a>02120         (void)phys_page;<span class="comment">//UNUSED</span>
<a name="l02121"></a>02121                 <span class="comment">// The 4kB map area is repeated in the 32kB range</span>
<a name="l02122"></a>02122                 <span class="keywordflow">return</span> &amp;vga.mem.linear[0];
<a name="l02123"></a>02123         }
<a name="l02124"></a>02124         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l02125"></a>02125                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l02126"></a>02126         }
<a name="l02127"></a>02127 };
<a name="l02128"></a>02128 
<a name="l02129"></a><a class="code" href="classVGA__Empty__Handler.html">02129</a> <span class="keyword">class </span><a class="code" href="classVGA__Empty__Handler.html">VGA_Empty_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l02130"></a>02130 <span class="keyword">public</span>:
<a name="l02131"></a>02131         <a class="code" href="classVGA__Empty__Handler.html">VGA_Empty_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l02132"></a>02132         Bit8u readb(PhysPt <span class="comment">/*addr*/</span>) {
<a name="l02133"></a>02133 <span class="comment">//              LOG(LOG_VGA, LOG_NORMAL ) ( &quot;Read from empty memory space at %x&quot;, addr );</span>
<a name="l02134"></a>02134                 <span class="keywordflow">return</span> 0xff;
<a name="l02135"></a>02135         } 
<a name="l02136"></a>02136         <span class="keywordtype">void</span> writeb(PhysPt <span class="comment">/*addr*/</span>,Bit8u <span class="comment">/*val*/</span>) {
<a name="l02137"></a>02137 <span class="comment">//              LOG(LOG_VGA, LOG_NORMAL ) ( &quot;Write %x to empty memory space at %x&quot;, val, addr );</span>
<a name="l02138"></a>02138         }
<a name="l02139"></a>02139 };
<a name="l02140"></a>02140 
<a name="l02141"></a>02141 <span class="keyword">static</span> <span class="keyword">struct </span>vg {
<a name="l02142"></a>02142         <a class="code" href="classVGA__PC98__LFB__Handler.html">VGA_PC98_LFB_Handler</a>            map_lfb_pc98;
<a name="l02143"></a>02143         <a class="code" href="classVGA__Map__Handler.html">VGA_Map_Handler</a>                         map;
<a name="l02144"></a>02144         <a class="code" href="classVGA__Slow__CGA__Handler.html">VGA_Slow_CGA_Handler</a>            slow;
<a name="l02145"></a>02145 <span class="comment">//      VGA_TEXT_PageHandler            text;</span>
<a name="l02146"></a>02146         <a class="code" href="classVGA__CGATEXT__PageHandler.html">VGA_CGATEXT_PageHandler</a>         cgatext;
<a name="l02147"></a>02147         <a class="code" href="classVGA__MCGATEXT__PageHandler.html">VGA_MCGATEXT_PageHandler</a>        mcgatext;
<a name="l02148"></a>02148         <a class="code" href="classVGA__TANDY__PageHandler.html">VGA_TANDY_PageHandler</a>           tandy;
<a name="l02149"></a>02149 <span class="comment">//      VGA_ChainedEGA_Handler          cega;</span>
<a name="l02150"></a>02150 <span class="comment">//      VGA_ChainedVGA_Handler          cvga;</span>
<a name="l02151"></a>02151         <a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">VGA_ChainedVGA_Slow_Handler</a>     cvga_slow;
<a name="l02152"></a>02152 <span class="comment">//      VGA_ET4000_ChainedVGA_Handler           cvga_et4000;</span>
<a name="l02153"></a>02153         <a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">VGA_ET4000_ChainedVGA_Slow_Handler</a>      cvga_et4000_slow;
<a name="l02154"></a>02154 <span class="comment">//      VGA_UnchainedEGA_Handler        uega;</span>
<a name="l02155"></a>02155         <a class="code" href="classVGA__UnchainedVGA__Handler.html">VGA_UnchainedVGA_Handler</a>        uvga;
<a name="l02156"></a>02156         <a class="code" href="classVGA__PCJR__Handler.html">VGA_PCJR_Handler</a>                        pcjr;
<a name="l02157"></a>02157         <a class="code" href="classVGA__HERC__Handler.html">VGA_HERC_Handler</a>                        herc;
<a name="l02158"></a>02158 <span class="comment">//      VGA_LIN4_Handler                        lin4;</span>
<a name="l02159"></a>02159         <a class="code" href="classVGA__LFB__Handler.html">VGA_LFB_Handler</a>                         lfb;
<a name="l02160"></a>02160         <a class="code" href="classVGA__MMIO__Handler.html">VGA_MMIO_Handler</a>                        mmio;
<a name="l02161"></a>02161         <a class="code" href="classVGA__AMS__Handler.html">VGA_AMS_Handler</a>                         ams;
<a name="l02162"></a>02162     <a class="code" href="classVGA__PC98__PageHandler.html">VGA_PC98_PageHandler</a>        pc98;
<a name="l02163"></a>02163     <a class="code" href="classVGA__PC98__TEXT__PageHandler.html">VGA_PC98_TEXT_PageHandler</a>   pc98_text;
<a name="l02164"></a>02164     <a class="code" href="classVGA__PC98__CG__PageHandler.html">VGA_PC98_CG_PageHandler</a>     pc98_cg;
<a name="l02165"></a>02165     <a class="code" href="classVGA__PC98__256MMIO__PageHandler.html">VGA_PC98_256MMIO_PageHandler</a> pc98_256mmio;
<a name="l02166"></a>02166     <a class="code" href="classVGA__PC98__256BANK__PageHandler.html">VGA_PC98_256BANK_PageHandler&lt;0&gt;</a> pc98_256bank0;
<a name="l02167"></a>02167     <a class="code" href="classVGA__PC98__256BANK__PageHandler.html">VGA_PC98_256BANK_PageHandler&lt;1&gt;</a> pc98_256bank1;
<a name="l02168"></a>02168     <a class="code" href="classVGA__PC98__256Planar__PageHandler.html">VGA_PC98_256Planar_PageHandler</a> pc98_256planar;
<a name="l02169"></a>02169         <a class="code" href="classVGA__Empty__Handler.html">VGA_Empty_Handler</a>                       empty;
<a name="l02170"></a>02170 } vgaph;
<a name="l02171"></a>02171 
<a name="l02172"></a>02172 <span class="keywordtype">void</span> VGA_ChangedBank(<span class="keywordtype">void</span>) {
<a name="l02173"></a>02173         VGA_SetupHandlers();
<a name="l02174"></a>02174 }
<a name="l02175"></a>02175 
<a name="l02176"></a>02176 <span class="keywordtype">void</span> MEM_ResetPageHandler_Unmapped(Bitu phys_page, Bitu pages);
<a name="l02177"></a>02177 <span class="keywordtype">void</span> MEM_ResetPageHandler_RAM(Bitu phys_page, Bitu pages);
<a name="l02178"></a>02178 
<a name="l02179"></a>02179 <span class="keywordtype">void</span> VGA_SetupHandlers(<span class="keywordtype">void</span>) {
<a name="l02180"></a>02180         vga.svga.bank_read_full = vga.svga.bank_read*vga.svga.bank_size;
<a name="l02181"></a>02181         vga.svga.bank_write_full = vga.svga.bank_write*vga.svga.bank_size;
<a name="l02182"></a>02182 
<a name="l02183"></a>02183         <a class="code" href="classPageHandler.html">PageHandler</a> *newHandler;
<a name="l02184"></a>02184         <span class="keywordflow">switch</span> (machine) {
<a name="l02185"></a>02185         <span class="keywordflow">case</span> MCH_CGA:
<a name="l02186"></a>02186                 <span class="keywordflow">if</span> (enableCGASnow &amp;&amp; (vga.mode == M_TEXT || vga.mode == M_TANDY_TEXT))
<a name="l02187"></a>02187                         MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.cgatext );
<a name="l02188"></a>02188                 <span class="keywordflow">else</span>
<a name="l02189"></a>02189                         MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.slow );
<a name="l02190"></a>02190                 <span class="keywordflow">goto</span> range_done;
<a name="l02191"></a>02191         <span class="keywordflow">case</span> MCH_MCGA:<span class="comment">//Based on real hardware, A0000-BFFFF is the 64KB of RAM mapped twice</span>
<a name="l02192"></a>02192                 MEM_SetPageHandler( VGA_PAGE_A0, 16, &amp;vgaph.mcgatext );     <span class="comment">// A0000-AFFFF is the 64KB of video RAM</span>
<a name="l02193"></a>02193         MEM_ResetPageHandler_Unmapped( VGA_PAGE_B0, 8 );            <span class="comment">// B0000-B7FFF is unmapped</span>
<a name="l02194"></a>02194                 MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.mcgatext );      <span class="comment">// B8000-BFFFF is the last 32KB half of video RAM, alias</span>
<a name="l02195"></a>02195                 <span class="keywordflow">goto</span> range_done;
<a name="l02196"></a>02196         <span class="keywordflow">case</span> MCH_PCJR:
<a name="l02197"></a>02197                 MEM_SetPageHandler( VGA_PAGE_A0, 16, &amp;vgaph.empty );
<a name="l02198"></a>02198                 MEM_SetPageHandler( VGA_PAGE_B0, 8, &amp;vgaph.empty );
<a name="l02199"></a>02199                 MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.pcjr );
<a name="l02200"></a>02200                 <span class="keywordflow">goto</span> range_done;
<a name="l02201"></a>02201         <span class="keywordflow">case</span> MCH_MDA:
<a name="l02202"></a>02202         <span class="keywordflow">case</span> MCH_HERC:
<a name="l02203"></a>02203                 MEM_SetPageHandler( VGA_PAGE_A0, 16, &amp;vgaph.empty );
<a name="l02204"></a>02204                 vgapages.base=VGA_PAGE_B0;
<a name="l02205"></a>02205                 <span class="comment">/* NTS: Implemented according to [http://www.seasip.info/VintagePC/hercplus.html#regs] */</span>
<a name="l02206"></a>02206                 <span class="keywordflow">if</span> (vga.herc.enable_bits &amp; 0x2) { <span class="comment">/* bit 1: page in upper 32KB */</span>
<a name="l02207"></a>02207                         vgapages.mask=0xffff;
<a name="l02208"></a>02208                         <span class="comment">/* NTS: I don&#39;t know what Hercules graphics cards do if you set bit 1 but not bit 0.</span>
<a name="l02209"></a>02209 <span class="comment">                         *      For the time being, I&#39;m assuming that they respond to 0xB8000+ because of bit 1</span>
<a name="l02210"></a>02210 <span class="comment">                         *      but only map to the first 4KB because of bit 0. Basically, a configuration no</span>
<a name="l02211"></a>02211 <span class="comment">                         *      software would actually use. */</span>
<a name="l02212"></a>02212                         <span class="keywordflow">if</span> (vga.herc.enable_bits &amp; 0x1) <span class="comment">/* allow graphics and enable 0xB1000-0xB7FFF */</span>
<a name="l02213"></a>02213                                 MEM_SetPageHandler(VGA_PAGE_B0,16,&amp;vgaph.map);
<a name="l02214"></a>02214                         <span class="keywordflow">else</span>
<a name="l02215"></a>02215                                 MEM_SetPageHandler(VGA_PAGE_B0,16,&amp;vgaph.herc);
<a name="l02216"></a>02216                 } <span class="keywordflow">else</span> {
<a name="l02217"></a>02217                         vgapages.mask=0x7fff;
<a name="l02218"></a>02218                         <span class="comment">// With hercules in 32kB mode it leaves a memory hole on 0xb800</span>
<a name="l02219"></a>02219                         <span class="comment">// and has MDA-compatible address wrapping when graphics are disabled</span>
<a name="l02220"></a>02220                         <span class="keywordflow">if</span> (vga.herc.enable_bits &amp; 0x1)
<a name="l02221"></a>02221                                 MEM_SetPageHandler(VGA_PAGE_B0,8,&amp;vgaph.map);
<a name="l02222"></a>02222                         <span class="keywordflow">else</span>
<a name="l02223"></a>02223                                 MEM_SetPageHandler(VGA_PAGE_B0,8,&amp;vgaph.herc);
<a name="l02224"></a>02224                         MEM_SetPageHandler(VGA_PAGE_B8,8,&amp;vgaph.empty);
<a name="l02225"></a>02225                 }
<a name="l02226"></a>02226                 <span class="keywordflow">goto</span> range_done;
<a name="l02227"></a>02227         <span class="keywordflow">case</span> MCH_TANDY:
<a name="l02228"></a>02228                 <span class="comment">/* Always map 0xa000 - 0xbfff, might overwrite 0xb800 */</span>
<a name="l02229"></a>02229                 vgapages.base=VGA_PAGE_A0;
<a name="l02230"></a>02230                 vgapages.mask=0x1ffff;
<a name="l02231"></a>02231                 MEM_SetPageHandler(VGA_PAGE_A0, 32, &amp;vgaph.map );
<a name="l02232"></a>02232                 <span class="keywordflow">if</span> ( vga.tandy.extended_ram &amp; 1 ) {
<a name="l02233"></a>02233                         <span class="comment">//You seem to be able to also map different 64kb banks, but have to figure that out</span>
<a name="l02234"></a>02234                         <span class="comment">//This seems to work so far though</span>
<a name="l02235"></a>02235                         vga.tandy.draw_base = vga.mem.linear;
<a name="l02236"></a>02236                         vga.tandy.mem_base = vga.mem.linear;
<a name="l02237"></a>02237                 } <span class="keywordflow">else</span> {
<a name="l02238"></a>02238                         vga.tandy.draw_base = TANDY_VIDBASE( vga.tandy.draw_bank * 16 * 1024);
<a name="l02239"></a>02239                         vga.tandy.mem_base = TANDY_VIDBASE( vga.tandy.mem_bank * 16 * 1024);
<a name="l02240"></a>02240                         MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.tandy );
<a name="l02241"></a>02241                 }
<a name="l02242"></a>02242                 <span class="keywordflow">goto</span> range_done;
<a name="l02243"></a>02243 <span class="comment">//              MEM_SetPageHandler(vga.tandy.mem_bank&lt;&lt;2,vga.tandy.is_32k_mode ? 0x08 : 0x04,range_handler);</span>
<a name="l02244"></a>02244         <span class="keywordflow">case</span> MCH_AMSTRAD: <span class="comment">// Memory handler.</span>
<a name="l02245"></a>02245                 MEM_SetPageHandler( 0xb8, 8, &amp;vgaph.ams );
<a name="l02246"></a>02246                 <span class="keywordflow">goto</span> range_done;
<a name="l02247"></a>02247         <span class="keywordflow">case</span> EGAVGA_ARCH_CASE:
<a name="l02248"></a>02248         <span class="keywordflow">break</span>;
<a name="l02249"></a>02249     <span class="keywordflow">case</span> PC98_ARCH_CASE:
<a name="l02250"></a>02250         MEM_SetPageHandler(             VGA_PAGE_A0 + 0x00, 0x02, &amp;vgaph.pc98_text );<span class="comment">/* A0000-A1FFFh text layer, character data */</span>
<a name="l02251"></a>02251         MEM_SetPageHandler(             VGA_PAGE_A0 + 0x02, 0x02, &amp;vgaph.pc98_text );<span class="comment">/* A2000-A3FFFh text layer, attribute data + non-volatile RAM */</span>
<a name="l02252"></a>02252         MEM_SetPageHandler(             VGA_PAGE_A0 + 0x04, 0x01, &amp;vgaph.pc98_cg );  <span class="comment">/* A4000-A4FFFh character generator memory-mapped I/O */</span>
<a name="l02253"></a>02253         MEM_ResetPageHandler_Unmapped(  VGA_PAGE_A0 + 0x05, 0x03);                   <span class="comment">/* A5000-A7FFFh not mapped */</span>
<a name="l02254"></a>02254 
<a name="l02255"></a>02255         <span class="keywordflow">if</span> (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_VGA)) {
<a name="l02256"></a>02256             <span class="keywordflow">if</span> (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_PEGC_PLANAR)) {
<a name="l02257"></a>02257                 MEM_SetPageHandler(             VGA_PAGE_A0 + 0x08, 0x10, &amp;vgaph.pc98_256planar );<span class="comment">/* A8000-B7FFFh planar graphics (???) */</span>
<a name="l02258"></a>02258                 MEM_ResetPageHandler_Unmapped(  VGA_PAGE_A0 + 0x18, 0x08);                        <span class="comment">/* B8000-BFFFFh graphics layer, not mapped */</span>
<a name="l02259"></a>02259             }
<a name="l02260"></a>02260             <span class="keywordflow">else</span> {
<a name="l02261"></a>02261                 MEM_SetPageHandler(             VGA_PAGE_A0 + 0x08, 0x08, &amp;vgaph.pc98_256bank0 );<span class="comment">/* A8000-AFFFFh graphics layer, bank 0 */</span>
<a name="l02262"></a>02262                 MEM_SetPageHandler(             VGA_PAGE_A0 + 0x10, 0x08, &amp;vgaph.pc98_256bank1 );<span class="comment">/* B0000-B7FFFh graphics layer, bank 1 */</span>
<a name="l02263"></a>02263                 MEM_ResetPageHandler_Unmapped(  VGA_PAGE_A0 + 0x18, 0x08);                       <span class="comment">/* B8000-BFFFFh graphics layer, not mapped */</span>
<a name="l02264"></a>02264             }
<a name="l02265"></a>02265         }
<a name="l02266"></a>02266         <span class="keywordflow">else</span> {
<a name="l02267"></a>02267             MEM_SetPageHandler(             VGA_PAGE_A0 + 0x08, 0x08, &amp;vgaph.pc98 );<span class="comment">/* A8000-AFFFFh graphics layer, B bitplane */</span>
<a name="l02268"></a>02268             MEM_SetPageHandler(             VGA_PAGE_A0 + 0x10, 0x08, &amp;vgaph.pc98 );<span class="comment">/* B0000-B7FFFh graphics layer, R bitplane */</span>
<a name="l02269"></a>02269             MEM_SetPageHandler(             VGA_PAGE_A0 + 0x18, 0x08, &amp;vgaph.pc98 );<span class="comment">/* B8000-BFFFFh graphics layer, G bitplane */</span>
<a name="l02270"></a>02270         }
<a name="l02271"></a>02271 
<a name="l02272"></a>02272         <span class="comment">/* E0000-E7FFFh graphics layer</span>
<a name="l02273"></a>02273 <span class="comment">         *  - In 8-color mode, E0000-E7FFFh is not mapped</span>
<a name="l02274"></a>02274 <span class="comment">         *  - In 16-color mode, E0000-E7FFFh is the 4th bitplane (E)</span>
<a name="l02275"></a>02275 <span class="comment">         *  - In 256-color mode, E0000-E7FFFh is memory-mapped I/O that controls the 256-color mode */</span>
<a name="l02276"></a>02276         <span class="keywordflow">if</span> (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_VGA))
<a name="l02277"></a>02277             MEM_SetPageHandler(0xE0, 8, &amp;vgaph.pc98_256mmio );
<a name="l02278"></a>02278         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_ANALOG))
<a name="l02279"></a>02279             MEM_SetPageHandler(0xE0, 8, &amp;vgaph.pc98 );
<a name="l02280"></a>02280         <span class="keywordflow">else</span>
<a name="l02281"></a>02281             MEM_ResetPageHandler_Unmapped(0xE0, 8);
<a name="l02282"></a>02282 
<a name="l02283"></a>02283         <span class="comment">// TODO: What about PC-9821 systems with more than 15MB of RAM? Do they maintain a &quot;hole&quot;</span>
<a name="l02284"></a>02284         <span class="comment">//       in memory for this linear framebuffer? Intel motherboard chipsets of that era do</span>
<a name="l02285"></a>02285         <span class="comment">//       support a 15MB memory hole.</span>
<a name="l02286"></a>02286         <span class="keywordflow">if</span> (MEM_TotalPages() &lt;= 0xF00<span class="comment">/*FIXME*/</span>) {
<a name="l02287"></a>02287             <span class="comment">/* F00000-FF7FFFh linear framebuffer (256-packed)</span>
<a name="l02288"></a>02288 <span class="comment">             *  - Does not exist except in 256-color mode.</span>
<a name="l02289"></a>02289 <span class="comment">             *  - Switching from 256-color mode immediately unmaps this linear framebuffer.</span>
<a name="l02290"></a>02290 <span class="comment">             *  - Switching to 256-color mode will immediately map the linear framebuffer if the enable bit is set in the PEGC MMIO registers */</span>
<a name="l02291"></a>02291             <span class="keywordflow">if</span> ((pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_VGA)) &amp;&amp; pc98_pegc_linear_framebuffer_enabled())
<a name="l02292"></a>02292                 MEM_SetPageHandler(0xF00, 512<span class="comment">/*kb*/</span> / 4<span class="comment">/*kb*/</span>, &amp;vgaph.map_lfb_pc98 );
<a name="l02293"></a>02293             <span class="keywordflow">else</span>
<a name="l02294"></a>02294                 MEM_ResetPageHandler_Unmapped(0xF00, 512<span class="comment">/*kb*/</span> / 4<span class="comment">/*kb*/</span>);
<a name="l02295"></a>02295         }
<a name="l02296"></a>02296 
<a name="l02297"></a>02297         <span class="keywordflow">goto</span> range_done;
<a name="l02298"></a>02298         <span class="keywordflow">default</span>:
<a name="l02299"></a>02299                 LOG_MSG(<span class="stringliteral">&quot;Illegal machine type %d&quot;</span>, machine );
<a name="l02300"></a>02300                 <span class="keywordflow">return</span>;
<a name="l02301"></a>02301         }
<a name="l02302"></a>02302 
<a name="l02303"></a>02303         <span class="comment">/* This should be vga only */</span>
<a name="l02304"></a>02304         <span class="keywordflow">switch</span> (vga.mode) {
<a name="l02305"></a>02305         <span class="keywordflow">case</span> M_ERROR:
<a name="l02306"></a>02306         <span class="keywordflow">default</span>:
<a name="l02307"></a>02307                 <span class="keywordflow">return</span>;
<a name="l02308"></a>02308         <span class="keywordflow">case</span> M_LIN15:
<a name="l02309"></a>02309         <span class="keywordflow">case</span> M_LIN16:
<a name="l02310"></a>02310         <span class="keywordflow">case</span> M_LIN24:
<a name="l02311"></a>02311         <span class="keywordflow">case</span> M_LIN32:
<a name="l02312"></a>02312     <span class="keywordflow">case</span> M_PACKED4:
<a name="l02313"></a>02313                 newHandler = &amp;vgaph.map;
<a name="l02314"></a>02314                 <span class="keywordflow">break</span>;
<a name="l02315"></a>02315         <span class="keywordflow">case</span> M_TEXT:
<a name="l02316"></a>02316         <span class="keywordflow">case</span> M_CGA2:
<a name="l02317"></a>02317         <span class="keywordflow">case</span> M_CGA4:
<a name="l02318"></a>02318         <span class="comment">/* EGA/VGA emulate CGA modes as chained */</span>
<a name="l02319"></a>02319         <span class="comment">/* fall through */</span>
<a name="l02320"></a>02320         <span class="keywordflow">case</span> M_LIN8:
<a name="l02321"></a>02321         <span class="keywordflow">case</span> M_LIN4:
<a name="l02322"></a>02322         <span class="keywordflow">case</span> M_VGA:
<a name="l02323"></a>02323         <span class="keywordflow">case</span> M_EGA:
<a name="l02324"></a>02324         <span class="keywordflow">if</span> (vga.config.chained) {
<a name="l02325"></a>02325             <span class="keywordflow">if</span> (vga.config.compatible_chain4) {
<a name="l02326"></a>02326                 <span class="comment">/* NTS: ET4000AX cards appear to have a different chain4 implementation from everyone else:</span>
<a name="l02327"></a>02327 <span class="comment">                 *      the planar memory byte address is address &gt;&gt; 2 and bits A0-A1 select the plane,</span>
<a name="l02328"></a>02328 <span class="comment">                 *      where all other clones I&#39;ve tested seem to write planar memory byte (address &amp; ~3)</span>
<a name="l02329"></a>02329 <span class="comment">                 *      (one byte per 4 bytes) and bits A0-A1 select the plane. */</span>
<a name="l02330"></a>02330                 <span class="comment">/* FIXME: Different chain4 implementation on ET4000 noted---is it true also for ET3000? */</span>
<a name="l02331"></a>02331                 <span class="keywordflow">if</span> (svgaCard == SVGA_TsengET3K || svgaCard == SVGA_TsengET4K)
<a name="l02332"></a>02332                     newHandler = &amp;vgaph.cvga_et4000_slow;
<a name="l02333"></a>02333                 <span class="keywordflow">else</span>
<a name="l02334"></a>02334                     newHandler = &amp;vgaph.cvga_slow;
<a name="l02335"></a>02335             }
<a name="l02336"></a>02336             <span class="keywordflow">else</span> {
<a name="l02337"></a>02337                 <span class="comment">/* this is needed for SVGA modes (Paradise, Tseng, S3) because SVGA</span>
<a name="l02338"></a>02338 <span class="comment">                 * modes do NOT use the chain4 configuration */</span>
<a name="l02339"></a>02339                 newHandler = &amp;vgaph.map;
<a name="l02340"></a>02340             }
<a name="l02341"></a>02341         } <span class="keywordflow">else</span> {
<a name="l02342"></a>02342             newHandler = &amp;vgaph.uvga;
<a name="l02343"></a>02343         }
<a name="l02344"></a>02344         <span class="keywordflow">break</span>;
<a name="l02345"></a>02345         <span class="keywordflow">case</span> M_AMSTRAD:
<a name="l02346"></a>02346                 newHandler = &amp;vgaph.map;
<a name="l02347"></a>02347                 <span class="keywordflow">break</span>;
<a name="l02348"></a>02348         }
<a name="l02349"></a>02349         <span class="keywordflow">switch</span> ((vga.gfx.miscellaneous &gt;&gt; 2) &amp; 3) {
<a name="l02350"></a>02350         <span class="keywordflow">case</span> 0:
<a name="l02351"></a>02351         vgapages.base = VGA_PAGE_A0;
<a name="l02352"></a>02352         <span class="keywordflow">switch</span> (svgaCard) {
<a name="l02353"></a>02353             <span class="keywordflow">case</span> SVGA_TsengET3K:
<a name="l02354"></a>02354             <span class="keywordflow">case</span> SVGA_TsengET4K:
<a name="l02355"></a>02355                 vgapages.mask = 0x1ffff &amp; vga.mem.memmask;
<a name="l02356"></a>02356                 <span class="keywordflow">break</span>;
<a name="l02357"></a>02357                 <span class="comment">/* NTS: Looking at the official ET4000 programming guide, it does in fact support the full 128KB */</span>
<a name="l02358"></a>02358             <span class="keywordflow">case</span> SVGA_S3Trio:
<a name="l02359"></a>02359             <span class="keywordflow">default</span>:
<a name="l02360"></a>02360                 vgapages.mask = 0xffff &amp; vga.mem.memmask;
<a name="l02361"></a>02361                 <span class="keywordflow">break</span>;
<a name="l02362"></a>02362                 }
<a name="l02363"></a>02363                 MEM_SetPageHandler(VGA_PAGE_A0, 32, newHandler );
<a name="l02364"></a>02364                 <span class="keywordflow">break</span>;
<a name="l02365"></a>02365         <span class="keywordflow">case</span> 1:
<a name="l02366"></a>02366                 vgapages.base = VGA_PAGE_A0;
<a name="l02367"></a>02367                 vgapages.mask = 0xffff &amp; vga.mem.memmask;
<a name="l02368"></a>02368                 MEM_SetPageHandler( VGA_PAGE_A0, 16, newHandler );
<a name="l02369"></a>02369                 MEM_SetPageHandler( VGA_PAGE_B0, 16, &amp;vgaph.empty );
<a name="l02370"></a>02370                 <span class="keywordflow">break</span>;
<a name="l02371"></a>02371         <span class="keywordflow">case</span> 2:
<a name="l02372"></a>02372                 vgapages.base = VGA_PAGE_B0;
<a name="l02373"></a>02373                 vgapages.mask = 0x7fff &amp; vga.mem.memmask;
<a name="l02374"></a>02374                 MEM_SetPageHandler( VGA_PAGE_B0, 8, newHandler );
<a name="l02375"></a>02375                 MEM_SetPageHandler( VGA_PAGE_A0, 16, &amp;vgaph.empty );
<a name="l02376"></a>02376                 MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.empty );
<a name="l02377"></a>02377         <span class="keywordflow">break</span>;
<a name="l02378"></a>02378         <span class="keywordflow">case</span> 3:
<a name="l02379"></a>02379                 vgapages.base = VGA_PAGE_B8;
<a name="l02380"></a>02380                 vgapages.mask = 0x7fff &amp; vga.mem.memmask;
<a name="l02381"></a>02381                 MEM_SetPageHandler( VGA_PAGE_B8, 8, newHandler );
<a name="l02382"></a>02382                 MEM_SetPageHandler( VGA_PAGE_A0, 16, &amp;vgaph.empty );
<a name="l02383"></a>02383                 MEM_SetPageHandler( VGA_PAGE_B0, 8, &amp;vgaph.empty );
<a name="l02384"></a>02384         <span class="keywordflow">break</span>;
<a name="l02385"></a>02385         }
<a name="l02386"></a>02386         <span class="keywordflow">if</span>(svgaCard == SVGA_S3Trio &amp;&amp; (vga.s3.ext_mem_ctrl &amp; 0x10))
<a name="l02387"></a>02387                 MEM_SetPageHandler(VGA_PAGE_A0, 16, &amp;vgaph.mmio);
<a name="l02388"></a>02388 
<a name="l02389"></a>02389     non_cga_ignore_oddeven_engage = (non_cga_ignore_oddeven &amp;&amp; !(vga.mode == M_TEXT || vga.mode == M_CGA2 || vga.mode == M_CGA4));
<a name="l02390"></a>02390 
<a name="l02391"></a>02391 range_done:
<a name="l02392"></a>02392         PAGING_ClearTLB();
<a name="l02393"></a>02393 }
<a name="l02394"></a>02394 
<a name="l02395"></a>02395 <span class="keywordtype">void</span> VGA_StartUpdateLFB(<span class="keywordtype">void</span>) {
<a name="l02396"></a>02396         <span class="comment">/* please obey the Linear Address Window Size register!</span>
<a name="l02397"></a>02397 <span class="comment">         * Windows 3.1 S3 driver will reprogram the linear framebuffer down to 0xA0000 when entering a DOSBox</span>
<a name="l02398"></a>02398 <span class="comment">         * and assuming the full VRAM size will cause a LOT of problems! */</span>
<a name="l02399"></a>02399         Bitu winsz = 0x10000;
<a name="l02400"></a>02400 
<a name="l02401"></a>02401         <span class="keywordflow">switch</span> (vga.s3.reg_58&amp;3) {
<a name="l02402"></a>02402                 <span class="keywordflow">case</span> 1:
<a name="l02403"></a>02403                         winsz = 1 &lt;&lt; 20;        <span class="comment">//1MB</span>
<a name="l02404"></a>02404                         <span class="keywordflow">break</span>;
<a name="l02405"></a>02405                 <span class="keywordflow">case</span> 2:
<a name="l02406"></a>02406                         winsz = 2 &lt;&lt; 20;        <span class="comment">//2MB</span>
<a name="l02407"></a>02407                         <span class="keywordflow">break</span>;
<a name="l02408"></a>02408                 <span class="keywordflow">case</span> 3:
<a name="l02409"></a>02409                         winsz = 4 &lt;&lt; 20;        <span class="comment">//4MB</span>
<a name="l02410"></a>02410                         <span class="keywordflow">break</span>;
<a name="l02411"></a>02411                 <span class="comment">// FIXME: What about the 8MB window?</span>
<a name="l02412"></a>02412         }
<a name="l02413"></a>02413 
<a name="l02414"></a>02414     <span class="comment">/* The LFB register has an enable bit */</span>
<a name="l02415"></a>02415     <span class="keywordflow">if</span> (!(vga.s3.reg_58 &amp; 0x10)) {
<a name="l02416"></a>02416         vga.lfb.page = (<span class="keywordtype">unsigned</span> int)vga.s3.la_window &lt;&lt; 4u;
<a name="l02417"></a>02417         vga.lfb.addr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.s3.la_window &lt;&lt; 16u;
<a name="l02418"></a>02418         vga.lfb.handler = NULL;
<a name="l02419"></a>02419         MEM_SetLFB(0,0,NULL,NULL);
<a name="l02420"></a>02420     }
<a name="l02421"></a>02421     <span class="comment">/* if the DOS application or Windows 3.1 driver attempts to put the linear framebuffer</span>
<a name="l02422"></a>02422 <span class="comment">         * below the top of memory, then we&#39;re probably entering a DOS VM and it&#39;s probably</span>
<a name="l02423"></a>02423 <span class="comment">         * a 64KB window. If it&#39;s not a 64KB window then print a warning. */</span>
<a name="l02424"></a>02424     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(vga.s3.la_window &lt;&lt; 4UL) &lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)MEM_TotalPages()) {
<a name="l02425"></a>02425                 <span class="keywordflow">if</span> (winsz != 0x10000) <span class="comment">// 64KB window normal for entering a DOS VM in Windows 3.1 or legacy bank switching in DOS</span>
<a name="l02426"></a>02426                         <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_WARN)(<span class="stringliteral">&quot;S3 warning: Window size != 64KB and address conflict with system RAM!&quot;</span>);
<a name="l02427"></a>02427 
<a name="l02428"></a>02428                 vga.lfb.page = (<span class="keywordtype">unsigned</span> int)vga.s3.la_window &lt;&lt; 4u;
<a name="l02429"></a>02429                 vga.lfb.addr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.s3.la_window &lt;&lt; 16u;
<a name="l02430"></a>02430                 vga.lfb.handler = NULL;
<a name="l02431"></a>02431                 MEM_SetLFB(0,0,NULL,NULL);
<a name="l02432"></a>02432         }
<a name="l02433"></a>02433         <span class="keywordflow">else</span> {
<a name="l02434"></a>02434                 vga.lfb.page = (<span class="keywordtype">unsigned</span> int)vga.s3.la_window &lt;&lt; 4u;
<a name="l02435"></a>02435                 vga.lfb.addr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.s3.la_window &lt;&lt; 16u;
<a name="l02436"></a>02436                 vga.lfb.handler = &amp;vgaph.lfb;
<a name="l02437"></a>02437                 MEM_SetLFB((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.s3.la_window &lt;&lt; 4u,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.mem.memsize/4096u, vga.lfb.handler, &amp;vgaph.mmio);
<a name="l02438"></a>02438         }
<a name="l02439"></a>02439 }
<a name="l02440"></a>02440 
<a name="l02441"></a>02441 <span class="keyword">static</span> <span class="keywordtype">bool</span> VGA_Memory_ShutDown_init = <span class="keyword">false</span>;
<a name="l02442"></a>02442 
<a name="l02443"></a>02443 <span class="keyword">static</span> <span class="keywordtype">void</span> VGA_Memory_ShutDown(<a class="code" href="classSection.html">Section</a> * <span class="comment">/*sec*/</span>) {
<a name="l02444"></a>02444         MEM_SetPageHandler(VGA_PAGE_A0,32,&amp;vgaph.empty);
<a name="l02445"></a>02445         PAGING_ClearTLB();
<a name="l02446"></a>02446 
<a name="l02447"></a>02447         <span class="keywordflow">if</span> (vga.mem.linear_orgptr != NULL) {
<a name="l02448"></a>02448                 <span class="keyword">delete</span>[] vga.mem.linear_orgptr;
<a name="l02449"></a>02449                 vga.mem.linear_orgptr = NULL;
<a name="l02450"></a>02450                 vga.mem.linear = NULL;
<a name="l02451"></a>02451         }
<a name="l02452"></a>02452 }
<a name="l02453"></a>02453 
<a name="l02454"></a>02454 <span class="keywordtype">void</span> VGA_SetupMemory() {
<a name="l02455"></a>02455         vga.svga.bank_read = vga.svga.bank_write = 0;
<a name="l02456"></a>02456         vga.svga.bank_read_full = vga.svga.bank_write_full = 0;
<a name="l02457"></a>02457 
<a name="l02458"></a>02458     <span class="keywordflow">if</span> (vga.mem.linear == NULL) {
<a name="l02459"></a>02459         VGA_Memory_ShutDown(NULL);
<a name="l02460"></a>02460 
<a name="l02461"></a>02461         vga.mem.linear_orgptr = <span class="keyword">new</span> Bit8u[vga.mem.memsize+32u];
<a name="l02462"></a>02462         memset(vga.mem.linear_orgptr,0,vga.mem.memsize+32u);
<a name="l02463"></a>02463         vga.mem.linear=(Bit8u*)(((uintptr_t)vga.mem.linear_orgptr + 16ull-1ull) &amp; ~(16ull-1ull));
<a name="l02464"></a>02464 
<a name="l02465"></a>02465         <span class="comment">/* HACK. try to avoid stale pointers */</span>
<a name="l02466"></a>02466             vga.draw.linear_base = vga.mem.linear;
<a name="l02467"></a>02467         vga.tandy.draw_base = vga.mem.linear;
<a name="l02468"></a>02468         vga.tandy.mem_base = vga.mem.linear;
<a name="l02469"></a>02469 
<a name="l02470"></a>02470         <span class="comment">/* PC-98 pointers */</span>
<a name="l02471"></a>02471         pc98_pgraph_current_cpu_page = vga.mem.linear + PC98_VRAM_GRAPHICS_OFFSET;
<a name="l02472"></a>02472         pc98_pgraph_current_display_page = vga.mem.linear + PC98_VRAM_GRAPHICS_OFFSET;
<a name="l02473"></a>02473 
<a name="l02474"></a>02474         <span class="comment">/* parallel system */</span>
<a name="l02475"></a>02475         <span class="keywordflow">if</span> (vga_alt_new_mode) {
<a name="l02476"></a>02476             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> si=0;si &lt; VGA_Draw_2_elem;si++)
<a name="l02477"></a>02477                 vga.draw_2[si].draw_base = vga.mem.linear;
<a name="l02478"></a>02478 
<a name="l02479"></a>02479             vga.draw_2[0].horz.char_pixel_mask = 0xFFu;
<a name="l02480"></a>02480             vga.draw_2[0].vert.char_pixel_mask = 0x1Fu;
<a name="l02481"></a>02481         }
<a name="l02482"></a>02482 
<a name="l02483"></a>02483         <span class="comment">/* may be related */</span>
<a name="l02484"></a>02484         VGA_SetupHandlers();
<a name="l02485"></a>02485     }
<a name="l02486"></a>02486 
<a name="l02487"></a>02487         vga.svga.bank_read = vga.svga.bank_write = 0;
<a name="l02488"></a>02488         vga.svga.bank_read_full = vga.svga.bank_write_full = 0;
<a name="l02489"></a>02489         vga.svga.bank_size = 0x10000; <span class="comment">/* most common bank size is 64K */</span>
<a name="l02490"></a>02490 
<a name="l02491"></a>02491         <span class="keywordflow">if</span> (!VGA_Memory_ShutDown_init) {
<a name="l02492"></a>02492                 AddExitFunction(AddExitFunctionFuncPair(VGA_Memory_ShutDown));
<a name="l02493"></a>02493                 VGA_Memory_ShutDown_init = <span class="keyword">true</span>;
<a name="l02494"></a>02494         }
<a name="l02495"></a>02495 
<a name="l02496"></a>02496         <span class="keywordflow">if</span> (machine==MCH_PCJR) {
<a name="l02497"></a>02497                 <span class="comment">/* PCJr does not have dedicated graphics memory but uses</span>
<a name="l02498"></a>02498 <span class="comment">                   conventional memory below 128k */</span>
<a name="l02499"></a>02499                 <span class="comment">//TODO map?     </span>
<a name="l02500"></a>02500         }
<a name="l02501"></a>02501 }
<a name="l02502"></a>02502 
<a name="l02503"></a>02503 <span class="comment">// save state support</span>
<a name="l02504"></a>02504 <span class="keywordtype">void</span> *VGA_PageHandler_Func[16] =
<a name="l02505"></a>02505 {
<a name="l02506"></a>02506         (<span class="keywordtype">void</span> *) &amp;vgaph.map,
<a name="l02507"></a>02507         <span class="comment">//(void *) &amp;vgaph.changes,</span>
<a name="l02508"></a>02508         <span class="comment">//(void *) &amp;vgaph.text,</span>
<a name="l02509"></a>02509         (<span class="keywordtype">void</span> *) &amp;vgaph.tandy,
<a name="l02510"></a>02510         <span class="comment">//(void *) &amp;vgaph.cega,</span>
<a name="l02511"></a>02511         <span class="comment">//(void *) &amp;vgaph.cvga,</span>
<a name="l02512"></a>02512         <span class="comment">//(void *) &amp;vgaph.uega,</span>
<a name="l02513"></a>02513         (<span class="keywordtype">void</span> *) &amp;vgaph.uvga,
<a name="l02514"></a>02514         (<span class="keywordtype">void</span> *) &amp;vgaph.pcjr,
<a name="l02515"></a>02515         (<span class="keywordtype">void</span> *) &amp;vgaph.herc,
<a name="l02516"></a>02516         <span class="comment">//(void *) &amp;vgaph.lin4,</span>
<a name="l02517"></a>02517         (<span class="keywordtype">void</span> *) &amp;vgaph.lfb,
<a name="l02518"></a>02518         <span class="comment">//(void *) &amp;vgaph.lfbchanges,</span>
<a name="l02519"></a>02519         (<span class="keywordtype">void</span> *) &amp;vgaph.mmio,
<a name="l02520"></a>02520         (<span class="keywordtype">void</span> *) &amp;vgaph.empty,
<a name="l02521"></a>02521 };
<a name="l02522"></a>02522 
<a name="l02523"></a>02523 <span class="keywordtype">void</span> POD_Save_VGA_Memory( std::ostream&amp; stream )
<a name="l02524"></a>02524 {
<a name="l02525"></a>02525         <span class="comment">// - static ptrs</span>
<a name="l02526"></a>02526         <span class="comment">//Bit8u* linear;</span>
<a name="l02527"></a>02527         <span class="comment">//Bit8u* linear_orgptr;</span>
<a name="l02528"></a>02528 
<a name="l02529"></a>02529 
<a name="l02530"></a>02530         <span class="comment">// - pure data</span>
<a name="l02531"></a>02531         WRITE_POD_SIZE( vga.mem.linear, <span class="keyword">sizeof</span>(Bit8u) * vga.mem.memsize);
<a name="l02532"></a>02532 
<a name="l02533"></a>02533         <span class="comment">//***************************************************</span>
<a name="l02534"></a>02534         <span class="comment">//***************************************************</span>
<a name="l02535"></a>02535 
<a name="l02536"></a>02536         <span class="comment">// static globals</span>
<a name="l02537"></a>02537 
<a name="l02538"></a>02538         <span class="comment">// - pure struct data</span>
<a name="l02539"></a>02539         WRITE_POD( &amp;vgapages, vgapages );
<a name="l02540"></a>02540 
<a name="l02541"></a>02541         <span class="comment">// - static classes</span>
<a name="l02542"></a>02542         <span class="comment">//WRITE_POD( &amp;vgaph, vgaph );</span>
<a name="l02543"></a>02543 }
<a name="l02544"></a>02544 
<a name="l02545"></a>02545 
<a name="l02546"></a>02546 <span class="keywordtype">void</span> POD_Load_VGA_Memory( std::istream&amp; stream )
<a name="l02547"></a>02547 {
<a name="l02548"></a>02548         <span class="comment">// - static ptrs</span>
<a name="l02549"></a>02549         <span class="comment">//Bit8u* linear;</span>
<a name="l02550"></a>02550         <span class="comment">//Bit8u* linear_orgptr;</span>
<a name="l02551"></a>02551 
<a name="l02552"></a>02552 
<a name="l02553"></a>02553         <span class="comment">// - pure data</span>
<a name="l02554"></a>02554         READ_POD_SIZE( vga.mem.linear, <span class="keyword">sizeof</span>(Bit8u) * vga.mem.memsize);
<a name="l02555"></a>02555 
<a name="l02556"></a>02556         <span class="comment">//***************************************************</span>
<a name="l02557"></a>02557         <span class="comment">//***************************************************</span>
<a name="l02558"></a>02558 
<a name="l02559"></a>02559         <span class="comment">// static globals</span>
<a name="l02560"></a>02560 
<a name="l02561"></a>02561         <span class="comment">// - pure struct data</span>
<a name="l02562"></a>02562         READ_POD( &amp;vgapages, vgapages );
<a name="l02563"></a>02563 
<a name="l02564"></a>02564         <span class="comment">// - static classes</span>
<a name="l02565"></a>02565         <span class="comment">//READ_POD( &amp;vgaph, vgaph );</span>
<a name="l02566"></a>02566 }
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 5 2020 13:11:37 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
