<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/hardware/vga_memory.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/hardware/vga_memory.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  Copyright (C) 2002-2015  The DOSBox Team</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  This program is free software; you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment"> *  (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *  This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment"> *  GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment"> *  along with this program; if not, write to the Free Software</span>
<a name="l00016"></a>00016 <span class="comment"> *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;dosbox.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;mem.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;vga.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;paging.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;pic.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;inout.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;setup.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;pc98_cg.h&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;pc98_gdc.h&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;zipfile.h&quot;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="keyword">extern</span> <a class="code" href="classZIPFile.html">ZIPFile</a> savestate_zip;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="keyword">extern</span> <span class="keywordtype">bool</span> non_cga_ignore_oddeven;
<a name="l00039"></a>00039 <span class="keyword">extern</span> <span class="keywordtype">bool</span> non_cga_ignore_oddeven_engage;
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#ifndef C_VGARAM_CHECKED</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#define C_VGARAM_CHECKED 1</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>
<a name="l00045"></a>00045 <span class="preprocessor">#if C_VGARAM_CHECKED</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="comment">// Checked linear offset</span>
<a name="l00047"></a>00047 <span class="preprocessor">#define CHECKED(v) ((v)&amp;vga.mem.memmask)</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="comment">// Checked planar offset (latched access)</span>
<a name="l00049"></a>00049 <span class="preprocessor">#define CHECKED2(v) ((v)&amp;(vga.mem.memmask&gt;&gt;2))</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#define CHECKED(v) (v)</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#define CHECKED2(v) (v)</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span>
<a name="l00055"></a>00055 <span class="preprocessor">#define CHECKED3(v) ((v)&amp;vga.mem.memmask)</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#define CHECKED4(v) ((v)&amp;(vga.mem.memmask&gt;&gt;2))</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>
<a name="l00058"></a>00058 <span class="preprocessor">#define TANDY_VIDBASE(_X_)  &amp;MemBase[ 0x80000 + (_X_)]</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>
<a name="l00060"></a>00060 <span class="comment">/* how much delay to add to VGA memory I/O in nanoseconds */</span>
<a name="l00061"></a>00061 <span class="keywordtype">int</span> vga_memio_delay_ns = 1000;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="keywordtype">void</span> VGAMEM_USEC_read_delay() {
<a name="l00064"></a>00064         <span class="keywordflow">if</span> (vga_memio_delay_ns &gt; 0) {
<a name="l00065"></a>00065                 Bits delaycyc = (CPU_CycleMax * vga_memio_delay_ns) / 1000000;
<a name="l00066"></a>00066 <span class="comment">//              if(GCC_UNLIKELY(CPU_Cycles &lt; 3*delaycyc)) delaycyc = 0; //Else port acces will set cycles to 0. which might trigger problem with games which read 16 bit values</span>
<a name="l00067"></a>00067                 CPU_Cycles -= delaycyc;
<a name="l00068"></a>00068                 CPU_IODelayRemoved += delaycyc;
<a name="l00069"></a>00069         }
<a name="l00070"></a>00070 }
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="keywordtype">void</span> VGAMEM_USEC_write_delay() {
<a name="l00073"></a>00073         <span class="keywordflow">if</span> (vga_memio_delay_ns &gt; 0) {
<a name="l00074"></a>00074                 Bits delaycyc = (CPU_CycleMax * vga_memio_delay_ns * 3) / (1000000 * 4);
<a name="l00075"></a>00075 <span class="comment">//              if(GCC_UNLIKELY(CPU_Cycles &lt; 3*delaycyc)) delaycyc = 0; //Else port acces will set cycles to 0. which might trigger problem with games which read 16 bit values</span>
<a name="l00076"></a>00076                 CPU_Cycles -= delaycyc;
<a name="l00077"></a>00077                 CPU_IODelayRemoved += delaycyc;
<a name="l00078"></a>00078         }
<a name="l00079"></a>00079 }
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Size&gt;
<a name="l00082"></a>00082 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> hostWrite(HostPt off, Bitu val) {
<a name="l00083"></a>00083         <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 1)
<a name="l00084"></a>00084                 host_writeb( off, (Bit8u)val );
<a name="l00085"></a>00085         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 2)
<a name="l00086"></a>00086                 host_writew( off, (Bit16u)val );
<a name="l00087"></a>00087         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 4)
<a name="l00088"></a>00088                 host_writed( off, (Bit32u)val );
<a name="l00089"></a>00089 }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Size&gt;
<a name="l00092"></a>00092 <span class="keyword">static</span> INLINE Bitu  hostRead(HostPt off ) {
<a name="l00093"></a>00093         <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 1)
<a name="l00094"></a>00094                 <span class="keywordflow">return</span> host_readb( off );
<a name="l00095"></a>00095         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 2)
<a name="l00096"></a>00096                 <span class="keywordflow">return</span> host_readw( off );
<a name="l00097"></a>00097         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 4)
<a name="l00098"></a>00098                 <span class="keywordflow">return</span> host_readd( off );
<a name="l00099"></a>00099         <span class="keywordflow">return</span> 0;
<a name="l00100"></a>00100 }
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="keywordtype">void</span> VGA_MapMMIO(<span class="keywordtype">void</span>);
<a name="l00104"></a>00104 <span class="comment">//Nice one from DosEmu</span>
<a name="l00105"></a>00105 INLINE <span class="keyword">static</span> Bit32u RasterOp(Bit32u input,Bit32u mask) {
<a name="l00106"></a>00106         <span class="keywordflow">switch</span> (vga.config.raster_op) {
<a name="l00107"></a>00107         <span class="keywordflow">case</span> 0x00:      <span class="comment">/* None */</span>
<a name="l00108"></a>00108                 <span class="keywordflow">return</span> (input &amp; mask) | (vga.latch.d &amp; ~mask);
<a name="l00109"></a>00109         <span class="keywordflow">case</span> 0x01:      <span class="comment">/* AND */</span>
<a name="l00110"></a>00110                 <span class="keywordflow">return</span> (input | ~mask) &amp; vga.latch.d;
<a name="l00111"></a>00111         <span class="keywordflow">case</span> 0x02:      <span class="comment">/* OR */</span>
<a name="l00112"></a>00112                 <span class="keywordflow">return</span> (input &amp; mask) | vga.latch.d;
<a name="l00113"></a>00113         <span class="keywordflow">case</span> 0x03:      <span class="comment">/* XOR */</span>
<a name="l00114"></a>00114                 <span class="keywordflow">return</span> (input &amp; mask) ^ vga.latch.d;
<a name="l00115"></a>00115         };
<a name="l00116"></a>00116         <span class="keywordflow">return</span> 0;
<a name="l00117"></a>00117 }
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 INLINE <span class="keyword">static</span> Bit32u ModeOperation(Bit8u val) {
<a name="l00120"></a>00120         Bit32u full;
<a name="l00121"></a>00121         <span class="keywordflow">switch</span> (vga.config.write_mode) {
<a name="l00122"></a>00122         <span class="keywordflow">case</span> 0x00:
<a name="l00123"></a>00123                 <span class="comment">// Write Mode 0: In this mode, the host data is first rotated as per the Rotate Count field, then the Enable Set/Reset mechanism selects data from this or the Set/Reset field. Then the selected Logical Operation is performed on the resulting data and the data in the latch register. Then the Bit Mask field is used to select which bits come from the resulting data and which come from the latch register. Finally, only the bit planes enabled by the Memory Plane Write Enable field are written to memory. </span>
<a name="l00124"></a>00124                 val=((val &gt;&gt; vga.config.data_rotate) | (val &lt;&lt; (8-vga.config.data_rotate)));
<a name="l00125"></a>00125                 full=ExpandTable[val];
<a name="l00126"></a>00126                 full=(full &amp; vga.config.full_not_enable_set_reset) | vga.config.full_enable_and_set_reset; 
<a name="l00127"></a>00127                 full=RasterOp(full,vga.config.full_bit_mask);
<a name="l00128"></a>00128                 <span class="keywordflow">break</span>;
<a name="l00129"></a>00129         <span class="keywordflow">case</span> 0x01:
<a name="l00130"></a>00130                 <span class="comment">// Write Mode 1: In this mode, data is transferred directly from the 32 bit latch register to display memory, affected only by the Memory Plane Write Enable field. The host data is not used in this mode. </span>
<a name="l00131"></a>00131                 full=vga.latch.d;
<a name="l00132"></a>00132                 <span class="keywordflow">break</span>;
<a name="l00133"></a>00133         <span class="keywordflow">case</span> 0x02:
<a name="l00134"></a>00134                 <span class="comment">//Write Mode 2: In this mode, the bits 3-0 of the host data are replicated across all 8 bits of their respective planes. Then the selected Logical Operation is performed on the resulting data and the data in the latch register. Then the Bit Mask field is used to select which bits come from the resulting data and which come from the latch register. Finally, only the bit planes enabled by the Memory Plane Write Enable field are written to memory. </span>
<a name="l00135"></a>00135                 full=RasterOp(FillTable[val&amp;0xF],vga.config.full_bit_mask);
<a name="l00136"></a>00136                 <span class="keywordflow">break</span>;
<a name="l00137"></a>00137         <span class="keywordflow">case</span> 0x03:
<a name="l00138"></a>00138                 <span class="comment">// Write Mode 3: In this mode, the data in the Set/Reset field is used as if the Enable Set/Reset field were set to 1111b. Then the host data is first rotated as per the Rotate Count field, then logical ANDed with the value of the Bit Mask field. The resulting value is used on the data obtained from the Set/Reset field in the same way that the Bit Mask field would ordinarily be used. to select which bits come from the expansion of the Set/Reset field and which come from the latch register. Finally, only the bit planes enabled by the Memory Plane Write Enable field are written to memory.</span>
<a name="l00139"></a>00139                 val=((val &gt;&gt; vga.config.data_rotate) | (val &lt;&lt; (8-vga.config.data_rotate)));
<a name="l00140"></a>00140                 full=RasterOp(vga.config.full_set_reset,ExpandTable[val] &amp; vga.config.full_bit_mask);
<a name="l00141"></a>00141                 <span class="keywordflow">break</span>;
<a name="l00142"></a>00142         <span class="keywordflow">default</span>:
<a name="l00143"></a>00143                 <a class="code" href="classLOG.html">LOG</a>(LOG_VGAMISC,LOG_NORMAL)(<span class="stringliteral">&quot;VGA:Unsupported write mode %d&quot;</span>,vga.config.write_mode);
<a name="l00144"></a>00144                 full=0;
<a name="l00145"></a>00145                 <span class="keywordflow">break</span>;
<a name="l00146"></a>00146         }
<a name="l00147"></a>00147         <span class="keywordflow">return</span> full;
<a name="l00148"></a>00148 }
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="comment">/* Gonna assume that whoever maps vga memory, maps it on 32/64kb boundary */</span>
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="preprocessor">#define VGA_PAGES               (128/4)</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span><span class="preprocessor">#define VGA_PAGE_A0             (0xA0000/4096)</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span><span class="preprocessor">#define VGA_PAGE_B0             (0xB0000/4096)</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span><span class="preprocessor">#define VGA_PAGE_B8             (0xB8000/4096)</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span>
<a name="l00157"></a>00157 <span class="keyword">static</span> <span class="keyword">struct </span>{
<a name="l00158"></a>00158         Bitu base, mask;
<a name="l00159"></a>00159 } vgapages;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="keyword">static</span> <span class="keyword">inline</span> Bitu VGA_Generic_Read_Handler(PhysPt planeaddr,PhysPt rawaddr,<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> plane) {
<a name="l00162"></a>00162     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hobit_n = (vga.seq.memory_mode&amp;2<span class="comment">/*Extended Memory*/</span>) ? 16u : 14u;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     <span class="comment">/* Sequencer Memory Mode Register (04h)</span>
<a name="l00165"></a>00165 <span class="comment">     * bits[3:3] = Chain 4 enable</span>
<a name="l00166"></a>00166 <span class="comment">     * bits[2:2] = Odd/Even Host Memory Write Addressing Disable</span>
<a name="l00167"></a>00167 <span class="comment">     * bits[1:1] = Extended memory (when EGA cards have &gt; 64KB of RAM)</span>
<a name="l00168"></a>00168 <span class="comment">     * </span>
<a name="l00169"></a>00169 <span class="comment">     * NTS: Real hardware experience says that despite the name, the Odd/Even bit affects reading as well */</span>
<a name="l00170"></a>00170     <span class="keywordflow">if</span> (!(vga.seq.memory_mode&amp;4) &amp;&amp; !non_cga_ignore_oddeven_engage)<span class="comment">/* Odd Even Host Memory Write Addressing Disable (is not set) */</span>
<a name="l00171"></a>00171         plane = (plane &amp; ~1u) + (rawaddr &amp; 1u);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173     <span class="comment">/* Graphics Controller: Miscellaneous Graphics Register register (06h)</span>
<a name="l00174"></a>00174 <span class="comment">     * bits[3:2] = memory map select</span>
<a name="l00175"></a>00175 <span class="comment">     * bits[1:1] = Chain Odd/Even Enable</span>
<a name="l00176"></a>00176 <span class="comment">     * bits[0:0] = Alphanumeric Mode Disable</span>
<a name="l00177"></a>00177 <span class="comment">     *</span>
<a name="l00178"></a>00178 <span class="comment">     * http://www.osdever.net/FreeVGA/vga/graphreg.htm</span>
<a name="l00179"></a>00179 <span class="comment">     *</span>
<a name="l00180"></a>00180 <span class="comment">     * When enabled, address bit A0 (bit 0) becomes bit 0 of the plane index.</span>
<a name="l00181"></a>00181 <span class="comment">     * Then when addressing VRAM A0 is replaced by a &quot;higher order bit&quot;, which is</span>
<a name="l00182"></a>00182 <span class="comment">     * probably A14 or A16 depending on Extended Memory bit 1 in Sequencer register 04h memory mode */</span>
<a name="l00183"></a>00183     <span class="keywordflow">if</span> ((vga.gfx.miscellaneous&amp;2) &amp;&amp; !non_cga_ignore_oddeven_engage) {<span class="comment">/* Odd/Even enable */</span>
<a name="l00184"></a>00184         <span class="keyword">const</span> PhysPt mask = (vga.config.compatible_chain4 ? 0u : ~0xFFFFu) + (1u &lt;&lt; hobit_n) - 2u;
<a name="l00185"></a>00185         <span class="keyword">const</span> PhysPt hobit = (planeaddr &gt;&gt; hobit_n) &amp; 1u;
<a name="l00186"></a>00186         <span class="comment">/* 1 &lt;&lt; 14 =     0x4000</span>
<a name="l00187"></a>00187 <span class="comment">         * 1 &lt;&lt; 14 - 1 = 0x3FFF</span>
<a name="l00188"></a>00188 <span class="comment">         * 1 &lt;&lt; 14 - 2 = 0x3FFE</span>
<a name="l00189"></a>00189 <span class="comment">         * The point is to mask upper bit AND the LSB */</span>
<a name="l00190"></a>00190         planeaddr = (planeaddr &amp; mask &amp; (vga.mem.memmask &gt;&gt; 2u)) + hobit;
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192     <span class="keywordflow">else</span> {
<a name="l00193"></a>00193         <span class="keyword">const</span> PhysPt mask = (vga.config.compatible_chain4 ? 0u : ~0xFFFFu) + (1u &lt;&lt; hobit_n) - 1u;
<a name="l00194"></a>00194         planeaddr &amp;= mask &amp; (vga.mem.memmask &gt;&gt; 2u);
<a name="l00195"></a>00195     }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197     vga.latch.d=((Bit32u*)vga.mem.linear)[planeaddr];
<a name="l00198"></a>00198     <span class="keywordflow">switch</span> (vga.config.read_mode) {
<a name="l00199"></a>00199         <span class="keywordflow">case</span> 0:
<a name="l00200"></a>00200             <span class="keywordflow">return</span> (vga.latch.b[plane]);
<a name="l00201"></a>00201         <span class="keywordflow">case</span> 1:
<a name="l00202"></a>00202             <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> templatch;
<a name="l00203"></a>00203             templatch.d=(vga.latch.d &amp; FillTable[vga.config.color_dont_care]) ^ FillTable[vga.config.color_compare &amp; vga.config.color_dont_care];
<a name="l00204"></a>00204             return (Bit8u)~(templatch.b[0] | templatch.b[1] | templatch.b[2] | templatch.b[3]);
<a name="l00205"></a>00205     }
<a name="l00206"></a>00206 
<a name="l00207"></a>00207     <span class="keywordflow">return</span> 0;
<a name="l00208"></a>00208 }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 <span class="keyword">template</span> &lt;const <span class="keywordtype">bool</span> chained&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> VGA_Generic_Write_Handler(PhysPt planeaddr,PhysPt rawaddr,Bit8u val) {
<a name="l00211"></a>00211     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hobit_n = (vga.seq.memory_mode&amp;2<span class="comment">/*Extended Memory*/</span>) ? 16u : 14u;
<a name="l00212"></a>00212     Bit32u mask = vga.config.full_map_mask;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214     <span class="comment">/* Sequencer Memory Mode Register (04h)</span>
<a name="l00215"></a>00215 <span class="comment">     * bits[3:3] = Chain 4 enable</span>
<a name="l00216"></a>00216 <span class="comment">     * bits[2:2] = Odd/Even Host Memory Write Addressing Disable</span>
<a name="l00217"></a>00217 <span class="comment">     * bits[1:1] = Extended memory (when EGA cards have &gt; 64KB of RAM)</span>
<a name="l00218"></a>00218 <span class="comment">     * </span>
<a name="l00219"></a>00219 <span class="comment">     * NTS: Real hardware experience says that despite the name, the Odd/Even bit affects reading as well */</span>
<a name="l00220"></a>00220     <span class="keywordflow">if</span> (chained) {
<a name="l00221"></a>00221         <span class="keywordflow">if</span> (!(vga.seq.memory_mode&amp;4) &amp;&amp; !non_cga_ignore_oddeven_engage)<span class="comment">/* Odd Even Host Memory Write Addressing Disable (is not set) */</span>
<a name="l00222"></a>00222             mask &amp;= 0xFF00FFu &lt;&lt; ((rawaddr &amp; 1u) * 8u);
<a name="l00223"></a>00223         <span class="keywordflow">else</span>
<a name="l00224"></a>00224             mask &amp;= 0xFFu &lt;&lt; ((rawaddr &amp; 3u) * 8u);
<a name="l00225"></a>00225     }
<a name="l00226"></a>00226     <span class="keywordflow">else</span> {
<a name="l00227"></a>00227         <span class="keywordflow">if</span> (!(vga.seq.memory_mode&amp;4) &amp;&amp; !non_cga_ignore_oddeven_engage)<span class="comment">/* Odd Even Host Memory Write Addressing Disable (is not set) */</span>
<a name="l00228"></a>00228             mask &amp;= 0xFF00FFu &lt;&lt; ((rawaddr &amp; 1u) * 8u);
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     <span class="comment">/* Graphics Controller: Miscellaneous Graphics Register register (06h)</span>
<a name="l00232"></a>00232 <span class="comment">     * bits[3:2] = memory map select</span>
<a name="l00233"></a>00233 <span class="comment">     * bits[1:1] = Chain Odd/Even Enable</span>
<a name="l00234"></a>00234 <span class="comment">     * bits[0:0] = Alphanumeric Mode Disable</span>
<a name="l00235"></a>00235 <span class="comment">     *</span>
<a name="l00236"></a>00236 <span class="comment">     * http://www.osdever.net/FreeVGA/vga/graphreg.htm</span>
<a name="l00237"></a>00237 <span class="comment">     *</span>
<a name="l00238"></a>00238 <span class="comment">     * When enabled, address bit A0 (bit 0) becomes bit 0 of the plane index.</span>
<a name="l00239"></a>00239 <span class="comment">     * Then when addressing VRAM A0 is replaced by a &quot;higher order bit&quot;, which is</span>
<a name="l00240"></a>00240 <span class="comment">     * probably A14 or A16 depending on Extended Memory bit 1 in Sequencer register 04h memory mode */</span>
<a name="l00241"></a>00241     <span class="keywordflow">if</span> ((vga.gfx.miscellaneous&amp;2) &amp;&amp; !non_cga_ignore_oddeven_engage) {<span class="comment">/* Odd/Even enable */</span>
<a name="l00242"></a>00242         <span class="keyword">const</span> PhysPt mask = (vga.config.compatible_chain4 ? 0u : ~0xFFFFu) + (1u &lt;&lt; hobit_n) - 2u;
<a name="l00243"></a>00243         <span class="keyword">const</span> PhysPt hobit = (planeaddr &gt;&gt; hobit_n) &amp; 1u;
<a name="l00244"></a>00244         <span class="comment">/* 1 &lt;&lt; 14 =     0x4000</span>
<a name="l00245"></a>00245 <span class="comment">         * 1 &lt;&lt; 14 - 1 = 0x3FFF</span>
<a name="l00246"></a>00246 <span class="comment">         * 1 &lt;&lt; 14 - 2 = 0x3FFE</span>
<a name="l00247"></a>00247 <span class="comment">         * The point is to mask upper bit AND the LSB */</span>
<a name="l00248"></a>00248         planeaddr = (planeaddr &amp; mask &amp; (vga.mem.memmask &gt;&gt; 2u)) + hobit;
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250     <span class="keywordflow">else</span> {
<a name="l00251"></a>00251         <span class="keyword">const</span> PhysPt mask = (vga.config.compatible_chain4 ? 0u : ~0xFFFFu) + (1u &lt;&lt; hobit_n) - 1u;
<a name="l00252"></a>00252         planeaddr &amp;= mask &amp; (vga.mem.memmask &gt;&gt; 2u);
<a name="l00253"></a>00253     }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     Bit32u data=ModeOperation(val);
<a name="l00256"></a>00256     <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> pixels;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258     pixels.d =((Bit32u*)vga.mem.linear)[planeaddr];
<a name="l00259"></a>00259     pixels.d&amp;=~mask;
<a name="l00260"></a>00260     pixels.d|=(data &amp; mask);
<a name="l00261"></a>00261 
<a name="l00262"></a>00262     <span class="comment">/* FIXME: A better method (I think) is to have the VGA text drawing code</span>
<a name="l00263"></a>00263 <span class="comment">     *        directly reference the font data in bitplane #2 instead of</span>
<a name="l00264"></a>00264 <span class="comment">     *        this hack */</span>
<a name="l00265"></a>00265     vga.draw.font[planeaddr] = pixels.b[2];
<a name="l00266"></a>00266 
<a name="l00267"></a>00267     ((Bit32u*)vga.mem.linear)[planeaddr]=pixels.d;
<a name="l00268"></a>00268 }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="comment">// Slow accurate emulation.</span>
<a name="l00271"></a>00271 <span class="comment">// This version takes the Graphics Controller bitmask and ROPs into account.</span>
<a name="l00272"></a>00272 <span class="comment">// This is needed for demos that use the bitmask to do color combination or bitplane &quot;page flipping&quot; tricks.</span>
<a name="l00273"></a>00273 <span class="comment">// This code will kick in if running in a chained VGA mode and the graphics controller bitmask register is</span>
<a name="l00274"></a>00274 <span class="comment">// changed to anything other than 0xFF.</span>
<a name="l00275"></a>00275 <span class="comment">//</span>
<a name="l00276"></a>00276 <span class="comment">// Impact Studios &quot;Legend&quot;</span>
<a name="l00277"></a>00277 <span class="comment">//  - The rotating objects, rendered as dots, needs this hack because it uses a combination of masking off</span>
<a name="l00278"></a>00278 <span class="comment">//    bitplanes using the VGA DAC pel mask and drawing on the hidden bitplane using the Graphics Controller</span>
<a name="l00279"></a>00279 <span class="comment">//    bitmask. It also relies on loading the VGA latches with zeros as a form of &quot;overdraw&quot;. Without this</span>
<a name="l00280"></a>00280 <span class="comment">//    version the effect will instead become a glowing ball of flickering yellow/red.</span>
<a name="l00281"></a><a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">00281</a> <span class="keyword">class </span><a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">VGA_ChainedVGA_Slow_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00282"></a>00282 <span class="keyword">public</span>:
<a name="l00283"></a>00283         <a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">VGA_ChainedVGA_Slow_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00284"></a>00284         <span class="keyword">static</span> INLINE Bitu readHandler8(PhysPt addr ) {
<a name="l00285"></a>00285         <span class="comment">// planar byte offset = addr &amp; ~3u      (discard low 2 bits)</span>
<a name="l00286"></a>00286         <span class="comment">// planer index = addr &amp; 3u             (use low 2 bits as plane index)</span>
<a name="l00287"></a>00287         <span class="comment">// FIXME: Does chained mode use the lower 2 bits of the CPU address or does it use the read mode select???</span>
<a name="l00288"></a>00288         <span class="keywordflow">return</span> VGA_Generic_Read_Handler(addr&amp;~3u, addr, addr&amp;3u);
<a name="l00289"></a>00289         }
<a name="l00290"></a>00290         <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> writeHandler8(PhysPt addr, Bitu val) {
<a name="l00291"></a>00291         <span class="comment">// planar byte offset = addr &amp; ~3u      (discard low 2 bits)</span>
<a name="l00292"></a>00292         <span class="comment">// planer index = addr &amp; 3u             (use low 2 bits as plane index)</span>
<a name="l00293"></a>00293         <span class="keywordflow">return</span> VGA_Generic_Write_Handler&lt;<span class="keyword">true</span><span class="comment">/*chained*/</span>&gt;(addr&amp;~3u, addr, val);
<a name="l00294"></a>00294         }
<a name="l00295"></a>00295         Bitu readb(PhysPt addr ) {
<a name="l00296"></a>00296                 VGAMEM_USEC_read_delay();
<a name="l00297"></a>00297                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00298"></a>00298                 addr += vga.svga.bank_read_full;
<a name="l00299"></a>00299 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00300"></a>00300                 <span class="keywordflow">return</span> readHandler8( addr );
<a name="l00301"></a>00301         }
<a name="l00302"></a>00302         Bitu readw(PhysPt addr ) {
<a name="l00303"></a>00303                 VGAMEM_USEC_read_delay();
<a name="l00304"></a>00304                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00305"></a>00305                 addr += vga.svga.bank_read_full;
<a name="l00306"></a>00306 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00307"></a>00307                 Bitu ret = (readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00308"></a>00308                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00309"></a>00309                 <span class="keywordflow">return</span> ret;
<a name="l00310"></a>00310         }
<a name="l00311"></a>00311         Bitu readd(PhysPt addr ) {
<a name="l00312"></a>00312                 VGAMEM_USEC_read_delay();
<a name="l00313"></a>00313                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00314"></a>00314                 addr += vga.svga.bank_read_full;
<a name="l00315"></a>00315 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00316"></a>00316                 Bitu ret = (readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00317"></a>00317                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00318"></a>00318                 ret     |= (readHandler8( addr+2 ) &lt;&lt; 16 );
<a name="l00319"></a>00319                 ret     |= (readHandler8( addr+3 ) &lt;&lt; 24 );
<a name="l00320"></a>00320                 <span class="keywordflow">return</span> ret;
<a name="l00321"></a>00321         }
<a name="l00322"></a>00322         <span class="keywordtype">void</span> writeb(PhysPt addr, Bitu val ) {
<a name="l00323"></a>00323                 VGAMEM_USEC_write_delay();
<a name="l00324"></a>00324                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00325"></a>00325                 addr += vga.svga.bank_write_full;
<a name="l00326"></a>00326 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00327"></a>00327                 writeHandler8( addr, val );
<a name="l00328"></a>00328         }
<a name="l00329"></a>00329         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00330"></a>00330                 VGAMEM_USEC_write_delay();
<a name="l00331"></a>00331                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00332"></a>00332                 addr += vga.svga.bank_write_full;
<a name="l00333"></a>00333 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00334"></a>00334                 writeHandler8( addr+0, val &gt;&gt; 0 );
<a name="l00335"></a>00335                 writeHandler8( addr+1, val &gt;&gt; 8 );
<a name="l00336"></a>00336         }
<a name="l00337"></a>00337         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00338"></a>00338                 VGAMEM_USEC_write_delay();
<a name="l00339"></a>00339                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00340"></a>00340                 addr += vga.svga.bank_write_full;
<a name="l00341"></a>00341 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00342"></a>00342                 writeHandler8( addr+0, val &gt;&gt; 0 );
<a name="l00343"></a>00343                 writeHandler8( addr+1, val &gt;&gt; 8 );
<a name="l00344"></a>00344                 writeHandler8( addr+2, val &gt;&gt; 16 );
<a name="l00345"></a>00345                 writeHandler8( addr+3, val &gt;&gt; 24 );
<a name="l00346"></a>00346         }
<a name="l00347"></a>00347 };
<a name="l00348"></a>00348 
<a name="l00349"></a><a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">00349</a> <span class="keyword">class </span><a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">VGA_ET4000_ChainedVGA_Slow_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00350"></a>00350 <span class="keyword">public</span>:
<a name="l00351"></a>00351         <a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">VGA_ET4000_ChainedVGA_Slow_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00352"></a>00352         <span class="keyword">static</span> INLINE Bitu readHandler8(PhysPt addr ) {
<a name="l00353"></a>00353         <span class="comment">// planar byte offset = addr &gt;&gt; 2       (shift 2 bits to the right)</span>
<a name="l00354"></a>00354         <span class="comment">// planer index = addr &amp; 3u             (use low 2 bits as plane index)</span>
<a name="l00355"></a>00355         <span class="keywordflow">return</span> VGA_Generic_Read_Handler(addr&gt;&gt;2u, addr, addr&amp;3u);
<a name="l00356"></a>00356         }
<a name="l00357"></a>00357         <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> writeHandler8(PhysPt addr, Bitu val) {
<a name="l00358"></a>00358         <span class="comment">// planar byte offset = addr &gt;&gt; 2       (shift 2 bits to the right)</span>
<a name="l00359"></a>00359         <span class="comment">// planer index = addr &amp; 3u             (use low 2 bits as plane index)</span>
<a name="l00360"></a>00360         <span class="keywordflow">return</span> VGA_Generic_Write_Handler&lt;<span class="keyword">true</span><span class="comment">/*chained*/</span>&gt;(addr&gt;&gt;2u, addr, val);
<a name="l00361"></a>00361         }
<a name="l00362"></a>00362         Bitu readb(PhysPt addr ) {
<a name="l00363"></a>00363                 VGAMEM_USEC_read_delay();
<a name="l00364"></a>00364                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00365"></a>00365                 addr += vga.svga.bank_read_full;
<a name="l00366"></a>00366 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00367"></a>00367                 <span class="keywordflow">return</span> readHandler8( addr );
<a name="l00368"></a>00368         }
<a name="l00369"></a>00369         Bitu readw(PhysPt addr ) {
<a name="l00370"></a>00370                 VGAMEM_USEC_read_delay();
<a name="l00371"></a>00371                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00372"></a>00372                 addr += vga.svga.bank_read_full;
<a name="l00373"></a>00373 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00374"></a>00374                 Bitu ret = (readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00375"></a>00375                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00376"></a>00376                 <span class="keywordflow">return</span> ret;
<a name="l00377"></a>00377         }
<a name="l00378"></a>00378         Bitu readd(PhysPt addr ) {
<a name="l00379"></a>00379                 VGAMEM_USEC_read_delay();
<a name="l00380"></a>00380                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00381"></a>00381                 addr += vga.svga.bank_read_full;
<a name="l00382"></a>00382 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00383"></a>00383                 Bitu ret = (readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00384"></a>00384                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00385"></a>00385                 ret     |= (readHandler8( addr+2 ) &lt;&lt; 16 );
<a name="l00386"></a>00386                 ret     |= (readHandler8( addr+3 ) &lt;&lt; 24 );
<a name="l00387"></a>00387                 <span class="keywordflow">return</span> ret;
<a name="l00388"></a>00388         }
<a name="l00389"></a>00389         <span class="keywordtype">void</span> writeb(PhysPt addr, Bitu val ) {
<a name="l00390"></a>00390                 VGAMEM_USEC_write_delay();
<a name="l00391"></a>00391                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00392"></a>00392                 addr += vga.svga.bank_write_full;
<a name="l00393"></a>00393 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00394"></a>00394                 writeHandler8( addr, val );
<a name="l00395"></a>00395         }
<a name="l00396"></a>00396         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00397"></a>00397                 VGAMEM_USEC_write_delay();
<a name="l00398"></a>00398                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00399"></a>00399                 addr += vga.svga.bank_write_full;
<a name="l00400"></a>00400 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00401"></a>00401                 writeHandler8( addr+0, val &gt;&gt; 0 );
<a name="l00402"></a>00402                 writeHandler8( addr+1, val &gt;&gt; 8 );
<a name="l00403"></a>00403         }
<a name="l00404"></a>00404         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00405"></a>00405                 VGAMEM_USEC_write_delay();
<a name="l00406"></a>00406                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00407"></a>00407                 addr += vga.svga.bank_write_full;
<a name="l00408"></a>00408 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00409"></a>00409                 writeHandler8( addr+0, val &gt;&gt; 0 );
<a name="l00410"></a>00410                 writeHandler8( addr+1, val &gt;&gt; 8 );
<a name="l00411"></a>00411                 writeHandler8( addr+2, val &gt;&gt; 16 );
<a name="l00412"></a>00412                 writeHandler8( addr+3, val &gt;&gt; 24 );
<a name="l00413"></a>00413         }
<a name="l00414"></a>00414 };
<a name="l00415"></a>00415 
<a name="l00416"></a><a class="code" href="classVGA__UnchainedVGA__Handler.html">00416</a> <span class="keyword">class </span><a class="code" href="classVGA__UnchainedVGA__Handler.html">VGA_UnchainedVGA_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00417"></a>00417 <span class="keyword">public</span>:
<a name="l00418"></a>00418         Bitu readHandler(PhysPt start) {
<a name="l00419"></a>00419         <span class="keywordflow">return</span> VGA_Generic_Read_Handler(start, start, vga.config.read_map_select);
<a name="l00420"></a>00420         }
<a name="l00421"></a>00421 <span class="keyword">public</span>:
<a name="l00422"></a>00422         Bitu readb(PhysPt addr) {
<a name="l00423"></a>00423                 VGAMEM_USEC_read_delay();
<a name="l00424"></a>00424                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00425"></a>00425                 addr += vga.svga.bank_read_full;
<a name="l00426"></a>00426 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00427"></a>00427                 <span class="keywordflow">return</span> readHandler(addr);
<a name="l00428"></a>00428         }
<a name="l00429"></a>00429         Bitu readw(PhysPt addr) {
<a name="l00430"></a>00430                 VGAMEM_USEC_read_delay();
<a name="l00431"></a>00431                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00432"></a>00432                 addr += vga.svga.bank_read_full;
<a name="l00433"></a>00433 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00434"></a>00434                 Bitu ret = (readHandler(addr+0) &lt;&lt; 0);
<a name="l00435"></a>00435                 ret     |= (readHandler(addr+1) &lt;&lt; 8);
<a name="l00436"></a>00436                 <span class="keywordflow">return</span>  ret;
<a name="l00437"></a>00437         }
<a name="l00438"></a>00438         Bitu readd(PhysPt addr) {
<a name="l00439"></a>00439                 VGAMEM_USEC_read_delay();
<a name="l00440"></a>00440                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00441"></a>00441                 addr += vga.svga.bank_read_full;
<a name="l00442"></a>00442 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00443"></a>00443                 Bitu ret = (readHandler(addr+0) &lt;&lt; 0);
<a name="l00444"></a>00444                 ret     |= (readHandler(addr+1) &lt;&lt; 8);
<a name="l00445"></a>00445                 ret     |= (readHandler(addr+2) &lt;&lt; 16);
<a name="l00446"></a>00446                 ret     |= (readHandler(addr+3) &lt;&lt; 24);
<a name="l00447"></a>00447                 <span class="keywordflow">return</span> ret;
<a name="l00448"></a>00448         }
<a name="l00449"></a>00449 <span class="keyword">public</span>:
<a name="l00450"></a>00450         <span class="keywordtype">void</span> writeHandler(PhysPt start, Bit8u val) {
<a name="l00451"></a>00451         VGA_Generic_Write_Handler&lt;<span class="keyword">false</span><span class="comment">/*chained*/</span>&gt;(start, start, val);
<a name="l00452"></a>00452         }
<a name="l00453"></a>00453 <span class="keyword">public</span>:
<a name="l00454"></a>00454         <a class="code" href="classVGA__UnchainedVGA__Handler.html">VGA_UnchainedVGA_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00455"></a>00455         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l00456"></a>00456                 VGAMEM_USEC_write_delay();
<a name="l00457"></a>00457                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00458"></a>00458                 addr += vga.svga.bank_write_full;
<a name="l00459"></a>00459 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00460"></a>00460                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00461"></a>00461         }
<a name="l00462"></a>00462         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00463"></a>00463                 VGAMEM_USEC_write_delay();
<a name="l00464"></a>00464                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00465"></a>00465                 addr += vga.svga.bank_write_full;
<a name="l00466"></a>00466 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00467"></a>00467                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00468"></a>00468                 writeHandler(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l00469"></a>00469         }
<a name="l00470"></a>00470         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00471"></a>00471                 VGAMEM_USEC_write_delay();
<a name="l00472"></a>00472                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00473"></a>00473                 addr += vga.svga.bank_write_full;
<a name="l00474"></a>00474 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00475"></a>00475                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00476"></a>00476                 writeHandler(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l00477"></a>00477                 writeHandler(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l00478"></a>00478                 writeHandler(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l00479"></a>00479         }
<a name="l00480"></a>00480 };
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00483"></a>00483 
<a name="l00484"></a><a class="code" href="classVGA__CGATEXT__PageHandler.html">00484</a> <span class="keyword">class </span><a class="code" href="classVGA__CGATEXT__PageHandler.html">VGA_CGATEXT_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00485"></a>00485 <span class="keyword">public</span>:
<a name="l00486"></a>00486         <a class="code" href="classVGA__CGATEXT__PageHandler.html">VGA_CGATEXT_PageHandler</a>() {
<a name="l00487"></a>00487                 flags=PFLAG_NOCODE;
<a name="l00488"></a>00488         }
<a name="l00489"></a>00489         Bitu readb(PhysPt addr) {
<a name="l00490"></a>00490                 addr = PAGING_GetPhysicalAddress(addr) &amp; 0x3FFF;
<a name="l00491"></a>00491                 VGAMEM_USEC_read_delay();
<a name="l00492"></a>00492                 <span class="keywordflow">return</span> vga.tandy.mem_base[addr];
<a name="l00493"></a>00493         }
<a name="l00494"></a>00494         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val){
<a name="l00495"></a>00495                 VGAMEM_USEC_write_delay();
<a name="l00496"></a>00496 
<a name="l00497"></a>00497                 <span class="keywordflow">if</span> (enableCGASnow) {
<a name="l00498"></a>00498                         <span class="comment">/* NTS: We can&#39;t use PIC_FullIndex() exclusively because it&#39;s not precise enough</span>
<a name="l00499"></a>00499 <span class="comment">                         *      with respect to when DOSBox CPU emulation is writing. We have to use other</span>
<a name="l00500"></a>00500 <span class="comment">                         *      variables like CPU_Cycles to gain additional precision */</span>
<a name="l00501"></a>00501                         <span class="keywordtype">double</span> timeInFrame = PIC_FullIndex()-vga.draw.delay.framestart;
<a name="l00502"></a>00502                         <span class="keywordtype">double</span> timeInLine = fmod(timeInFrame,vga.draw.delay.htotal);
<a name="l00503"></a>00503 
<a name="l00504"></a>00504                         <span class="comment">/* we&#39;re in active area. which column should the snow show up on? */</span>
<a name="l00505"></a>00505                         Bit32u x = (Bit32u)((timeInLine * 80) / vga.draw.delay.hblkstart);
<a name="l00506"></a>00506                         <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span>)x &lt; 80) vga.draw.cga_snow[x] = val;
<a name="l00507"></a>00507                 }
<a name="l00508"></a>00508 
<a name="l00509"></a>00509                 addr = PAGING_GetPhysicalAddress(addr) &amp; 0x3FFF;
<a name="l00510"></a>00510                 vga.tandy.mem_base[addr] = val;
<a name="l00511"></a>00511         }
<a name="l00512"></a>00512 };
<a name="l00513"></a>00513 
<a name="l00514"></a><a class="code" href="classVGA__MCGATEXT__PageHandler.html">00514</a> <span class="keyword">class </span><a class="code" href="classVGA__MCGATEXT__PageHandler.html">VGA_MCGATEXT_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00515"></a>00515 <span class="keyword">public</span>:
<a name="l00516"></a>00516         <a class="code" href="classVGA__MCGATEXT__PageHandler.html">VGA_MCGATEXT_PageHandler</a>() {
<a name="l00517"></a>00517                 flags=PFLAG_NOCODE;
<a name="l00518"></a>00518         }
<a name="l00519"></a>00519         Bitu readb(PhysPt addr) {
<a name="l00520"></a>00520                 addr = PAGING_GetPhysicalAddress(addr) &amp; 0xFFFF;
<a name="l00521"></a>00521                 VGAMEM_USEC_read_delay();
<a name="l00522"></a>00522                 <span class="keywordflow">return</span> vga.tandy.mem_base[addr];
<a name="l00523"></a>00523         }
<a name="l00524"></a>00524         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val){
<a name="l00525"></a>00525                 VGAMEM_USEC_write_delay();
<a name="l00526"></a>00526 
<a name="l00527"></a>00527                 addr = PAGING_GetPhysicalAddress(addr) &amp; 0xFFFF;
<a name="l00528"></a>00528                 vga.tandy.mem_base[addr] = val;
<a name="l00529"></a>00529         }
<a name="l00530"></a>00530 };
<a name="l00531"></a>00531 
<a name="l00532"></a>00532 <span class="keyword">extern</span> uint8_t pc98_egc_srcmask[2]; <span class="comment">/* host given (Neko: egc.srcmask) */</span>
<a name="l00533"></a>00533 <span class="keyword">extern</span> uint8_t pc98_egc_maskef[2]; <span class="comment">/* effective (Neko: egc.mask2) */</span>
<a name="l00534"></a>00534 <span class="keyword">extern</span> uint8_t pc98_egc_mask[2]; <span class="comment">/* host given (Neko: egc.mask) */</span>
<a name="l00535"></a>00535 <span class="keyword">extern</span> uint8_t pc98_egc_access;
<a name="l00536"></a>00536 <span class="keyword">extern</span> uint8_t pc98_egc_fgc;
<a name="l00537"></a>00537 <span class="keyword">extern</span> uint8_t pc98_egc_foreground_color;
<a name="l00538"></a>00538 <span class="keyword">extern</span> uint8_t pc98_egc_background_color;
<a name="l00539"></a>00539 <span class="keyword">extern</span> uint8_t pc98_egc_lead_plane;
<a name="l00540"></a>00540 <span class="keyword">extern</span> uint8_t pc98_egc_compare_lead;
<a name="l00541"></a>00541 <span class="keyword">extern</span> uint8_t pc98_egc_lightsource;
<a name="l00542"></a>00542 <span class="keyword">extern</span> uint8_t pc98_egc_shiftinput;
<a name="l00543"></a>00543 <span class="keyword">extern</span> uint8_t pc98_egc_regload;
<a name="l00544"></a>00544 <span class="keyword">extern</span> uint8_t pc98_egc_rop;
<a name="l00545"></a>00545 
<a name="l00546"></a>00546 <span class="keyword">extern</span> <span class="keywordtype">bool</span> pc98_egc_shift_descend;
<a name="l00547"></a>00547 <span class="keyword">extern</span> uint8_t pc98_egc_shift_destbit;
<a name="l00548"></a>00548 <span class="keyword">extern</span> uint8_t pc98_egc_shift_srcbit;
<a name="l00549"></a>00549 <span class="keyword">extern</span> uint16_t pc98_egc_shift_length;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="comment">/* I don&#39;t think we necessarily need the full 4096 bit buffer</span>
<a name="l00552"></a>00552 <span class="comment"> * Neko Project II uses to render things, though that is</span>
<a name="l00553"></a>00553 <span class="comment"> * probably faster to execute. It makes it hard to make sense</span>
<a name="l00554"></a>00554 <span class="comment"> * of the code though. */</span>
<a name="l00555"></a><a class="code" href="structpc98__egc__shifter.html">00555</a> <span class="keyword">struct </span><a class="code" href="structpc98__egc__shifter.html">pc98_egc_shifter</a> {
<a name="l00556"></a>00556     <a class="code" href="structpc98__egc__shifter.html">pc98_egc_shifter</a>() : decrement(<span class="keyword">false</span>), remain(0x10), srcbit(0), dstbit(0) { }
<a name="l00557"></a>00557 
<a name="l00558"></a>00558     <span class="keywordtype">void</span> reinit(<span class="keywordtype">void</span>) { <span class="comment">/* from global vars set by guest */</span>
<a name="l00559"></a>00559         decrement = pc98_egc_shift_descend;
<a name="l00560"></a>00560         remain = pc98_egc_shift_length + 1; <span class="comment">/* the register is length - 1 apparently */</span>
<a name="l00561"></a>00561         dstbit = pc98_egc_shift_destbit;
<a name="l00562"></a>00562         srcbit = pc98_egc_shift_srcbit;
<a name="l00563"></a>00563         bufi = bufo = decrement ? (<span class="keyword">sizeof</span>(buffer) + 3 - (4*4)) : 0;
<a name="l00564"></a>00564 
<a name="l00565"></a>00565         <span class="keywordflow">if</span> ((srcbit&amp;7) &lt; (dstbit&amp;7)) {
<a name="l00566"></a>00566             shft8bitr = (dstbit&amp;7) - (srcbit&amp;7);
<a name="l00567"></a>00567             shft8bitl = 8 - shft8bitr;
<a name="l00568"></a>00568         }
<a name="l00569"></a>00569         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((srcbit&amp;7) &gt; (dstbit&amp;7)) {
<a name="l00570"></a>00570             shft8bitl = (srcbit&amp;7) - (dstbit&amp;7);
<a name="l00571"></a>00571             shft8bitr = 8 - shft8bitl;
<a name="l00572"></a>00572         }
<a name="l00573"></a>00573         <span class="keywordflow">else</span> {
<a name="l00574"></a>00574             shft8bitr = 0;
<a name="l00575"></a>00575             shft8bitl = 0;
<a name="l00576"></a>00576         }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578         shft8load = 0;
<a name="l00579"></a>00579         o_srcbit = srcbit &amp; 7;
<a name="l00580"></a>00580         o_dstbit = dstbit &amp; 7;
<a name="l00581"></a>00581     }
<a name="l00582"></a>00582 
<a name="l00583"></a>00583     <span class="keywordtype">bool</span>                decrement;
<a name="l00584"></a>00584     uint16_t            remain;
<a name="l00585"></a>00585     uint16_t            srcbit;
<a name="l00586"></a>00586     uint16_t            dstbit;
<a name="l00587"></a>00587     uint16_t            o_srcbit;
<a name="l00588"></a>00588     uint16_t            o_dstbit;
<a name="l00589"></a>00589 
<a name="l00590"></a>00590     uint8_t             buffer[512]; <span class="comment">/* 4096/8 = 512 */</span>
<a name="l00591"></a>00591     uint16_t            bufi,bufo;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593     uint8_t             shft8load;
<a name="l00594"></a>00594     uint8_t             shft8bitr;
<a name="l00595"></a>00595     uint8_t             shft8bitl;
<a name="l00596"></a>00596 
<a name="l00597"></a>00597     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> bi(<span class="keyword">const</span> uint16_t ofs,<span class="keyword">const</span> AWT val) {
<a name="l00598"></a>00598         <span class="keywordtype">size_t</span> ip = (bufi + ofs) &amp; (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00599"></a>00599 
<a name="l00600"></a>00600         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; <span class="keyword">sizeof</span>(AWT);) {
<a name="l00601"></a>00601             buffer[ip] = (uint8_t)(val &gt;&gt; ((AWT)(i * 8U)));
<a name="l00602"></a>00602             <span class="keywordflow">if</span> ((++ip) == <span class="keyword">sizeof</span>(buffer)) ip = 0;
<a name="l00603"></a>00603             i++;
<a name="l00604"></a>00604         }
<a name="l00605"></a>00605     }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> bi_adv(<span class="keywordtype">void</span>) {
<a name="l00608"></a>00608         bufi += pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) - <span class="keyword">sizeof</span>(AWT)) : <span class="keyword">sizeof</span>(AWT);
<a name="l00609"></a>00609         bufi &amp;= (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00610"></a>00610     }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> AWT bo(<span class="keyword">const</span> uint16_t ofs) {
<a name="l00613"></a>00613         <span class="keywordtype">size_t</span> op = (bufo + ofs) &amp; (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00614"></a>00614         AWT ret = 0;
<a name="l00615"></a>00615 
<a name="l00616"></a>00616         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; <span class="keyword">sizeof</span>(AWT);) {
<a name="l00617"></a>00617             ret += ((AWT)buffer[op]) &lt;&lt; ((AWT)(i * 8U));
<a name="l00618"></a>00618             <span class="keywordflow">if</span> ((++op) == <span class="keyword">sizeof</span>(buffer)) op = 0;
<a name="l00619"></a>00619             i++;
<a name="l00620"></a>00620         }
<a name="l00621"></a>00621 
<a name="l00622"></a>00622         <span class="keywordflow">return</span> ret;
<a name="l00623"></a>00623     }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> bo_adv(<span class="keywordtype">void</span>) {
<a name="l00626"></a>00626         bufo += pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) - <span class="keyword">sizeof</span>(AWT)) : <span class="keyword">sizeof</span>(AWT);
<a name="l00627"></a>00627         bufo &amp;= (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00628"></a>00628     }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> input(<span class="keyword">const</span> AWT a,<span class="keyword">const</span> AWT b,<span class="keyword">const</span> AWT c,<span class="keyword">const</span> AWT d,uint8_t odd) {
<a name="l00631"></a>00631         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 0,a);
<a name="l00632"></a>00632         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 4,b);
<a name="l00633"></a>00633         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 8,c);
<a name="l00634"></a>00634         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 12,d);
<a name="l00635"></a>00635 
<a name="l00636"></a>00636         <span class="keywordflow">if</span> (shft8load &lt;= 16) {
<a name="l00637"></a>00637             bi_adv&lt;AWT&gt;();
<a name="l00638"></a>00638 
<a name="l00639"></a>00639             <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) == 2) {
<a name="l00640"></a>00640                 <span class="keywordflow">if</span> (srcbit &gt;= 8) bo_adv&lt;uint8_t&gt;();
<a name="l00641"></a>00641                 shft8load += (16 - srcbit);
<a name="l00642"></a>00642                 srcbit = 0;
<a name="l00643"></a>00643             }
<a name="l00644"></a>00644             <span class="keywordflow">else</span> {
<a name="l00645"></a>00645                 <span class="keywordflow">if</span> (srcbit &gt;= 8)
<a name="l00646"></a>00646                     srcbit -= 8;
<a name="l00647"></a>00647                 <span class="keywordflow">else</span> {
<a name="l00648"></a>00648                     shft8load += (8 - srcbit);
<a name="l00649"></a>00649                     srcbit = 0;
<a name="l00650"></a>00650                 }
<a name="l00651"></a>00651             }
<a name="l00652"></a>00652         }
<a name="l00653"></a>00653 
<a name="l00654"></a>00654         *((AWT*)(pc98_egc_srcmask+odd)) = (AWT)(~0ull);
<a name="l00655"></a>00655     }
<a name="l00656"></a>00656 
<a name="l00657"></a>00657     <span class="keyword">inline</span> uint8_t dstbit_mask(<span class="keywordtype">void</span>) {
<a name="l00658"></a>00658         uint8_t mb;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660         <span class="comment">/* assume remain &gt; 0 */</span>
<a name="l00661"></a>00661         <span class="keywordflow">if</span> (remain &gt;= 8)
<a name="l00662"></a>00662             mb = 0xFF;
<a name="l00663"></a>00663         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pc98_egc_shift_descend)
<a name="l00664"></a>00664             mb = 0xFF &lt;&lt; (uint8_t)(8 - remain); <span class="comment">/* 0x80 0xC0 0xE0 0xF0 ... */</span>
<a name="l00665"></a>00665         <span class="keywordflow">else</span>
<a name="l00666"></a>00666             mb = 0xFF &gt;&gt; (uint8_t)(8 - remain); <span class="comment">/* 0x01 0x03 0x07 0x0F ... */</span>
<a name="l00667"></a>00667 
<a name="l00668"></a>00668         <span class="comment">/* assume dstbit &lt; 8 */</span>
<a name="l00669"></a>00669         <span class="keywordflow">if</span> (!pc98_egc_shift_descend)
<a name="l00670"></a>00670             <span class="keywordflow">return</span> mb &gt;&gt; (uint8_t)dstbit; <span class="comment">/* 0xFF 0x7F 0x3F 0x1F ... */</span>
<a name="l00671"></a>00671         <span class="keywordflow">else</span>
<a name="l00672"></a>00672             <span class="keywordflow">return</span> mb &lt;&lt; (uint8_t)dstbit; <span class="comment">/* 0xFF 0xFE 0xFC 0xF8 ... */</span>
<a name="l00673"></a>00673     }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> output(AWT &amp;a,AWT &amp;b,AWT &amp;c,AWT &amp;d,uint8_t odd,<span class="keywordtype">bool</span> recursive=<span class="keyword">false</span>) {
<a name="l00676"></a>00676         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) == 2) {
<a name="l00677"></a>00677             <span class="keywordflow">if</span> (shft8load &lt; (16 - dstbit)) {
<a name="l00678"></a>00678                 *((AWT*)(pc98_egc_srcmask+odd)) = 0;
<a name="l00679"></a>00679                 <span class="keywordflow">return</span>;
<a name="l00680"></a>00680             }
<a name="l00681"></a>00681             shft8load -= (16 - dstbit);
<a name="l00682"></a>00682 
<a name="l00683"></a>00683             <span class="comment">/* assume odd == false and output is to even byte offset */</span>
<a name="l00684"></a>00684             <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00685"></a>00685                 output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[1],((uint8_t*)(&amp;b))[1],((uint8_t*)(&amp;c))[1],((uint8_t*)(&amp;d))[1],1,<span class="keyword">true</span>);
<a name="l00686"></a>00686                 <span class="keywordflow">if</span> (remain != 0) output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[0],((uint8_t*)(&amp;b))[0],((uint8_t*)(&amp;c))[0],((uint8_t*)(&amp;d))[0],0,<span class="keyword">true</span>);
<a name="l00687"></a>00687                 <span class="keywordflow">else</span> pc98_egc_srcmask[0] = 0;
<a name="l00688"></a>00688             }
<a name="l00689"></a>00689             <span class="keywordflow">else</span> {
<a name="l00690"></a>00690                 output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[0],((uint8_t*)(&amp;b))[0],((uint8_t*)(&amp;c))[0],((uint8_t*)(&amp;d))[0],0,<span class="keyword">true</span>);
<a name="l00691"></a>00691                 <span class="keywordflow">if</span> (remain != 0) output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[1],((uint8_t*)(&amp;b))[1],((uint8_t*)(&amp;c))[1],((uint8_t*)(&amp;d))[1],1,<span class="keyword">true</span>);
<a name="l00692"></a>00692                 <span class="keywordflow">else</span> pc98_egc_srcmask[1] = 0;
<a name="l00693"></a>00693             }
<a name="l00694"></a>00694 
<a name="l00695"></a>00695             <span class="keywordflow">if</span> (remain == 0)
<a name="l00696"></a>00696                 reinit();
<a name="l00697"></a>00697 
<a name="l00698"></a>00698             <span class="keywordflow">return</span>;
<a name="l00699"></a>00699         }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701         <span class="keywordflow">if</span> (!recursive) {
<a name="l00702"></a>00702             <span class="keywordflow">if</span> (shft8load &lt; (8 - dstbit)) {
<a name="l00703"></a>00703                 *((AWT*)(pc98_egc_srcmask+odd)) = 0;
<a name="l00704"></a>00704                 <span class="keywordflow">return</span>;
<a name="l00705"></a>00705             }
<a name="l00706"></a>00706             shft8load -= (8 - dstbit);
<a name="l00707"></a>00707         }
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         <span class="keywordflow">if</span> (dstbit &gt;= 8) {
<a name="l00710"></a>00710             dstbit -= 8;
<a name="l00711"></a>00711             *((AWT*)(pc98_egc_srcmask+odd)) = 0;
<a name="l00712"></a>00712             <span class="keywordflow">return</span>;
<a name="l00713"></a>00713         }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715         *((AWT*)(pc98_egc_srcmask+odd)) = dstbit_mask();
<a name="l00716"></a>00716 
<a name="l00717"></a>00717         <span class="keywordflow">if</span> (dstbit &gt; 0) {
<a name="l00718"></a>00718             <span class="keyword">const</span> uint8_t bc = 8 - dstbit;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720             <span class="keywordflow">if</span> (remain &gt;= bc)
<a name="l00721"></a>00721                 remain -= bc;
<a name="l00722"></a>00722             <span class="keywordflow">else</span>
<a name="l00723"></a>00723                 remain = 0;
<a name="l00724"></a>00724         }
<a name="l00725"></a>00725         <span class="keywordflow">else</span> {
<a name="l00726"></a>00726             <span class="keywordflow">if</span> (remain &gt;= 8)
<a name="l00727"></a>00727                 remain -= 8;
<a name="l00728"></a>00728             <span class="keywordflow">else</span>
<a name="l00729"></a>00729                 remain = 0;
<a name="l00730"></a>00730         }
<a name="l00731"></a>00731 
<a name="l00732"></a>00732         <span class="keywordflow">if</span> (o_srcbit &lt; o_dstbit) {
<a name="l00733"></a>00733             <span class="keywordflow">if</span> (dstbit != 0) {
<a name="l00734"></a>00734                 <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00735"></a>00735                     a = bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitr;
<a name="l00736"></a>00736                     b = bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitr;
<a name="l00737"></a>00737                     c = bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitr;
<a name="l00738"></a>00738                     d = bo&lt;AWT&gt;(12) &lt;&lt; shft8bitr;
<a name="l00739"></a>00739                 }
<a name="l00740"></a>00740                 <span class="keywordflow">else</span> {
<a name="l00741"></a>00741                     a = bo&lt;AWT&gt;( 0) &gt;&gt; shft8bitr;
<a name="l00742"></a>00742                     b = bo&lt;AWT&gt;( 4) &gt;&gt; shft8bitr;
<a name="l00743"></a>00743                     c = bo&lt;AWT&gt;( 8) &gt;&gt; shft8bitr;
<a name="l00744"></a>00744                     d = bo&lt;AWT&gt;(12) &gt;&gt; shft8bitr;
<a name="l00745"></a>00745                 }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747                 dstbit = 0;
<a name="l00748"></a>00748             }
<a name="l00749"></a>00749             <span class="keywordflow">else</span> {
<a name="l00750"></a>00750                 <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00751"></a>00751                     bo_adv&lt;AWT&gt;();
<a name="l00752"></a>00752                     a = (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitr);
<a name="l00753"></a>00753                     b = (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitr);
<a name="l00754"></a>00754                     c = (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitr);
<a name="l00755"></a>00755                     d = (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitr);
<a name="l00756"></a>00756                 }
<a name="l00757"></a>00757                 <span class="keywordflow">else</span> {
<a name="l00758"></a>00758                     a = (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitr);
<a name="l00759"></a>00759                     b = (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitr);
<a name="l00760"></a>00760                     c = (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitr);
<a name="l00761"></a>00761                     d = (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitr);
<a name="l00762"></a>00762                     bo_adv&lt;AWT&gt;();
<a name="l00763"></a>00763                 }
<a name="l00764"></a>00764             }
<a name="l00765"></a>00765         }
<a name="l00766"></a>00766         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (o_srcbit &gt; o_dstbit) {
<a name="l00767"></a>00767             dstbit = 0;
<a name="l00768"></a>00768 
<a name="l00769"></a>00769             <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00770"></a>00770                 bo_adv&lt;AWT&gt;();
<a name="l00771"></a>00771                 a = (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitr);
<a name="l00772"></a>00772                 b = (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitr);
<a name="l00773"></a>00773                 c = (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitr);
<a name="l00774"></a>00774                 d = (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitr);
<a name="l00775"></a>00775             }
<a name="l00776"></a>00776             <span class="keywordflow">else</span> {
<a name="l00777"></a>00777                 a = (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitr);
<a name="l00778"></a>00778                 b = (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitr);
<a name="l00779"></a>00779                 c = (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitr);
<a name="l00780"></a>00780                 d = (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitr);
<a name="l00781"></a>00781                 bo_adv&lt;AWT&gt;();
<a name="l00782"></a>00782             }
<a name="l00783"></a>00783         }
<a name="l00784"></a>00784         <span class="keywordflow">else</span> {
<a name="l00785"></a>00785             dstbit = 0;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787             a = bo&lt;AWT&gt;( 0);
<a name="l00788"></a>00788             b = bo&lt;AWT&gt;( 4);
<a name="l00789"></a>00789             c = bo&lt;AWT&gt;( 8);
<a name="l00790"></a>00790             d = bo&lt;AWT&gt;(12);
<a name="l00791"></a>00791             bo_adv&lt;AWT&gt;();
<a name="l00792"></a>00792         }
<a name="l00793"></a>00793 
<a name="l00794"></a>00794         <span class="keywordflow">if</span> (!recursive &amp;&amp; remain == 0)
<a name="l00795"></a>00795             reinit();
<a name="l00796"></a>00796     }
<a name="l00797"></a>00797 };
<a name="l00798"></a>00798 
<a name="l00799"></a>00799 egc_quad pc98_egc_src;
<a name="l00800"></a>00800 egc_quad pc98_egc_bgcm;
<a name="l00801"></a>00801 egc_quad pc98_egc_fgcm;
<a name="l00802"></a>00802 egc_quad pc98_egc_data;
<a name="l00803"></a>00803 egc_quad pc98_egc_last_vram;
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 <a class="code" href="structpc98__egc__shifter.html">pc98_egc_shifter</a> pc98_egc_shift;
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 <span class="keyword">typedef</span> egc_quad &amp; (*PC98_OPEFN)(uint8_t ope, <span class="keyword">const</span> PhysPt ad);
<a name="l00808"></a>00808 
<a name="l00809"></a>00809 <span class="keywordtype">void</span> pc98_egc_shift_reinit() {
<a name="l00810"></a>00810     pc98_egc_shift.reinit();
<a name="l00811"></a>00811 }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 <span class="keyword">static</span> egc_quad &amp;ope_xx(uint8_t ope, <span class="keyword">const</span> PhysPt ad) {
<a name="l00814"></a>00814     (void)ad;<span class="comment">//UNUSED</span>
<a name="l00815"></a>00815     LOG_MSG(<span class="stringliteral">&quot;EGC ROP 0x%2x not impl&quot;</span>,ope);
<a name="l00816"></a>00816     <span class="keywordflow">return</span> pc98_egc_last_vram;
<a name="l00817"></a>00817 }
<a name="l00818"></a>00818 
<a name="l00819"></a>00819 <span class="keyword">static</span> egc_quad &amp;ope_np(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00820"></a>00820         egc_quad dst;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822         dst[0].w = *((uint16_t*)(vga.mem.linear+vramoff+0x08000));
<a name="l00823"></a>00823         dst[1].w = *((uint16_t*)(vga.mem.linear+vramoff+0x10000));
<a name="l00824"></a>00824         dst[2].w = *((uint16_t*)(vga.mem.linear+vramoff+0x18000));
<a name="l00825"></a>00825         dst[3].w = *((uint16_t*)(vga.mem.linear+vramoff+0x20000));
<a name="l00826"></a>00826 
<a name="l00827"></a>00827         pc98_egc_data[0].w = 0;
<a name="l00828"></a>00828         pc98_egc_data[1].w = 0;
<a name="l00829"></a>00829         pc98_egc_data[2].w = 0;
<a name="l00830"></a>00830         pc98_egc_data[3].w = 0;
<a name="l00831"></a>00831 
<a name="l00832"></a>00832         <span class="keywordflow">if</span> (ope &amp; 0x80) {
<a name="l00833"></a>00833         pc98_egc_data[0].w |= (pc98_egc_src[0].w &amp; dst[0].w);
<a name="l00834"></a>00834         pc98_egc_data[1].w |= (pc98_egc_src[1].w &amp; dst[1].w);
<a name="l00835"></a>00835         pc98_egc_data[2].w |= (pc98_egc_src[2].w &amp; dst[2].w);
<a name="l00836"></a>00836         pc98_egc_data[3].w |= (pc98_egc_src[3].w &amp; dst[3].w);
<a name="l00837"></a>00837     }
<a name="l00838"></a>00838         <span class="keywordflow">if</span> (ope &amp; 0x20) {
<a name="l00839"></a>00839         pc98_egc_data[0].w |= (pc98_egc_src[0].w &amp; (~dst[0].w));
<a name="l00840"></a>00840         pc98_egc_data[1].w |= (pc98_egc_src[1].w &amp; (~dst[1].w));
<a name="l00841"></a>00841         pc98_egc_data[2].w |= (pc98_egc_src[2].w &amp; (~dst[2].w));
<a name="l00842"></a>00842         pc98_egc_data[3].w |= (pc98_egc_src[3].w &amp; (~dst[3].w));
<a name="l00843"></a>00843         }
<a name="l00844"></a>00844         <span class="keywordflow">if</span> (ope &amp; 0x08) {
<a name="l00845"></a>00845         pc98_egc_data[0].w |= ((~pc98_egc_src[0].w) &amp; dst[0].w);
<a name="l00846"></a>00846         pc98_egc_data[1].w |= ((~pc98_egc_src[1].w) &amp; dst[1].w);
<a name="l00847"></a>00847         pc98_egc_data[2].w |= ((~pc98_egc_src[2].w) &amp; dst[2].w);
<a name="l00848"></a>00848         pc98_egc_data[3].w |= ((~pc98_egc_src[3].w) &amp; dst[3].w);
<a name="l00849"></a>00849         }
<a name="l00850"></a>00850         <span class="keywordflow">if</span> (ope &amp; 0x02) {
<a name="l00851"></a>00851         pc98_egc_data[0].w |= ((~pc98_egc_src[0].w) &amp; (~dst[0].w));
<a name="l00852"></a>00852         pc98_egc_data[1].w |= ((~pc98_egc_src[1].w) &amp; (~dst[1].w));
<a name="l00853"></a>00853         pc98_egc_data[2].w |= ((~pc98_egc_src[2].w) &amp; (~dst[2].w));
<a name="l00854"></a>00854         pc98_egc_data[3].w |= ((~pc98_egc_src[3].w) &amp; (~dst[3].w));
<a name="l00855"></a>00855         }
<a name="l00856"></a>00856 
<a name="l00857"></a>00857         (void)ope;
<a name="l00858"></a>00858         (void)vramoff;
<a name="l00859"></a>00859         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l00860"></a>00860 }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862 <span class="keyword">static</span> egc_quad &amp;ope_c0(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00863"></a>00863         egc_quad dst;
<a name="l00864"></a>00864 
<a name="l00865"></a>00865     <span class="comment">/* assume: ad is word aligned */</span>
<a name="l00866"></a>00866 
<a name="l00867"></a>00867         dst[0].w = *((uint16_t*)(vga.mem.linear+vramoff+0x08000));
<a name="l00868"></a>00868         dst[1].w = *((uint16_t*)(vga.mem.linear+vramoff+0x10000));
<a name="l00869"></a>00869         dst[2].w = *((uint16_t*)(vga.mem.linear+vramoff+0x18000));
<a name="l00870"></a>00870         dst[3].w = *((uint16_t*)(vga.mem.linear+vramoff+0x20000));
<a name="l00871"></a>00871 
<a name="l00872"></a>00872         pc98_egc_data[0].w = pc98_egc_src[0].w &amp; dst[0].w;
<a name="l00873"></a>00873         pc98_egc_data[1].w = pc98_egc_src[1].w &amp; dst[1].w;
<a name="l00874"></a>00874         pc98_egc_data[2].w = pc98_egc_src[2].w &amp; dst[2].w;
<a name="l00875"></a>00875         pc98_egc_data[3].w = pc98_egc_src[3].w &amp; dst[3].w;
<a name="l00876"></a>00876 
<a name="l00877"></a>00877         (void)ope;
<a name="l00878"></a>00878         (void)vramoff;
<a name="l00879"></a>00879         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l00880"></a>00880 }
<a name="l00881"></a>00881 
<a name="l00882"></a>00882 <span class="keyword">static</span> egc_quad &amp;ope_f0(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00883"></a>00883         (void)ope;
<a name="l00884"></a>00884         (void)vramoff;
<a name="l00885"></a>00885         <span class="keywordflow">return</span> pc98_egc_src;
<a name="l00886"></a>00886 }
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 <span class="keyword">static</span> egc_quad &amp;ope_fc(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00889"></a>00889         egc_quad dst;
<a name="l00890"></a>00890 
<a name="l00891"></a>00891     <span class="comment">/* assume: ad is word aligned */</span>
<a name="l00892"></a>00892 
<a name="l00893"></a>00893         dst[0].w = *((uint16_t*)(vga.mem.linear+vramoff+0x08000));
<a name="l00894"></a>00894         dst[1].w = *((uint16_t*)(vga.mem.linear+vramoff+0x10000));
<a name="l00895"></a>00895         dst[2].w = *((uint16_t*)(vga.mem.linear+vramoff+0x18000));
<a name="l00896"></a>00896         dst[3].w = *((uint16_t*)(vga.mem.linear+vramoff+0x20000));
<a name="l00897"></a>00897 
<a name="l00898"></a>00898         pc98_egc_data[0].w  =    pc98_egc_src[0].w;
<a name="l00899"></a>00899         pc98_egc_data[0].w |= ((~pc98_egc_src[0].w) &amp; dst[0].w);
<a name="l00900"></a>00900         pc98_egc_data[1].w  =    pc98_egc_src[1].w;
<a name="l00901"></a>00901         pc98_egc_data[1].w |= ((~pc98_egc_src[1].w) &amp; dst[1].w);
<a name="l00902"></a>00902         pc98_egc_data[2].w  =    pc98_egc_src[2].w;
<a name="l00903"></a>00903         pc98_egc_data[2].w |= ((~pc98_egc_src[2].w) &amp; dst[2].w);
<a name="l00904"></a>00904         pc98_egc_data[3].w  =    pc98_egc_src[3].w;
<a name="l00905"></a>00905         pc98_egc_data[3].w |= ((~pc98_egc_src[3].w) &amp; dst[3].w);
<a name="l00906"></a>00906 
<a name="l00907"></a>00907         (void)ope;
<a name="l00908"></a>00908         (void)vramoff;
<a name="l00909"></a>00909         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l00910"></a>00910 }
<a name="l00911"></a>00911 
<a name="l00912"></a>00912 <span class="keyword">static</span> egc_quad &amp;ope_gg(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00913"></a>00913     egc_quad pat,dst;
<a name="l00914"></a>00914 
<a name="l00915"></a>00915         <span class="keywordflow">switch</span>(pc98_egc_fgc) {
<a name="l00916"></a>00916                 <span class="keywordflow">case</span> 1:
<a name="l00917"></a>00917                         pat[0].w = pc98_egc_bgcm[0].w;
<a name="l00918"></a>00918                         pat[1].w = pc98_egc_bgcm[1].w;
<a name="l00919"></a>00919                         pat[2].w = pc98_egc_bgcm[2].w;
<a name="l00920"></a>00920                         pat[3].w = pc98_egc_bgcm[3].w;
<a name="l00921"></a>00921                         <span class="keywordflow">break</span>;
<a name="l00922"></a>00922 
<a name="l00923"></a>00923                 <span class="keywordflow">case</span> 2:
<a name="l00924"></a>00924                         pat[0].w = pc98_egc_fgcm[0].w;
<a name="l00925"></a>00925                         pat[1].w = pc98_egc_fgcm[1].w;
<a name="l00926"></a>00926                         pat[2].w = pc98_egc_fgcm[2].w;
<a name="l00927"></a>00927                         pat[3].w = pc98_egc_fgcm[3].w;
<a name="l00928"></a>00928                         <span class="keywordflow">break</span>;
<a name="l00929"></a>00929 
<a name="l00930"></a>00930                 <span class="keywordflow">default</span>:
<a name="l00931"></a>00931                         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 1) {
<a name="l00932"></a>00932                                 pat[0].w = pc98_egc_src[0].w;
<a name="l00933"></a>00933                                 pat[1].w = pc98_egc_src[1].w;
<a name="l00934"></a>00934                                 pat[2].w = pc98_egc_src[2].w;
<a name="l00935"></a>00935                                 pat[3].w = pc98_egc_src[3].w;
<a name="l00936"></a>00936                         }
<a name="l00937"></a>00937                         <span class="keywordflow">else</span> {
<a name="l00938"></a>00938                                 pat[0].w = pc98_gdc_tiles[0].w;
<a name="l00939"></a>00939                                 pat[1].w = pc98_gdc_tiles[1].w;
<a name="l00940"></a>00940                                 pat[2].w = pc98_gdc_tiles[2].w;
<a name="l00941"></a>00941                                 pat[3].w = pc98_gdc_tiles[3].w;
<a name="l00942"></a>00942                         }
<a name="l00943"></a>00943                         <span class="keywordflow">break</span>;
<a name="l00944"></a>00944         }
<a name="l00945"></a>00945 
<a name="l00946"></a>00946         dst[0].w = *((uint16_t*)(vga.mem.linear+vramoff+0x08000));
<a name="l00947"></a>00947         dst[1].w = *((uint16_t*)(vga.mem.linear+vramoff+0x10000));
<a name="l00948"></a>00948         dst[2].w = *((uint16_t*)(vga.mem.linear+vramoff+0x18000));
<a name="l00949"></a>00949         dst[3].w = *((uint16_t*)(vga.mem.linear+vramoff+0x20000));
<a name="l00950"></a>00950 
<a name="l00951"></a>00951         pc98_egc_data[0].w = 0;
<a name="l00952"></a>00952         pc98_egc_data[1].w = 0;
<a name="l00953"></a>00953         pc98_egc_data[2].w = 0;
<a name="l00954"></a>00954         pc98_egc_data[3].w = 0;
<a name="l00955"></a>00955 
<a name="l00956"></a>00956         <span class="keywordflow">if</span> (ope &amp; 0x80) {
<a name="l00957"></a>00957                 pc98_egc_data[0].w |=  ( pat[0].w  &amp;   pc98_egc_src[0].w &amp;    dst[0].w);
<a name="l00958"></a>00958                 pc98_egc_data[1].w |=  ( pat[1].w  &amp;   pc98_egc_src[1].w &amp;    dst[1].w);
<a name="l00959"></a>00959                 pc98_egc_data[2].w |=  ( pat[2].w  &amp;   pc98_egc_src[2].w &amp;    dst[2].w);
<a name="l00960"></a>00960                 pc98_egc_data[3].w |=  ( pat[3].w  &amp;   pc98_egc_src[3].w &amp;    dst[3].w);
<a name="l00961"></a>00961         }
<a name="l00962"></a>00962         <span class="keywordflow">if</span> (ope &amp; 0x40) {
<a name="l00963"></a>00963                 pc98_egc_data[0].w |= ((~pat[0].w) &amp;   pc98_egc_src[0].w &amp;    dst[0].w);
<a name="l00964"></a>00964                 pc98_egc_data[1].w |= ((~pat[1].w) &amp;   pc98_egc_src[1].w &amp;    dst[1].w);
<a name="l00965"></a>00965                 pc98_egc_data[2].w |= ((~pat[2].w) &amp;   pc98_egc_src[2].w &amp;    dst[2].w);
<a name="l00966"></a>00966                 pc98_egc_data[3].w |= ((~pat[3].w) &amp;   pc98_egc_src[3].w &amp;    dst[3].w);
<a name="l00967"></a>00967         }
<a name="l00968"></a>00968         <span class="keywordflow">if</span> (ope &amp; 0x20) {
<a name="l00969"></a>00969                 pc98_egc_data[0].w |= (  pat[0].w  &amp;   pc98_egc_src[0].w &amp;  (~dst[0].w));
<a name="l00970"></a>00970                 pc98_egc_data[1].w |= (  pat[1].w  &amp;   pc98_egc_src[1].w &amp;  (~dst[1].w));
<a name="l00971"></a>00971                 pc98_egc_data[2].w |= (  pat[2].w  &amp;   pc98_egc_src[2].w &amp;  (~dst[2].w));
<a name="l00972"></a>00972                 pc98_egc_data[3].w |= (  pat[3].w  &amp;   pc98_egc_src[3].w &amp;  (~dst[3].w));
<a name="l00973"></a>00973         }
<a name="l00974"></a>00974         <span class="keywordflow">if</span> (ope &amp; 0x10) {
<a name="l00975"></a>00975                 pc98_egc_data[0].w |= ((~pat[0].w) &amp;   pc98_egc_src[0].w &amp;  (~dst[0].w));
<a name="l00976"></a>00976                 pc98_egc_data[1].w |= ((~pat[1].w) &amp;   pc98_egc_src[1].w &amp;  (~dst[1].w));
<a name="l00977"></a>00977                 pc98_egc_data[2].w |= ((~pat[2].w) &amp;   pc98_egc_src[2].w &amp;  (~dst[2].w));
<a name="l00978"></a>00978                 pc98_egc_data[3].w |= ((~pat[3].w) &amp;   pc98_egc_src[3].w &amp;  (~dst[3].w));
<a name="l00979"></a>00979         }
<a name="l00980"></a>00980         <span class="keywordflow">if</span> (ope &amp; 0x08) {
<a name="l00981"></a>00981                 pc98_egc_data[0].w |= (  pat[0].w  &amp; (~pc98_egc_src[0].w) &amp;   dst[0].w);
<a name="l00982"></a>00982                 pc98_egc_data[1].w |= (  pat[1].w  &amp; (~pc98_egc_src[1].w) &amp;   dst[1].w);
<a name="l00983"></a>00983                 pc98_egc_data[2].w |= (  pat[2].w  &amp; (~pc98_egc_src[2].w) &amp;   dst[2].w);
<a name="l00984"></a>00984                 pc98_egc_data[3].w |= (  pat[3].w  &amp; (~pc98_egc_src[3].w) &amp;   dst[3].w);
<a name="l00985"></a>00985         }
<a name="l00986"></a>00986         <span class="keywordflow">if</span> (ope &amp; 0x04) {
<a name="l00987"></a>00987                 pc98_egc_data[0].w |= ((~pat[0].w) &amp; (~pc98_egc_src[0].w) &amp;   dst[0].w);
<a name="l00988"></a>00988                 pc98_egc_data[1].w |= ((~pat[1].w) &amp; (~pc98_egc_src[1].w) &amp;   dst[1].w);
<a name="l00989"></a>00989                 pc98_egc_data[2].w |= ((~pat[2].w) &amp; (~pc98_egc_src[2].w) &amp;   dst[2].w);
<a name="l00990"></a>00990                 pc98_egc_data[3].w |= ((~pat[3].w) &amp; (~pc98_egc_src[3].w) &amp;   dst[3].w);
<a name="l00991"></a>00991         }
<a name="l00992"></a>00992         <span class="keywordflow">if</span> (ope &amp; 0x02) {
<a name="l00993"></a>00993                 pc98_egc_data[0].w |= (  pat[0].w  &amp; (~pc98_egc_src[0].w) &amp; (~dst[0].w));
<a name="l00994"></a>00994                 pc98_egc_data[1].w |= (  pat[1].w  &amp; (~pc98_egc_src[1].w) &amp; (~dst[1].w));
<a name="l00995"></a>00995                 pc98_egc_data[2].w |= (  pat[2].w  &amp; (~pc98_egc_src[2].w) &amp; (~dst[2].w));
<a name="l00996"></a>00996                 pc98_egc_data[3].w |= (  pat[3].w  &amp; (~pc98_egc_src[3].w) &amp; (~dst[3].w));
<a name="l00997"></a>00997         }
<a name="l00998"></a>00998         <span class="keywordflow">if</span> (ope &amp; 0x01) {
<a name="l00999"></a>00999                 pc98_egc_data[0].w |= ((~pat[0].w) &amp; (~pc98_egc_src[0].w) &amp; (~dst[0].w));
<a name="l01000"></a>01000                 pc98_egc_data[1].w |= ((~pat[1].w) &amp; (~pc98_egc_src[1].w) &amp; (~dst[1].w));
<a name="l01001"></a>01001                 pc98_egc_data[2].w |= ((~pat[2].w) &amp; (~pc98_egc_src[2].w) &amp; (~dst[2].w));
<a name="l01002"></a>01002                 pc98_egc_data[3].w |= ((~pat[3].w) &amp; (~pc98_egc_src[3].w) &amp; (~dst[3].w));
<a name="l01003"></a>01003         }
<a name="l01004"></a>01004 
<a name="l01005"></a>01005         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01006"></a>01006 }
<a name="l01007"></a>01007 
<a name="l01008"></a>01008 <span class="keyword">static</span> <span class="keyword">const</span> PC98_OPEFN pc98_egc_opfn[256] = {
<a name="l01009"></a>01009                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01010"></a>01010                         ope_xx, ope_xx, ope_xx, ope_xx, ope_np, ope_xx, ope_xx, ope_xx,
<a name="l01011"></a>01011                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01012"></a>01012                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01013"></a>01013                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01014"></a>01014                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01015"></a>01015                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01016"></a>01016                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01017"></a>01017                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01018"></a>01018                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01019"></a>01019                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01020"></a>01020                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01021"></a>01021                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01022"></a>01022                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01023"></a>01023                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01024"></a>01024                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01025"></a>01025                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01026"></a>01026                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01027"></a>01027                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01028"></a>01028                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01029"></a>01029                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01030"></a>01030                         ope_xx, ope_xx, ope_xx, ope_xx, ope_gg, ope_xx, ope_xx, ope_xx,
<a name="l01031"></a>01031                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01032"></a>01032                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01033"></a>01033                         ope_c0, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01034"></a>01034                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01035"></a>01035                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01036"></a>01036                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01037"></a>01037                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01038"></a>01038                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01039"></a>01039                         ope_f0, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01040"></a>01040                         ope_xx, ope_xx, ope_xx, ope_xx, ope_fc, ope_xx, ope_xx, ope_xx};
<a name="l01041"></a>01041 
<a name="l01042"></a>01042 <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> egc_quad &amp;egc_ope(<span class="keyword">const</span> PhysPt vramoff, <span class="keyword">const</span> AWT val) {
<a name="l01043"></a>01043     *((uint16_t*)pc98_egc_maskef) = *((uint16_t*)pc98_egc_mask);
<a name="l01044"></a>01044 
<a name="l01045"></a>01045     <span class="comment">/* 4A4h</span>
<a name="l01046"></a>01046 <span class="comment">     * bits [12:11] = light source</span>
<a name="l01047"></a>01047 <span class="comment">     *    11 = invalid</span>
<a name="l01048"></a>01048 <span class="comment">     *    10 = write the contents of the palette register</span>
<a name="l01049"></a>01049 <span class="comment">     *    01 = write the result of the raster operation</span>
<a name="l01050"></a>01050 <span class="comment">     *    00 = write CPU data</span>
<a name="l01051"></a>01051 <span class="comment">     *</span>
<a name="l01052"></a>01052 <span class="comment">     * 4A2h</span>
<a name="l01053"></a>01053 <span class="comment">     * bits [14:13] = foreground, background color</span>
<a name="l01054"></a>01054 <span class="comment">     *    11 = invalid</span>
<a name="l01055"></a>01055 <span class="comment">     *    10 = foreground color</span>
<a name="l01056"></a>01056 <span class="comment">     *    01 = background color</span>
<a name="l01057"></a>01057 <span class="comment">     *    00 = pattern register</span>
<a name="l01058"></a>01058 <span class="comment">     */</span>
<a name="l01059"></a>01059     <span class="keywordflow">switch</span> (pc98_egc_lightsource) {
<a name="l01060"></a>01060         <span class="keywordflow">case</span> 1: <span class="comment">/* 0x0800 */</span>
<a name="l01061"></a>01061             <span class="keywordflow">if</span> (pc98_egc_shiftinput) {
<a name="l01062"></a>01062                 pc98_egc_shift.input&lt;AWT&gt;(
<a name="l01063"></a>01063                     val,
<a name="l01064"></a>01064                     val,
<a name="l01065"></a>01065                     val,
<a name="l01066"></a>01066                     val,
<a name="l01067"></a>01067                     vramoff&amp;1);
<a name="l01068"></a>01068 
<a name="l01069"></a>01069                 pc98_egc_shift.output&lt;AWT&gt;(
<a name="l01070"></a>01070                     *((AWT*)(pc98_egc_src[0].b+(vramoff&amp;1))),
<a name="l01071"></a>01071                     *((AWT*)(pc98_egc_src[1].b+(vramoff&amp;1))),
<a name="l01072"></a>01072                     *((AWT*)(pc98_egc_src[2].b+(vramoff&amp;1))),
<a name="l01073"></a>01073                     *((AWT*)(pc98_egc_src[3].b+(vramoff&amp;1))),
<a name="l01074"></a>01074                     vramoff&amp;1);
<a name="l01075"></a>01075             }
<a name="l01076"></a>01076 
<a name="l01077"></a>01077             *((uint16_t*)pc98_egc_maskef) &amp;= *((uint16_t*)pc98_egc_srcmask);
<a name="l01078"></a>01078             <span class="keywordflow">return</span> pc98_egc_opfn[pc98_egc_rop](pc98_egc_rop, vramoff &amp; (~1U));
<a name="l01079"></a>01079         <span class="keywordflow">case</span> 2: <span class="comment">/* 0x1000 */</span>
<a name="l01080"></a>01080             <span class="keywordflow">if</span> (pc98_egc_fgc == 1)
<a name="l01081"></a>01081                 <span class="keywordflow">return</span> pc98_egc_bgcm;
<a name="l01082"></a>01082             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pc98_egc_fgc == 2)
<a name="l01083"></a>01083                 <span class="keywordflow">return</span> pc98_egc_fgcm;
<a name="l01084"></a>01084 
<a name="l01085"></a>01085             <span class="keywordflow">if</span> (pc98_egc_shiftinput) {
<a name="l01086"></a>01086                 pc98_egc_shift.input&lt;AWT&gt;(
<a name="l01087"></a>01087                     val,
<a name="l01088"></a>01088                     val,
<a name="l01089"></a>01089                     val,
<a name="l01090"></a>01090                     val,
<a name="l01091"></a>01091                     vramoff&amp;1);
<a name="l01092"></a>01092 
<a name="l01093"></a>01093                 pc98_egc_shift.output&lt;AWT&gt;(
<a name="l01094"></a>01094                     *((AWT*)(pc98_egc_src[0].b+(vramoff&amp;1))),
<a name="l01095"></a>01095                     *((AWT*)(pc98_egc_src[1].b+(vramoff&amp;1))),
<a name="l01096"></a>01096                     *((AWT*)(pc98_egc_src[2].b+(vramoff&amp;1))),
<a name="l01097"></a>01097                     *((AWT*)(pc98_egc_src[3].b+(vramoff&amp;1))),
<a name="l01098"></a>01098                     vramoff&amp;1);
<a name="l01099"></a>01099             }
<a name="l01100"></a>01100  
<a name="l01101"></a>01101             *((uint16_t*)pc98_egc_maskef) &amp;= *((uint16_t*)pc98_egc_srcmask);
<a name="l01102"></a>01102             <span class="keywordflow">return</span> pc98_egc_src;
<a name="l01103"></a>01103         <span class="keywordflow">default</span>: {
<a name="l01104"></a>01104             uint16_t tmp = (uint16_t)val;
<a name="l01105"></a>01105 
<a name="l01106"></a>01106             <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &lt; 2) {
<a name="l01107"></a>01107                 tmp &amp;= 0xFFU;
<a name="l01108"></a>01108                 tmp |= tmp &lt;&lt; 8U;
<a name="l01109"></a>01109             }
<a name="l01110"></a>01110 
<a name="l01111"></a>01111             pc98_egc_data[0].w = tmp;
<a name="l01112"></a>01112             pc98_egc_data[1].w = tmp;
<a name="l01113"></a>01113             pc98_egc_data[2].w = tmp;
<a name="l01114"></a>01114             pc98_egc_data[3].w = tmp;
<a name="l01115"></a>01115             } <span class="keywordflow">break</span>;
<a name="l01116"></a>01116     };
<a name="l01117"></a>01117 
<a name="l01118"></a>01118     <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01119"></a>01119 }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pc98_mem_msw_m[8] = {0};
<a name="l01122"></a>01122 
<a name="l01123"></a>01123 <span class="keywordtype">void</span> pc98_msw3_set_ramsize(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b) {
<a name="l01124"></a>01124     pc98_mem_msw_m[2<span class="comment">/*MSW3*/</span>] = b;
<a name="l01125"></a>01125 }
<a name="l01126"></a>01126 
<a name="l01127"></a>01127 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pc98_mem_msw(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> which) {
<a name="l01128"></a>01128     <span class="keywordflow">return</span> pc98_mem_msw_m[which&amp;7];
<a name="l01129"></a>01129 }
<a name="l01130"></a>01130 
<a name="l01131"></a>01131 <span class="comment">/* The NEC display is documented to have:</span>
<a name="l01132"></a>01132 <span class="comment"> *</span>
<a name="l01133"></a>01133 <span class="comment"> * A0000-A3FFF      T-RAM (text) (8KB WORDs)</span>
<a name="l01134"></a>01134 <span class="comment"> *   A0000-A1FFF      Characters (4KB WORDs)</span>
<a name="l01135"></a>01135 <span class="comment"> *   A2000-A3FFF      Attributes (4KB WORDs). For each 16-bit WORD only the lower 8 bits are read/writeable.</span>
<a name="l01136"></a>01136 <span class="comment"> *   A4000-A5FFF      Unknown ?? (4KB WORDs)</span>
<a name="l01137"></a>01137 <span class="comment"> *   A6000-A7FFF      Not present (4KB WORDs)</span>
<a name="l01138"></a>01138 <span class="comment"> * A8000-BFFFF      G-RAM (graphics) (96KB)</span>
<a name="l01139"></a>01139 <span class="comment"> *</span>
<a name="l01140"></a>01140 <span class="comment"> * T-RAM character display RAM is 16-bits per character.</span>
<a name="l01141"></a>01141 <span class="comment"> * ASCII text has upper 8 bits zero.</span>
<a name="l01142"></a>01142 <span class="comment"> * SHIFT-JIS doublewide characters use the upper byte for non-ASCII. */</span>
<a name="l01143"></a>01143 
<a name="l01144"></a><a class="code" href="classVGA__PC98__PageHandler.html">01144</a> <span class="keyword">class </span><a class="code" href="classVGA__PC98__PageHandler.html">VGA_PC98_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01145"></a>01145 <span class="keyword">public</span>:
<a name="l01146"></a>01146         <a class="code" href="classVGA__PC98__PageHandler.html">VGA_PC98_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01147"></a>01147     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> check_align(<span class="keyword">const</span> PhysPt addr) {
<a name="l01148"></a>01148         <span class="comment">/* DEBUG: address must be aligned to datatype.</span>
<a name="l01149"></a>01149 <span class="comment">         *        Code that calls us must enforce that or subdivide</span>
<a name="l01150"></a>01150 <span class="comment">         *        to a small datatype that can follow this rule. */</span>
<a name="l01151"></a>01151         PhysPt chk = (1UL &lt;&lt; (<span class="keyword">sizeof</span>(AWT) - 1)) - 1;
<a name="l01152"></a>01152         <span class="comment">/* uint8_t:  chk = 0</span>
<a name="l01153"></a>01153 <span class="comment">         * uint16_t: chk = 1</span>
<a name="l01154"></a>01154 <span class="comment">         * TODO: Do you suppose later generation PC-9821&#39;s supported DWORD size bitplane transfers?</span>
<a name="l01155"></a>01155 <span class="comment">         *       Or did NEC just give up on anything past 16-bit and focus on the SVGA side of things? */</span>
<a name="l01156"></a>01156         assert((addr&amp;chk) == 0);
<a name="l01157"></a>01157     }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> AWT mode8_r(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane,<span class="keyword">const</span> PhysPt vramoff) {
<a name="l01160"></a>01160         AWT r,b;
<a name="l01161"></a>01161 
<a name="l01162"></a>01162         b = *((AWT*)(vga.mem.linear + vramoff));
<a name="l01163"></a>01163         r = b ^ *((AWT*)pc98_gdc_tiles[plane].b);
<a name="l01164"></a>01164 
<a name="l01165"></a>01165         <span class="keywordflow">return</span> r;
<a name="l01166"></a>01166     }
<a name="l01167"></a>01167 
<a name="l01168"></a>01168     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> mode8_w(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane,<span class="keyword">const</span> PhysPt vramoff) {
<a name="l01169"></a>01169         <span class="comment">/* Neko Project II code suggests that the first byte is repeated. */</span>
<a name="l01170"></a>01170         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &gt; 1)
<a name="l01171"></a>01171             pc98_gdc_tiles[plane].b[1] = pc98_gdc_tiles[plane].b[0];
<a name="l01172"></a>01172 
<a name="l01173"></a>01173         *((AWT*)(vga.mem.linear + vramoff)) = *((AWT*)pc98_gdc_tiles[plane].b);
<a name="l01174"></a>01174     }
<a name="l01175"></a>01175 
<a name="l01176"></a>01176     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> modeC_w(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane,<span class="keyword">const</span> PhysPt vramoff,<span class="keyword">const</span> AWT mask,<span class="keyword">const</span> AWT val) {
<a name="l01177"></a>01177         AWT t;
<a name="l01178"></a>01178 
<a name="l01179"></a>01179         <span class="comment">/* Neko Project II code suggests that the first byte is repeated. */</span>
<a name="l01180"></a>01180         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &gt; 1)
<a name="l01181"></a>01181             pc98_gdc_tiles[plane].b[1] = pc98_gdc_tiles[plane].b[0];
<a name="l01182"></a>01182 
<a name="l01183"></a>01183         t  = *((AWT*)(vga.mem.linear + vramoff)) &amp; mask;
<a name="l01184"></a>01184         t |= val &amp; *((AWT*)pc98_gdc_tiles[plane].b);
<a name="l01185"></a>01185         *((AWT*)(vga.mem.linear + vramoff)) = t;
<a name="l01186"></a>01186     }
<a name="l01187"></a>01187 
<a name="l01188"></a>01188     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> AWT modeEGC_r(<span class="keyword">const</span> PhysPt vramoff,<span class="keyword">const</span> PhysPt fulloff) {
<a name="l01189"></a>01189         <span class="comment">/* assume: vramoff is even IF AWT is 16-bit wide */</span>
<a name="l01190"></a>01190         *((AWT*)(pc98_egc_last_vram[0].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x08000));
<a name="l01191"></a>01191         *((AWT*)(pc98_egc_last_vram[1].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x10000));
<a name="l01192"></a>01192         *((AWT*)(pc98_egc_last_vram[2].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x18000));
<a name="l01193"></a>01193         *((AWT*)(pc98_egc_last_vram[3].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x20000));
<a name="l01194"></a>01194 
<a name="l01195"></a>01195         <span class="comment">/* bits [10:10] = read source</span>
<a name="l01196"></a>01196 <span class="comment">         *    1 = shifter input is CPU write data</span>
<a name="l01197"></a>01197 <span class="comment">         *    0 = shifter input is VRAM data */</span>
<a name="l01198"></a>01198         <span class="comment">/* Neko Project II: if ((egc.ope &amp; 0x0400) == 0) ... */</span>
<a name="l01199"></a>01199         <span class="keywordflow">if</span> (!pc98_egc_shiftinput) {
<a name="l01200"></a>01200             pc98_egc_shift.input&lt;AWT&gt;(
<a name="l01201"></a>01201                 *((AWT*)(pc98_egc_last_vram[0].b+(vramoff&amp;1))),
<a name="l01202"></a>01202                 *((AWT*)(pc98_egc_last_vram[1].b+(vramoff&amp;1))),
<a name="l01203"></a>01203                 *((AWT*)(pc98_egc_last_vram[2].b+(vramoff&amp;1))),
<a name="l01204"></a>01204                 *((AWT*)(pc98_egc_last_vram[3].b+(vramoff&amp;1))),
<a name="l01205"></a>01205                 vramoff&amp;1);
<a name="l01206"></a>01206 
<a name="l01207"></a>01207             pc98_egc_shift.output&lt;AWT&gt;(
<a name="l01208"></a>01208                 *((AWT*)(pc98_egc_src[0].b+(vramoff&amp;1))),
<a name="l01209"></a>01209                 *((AWT*)(pc98_egc_src[1].b+(vramoff&amp;1))),
<a name="l01210"></a>01210                 *((AWT*)(pc98_egc_src[2].b+(vramoff&amp;1))),
<a name="l01211"></a>01211                 *((AWT*)(pc98_egc_src[3].b+(vramoff&amp;1))),
<a name="l01212"></a>01212                 vramoff&amp;1);
<a name="l01213"></a>01213         }
<a name="l01214"></a>01214 
<a name="l01215"></a>01215         <span class="comment">/* 0x4A4:</span>
<a name="l01216"></a>01216 <span class="comment">         * ...</span>
<a name="l01217"></a>01217 <span class="comment">         * bits [9:8] = register load (pc98_egc_regload[1:0])</span>
<a name="l01218"></a>01218 <span class="comment">         *    11 = invalid</span>
<a name="l01219"></a>01219 <span class="comment">         *    10 = load VRAM data before writing on VRAM write</span>
<a name="l01220"></a>01220 <span class="comment">         *    01 = load VRAM data into pattern/tile register on VRAM read</span>
<a name="l01221"></a>01221 <span class="comment">         *    00 = Do not change pattern/tile register</span>
<a name="l01222"></a>01222 <span class="comment">         * ...</span>
<a name="l01223"></a>01223 <span class="comment">         *</span>
<a name="l01224"></a>01224 <span class="comment">         * pc98_egc_regload = (val &gt;&gt; 8) &amp; 3;</span>
<a name="l01225"></a>01225 <span class="comment">         */</span>
<a name="l01226"></a>01226         <span class="comment">/* Neko Project II: if ((egc.ope &amp; 0x0300) == 0x0100) ... */</span>
<a name="l01227"></a>01227         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 1) { <span class="comment">/* load VRAM data into pattern/tile... (or INVALID) */</span>
<a name="l01228"></a>01228             *((AWT*)(pc98_gdc_tiles[0].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[0].b+(vramoff&amp;1)));
<a name="l01229"></a>01229             *((AWT*)(pc98_gdc_tiles[1].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[1].b+(vramoff&amp;1)));
<a name="l01230"></a>01230             *((AWT*)(pc98_gdc_tiles[2].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[2].b+(vramoff&amp;1)));
<a name="l01231"></a>01231             *((AWT*)(pc98_gdc_tiles[3].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[3].b+(vramoff&amp;1)));
<a name="l01232"></a>01232         }
<a name="l01233"></a>01233 
<a name="l01234"></a>01234         <span class="comment">/* 0x4A4:</span>
<a name="l01235"></a>01235 <span class="comment">         * bits [13:13] = 0=compare lead plane  1=don&#39;t</span>
<a name="l01236"></a>01236 <span class="comment">         *</span>
<a name="l01237"></a>01237 <span class="comment">         * bits [10:10] = read source</span>
<a name="l01238"></a>01238 <span class="comment">         *    1 = shifter input is CPU write data</span>
<a name="l01239"></a>01239 <span class="comment">         *    0 = shifter input is VRAM data */</span>
<a name="l01240"></a>01240         <span class="keywordflow">if</span> (pc98_egc_compare_lead) {
<a name="l01241"></a>01241             <span class="keywordflow">if</span> (!pc98_egc_shiftinput)
<a name="l01242"></a>01242                 <span class="keywordflow">return</span> *((AWT*)(pc98_egc_src[pc98_egc_lead_plane&amp;3].b));
<a name="l01243"></a>01243             <span class="keywordflow">else</span>
<a name="l01244"></a>01244                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+vramoff+0x08000+((pc98_egc_lead_plane&amp;3)*0x8000)));
<a name="l01245"></a>01245         }
<a name="l01246"></a>01246 
<a name="l01247"></a>01247         <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+fulloff));
<a name="l01248"></a>01248     }
<a name="l01249"></a>01249 
<a name="l01250"></a>01250     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> modeEGC_w(<span class="keyword">const</span> PhysPt vramoff,<span class="keyword">const</span> PhysPt fulloff,<span class="keyword">const</span> AWT val) {
<a name="l01251"></a>01251         (void)fulloff;<span class="comment">//UNUSED</span>
<a name="l01252"></a>01252 
<a name="l01253"></a>01253         <span class="comment">/* assume: vramoff is even IF AWT is 16-bit wide */</span>
<a name="l01254"></a>01254 
<a name="l01255"></a>01255         <span class="comment">/* 0x4A4:</span>
<a name="l01256"></a>01256 <span class="comment">         * ...</span>
<a name="l01257"></a>01257 <span class="comment">         * bits [9:8] = register load (pc98_egc_regload[1:0])</span>
<a name="l01258"></a>01258 <span class="comment">         *    11 = invalid</span>
<a name="l01259"></a>01259 <span class="comment">         *    10 = load VRAM data before writing on VRAM write</span>
<a name="l01260"></a>01260 <span class="comment">         *    01 = load VRAM data into pattern/tile register on VRAM read</span>
<a name="l01261"></a>01261 <span class="comment">         *    00 = Do not change pattern/tile register</span>
<a name="l01262"></a>01262 <span class="comment">         * ...</span>
<a name="l01263"></a>01263 <span class="comment">         * pc98_egc_regload = (val &gt;&gt; 8) &amp; 3;</span>
<a name="l01264"></a>01264 <span class="comment">         */</span>
<a name="l01265"></a>01265         <span class="comment">/* Neko Project II: if ((egc.ope &amp; 0x0300) == 0x0200) ... */</span>
<a name="l01266"></a>01266         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 2) { <span class="comment">/* load VRAM data before writing on VRAM write (or INVALID) */</span>
<a name="l01267"></a>01267             *((AWT*)(pc98_gdc_tiles[0].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x08000));
<a name="l01268"></a>01268             *((AWT*)(pc98_gdc_tiles[1].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x10000));
<a name="l01269"></a>01269             *((AWT*)(pc98_gdc_tiles[2].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x18000));
<a name="l01270"></a>01270             *((AWT*)(pc98_gdc_tiles[3].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x20000));
<a name="l01271"></a>01271         }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273         egc_quad &amp;ropdata = egc_ope&lt;AWT&gt;(vramoff, val);
<a name="l01274"></a>01274 
<a name="l01275"></a>01275         <span class="keyword">const</span> AWT accmask = *((AWT*)(pc98_egc_maskef+(vramoff&amp;1)));
<a name="l01276"></a>01276 
<a name="l01277"></a>01277         <span class="keywordflow">if</span> (accmask != 0) {
<a name="l01278"></a>01278             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 1)) {
<a name="l01279"></a>01279                 *((AWT*)(vga.mem.linear+vramoff+0x08000)) &amp;= ~accmask;
<a name="l01280"></a>01280                 *((AWT*)(vga.mem.linear+vramoff+0x08000)) |=  accmask &amp; *((AWT*)(ropdata[0].b+(vramoff&amp;1)));
<a name="l01281"></a>01281             }
<a name="l01282"></a>01282             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 2)) {
<a name="l01283"></a>01283                 *((AWT*)(vga.mem.linear+vramoff+0x10000)) &amp;= ~accmask;
<a name="l01284"></a>01284                 *((AWT*)(vga.mem.linear+vramoff+0x10000)) |=  accmask &amp; *((AWT*)(ropdata[1].b+(vramoff&amp;1)));
<a name="l01285"></a>01285             }
<a name="l01286"></a>01286             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 4)) {
<a name="l01287"></a>01287                 *((AWT*)(vga.mem.linear+vramoff+0x18000)) &amp;= ~accmask;
<a name="l01288"></a>01288                 *((AWT*)(vga.mem.linear+vramoff+0x18000)) |=  accmask &amp; *((AWT*)(ropdata[2].b+(vramoff&amp;1)));
<a name="l01289"></a>01289             }
<a name="l01290"></a>01290             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 8)) {
<a name="l01291"></a>01291                 *((AWT*)(vga.mem.linear+vramoff+0x20000)) &amp;= ~accmask;
<a name="l01292"></a>01292                 *((AWT*)(vga.mem.linear+vramoff+0x20000)) |=  accmask &amp; *((AWT*)(ropdata[3].b+(vramoff&amp;1)));
<a name="l01293"></a>01293             }
<a name="l01294"></a>01294         }
<a name="l01295"></a>01295     }
<a name="l01296"></a>01296 
<a name="l01297"></a>01297     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; AWT readc(PhysPt addr) {
<a name="l01298"></a>01298         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vop_offset = 0;
<a name="l01299"></a>01299 
<a name="l01300"></a>01300                 addr = PAGING_GetPhysicalAddress(addr);
<a name="l01301"></a>01301 
<a name="l01302"></a>01302         check_align&lt;AWT&gt;(addr);
<a name="l01303"></a>01303 
<a name="l01304"></a>01304         <span class="keywordflow">if</span> ((addr &amp; (~0x1F)) == 0xA3FE0) {
<a name="l01305"></a>01305             <span class="comment">/* </span>
<a name="l01306"></a>01306 <span class="comment">             * 0xA3FE2      MSW1</span>
<a name="l01307"></a>01307 <span class="comment">             * 0xA3FE6      MSW2</span>
<a name="l01308"></a>01308 <span class="comment">             * 0xA3FEA      MSW3</span>
<a name="l01309"></a>01309 <span class="comment">             * 0xA3FEE      MSW4</span>
<a name="l01310"></a>01310 <span class="comment">             * 0xA3FF2      MSW5</span>
<a name="l01311"></a>01311 <span class="comment">             * 0xA3FF6      MSW6</span>
<a name="l01312"></a>01312 <span class="comment">             * 0xA3FFA      MSW7</span>
<a name="l01313"></a>01313 <span class="comment">             * 0xA3FFE      MSW8</span>
<a name="l01314"></a>01314 <span class="comment">             */</span>
<a name="l01315"></a>01315             <span class="comment">// TODO: What does WORD-sized reading do? This returns a BYTE</span>
<a name="l01316"></a>01316             <span class="keywordflow">return</span> pc98_mem_msw((addr &gt;&gt; 2) &amp; 7);
<a name="l01317"></a>01317         }
<a name="l01318"></a>01318 
<a name="l01319"></a>01319         <span class="comment">/* 0xA4000-0xA401F is word-sized access to the character generator.</span>
<a name="l01320"></a>01320 <span class="comment">         *</span>
<a name="l01321"></a>01321 <span class="comment">         * Some games, though not many, appear to prefer this memory-mapped I/O</span>
<a name="l01322"></a>01322 <span class="comment">         * rather than the I/O ports.</span>
<a name="l01323"></a>01323 <span class="comment">         *</span>
<a name="l01324"></a>01324 <span class="comment">         * This fixes:</span>
<a name="l01325"></a>01325 <span class="comment">         *   - Eve Burst Error</span>
<a name="l01326"></a>01326 <span class="comment">         *</span>
<a name="l01327"></a>01327 <span class="comment">         * Also noted: Disassembling the CG functions of the BIOS on an actual</span>
<a name="l01328"></a>01328 <span class="comment">         *             PC9821 laptop reveals that the BIOS also uses this method,</span>
<a name="l01329"></a>01329 <span class="comment">         *             using REP MOVSW</span>
<a name="l01330"></a>01330 <span class="comment">         *</span>
<a name="l01331"></a>01331 <span class="comment">         * TODO: It&#39;s not clear if only 0xA4000-0xA401F is involved or if a wider</span>
<a name="l01332"></a>01332 <span class="comment">         *       range is involved (meaning that the hardware latches A4000-A5FFF</span>
<a name="l01333"></a>01333 <span class="comment">         *       to this function and then decodes only the low bits).</span>
<a name="l01334"></a>01334 <span class="comment">         *</span>
<a name="l01335"></a>01335 <span class="comment">         *       CHECK REAL HARDWARE to answer this question. */</span>
<a name="l01336"></a>01336         <span class="keywordflow">if</span> ((addr &amp; (~0x1F)) == 0xA4000) {
<a name="l01337"></a>01337             <span class="keyword">extern</span> uint16_t a1_font_load_addr;
<a name="l01338"></a>01338 
<a name="l01339"></a>01339             <span class="comment">// TODO: Does the memory address update the char offset value written to the I/O port version?</span>
<a name="l01340"></a>01340             <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &gt; 1) {
<a name="l01341"></a>01341                 <span class="keywordflow">return</span>
<a name="l01342"></a>01342                     (pc98_font_char_read(a1_font_load_addr,(addr &gt;&gt; 1) &amp; 0xF,0)      ) +
<a name="l01343"></a>01343                     (pc98_font_char_read(a1_font_load_addr,(addr &gt;&gt; 1) &amp; 0xF,1) &lt;&lt; 8u);
<a name="l01344"></a>01344             }
<a name="l01345"></a>01345             <span class="keywordflow">else</span> {
<a name="l01346"></a>01346                 <span class="keywordflow">return</span> pc98_font_char_read(a1_font_load_addr,(addr &gt;&gt; 1) &amp; 0xF,addr &amp; 1);
<a name="l01347"></a>01347             }
<a name="l01348"></a>01348         }
<a name="l01349"></a>01349 
<a name="l01350"></a>01350         <span class="keywordflow">if</span> (addr &gt;= 0xE0000) <span class="comment">/* the 4th bitplane (EGC 16-color mode) */</span>
<a name="l01351"></a>01351             addr = (addr &amp; 0x7FFF) + 0x20000;
<a name="l01352"></a>01352         <span class="keywordflow">else</span>
<a name="l01353"></a>01353             addr &amp;= 0x1FFFF;
<a name="l01354"></a>01354 
<a name="l01355"></a>01355         <span class="keywordflow">switch</span> (addr&gt;&gt;13) {
<a name="l01356"></a>01356             <span class="keywordflow">case</span> 0:     <span class="comment">/* A0000-A1FFF Character RAM */</span>
<a name="l01357"></a>01357                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr));
<a name="l01358"></a>01358             <span class="keywordflow">case</span> 1:     <span class="comment">/* A2000-A3FFF Attribute RAM */</span>
<a name="l01359"></a>01359                 <span class="keywordflow">if</span> (addr &amp; 1) <span class="keywordflow">return</span> (AWT)(~0ull); <span class="comment">/* ignore odd bytes */</span>
<a name="l01360"></a>01360                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr)) | 0xFF00; <span class="comment">/* odd bytes 0xFF */</span>
<a name="l01361"></a>01361             <span class="keywordflow">case</span> 2:     <span class="comment">/* A4000-A5FFF Unknown ?? */</span>
<a name="l01362"></a>01362                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr));
<a name="l01363"></a>01363             <span class="keywordflow">case</span> 3:     <span class="comment">/* A6000-A7FFF Not present */</span>
<a name="l01364"></a>01364                 <span class="keywordflow">return</span> (AWT)(~0ull);
<a name="l01365"></a>01365             <span class="keywordflow">default</span>:    <span class="comment">/* A8000-BFFFF G-RAM */</span>
<a name="l01366"></a>01366                 vop_offset = (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_ACCESS)) ? 0x20000 : 0;
<a name="l01367"></a>01367                 <span class="keywordflow">break</span>;
<a name="l01368"></a>01368         };
<a name="l01369"></a>01369 
<a name="l01370"></a>01370         <span class="keywordflow">switch</span> (pc98_gdc_vramop &amp; 0xF) {
<a name="l01371"></a>01371             <span class="keywordflow">case</span> 0x00:
<a name="l01372"></a>01372             <span class="keywordflow">case</span> 0x01:
<a name="l01373"></a>01373             <span class="keywordflow">case</span> 0x02:
<a name="l01374"></a>01374             <span class="keywordflow">case</span> 0x03:
<a name="l01375"></a>01375             <span class="keywordflow">case</span> 0x04:
<a name="l01376"></a>01376             <span class="keywordflow">case</span> 0x05:
<a name="l01377"></a>01377             <span class="keywordflow">case</span> 0x06:
<a name="l01378"></a>01378             <span class="keywordflow">case</span> 0x07:
<a name="l01379"></a>01379                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr+vop_offset));
<a name="l01380"></a>01380             <span class="keywordflow">case</span> 0x08: <span class="comment">/* TCR/TDW */</span>
<a name="l01381"></a>01381             <span class="keywordflow">case</span> 0x09:
<a name="l01382"></a>01382                 {
<a name="l01383"></a>01383                     AWT r = 0;
<a name="l01384"></a>01384 
<a name="l01385"></a>01385                     <span class="comment">/* this reads multiple bitplanes at once */</span>
<a name="l01386"></a>01386                     addr &amp;= 0x7FFF;
<a name="l01387"></a>01387 
<a name="l01388"></a>01388                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 1)) <span class="comment">// blue channel</span>
<a name="l01389"></a>01389                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>0,addr + 0x8000 + vop_offset);
<a name="l01390"></a>01390 
<a name="l01391"></a>01391                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 2)) <span class="comment">// red channel</span>
<a name="l01392"></a>01392                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>1,addr + 0x10000 + vop_offset);
<a name="l01393"></a>01393 
<a name="l01394"></a>01394                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 4)) <span class="comment">// green channel</span>
<a name="l01395"></a>01395                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>2,addr + 0x18000 + vop_offset);
<a name="l01396"></a>01396 
<a name="l01397"></a>01397                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 8)) <span class="comment">// extended channel</span>
<a name="l01398"></a>01398                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>3,addr + 0x20000 + vop_offset);
<a name="l01399"></a>01399 
<a name="l01400"></a>01400                     <span class="comment">/* NTS: Apparently returning this value correctly really matters to the</span>
<a name="l01401"></a>01401 <span class="comment">                     *      sprite engine in &quot;Edge&quot;, else visual errors occur. */</span>
<a name="l01402"></a>01402                     <span class="keywordflow">return</span> ~r;
<a name="l01403"></a>01403                 }
<a name="l01404"></a>01404             <span class="keywordflow">case</span> 0x0C:
<a name="l01405"></a>01405             <span class="keywordflow">case</span> 0x0D:
<a name="l01406"></a>01406                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr+vop_offset));
<a name="l01407"></a>01407             <span class="keywordflow">case</span> 0x0A: <span class="comment">/* EGC read */</span>
<a name="l01408"></a>01408             <span class="keywordflow">case</span> 0x0B:
<a name="l01409"></a>01409             <span class="keywordflow">case</span> 0x0E:
<a name="l01410"></a>01410             <span class="keywordflow">case</span> 0x0F:
<a name="l01411"></a>01411                 <span class="comment">/* this reads multiple bitplanes at once */</span>
<a name="l01412"></a>01412                 <span class="keywordflow">return</span> modeEGC_r&lt;AWT&gt;((addr&amp;0x7FFF) + vop_offset,addr + vop_offset);
<a name="l01413"></a>01413             <span class="keywordflow">default</span>: <span class="comment">/* should not happen */</span>
<a name="l01414"></a>01414                 LOG_MSG(<span class="stringliteral">&quot;PC-98 VRAM read warning: Unsupported opmode 0x%X&quot;</span>,pc98_gdc_vramop);
<a name="l01415"></a>01415                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr+vop_offset));
<a name="l01416"></a>01416         };
<a name="l01417"></a>01417 
<a name="l01418"></a>01418                 <span class="keywordflow">return</span> (AWT)(~0ull);
<a name="l01419"></a>01419         }
<a name="l01420"></a>01420 
<a name="l01421"></a>01421         <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keywordtype">void</span> writec(PhysPt addr,AWT val){
<a name="l01422"></a>01422         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vop_offset = 0;
<a name="l01423"></a>01423 
<a name="l01424"></a>01424                 addr = PAGING_GetPhysicalAddress(addr);
<a name="l01425"></a>01425 
<a name="l01426"></a>01426         check_align&lt;AWT&gt;(addr);
<a name="l01427"></a>01427 
<a name="l01428"></a>01428         <span class="keywordflow">if</span> ((addr &amp; (~0x1F)) == 0xA3FE0)
<a name="l01429"></a>01429             <span class="keywordflow">return</span>;
<a name="l01430"></a>01430 
<a name="l01431"></a>01431         <span class="keywordflow">if</span> (addr &gt;= 0xE0000) <span class="comment">/* the 4th bitplane (EGC 16-color mode) */</span>
<a name="l01432"></a>01432             addr = (addr &amp; 0x7FFF) + 0x20000;
<a name="l01433"></a>01433         <span class="keywordflow">else</span>
<a name="l01434"></a>01434             addr &amp;= 0x1FFFF;
<a name="l01435"></a>01435 
<a name="l01436"></a>01436         <span class="comment">/* 0xA4000-0xA401F is word-sized access to the character generator.</span>
<a name="l01437"></a>01437 <span class="comment">         *</span>
<a name="l01438"></a>01438 <span class="comment">         * Some games, though not many, appear to prefer this memory-mapped I/O</span>
<a name="l01439"></a>01439 <span class="comment">         * rather than the I/O ports.</span>
<a name="l01440"></a>01440 <span class="comment">         *</span>
<a name="l01441"></a>01441 <span class="comment">         * This fixes:</span>
<a name="l01442"></a>01442 <span class="comment">         *   - Eve Burst Error</span>
<a name="l01443"></a>01443 <span class="comment">         *</span>
<a name="l01444"></a>01444 <span class="comment">         * Also noted: Disassembling the CG functions of the BIOS on an actual</span>
<a name="l01445"></a>01445 <span class="comment">         *             PC9821 laptop reveals that the BIOS also uses this method,</span>
<a name="l01446"></a>01446 <span class="comment">         *             using REP MOVSW</span>
<a name="l01447"></a>01447 <span class="comment">         *</span>
<a name="l01448"></a>01448 <span class="comment">         * TODO: It&#39;s not clear if only 0xA4000-0xA401F is involved or if a wider</span>
<a name="l01449"></a>01449 <span class="comment">         *       range is involved (meaning that the hardware latches A4000-A5FFF</span>
<a name="l01450"></a>01450 <span class="comment">         *       to this function and then decodes only the low bits).</span>
<a name="l01451"></a>01451 <span class="comment">         *</span>
<a name="l01452"></a>01452 <span class="comment">         *       CHECK REAL HARDWARE to answer this question. */</span>
<a name="l01453"></a>01453         <span class="keywordflow">if</span> ((addr &amp; (~0x1F)) == 0xA4000) {
<a name="l01454"></a>01454             <span class="keyword">extern</span> uint16_t a1_font_load_addr;
<a name="l01455"></a>01455 
<a name="l01456"></a>01456             <span class="comment">// TODO: Does the memory address update the char offset value written to the I/O port version?</span>
<a name="l01457"></a>01457             <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &gt; 1) {
<a name="l01458"></a>01458                 <span class="comment">// FIXME: Untested</span>
<a name="l01459"></a>01459                 pc98_font_char_write(a1_font_load_addr,(addr &gt;&gt; 1) &amp; 0xF,0,val);
<a name="l01460"></a>01460                 pc98_font_char_write(a1_font_load_addr,(addr &gt;&gt; 1) &amp; 0xF,1,val &gt;&gt; 8);
<a name="l01461"></a>01461             }
<a name="l01462"></a>01462             <span class="keywordflow">else</span> {
<a name="l01463"></a>01463                 pc98_font_char_write(a1_font_load_addr,(addr &gt;&gt; 1) &amp; 0xF,addr &amp; 1,val);
<a name="l01464"></a>01464             }
<a name="l01465"></a>01465 
<a name="l01466"></a>01466             <span class="keywordflow">return</span>;
<a name="l01467"></a>01467         }
<a name="l01468"></a>01468 
<a name="l01469"></a>01469         <span class="keywordflow">switch</span> (addr&gt;&gt;13) {
<a name="l01470"></a>01470             <span class="keywordflow">case</span> 0:     <span class="comment">/* A0000-A1FFF Character RAM */</span>
<a name="l01471"></a>01471                 *((AWT*)(vga.mem.linear+addr)) = val;
<a name="l01472"></a>01472                 <span class="keywordflow">return</span>;
<a name="l01473"></a>01473             <span class="keywordflow">case</span> 1:     <span class="comment">/* A2000-A3FFF Attribute RAM */</span>
<a name="l01474"></a>01474                 <span class="keywordflow">if</span> (addr &amp; 1) <span class="keywordflow">return</span>; <span class="comment">/* ignore odd bytes */</span>
<a name="l01475"></a>01475                 *((AWT*)(vga.mem.linear+addr)) = val | 0xFF00;
<a name="l01476"></a>01476                 <span class="keywordflow">return</span>;
<a name="l01477"></a>01477             <span class="keywordflow">case</span> 2:     <span class="comment">/* A4000-A5FFF Unknown ?? */</span>
<a name="l01478"></a>01478                 *((AWT*)(vga.mem.linear+addr)) = val;
<a name="l01479"></a>01479                 <span class="keywordflow">return</span>;
<a name="l01480"></a>01480             <span class="keywordflow">case</span> 3:     <span class="comment">/* A6000-A7FFF Not present */</span>
<a name="l01481"></a>01481                 <span class="keywordflow">return</span>;
<a name="l01482"></a>01482             <span class="keywordflow">default</span>:    <span class="comment">/* A8000-BFFFF G-RAM */</span>
<a name="l01483"></a>01483                 vop_offset = (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_ACCESS)) ? 0x20000 : 0;
<a name="l01484"></a>01484                 <span class="keywordflow">break</span>;
<a name="l01485"></a>01485         };
<a name="l01486"></a>01486 
<a name="l01487"></a>01487         <span class="keywordflow">switch</span> (pc98_gdc_vramop &amp; 0xF) {
<a name="l01488"></a>01488             <span class="keywordflow">case</span> 0x00:
<a name="l01489"></a>01489             <span class="keywordflow">case</span> 0x01:
<a name="l01490"></a>01490             <span class="keywordflow">case</span> 0x02:
<a name="l01491"></a>01491             <span class="keywordflow">case</span> 0x03:
<a name="l01492"></a>01492             <span class="keywordflow">case</span> 0x04:
<a name="l01493"></a>01493             <span class="keywordflow">case</span> 0x05:
<a name="l01494"></a>01494             <span class="keywordflow">case</span> 0x06:
<a name="l01495"></a>01495             <span class="keywordflow">case</span> 0x07:
<a name="l01496"></a>01496                 *((AWT*)(vga.mem.linear+addr+vop_offset)) = val;
<a name="l01497"></a>01497                 <span class="keywordflow">break</span>;
<a name="l01498"></a>01498             <span class="keywordflow">case</span> 0x08:  <span class="comment">/* TCR/TDW write tile data, no masking */</span>
<a name="l01499"></a>01499             <span class="keywordflow">case</span> 0x09:
<a name="l01500"></a>01500                 {
<a name="l01501"></a>01501                     <span class="comment">/* this writes to multiple bitplanes at once.</span>
<a name="l01502"></a>01502 <span class="comment">                     * notice that the value written has no meaning, only the tile data and memory address. */</span>
<a name="l01503"></a>01503                     addr &amp;= 0x7FFF;
<a name="l01504"></a>01504 
<a name="l01505"></a>01505                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 1)) <span class="comment">// blue channel</span>
<a name="l01506"></a>01506                         mode8_w&lt;AWT&gt;(0<span class="comment">/*plane*/</span>,addr + 0x8000 + vop_offset);
<a name="l01507"></a>01507 
<a name="l01508"></a>01508                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 2)) <span class="comment">// red channel</span>
<a name="l01509"></a>01509                         mode8_w&lt;AWT&gt;(1<span class="comment">/*plane*/</span>,addr + 0x10000 + vop_offset);
<a name="l01510"></a>01510 
<a name="l01511"></a>01511                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 4)) <span class="comment">// green channel</span>
<a name="l01512"></a>01512                         mode8_w&lt;AWT&gt;(2<span class="comment">/*plane*/</span>,addr + 0x18000 + vop_offset);
<a name="l01513"></a>01513 
<a name="l01514"></a>01514                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 8)) <span class="comment">// extended channel</span>
<a name="l01515"></a>01515                         mode8_w&lt;AWT&gt;(3<span class="comment">/*plane*/</span>,addr + 0x20000 + vop_offset);
<a name="l01516"></a>01516                 }
<a name="l01517"></a>01517                 <span class="keywordflow">break</span>;
<a name="l01518"></a>01518             <span class="keywordflow">case</span> 0x0C:  <span class="comment">/* read/modify/write from tile with masking */</span>
<a name="l01519"></a>01519             <span class="keywordflow">case</span> 0x0D:  <span class="comment">/* a lot of PC-98 games seem to rely on this for sprite rendering */</span>
<a name="l01520"></a>01520                 {
<a name="l01521"></a>01521                     <span class="keyword">const</span> AWT mask = ~val;
<a name="l01522"></a>01522 
<a name="l01523"></a>01523                     <span class="comment">/* this writes to multiple bitplanes at once */</span>
<a name="l01524"></a>01524                     addr &amp;= 0x7FFF;
<a name="l01525"></a>01525 
<a name="l01526"></a>01526                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 1)) <span class="comment">// blue channel</span>
<a name="l01527"></a>01527                         modeC_w&lt;AWT&gt;(0<span class="comment">/*plane*/</span>,addr + 0x8000 + vop_offset,mask,val);
<a name="l01528"></a>01528 
<a name="l01529"></a>01529                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 2)) <span class="comment">// red channel</span>
<a name="l01530"></a>01530                         modeC_w&lt;AWT&gt;(1<span class="comment">/*plane*/</span>,addr + 0x10000 + vop_offset,mask,val);
<a name="l01531"></a>01531 
<a name="l01532"></a>01532                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 4)) <span class="comment">// green channel</span>
<a name="l01533"></a>01533                         modeC_w&lt;AWT&gt;(2<span class="comment">/*plane*/</span>,addr + 0x18000 + vop_offset,mask,val);
<a name="l01534"></a>01534 
<a name="l01535"></a>01535                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 8)) <span class="comment">// extended channel</span>
<a name="l01536"></a>01536                         modeC_w&lt;AWT&gt;(3<span class="comment">/*plane*/</span>,addr + 0x20000 + vop_offset,mask,val);
<a name="l01537"></a>01537                 }
<a name="l01538"></a>01538                 <span class="keywordflow">break</span>;
<a name="l01539"></a>01539             <span class="keywordflow">case</span> 0x0A: <span class="comment">/* EGC write */</span>
<a name="l01540"></a>01540             <span class="keywordflow">case</span> 0x0B:
<a name="l01541"></a>01541             <span class="keywordflow">case</span> 0x0E:
<a name="l01542"></a>01542             <span class="keywordflow">case</span> 0x0F:
<a name="l01543"></a>01543                 <span class="comment">/* this reads multiple bitplanes at once */</span>
<a name="l01544"></a>01544                 modeEGC_w&lt;AWT&gt;((addr&amp;0x7FFF) + vop_offset,addr + vop_offset,val);
<a name="l01545"></a>01545                 <span class="keywordflow">break</span>;
<a name="l01546"></a>01546             <span class="keywordflow">default</span>: <span class="comment">/* Should no longer happen */</span>
<a name="l01547"></a>01547                 LOG_MSG(<span class="stringliteral">&quot;PC-98 VRAM write warning: Unsupported opmode 0x%X&quot;</span>,pc98_gdc_vramop);
<a name="l01548"></a>01548                 *((AWT*)(vga.mem.linear+addr+vop_offset)) = val;
<a name="l01549"></a>01549                 <span class="keywordflow">break</span>;
<a name="l01550"></a>01550         };
<a name="l01551"></a>01551         }
<a name="l01552"></a>01552 
<a name="l01553"></a>01553     <span class="comment">/* byte-wise */</span>
<a name="l01554"></a>01554         Bitu readb(PhysPt addr) {
<a name="l01555"></a>01555         <span class="keywordflow">return</span> readc&lt;uint8_t&gt;(addr);
<a name="l01556"></a>01556     }
<a name="l01557"></a>01557         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l01558"></a>01558         writec&lt;uint8_t&gt;(addr,(uint8_t)val);
<a name="l01559"></a>01559     }
<a name="l01560"></a>01560 
<a name="l01561"></a>01561     <span class="comment">/* word-wise.</span>
<a name="l01562"></a>01562 <span class="comment">     * in the style of the 8086, non-word-aligned I/O is split into byte I/O */</span>
<a name="l01563"></a>01563         Bitu readw(PhysPt addr) {
<a name="l01564"></a>01564         <span class="keywordflow">if</span> (!(addr &amp; 1)) <span class="comment">/* if WORD aligned */</span>
<a name="l01565"></a>01565             <span class="keywordflow">return</span> readc&lt;uint16_t&gt;(addr);
<a name="l01566"></a>01566         <span class="keywordflow">else</span> {
<a name="l01567"></a>01567             <span class="keywordflow">return</span>   (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)readc&lt;uint8_t&gt;(addr+0U) +
<a name="l01568"></a>01568                     ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)readc&lt;uint8_t&gt;(addr+1U) &lt;&lt; 8u);
<a name="l01569"></a>01569         }
<a name="l01570"></a>01570     }
<a name="l01571"></a>01571         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l01572"></a>01572         <span class="keywordflow">if</span> (!(addr &amp; 1)) <span class="comment">/* if WORD aligned */</span>
<a name="l01573"></a>01573             writec&lt;uint16_t&gt;(addr,(uint16_t)val);
<a name="l01574"></a>01574         <span class="keywordflow">else</span> {
<a name="l01575"></a>01575             writec&lt;uint8_t&gt;(addr+0,(uint8_t)val);
<a name="l01576"></a>01576             writec&lt;uint8_t&gt;(addr+1,(uint8_t)(val &gt;&gt; 8U));
<a name="l01577"></a>01577         }
<a name="l01578"></a>01578     }
<a name="l01579"></a>01579 };
<a name="l01580"></a>01580 
<a name="l01581"></a><a class="code" href="classVGA__Map__Handler.html">01581</a> <span class="keyword">class </span><a class="code" href="classVGA__Map__Handler.html">VGA_Map_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01582"></a>01582 <span class="keyword">public</span>:
<a name="l01583"></a>01583         <a class="code" href="classVGA__Map__Handler.html">VGA_Map_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE|PFLAG_NOCODE) {}
<a name="l01584"></a>01584         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01585"></a>01585                 phys_page-=vgapages.base;
<a name="l01586"></a>01586                 <span class="keywordflow">return</span> &amp;vga.mem.linear[CHECKED3(vga.svga.bank_read_full+phys_page*4096)];
<a name="l01587"></a>01587         }
<a name="l01588"></a>01588         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01589"></a>01589                 phys_page-=vgapages.base;
<a name="l01590"></a>01590                 <span class="keywordflow">return</span> &amp;vga.mem.linear[CHECKED3(vga.svga.bank_write_full+phys_page*4096)];
<a name="l01591"></a>01591         }
<a name="l01592"></a>01592 };
<a name="l01593"></a>01593 
<a name="l01594"></a><a class="code" href="classVGA__Slow__CGA__Handler.html">01594</a> <span class="keyword">class </span><a class="code" href="classVGA__Slow__CGA__Handler.html">VGA_Slow_CGA_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01595"></a>01595 <span class="keyword">public</span>:
<a name="l01596"></a>01596         <a class="code" href="classVGA__Slow__CGA__Handler.html">VGA_Slow_CGA_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01597"></a>01597         <span class="keywordtype">void</span> delay() {
<a name="l01598"></a>01598                 Bits delaycyc = CPU_CycleMax/((Bit32u)(1024/2.80)); 
<a name="l01599"></a>01599                 <span class="keywordflow">if</span>(GCC_UNLIKELY(CPU_Cycles &lt; 3*delaycyc)) delaycyc=0;
<a name="l01600"></a>01600                 CPU_Cycles -= delaycyc;
<a name="l01601"></a>01601                 CPU_IODelayRemoved += delaycyc;
<a name="l01602"></a>01602         }
<a name="l01603"></a>01603 
<a name="l01604"></a>01604         Bitu readb(PhysPt addr) {
<a name="l01605"></a>01605                 delay();
<a name="l01606"></a>01606                 <span class="keywordflow">return</span> vga.tandy.mem_base[addr - 0xb8000];
<a name="l01607"></a>01607         }
<a name="l01608"></a>01608         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val){
<a name="l01609"></a>01609                 delay();
<a name="l01610"></a>01610                 vga.tandy.mem_base[addr - 0xb8000] = (Bit8u) val;
<a name="l01611"></a>01611         }
<a name="l01612"></a>01612         
<a name="l01613"></a>01613 };
<a name="l01614"></a>01614 
<a name="l01615"></a><a class="code" href="classVGA__LFB__Handler.html">01615</a> <span class="keyword">class </span><a class="code" href="classVGA__LFB__Handler.html">VGA_LFB_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01616"></a>01616 <span class="keyword">public</span>:
<a name="l01617"></a>01617         <a class="code" href="classVGA__LFB__Handler.html">VGA_LFB_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE|PFLAG_NOCODE) {}
<a name="l01618"></a>01618         HostPt GetHostReadPt( Bitu phys_page ) {
<a name="l01619"></a>01619                 phys_page -= vga.lfb.page;
<a name="l01620"></a>01620                 phys_page &amp;= (vga.mem.memsize &gt;&gt; 12) - 1;
<a name="l01621"></a>01621                 <span class="keywordflow">return</span> &amp;vga.mem.linear[CHECKED3(phys_page * 4096)];
<a name="l01622"></a>01622         }
<a name="l01623"></a>01623         HostPt GetHostWritePt( Bitu phys_page ) {
<a name="l01624"></a>01624                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01625"></a>01625         }
<a name="l01626"></a>01626 };
<a name="l01627"></a>01627 
<a name="l01628"></a>01628 <span class="keyword">extern</span> <span class="keywordtype">void</span> XGA_Write(Bitu port, Bitu val, Bitu len);
<a name="l01629"></a>01629 <span class="keyword">extern</span> Bitu XGA_Read(Bitu port, Bitu len);
<a name="l01630"></a>01630 
<a name="l01631"></a><a class="code" href="classVGA__MMIO__Handler.html">01631</a> <span class="keyword">class </span><a class="code" href="classVGA__MMIO__Handler.html">VGA_MMIO_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01632"></a>01632 <span class="keyword">public</span>:
<a name="l01633"></a>01633         <a class="code" href="classVGA__MMIO__Handler.html">VGA_MMIO_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01634"></a>01634         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l01635"></a>01635                 VGAMEM_USEC_write_delay();
<a name="l01636"></a>01636                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01637"></a>01637                 XGA_Write(port, val, 1);
<a name="l01638"></a>01638         }
<a name="l01639"></a>01639         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l01640"></a>01640                 VGAMEM_USEC_write_delay();
<a name="l01641"></a>01641                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01642"></a>01642                 XGA_Write(port, val, 2);
<a name="l01643"></a>01643         }
<a name="l01644"></a>01644         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l01645"></a>01645                 VGAMEM_USEC_write_delay();
<a name="l01646"></a>01646                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01647"></a>01647                 XGA_Write(port, val, 4);
<a name="l01648"></a>01648         }
<a name="l01649"></a>01649 
<a name="l01650"></a>01650         Bitu readb(PhysPt addr) {
<a name="l01651"></a>01651                 VGAMEM_USEC_read_delay();
<a name="l01652"></a>01652                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01653"></a>01653                 <span class="keywordflow">return</span> XGA_Read(port, 1);
<a name="l01654"></a>01654         }
<a name="l01655"></a>01655         Bitu readw(PhysPt addr) {
<a name="l01656"></a>01656                 VGAMEM_USEC_read_delay();
<a name="l01657"></a>01657                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01658"></a>01658                 <span class="keywordflow">return</span> XGA_Read(port, 2);
<a name="l01659"></a>01659         }
<a name="l01660"></a>01660         Bitu readd(PhysPt addr) {
<a name="l01661"></a>01661                 VGAMEM_USEC_read_delay();
<a name="l01662"></a>01662                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01663"></a>01663                 <span class="keywordflow">return</span> XGA_Read(port, 4);
<a name="l01664"></a>01664         }
<a name="l01665"></a>01665 };
<a name="l01666"></a>01666 
<a name="l01667"></a><a class="code" href="classVGA__TANDY__PageHandler.html">01667</a> <span class="keyword">class </span><a class="code" href="classVGA__TANDY__PageHandler.html">VGA_TANDY_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01668"></a>01668 <span class="keyword">public</span>:
<a name="l01669"></a>01669         <a class="code" href="classVGA__TANDY__PageHandler.html">VGA_TANDY_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE) {}
<a name="l01670"></a>01670         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01671"></a>01671                 <span class="comment">// Odd banks are limited to 16kB and repeated</span>
<a name="l01672"></a>01672                 <span class="keywordflow">if</span> (vga.tandy.mem_bank &amp; 1) 
<a name="l01673"></a>01673                         phys_page&amp;=0x03;
<a name="l01674"></a>01674                 <span class="keywordflow">else</span> 
<a name="l01675"></a>01675                         phys_page&amp;=0x07;
<a name="l01676"></a>01676                 <span class="keywordflow">return</span> vga.tandy.mem_base + (phys_page * 4096);
<a name="l01677"></a>01677         }
<a name="l01678"></a>01678         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01679"></a>01679                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01680"></a>01680         }
<a name="l01681"></a>01681 };
<a name="l01682"></a>01682 
<a name="l01683"></a>01683 
<a name="l01684"></a><a class="code" href="classVGA__PCJR__Handler.html">01684</a> <span class="keyword">class </span><a class="code" href="classVGA__PCJR__Handler.html">VGA_PCJR_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01685"></a>01685 <span class="keyword">public</span>:
<a name="l01686"></a>01686         <a class="code" href="classVGA__PCJR__Handler.html">VGA_PCJR_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE) {}
<a name="l01687"></a>01687         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01688"></a>01688                 phys_page-=0xb8;
<a name="l01689"></a>01689                 <span class="comment">// The 16kB map area is repeated in the 32kB range</span>
<a name="l01690"></a>01690                 <span class="comment">// On CGA CPU A14 is not decoded so it repeats there too</span>
<a name="l01691"></a>01691                 phys_page&amp;=0x03;
<a name="l01692"></a>01692                 <span class="keywordflow">return</span> vga.tandy.mem_base + (phys_page * 4096);
<a name="l01693"></a>01693         }
<a name="l01694"></a>01694         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01695"></a>01695                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01696"></a>01696         }
<a name="l01697"></a>01697 };
<a name="l01698"></a>01698 
<a name="l01699"></a><a class="code" href="classVGA__AMS__Handler.html">01699</a> <span class="keyword">class </span><a class="code" href="classVGA__AMS__Handler.html">VGA_AMS_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01700"></a>01700 <span class="keyword">public</span>:
<a name="l01701"></a>01701         <span class="keyword">template</span>&lt; <span class="keywordtype">bool</span> wrapping&gt;
<a name="l01702"></a>01702         <span class="keywordtype">void</span> writeHandler(PhysPt start, Bit8u val) {
<a name="l01703"></a>01703                 vga.tandy.mem_base[ start ] = val;
<a name="l01704"></a>01704 <span class="preprocessor">#ifdef DIJDIJD</span>
<a name="l01705"></a>01705 <span class="preprocessor"></span>                Bit32u data=ModeOperation(val);
<a name="l01706"></a>01706                 <span class="comment">/* Update video memory and the pixel buffer */</span>
<a name="l01707"></a>01707                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> pixels;
<a name="l01708"></a>01708                 pixels.d=((Bit32u*)vga.mem.linear)[start];
<a name="l01709"></a>01709                 pixels.d&amp;=vga.config.full_not_map_mask;
<a name="l01710"></a>01710                 pixels.d|=(data &amp; vga.config.full_map_mask);
<a name="l01711"></a>01711                 ((Bit32u*)vga.mem.linear)[start]=pixels.d;
<a name="l01712"></a>01712                 Bit8u * write_pixels=&amp;vga.mem.linear[VGA_CACHE_OFFSET+(start&lt;&lt;3)];
<a name="l01713"></a>01713 
<a name="l01714"></a>01714                 Bit32u colors0_3, colors4_7;
<a name="l01715"></a>01715                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> temp;temp.d=(pixels.d&gt;&gt;4) &amp; 0x0f0f0f0f;
<a name="l01716"></a>01716                         colors0_3 = 
<a name="l01717"></a>01717                         Expand16Table[0][temp.b[0]] |
<a name="l01718"></a>01718                         Expand16Table[1][temp.b[1]] |
<a name="l01719"></a>01719                         Expand16Table[2][temp.b[2]] |
<a name="l01720"></a>01720                         Expand16Table[3][temp.b[3]];
<a name="l01721"></a>01721                 *(Bit32u *)write_pixels=colors0_3;
<a name="l01722"></a>01722                 temp.d=pixels.d &amp; 0x0f0f0f0f;
<a name="l01723"></a>01723                 colors4_7 = 
<a name="l01724"></a>01724                         Expand16Table[0][temp.b[0]] |
<a name="l01725"></a>01725                         Expand16Table[1][temp.b[1]] |
<a name="l01726"></a>01726                         Expand16Table[2][temp.b[2]] |
<a name="l01727"></a>01727                         Expand16Table[3][temp.b[3]];
<a name="l01728"></a>01728                 *(Bit32u *)(write_pixels+4)=colors4_7;
<a name="l01729"></a>01729                 <span class="keywordflow">if</span> (wrapping &amp;&amp; GCC_UNLIKELY( start &lt; 512)) {
<a name="l01730"></a>01730                         *(Bit32u *)(write_pixels+512*1024)=colors0_3;
<a name="l01731"></a>01731                         *(Bit32u *)(write_pixels+512*1024+4)=colors4_7;
<a name="l01732"></a>01732                 }
<a name="l01733"></a>01733 <span class="preprocessor">#endif</span>
<a name="l01734"></a>01734 <span class="preprocessor"></span>        }
<a name="l01735"></a>01735 <span class="comment">//      template&lt; bool wrapping&gt;</span>
<a name="l01736"></a>01736         Bit8u readHandler(PhysPt start) {
<a name="l01737"></a>01737                 <span class="keywordflow">return</span> vga.tandy.mem_base[ start ];
<a name="l01738"></a>01738         }
<a name="l01739"></a>01739 
<a name="l01740"></a>01740 <span class="keyword">public</span>:
<a name="l01741"></a>01741         <a class="code" href="classVGA__AMS__Handler.html">VGA_AMS_Handler</a>() {
<a name="l01742"></a>01742                 <span class="comment">//flags=PFLAG_READABLE|PFLAG_WRITEABLE;</span>
<a name="l01743"></a>01743                 flags=PFLAG_NOCODE;
<a name="l01744"></a>01744         }
<a name="l01745"></a>01745         <span class="keyword">inline</span> PhysPt wrAddr( PhysPt addr )
<a name="l01746"></a>01746         {
<a name="l01747"></a>01747                 <span class="keywordflow">if</span>( vga.mode != M_AMSTRAD )
<a name="l01748"></a>01748                 {
<a name="l01749"></a>01749                         addr -= 0xb8000;
<a name="l01750"></a>01750                         Bitu phys_page = addr &gt;&gt; 12;
<a name="l01751"></a>01751                         <span class="comment">//test for a unaliged bank, then replicate 2x16kb</span>
<a name="l01752"></a>01752                         <span class="keywordflow">if</span> (vga.tandy.mem_bank &amp; 1) 
<a name="l01753"></a>01753                                 phys_page&amp;=0x03;
<a name="l01754"></a>01754                         <span class="keywordflow">return</span> ( phys_page * 4096 ) + ( addr &amp; 0x0FFF );
<a name="l01755"></a>01755                 }
<a name="l01756"></a>01756                 <span class="keywordflow">return</span> ( (PAGING_GetPhysicalAddress(addr) &amp; 0xffff) - 0x8000 ) &amp; ( 32*1024-1 );
<a name="l01757"></a>01757         }
<a name="l01758"></a>01758 
<a name="l01759"></a>01759         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l01760"></a>01760                 VGAMEM_USEC_write_delay();
<a name="l01761"></a>01761                 addr = wrAddr( addr );
<a name="l01762"></a>01762                 Bitu plane = vga.mode==M_AMSTRAD ? vga.amstrad.write_plane : 0x01; <span class="comment">// 0x0F?</span>
<a name="l01763"></a>01763                 <span class="keywordflow">if</span>( plane &amp; 0x08 ) writeHandler&lt;false&gt;(addr+49152,(Bit8u)(val &gt;&gt; 0));
<a name="l01764"></a>01764                 <span class="keywordflow">if</span>( plane &amp; 0x04 ) writeHandler&lt;false&gt;(addr+32768,(Bit8u)(val &gt;&gt; 0));
<a name="l01765"></a>01765                 <span class="keywordflow">if</span>( plane &amp; 0x02 ) writeHandler&lt;false&gt;(addr+16384,(Bit8u)(val &gt;&gt; 0));
<a name="l01766"></a>01766                 <span class="keywordflow">if</span>( plane &amp; 0x01 ) writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01767"></a>01767         }
<a name="l01768"></a>01768         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l01769"></a>01769                 VGAMEM_USEC_write_delay();
<a name="l01770"></a>01770                 addr = wrAddr( addr );
<a name="l01771"></a>01771                 Bitu plane = vga.mode==M_AMSTRAD ? vga.amstrad.write_plane : 0x01; <span class="comment">// 0x0F?</span>
<a name="l01772"></a>01772                 <span class="keywordflow">if</span>( plane &amp; 0x01 )
<a name="l01773"></a>01773                 {
<a name="l01774"></a>01774                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01775"></a>01775                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01776"></a>01776                 }
<a name="l01777"></a>01777                 addr += 16384;
<a name="l01778"></a>01778                 <span class="keywordflow">if</span>( plane &amp; 0x02 )
<a name="l01779"></a>01779                 {
<a name="l01780"></a>01780                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01781"></a>01781                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01782"></a>01782                 }
<a name="l01783"></a>01783                 addr += 16384;
<a name="l01784"></a>01784                 <span class="keywordflow">if</span>( plane &amp; 0x04 )
<a name="l01785"></a>01785                 {
<a name="l01786"></a>01786                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01787"></a>01787                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01788"></a>01788                 }
<a name="l01789"></a>01789                 addr += 16384;
<a name="l01790"></a>01790                 <span class="keywordflow">if</span>( plane &amp; 0x08 )
<a name="l01791"></a>01791                 {
<a name="l01792"></a>01792                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01793"></a>01793                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01794"></a>01794                 }
<a name="l01795"></a>01795 
<a name="l01796"></a>01796         }
<a name="l01797"></a>01797         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l01798"></a>01798                 VGAMEM_USEC_write_delay();
<a name="l01799"></a>01799                 addr = wrAddr( addr );
<a name="l01800"></a>01800                 Bitu plane = vga.mode==M_AMSTRAD ? vga.amstrad.write_plane : 0x01; <span class="comment">// 0x0F?</span>
<a name="l01801"></a>01801                 <span class="keywordflow">if</span>( plane &amp; 0x01 )
<a name="l01802"></a>01802                 {
<a name="l01803"></a>01803                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01804"></a>01804                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01805"></a>01805                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l01806"></a>01806                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l01807"></a>01807                 }
<a name="l01808"></a>01808                 addr += 16384;
<a name="l01809"></a>01809                 <span class="keywordflow">if</span>( plane &amp; 0x02 )
<a name="l01810"></a>01810                 {
<a name="l01811"></a>01811                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01812"></a>01812                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01813"></a>01813                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l01814"></a>01814                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l01815"></a>01815                 }
<a name="l01816"></a>01816                 addr += 16384;
<a name="l01817"></a>01817                 <span class="keywordflow">if</span>( plane &amp; 0x04 )
<a name="l01818"></a>01818                 {
<a name="l01819"></a>01819                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01820"></a>01820                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01821"></a>01821                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l01822"></a>01822                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l01823"></a>01823                 }
<a name="l01824"></a>01824                 addr += 16384;
<a name="l01825"></a>01825                 <span class="keywordflow">if</span>( plane &amp; 0x08 )
<a name="l01826"></a>01826                 {
<a name="l01827"></a>01827                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01828"></a>01828                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01829"></a>01829                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l01830"></a>01830                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l01831"></a>01831                 }
<a name="l01832"></a>01832 
<a name="l01833"></a>01833         }
<a name="l01834"></a>01834         Bitu readb(PhysPt addr) {
<a name="l01835"></a>01835                 VGAMEM_USEC_read_delay();
<a name="l01836"></a>01836                 addr = wrAddr( addr ) + ( vga.amstrad.read_plane * 16384u );
<a name="l01837"></a>01837                 addr &amp;= (64u*1024u-1u);
<a name="l01838"></a>01838                 <span class="keywordflow">return</span> readHandler(addr);
<a name="l01839"></a>01839         }
<a name="l01840"></a>01840         Bitu readw(PhysPt addr) {
<a name="l01841"></a>01841                 VGAMEM_USEC_read_delay();
<a name="l01842"></a>01842                 addr = wrAddr( addr ) + ( vga.amstrad.read_plane * 16384u );
<a name="l01843"></a>01843                 addr &amp;= (64u*1024u-1u);
<a name="l01844"></a>01844                 <span class="keywordflow">return</span> 
<a name="l01845"></a>01845                         ((Bitu)readHandler(addr+0) &lt;&lt; 0u) |
<a name="l01846"></a>01846                         ((Bitu)readHandler(addr+1) &lt;&lt; 8u);
<a name="l01847"></a>01847         }
<a name="l01848"></a>01848         Bitu readd(PhysPt addr) {
<a name="l01849"></a>01849                 VGAMEM_USEC_read_delay();
<a name="l01850"></a>01850                 addr = wrAddr( addr ) + ( vga.amstrad.read_plane * 16384u );
<a name="l01851"></a>01851                 addr &amp;= (64u*1024u-1u);
<a name="l01852"></a>01852                 <span class="keywordflow">return</span> 
<a name="l01853"></a>01853                         ((Bitu)readHandler(addr+0) &lt;&lt; 0u)  |
<a name="l01854"></a>01854                         ((Bitu)readHandler(addr+1) &lt;&lt; 8u)  |
<a name="l01855"></a>01855                         ((Bitu)readHandler(addr+2) &lt;&lt; 16u) |
<a name="l01856"></a>01856                         ((Bitu)readHandler(addr+3) &lt;&lt; 24u);
<a name="l01857"></a>01857         }
<a name="l01858"></a>01858 
<a name="l01859"></a>01859 <span class="comment">/*</span>
<a name="l01860"></a>01860 <span class="comment">        HostPt GetHostReadPt(Bitu phys_page)</span>
<a name="l01861"></a>01861 <span class="comment">        {</span>
<a name="l01862"></a>01862 <span class="comment">                if( vga.mode!=M_AMSTRAD )</span>
<a name="l01863"></a>01863 <span class="comment">                {</span>
<a name="l01864"></a>01864 <span class="comment">                        phys_page-=0xb8;</span>
<a name="l01865"></a>01865 <span class="comment">                        //test for a unaliged bank, then replicate 2x16kb</span>
<a name="l01866"></a>01866 <span class="comment">                        if (vga.tandy.mem_bank &amp; 1) </span>
<a name="l01867"></a>01867 <span class="comment">                                phys_page&amp;=0x03;</span>
<a name="l01868"></a>01868 <span class="comment">                        return vga.tandy.mem_base + (phys_page * 4096);</span>
<a name="l01869"></a>01869 <span class="comment">                }</span>
<a name="l01870"></a>01870 <span class="comment">                phys_page-=0xb8;</span>
<a name="l01871"></a>01871 <span class="comment">                return vga.tandy.mem_base + (phys_page*4096) + (vga.amstrad.read_plane * 16384) ;</span>
<a name="l01872"></a>01872 <span class="comment">        }</span>
<a name="l01873"></a>01873 <span class="comment">*/</span>
<a name="l01874"></a>01874 <span class="comment">/*</span>
<a name="l01875"></a>01875 <span class="comment">        HostPt GetHostWritePt(Bitu phys_page) {</span>
<a name="l01876"></a>01876 <span class="comment">                return GetHostReadPt( phys_page );</span>
<a name="l01877"></a>01877 <span class="comment">        }</span>
<a name="l01878"></a>01878 <span class="comment">*/</span>
<a name="l01879"></a>01879 };
<a name="l01880"></a>01880 
<a name="l01881"></a><a class="code" href="classVGA__HERC__Handler.html">01881</a> <span class="keyword">class </span><a class="code" href="classVGA__HERC__Handler.html">VGA_HERC_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01882"></a>01882 <span class="keyword">public</span>:
<a name="l01883"></a>01883         <a class="code" href="classVGA__HERC__Handler.html">VGA_HERC_Handler</a>() {
<a name="l01884"></a>01884                 flags=PFLAG_READABLE|PFLAG_WRITEABLE;
<a name="l01885"></a>01885         }
<a name="l01886"></a>01886         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01887"></a>01887         (void)phys_page;<span class="comment">//UNUSED</span>
<a name="l01888"></a>01888                 <span class="comment">// The 4kB map area is repeated in the 32kB range</span>
<a name="l01889"></a>01889                 <span class="keywordflow">return</span> &amp;vga.mem.linear[0];
<a name="l01890"></a>01890         }
<a name="l01891"></a>01891         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01892"></a>01892                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01893"></a>01893         }
<a name="l01894"></a>01894 };
<a name="l01895"></a>01895 
<a name="l01896"></a><a class="code" href="classVGA__Empty__Handler.html">01896</a> <span class="keyword">class </span><a class="code" href="classVGA__Empty__Handler.html">VGA_Empty_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01897"></a>01897 <span class="keyword">public</span>:
<a name="l01898"></a>01898         <a class="code" href="classVGA__Empty__Handler.html">VGA_Empty_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01899"></a>01899         Bitu readb(PhysPt <span class="comment">/*addr*/</span>) {
<a name="l01900"></a>01900 <span class="comment">//              LOG(LOG_VGA, LOG_NORMAL ) ( &quot;Read from empty memory space at %x&quot;, addr );</span>
<a name="l01901"></a>01901                 <span class="keywordflow">return</span> 0xff;
<a name="l01902"></a>01902         } 
<a name="l01903"></a>01903         <span class="keywordtype">void</span> writeb(PhysPt <span class="comment">/*addr*/</span>,Bitu <span class="comment">/*val*/</span>) {
<a name="l01904"></a>01904 <span class="comment">//              LOG(LOG_VGA, LOG_NORMAL ) ( &quot;Write %x to empty memory space at %x&quot;, val, addr );</span>
<a name="l01905"></a>01905         }
<a name="l01906"></a>01906 };
<a name="l01907"></a>01907 
<a name="l01908"></a>01908 <span class="keyword">static</span> <span class="keyword">struct </span>vg {
<a name="l01909"></a>01909         <a class="code" href="classVGA__Map__Handler.html">VGA_Map_Handler</a>                         map;
<a name="l01910"></a>01910         <a class="code" href="classVGA__Slow__CGA__Handler.html">VGA_Slow_CGA_Handler</a>            slow;
<a name="l01911"></a>01911 <span class="comment">//      VGA_TEXT_PageHandler            text;</span>
<a name="l01912"></a>01912         <a class="code" href="classVGA__CGATEXT__PageHandler.html">VGA_CGATEXT_PageHandler</a>         cgatext;
<a name="l01913"></a>01913         <a class="code" href="classVGA__MCGATEXT__PageHandler.html">VGA_MCGATEXT_PageHandler</a>        mcgatext;
<a name="l01914"></a>01914         <a class="code" href="classVGA__TANDY__PageHandler.html">VGA_TANDY_PageHandler</a>           tandy;
<a name="l01915"></a>01915 <span class="comment">//      VGA_ChainedEGA_Handler          cega;</span>
<a name="l01916"></a>01916 <span class="comment">//      VGA_ChainedVGA_Handler          cvga;</span>
<a name="l01917"></a>01917         <a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">VGA_ChainedVGA_Slow_Handler</a>     cvga_slow;
<a name="l01918"></a>01918 <span class="comment">//      VGA_ET4000_ChainedVGA_Handler           cvga_et4000;</span>
<a name="l01919"></a>01919         <a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">VGA_ET4000_ChainedVGA_Slow_Handler</a>      cvga_et4000_slow;
<a name="l01920"></a>01920 <span class="comment">//      VGA_UnchainedEGA_Handler        uega;</span>
<a name="l01921"></a>01921         <a class="code" href="classVGA__UnchainedVGA__Handler.html">VGA_UnchainedVGA_Handler</a>        uvga;
<a name="l01922"></a>01922         <a class="code" href="classVGA__PCJR__Handler.html">VGA_PCJR_Handler</a>                        pcjr;
<a name="l01923"></a>01923         <a class="code" href="classVGA__HERC__Handler.html">VGA_HERC_Handler</a>                        herc;
<a name="l01924"></a>01924 <span class="comment">//      VGA_LIN4_Handler                        lin4;</span>
<a name="l01925"></a>01925         <a class="code" href="classVGA__LFB__Handler.html">VGA_LFB_Handler</a>                         lfb;
<a name="l01926"></a>01926         <a class="code" href="classVGA__MMIO__Handler.html">VGA_MMIO_Handler</a>                        mmio;
<a name="l01927"></a>01927         <a class="code" href="classVGA__AMS__Handler.html">VGA_AMS_Handler</a>                         ams;
<a name="l01928"></a>01928     <a class="code" href="classVGA__PC98__PageHandler.html">VGA_PC98_PageHandler</a>        pc98;
<a name="l01929"></a>01929         <a class="code" href="classVGA__Empty__Handler.html">VGA_Empty_Handler</a>                       empty;
<a name="l01930"></a>01930 } vgaph;
<a name="l01931"></a>01931 
<a name="l01932"></a>01932 <span class="keywordtype">void</span> VGA_ChangedBank(<span class="keywordtype">void</span>) {
<a name="l01933"></a>01933         VGA_SetupHandlers();
<a name="l01934"></a>01934 }
<a name="l01935"></a>01935 
<a name="l01936"></a>01936 <span class="keywordtype">void</span> MEM_ResetPageHandler_Unmapped(Bitu phys_page, Bitu pages);
<a name="l01937"></a>01937 <span class="keywordtype">void</span> MEM_ResetPageHandler_RAM(Bitu phys_page, Bitu pages);
<a name="l01938"></a>01938 
<a name="l01939"></a>01939 <span class="keywordtype">void</span> VGA_SetupHandlers(<span class="keywordtype">void</span>) {
<a name="l01940"></a>01940         vga.svga.bank_read_full = vga.svga.bank_read*vga.svga.bank_size;
<a name="l01941"></a>01941         vga.svga.bank_write_full = vga.svga.bank_write*vga.svga.bank_size;
<a name="l01942"></a>01942 
<a name="l01943"></a>01943         <a class="code" href="classPageHandler.html">PageHandler</a> *newHandler;
<a name="l01944"></a>01944         <span class="keywordflow">switch</span> (machine) {
<a name="l01945"></a>01945         <span class="keywordflow">case</span> MCH_CGA:
<a name="l01946"></a>01946                 <span class="keywordflow">if</span> (enableCGASnow &amp;&amp; (vga.mode == M_TEXT || vga.mode == M_TANDY_TEXT))
<a name="l01947"></a>01947                         MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.cgatext );
<a name="l01948"></a>01948                 <span class="keywordflow">else</span>
<a name="l01949"></a>01949                         MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.slow );
<a name="l01950"></a>01950                 <span class="keywordflow">goto</span> range_done;
<a name="l01951"></a>01951         <span class="keywordflow">case</span> MCH_MCGA:<span class="comment">//Based on real hardware, A0000-BFFFF is the 64KB of RAM mapped twice</span>
<a name="l01952"></a>01952                 MEM_SetPageHandler( VGA_PAGE_A0, 16, &amp;vgaph.mcgatext );     <span class="comment">// A0000-AFFFF is the 64KB of video RAM</span>
<a name="l01953"></a>01953         MEM_ResetPageHandler_Unmapped( VGA_PAGE_B0, 8 );            <span class="comment">// B0000-B7FFF is unmapped</span>
<a name="l01954"></a>01954                 MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.mcgatext );      <span class="comment">// B8000-BFFFF is the last 32KB half of video RAM, alias</span>
<a name="l01955"></a>01955                 <span class="keywordflow">goto</span> range_done;
<a name="l01956"></a>01956         <span class="keywordflow">case</span> MCH_PCJR:
<a name="l01957"></a>01957                 MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.pcjr );
<a name="l01958"></a>01958                 <span class="keywordflow">goto</span> range_done;
<a name="l01959"></a>01959         <span class="keywordflow">case</span> MCH_MDA:
<a name="l01960"></a>01960         <span class="keywordflow">case</span> MCH_HERC:
<a name="l01961"></a>01961                 vgapages.base=VGA_PAGE_B0;
<a name="l01962"></a>01962                 <span class="comment">/* NTS: Implemented according to [http://www.seasip.info/VintagePC/hercplus.html#regs] */</span>
<a name="l01963"></a>01963                 <span class="keywordflow">if</span> (vga.herc.enable_bits &amp; 0x2) { <span class="comment">/* bit 1: page in upper 32KB */</span>
<a name="l01964"></a>01964                         vgapages.mask=0xffff;
<a name="l01965"></a>01965                         <span class="comment">/* NTS: I don&#39;t know what Hercules graphics cards do if you set bit 1 but not bit 0.</span>
<a name="l01966"></a>01966 <span class="comment">                         *      For the time being, I&#39;m assuming that they respond to 0xB8000+ because of bit 1</span>
<a name="l01967"></a>01967 <span class="comment">                         *      but only map to the first 4KB because of bit 0. Basically, a configuration no</span>
<a name="l01968"></a>01968 <span class="comment">                         *      software would actually use. */</span>
<a name="l01969"></a>01969                         <span class="keywordflow">if</span> (vga.herc.enable_bits &amp; 0x1) <span class="comment">/* allow graphics and enable 0xB1000-0xB7FFF */</span>
<a name="l01970"></a>01970                                 MEM_SetPageHandler(VGA_PAGE_B0,16,&amp;vgaph.map);
<a name="l01971"></a>01971                         <span class="keywordflow">else</span>
<a name="l01972"></a>01972                                 MEM_SetPageHandler(VGA_PAGE_B0,16,&amp;vgaph.herc);
<a name="l01973"></a>01973                 } <span class="keywordflow">else</span> {
<a name="l01974"></a>01974                         vgapages.mask=0x7fff;
<a name="l01975"></a>01975                         <span class="comment">// With hercules in 32kB mode it leaves a memory hole on 0xb800</span>
<a name="l01976"></a>01976                         <span class="comment">// and has MDA-compatible address wrapping when graphics are disabled</span>
<a name="l01977"></a>01977                         <span class="keywordflow">if</span> (vga.herc.enable_bits &amp; 0x1)
<a name="l01978"></a>01978                                 MEM_SetPageHandler(VGA_PAGE_B0,8,&amp;vgaph.map);
<a name="l01979"></a>01979                         <span class="keywordflow">else</span>
<a name="l01980"></a>01980                                 MEM_SetPageHandler(VGA_PAGE_B0,8,&amp;vgaph.herc);
<a name="l01981"></a>01981                         MEM_SetPageHandler(VGA_PAGE_B8,8,&amp;vgaph.empty);
<a name="l01982"></a>01982                 }
<a name="l01983"></a>01983                 <span class="keywordflow">goto</span> range_done;
<a name="l01984"></a>01984         <span class="keywordflow">case</span> MCH_TANDY:
<a name="l01985"></a>01985                 <span class="comment">/* Always map 0xa000 - 0xbfff, might overwrite 0xb800 */</span>
<a name="l01986"></a>01986                 vgapages.base=VGA_PAGE_A0;
<a name="l01987"></a>01987                 vgapages.mask=0x1ffff;
<a name="l01988"></a>01988                 MEM_SetPageHandler(VGA_PAGE_A0, 32, &amp;vgaph.map );
<a name="l01989"></a>01989                 <span class="keywordflow">if</span> ( vga.tandy.extended_ram &amp; 1 ) {
<a name="l01990"></a>01990                         <span class="comment">//You seem to be able to also map different 64kb banks, but have to figure that out</span>
<a name="l01991"></a>01991                         <span class="comment">//This seems to work so far though</span>
<a name="l01992"></a>01992                         vga.tandy.draw_base = vga.mem.linear;
<a name="l01993"></a>01993                         vga.tandy.mem_base = vga.mem.linear;
<a name="l01994"></a>01994                 } <span class="keywordflow">else</span> {
<a name="l01995"></a>01995                         vga.tandy.draw_base = TANDY_VIDBASE( vga.tandy.draw_bank * 16 * 1024);
<a name="l01996"></a>01996                         vga.tandy.mem_base = TANDY_VIDBASE( vga.tandy.mem_bank * 16 * 1024);
<a name="l01997"></a>01997                         MEM_SetPageHandler( 0xb8, 8, &amp;vgaph.tandy );
<a name="l01998"></a>01998                 }
<a name="l01999"></a>01999                 <span class="keywordflow">goto</span> range_done;
<a name="l02000"></a>02000 <span class="comment">//              MEM_SetPageHandler(vga.tandy.mem_bank&lt;&lt;2,vga.tandy.is_32k_mode ? 0x08 : 0x04,range_handler);</span>
<a name="l02001"></a>02001         <span class="keywordflow">case</span> MCH_AMSTRAD: <span class="comment">// Memory handler.</span>
<a name="l02002"></a>02002                 MEM_SetPageHandler( 0xb8, 8, &amp;vgaph.ams );
<a name="l02003"></a>02003                 <span class="keywordflow">goto</span> range_done;
<a name="l02004"></a>02004         <span class="keywordflow">case</span> EGAVGA_ARCH_CASE:
<a name="l02005"></a>02005     <span class="keywordflow">case</span> PC98_ARCH_CASE:
<a name="l02006"></a>02006                 <span class="keywordflow">break</span>;
<a name="l02007"></a>02007         <span class="keywordflow">default</span>:
<a name="l02008"></a>02008                 LOG_MSG(<span class="stringliteral">&quot;Illegal machine type %d&quot;</span>, machine );
<a name="l02009"></a>02009                 <span class="keywordflow">return</span>;
<a name="l02010"></a>02010         }
<a name="l02011"></a>02011 
<a name="l02012"></a>02012         <span class="comment">/* This should be vga only */</span>
<a name="l02013"></a>02013         <span class="keywordflow">switch</span> (vga.mode) {
<a name="l02014"></a>02014         <span class="keywordflow">case</span> M_ERROR:
<a name="l02015"></a>02015         <span class="keywordflow">default</span>:
<a name="l02016"></a>02016                 <span class="keywordflow">return</span>;
<a name="l02017"></a>02017         <span class="keywordflow">case</span> M_LIN15:
<a name="l02018"></a>02018         <span class="keywordflow">case</span> M_LIN16:
<a name="l02019"></a>02019         <span class="keywordflow">case</span> M_LIN24:
<a name="l02020"></a>02020         <span class="keywordflow">case</span> M_LIN32:
<a name="l02021"></a>02021     <span class="keywordflow">case</span> M_PACKED4:
<a name="l02022"></a>02022                 newHandler = &amp;vgaph.map;
<a name="l02023"></a>02023                 <span class="keywordflow">break</span>;
<a name="l02024"></a>02024         <span class="keywordflow">case</span> M_TEXT:
<a name="l02025"></a>02025         <span class="keywordflow">case</span> M_CGA2:
<a name="l02026"></a>02026         <span class="keywordflow">case</span> M_CGA4:
<a name="l02027"></a>02027         <span class="comment">/* EGA/VGA emulate CGA modes as chained */</span>
<a name="l02028"></a>02028         <span class="comment">/* fall through */</span>
<a name="l02029"></a>02029         <span class="keywordflow">case</span> M_LIN8:
<a name="l02030"></a>02030         <span class="keywordflow">case</span> M_LIN4:
<a name="l02031"></a>02031         <span class="keywordflow">case</span> M_VGA:
<a name="l02032"></a>02032         <span class="keywordflow">case</span> M_EGA:
<a name="l02033"></a>02033         <span class="keywordflow">if</span> (vga.config.chained) {
<a name="l02034"></a>02034             <span class="keywordflow">if</span> (vga.config.compatible_chain4) {
<a name="l02035"></a>02035                 <span class="comment">/* NTS: ET4000AX cards appear to have a different chain4 implementation from everyone else:</span>
<a name="l02036"></a>02036 <span class="comment">                 *      the planar memory byte address is address &gt;&gt; 2 and bits A0-A1 select the plane,</span>
<a name="l02037"></a>02037 <span class="comment">                 *      where all other clones I&#39;ve tested seem to write planar memory byte (address &amp; ~3)</span>
<a name="l02038"></a>02038 <span class="comment">                 *      (one byte per 4 bytes) and bits A0-A1 select the plane. */</span>
<a name="l02039"></a>02039                 <span class="comment">/* FIXME: Different chain4 implementation on ET4000 noted---is it true also for ET3000? */</span>
<a name="l02040"></a>02040                 <span class="keywordflow">if</span> (svgaCard == SVGA_TsengET3K || svgaCard == SVGA_TsengET4K)
<a name="l02041"></a>02041                     newHandler = &amp;vgaph.cvga_et4000_slow;
<a name="l02042"></a>02042                 <span class="keywordflow">else</span>
<a name="l02043"></a>02043                     newHandler = &amp;vgaph.cvga_slow;
<a name="l02044"></a>02044             }
<a name="l02045"></a>02045             <span class="keywordflow">else</span> {
<a name="l02046"></a>02046                 <span class="comment">/* this is needed for SVGA modes (Paradise, Tseng, S3) because SVGA</span>
<a name="l02047"></a>02047 <span class="comment">                 * modes do NOT use the chain4 configuration */</span>
<a name="l02048"></a>02048                 newHandler = &amp;vgaph.map;
<a name="l02049"></a>02049             }
<a name="l02050"></a>02050         } <span class="keywordflow">else</span> {
<a name="l02051"></a>02051             newHandler = &amp;vgaph.uvga;
<a name="l02052"></a>02052         }
<a name="l02053"></a>02053         <span class="keywordflow">break</span>;
<a name="l02054"></a>02054     <span class="keywordflow">case</span> M_PC98:
<a name="l02055"></a>02055                 newHandler = &amp;vgaph.pc98;
<a name="l02056"></a>02056 
<a name="l02057"></a>02057         <span class="comment">/* We need something to catch access to E0000-E7FFF IF 16/256-color mode */</span>
<a name="l02058"></a>02058         <span class="keywordflow">if</span> (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_ANALOG))
<a name="l02059"></a>02059             MEM_SetPageHandler(0xE0, 8, newHandler );
<a name="l02060"></a>02060         <span class="keywordflow">else</span>
<a name="l02061"></a>02061             MEM_ResetPageHandler_Unmapped(0xE0, 8);
<a name="l02062"></a>02062 
<a name="l02063"></a>02063         <span class="keywordflow">break</span>;
<a name="l02064"></a>02064         <span class="keywordflow">case</span> M_AMSTRAD:
<a name="l02065"></a>02065                 newHandler = &amp;vgaph.map;
<a name="l02066"></a>02066                 <span class="keywordflow">break</span>;
<a name="l02067"></a>02067         }
<a name="l02068"></a>02068         <span class="keywordflow">switch</span> ((vga.gfx.miscellaneous &gt;&gt; 2) &amp; 3) {
<a name="l02069"></a>02069         <span class="keywordflow">case</span> 0:
<a name="l02070"></a>02070         vgapages.base = VGA_PAGE_A0;
<a name="l02071"></a>02071         <span class="keywordflow">switch</span> (svgaCard) {
<a name="l02072"></a>02072             <span class="keywordflow">case</span> SVGA_TsengET3K:
<a name="l02073"></a>02073             <span class="keywordflow">case</span> SVGA_TsengET4K:
<a name="l02074"></a>02074                 vgapages.mask = 0x1ffff &amp; vga.mem.memmask;
<a name="l02075"></a>02075                 <span class="keywordflow">break</span>;
<a name="l02076"></a>02076                 <span class="comment">/* NTS: Looking at the official ET4000 programming guide, it does in fact support the full 128KB */</span>
<a name="l02077"></a>02077             <span class="keywordflow">case</span> SVGA_S3Trio:
<a name="l02078"></a>02078             <span class="keywordflow">default</span>:
<a name="l02079"></a>02079                 vgapages.mask = 0xffff &amp; vga.mem.memmask;
<a name="l02080"></a>02080                 <span class="keywordflow">break</span>;
<a name="l02081"></a>02081                 }
<a name="l02082"></a>02082                 MEM_SetPageHandler(VGA_PAGE_A0, 32, newHandler );
<a name="l02083"></a>02083                 <span class="keywordflow">break</span>;
<a name="l02084"></a>02084         <span class="keywordflow">case</span> 1:
<a name="l02085"></a>02085                 vgapages.base = VGA_PAGE_A0;
<a name="l02086"></a>02086                 vgapages.mask = 0xffff &amp; vga.mem.memmask;
<a name="l02087"></a>02087                 MEM_SetPageHandler( VGA_PAGE_A0, 16, newHandler );
<a name="l02088"></a>02088                 MEM_ResetPageHandler_Unmapped( VGA_PAGE_B0, 16);
<a name="l02089"></a>02089                 <span class="keywordflow">break</span>;
<a name="l02090"></a>02090         <span class="keywordflow">case</span> 2:
<a name="l02091"></a>02091                 vgapages.base = VGA_PAGE_B0;
<a name="l02092"></a>02092                 vgapages.mask = 0x7fff &amp; vga.mem.memmask;
<a name="l02093"></a>02093                 MEM_SetPageHandler( VGA_PAGE_B0, 8, newHandler );
<a name="l02094"></a>02094         MEM_ResetPageHandler_Unmapped( VGA_PAGE_A0, 16 );
<a name="l02095"></a>02095         MEM_ResetPageHandler_Unmapped( VGA_PAGE_B8, 8 );
<a name="l02096"></a>02096         <span class="keywordflow">break</span>;
<a name="l02097"></a>02097         <span class="keywordflow">case</span> 3:
<a name="l02098"></a>02098                 vgapages.base = VGA_PAGE_B8;
<a name="l02099"></a>02099                 vgapages.mask = 0x7fff &amp; vga.mem.memmask;
<a name="l02100"></a>02100                 MEM_SetPageHandler( VGA_PAGE_B8, 8, newHandler );
<a name="l02101"></a>02101         MEM_ResetPageHandler_Unmapped( VGA_PAGE_A0, 16 );
<a name="l02102"></a>02102         MEM_ResetPageHandler_Unmapped( VGA_PAGE_B0, 8 );
<a name="l02103"></a>02103         <span class="keywordflow">break</span>;
<a name="l02104"></a>02104         }
<a name="l02105"></a>02105         <span class="keywordflow">if</span>(svgaCard == SVGA_S3Trio &amp;&amp; (vga.s3.ext_mem_ctrl &amp; 0x10))
<a name="l02106"></a>02106                 MEM_SetPageHandler(VGA_PAGE_A0, 16, &amp;vgaph.mmio);
<a name="l02107"></a>02107 
<a name="l02108"></a>02108     non_cga_ignore_oddeven_engage = (non_cga_ignore_oddeven &amp;&amp; !(vga.mode == M_TEXT || vga.mode == M_CGA2 || vga.mode == M_CGA4));
<a name="l02109"></a>02109 
<a name="l02110"></a>02110 range_done:
<a name="l02111"></a>02111         PAGING_ClearTLB();
<a name="l02112"></a>02112 }
<a name="l02113"></a>02113 
<a name="l02114"></a>02114 <span class="keywordtype">void</span> VGA_StartUpdateLFB(<span class="keywordtype">void</span>) {
<a name="l02115"></a>02115         <span class="comment">/* please obey the Linear Address Window Size register!</span>
<a name="l02116"></a>02116 <span class="comment">         * Windows 3.1 S3 driver will reprogram the linear framebuffer down to 0xA0000 when entering a DOSBox</span>
<a name="l02117"></a>02117 <span class="comment">         * and assuming the full VRAM size will cause a LOT of problems! */</span>
<a name="l02118"></a>02118         Bitu winsz = 0x10000;
<a name="l02119"></a>02119 
<a name="l02120"></a>02120         <span class="keywordflow">switch</span> (vga.s3.reg_58&amp;3) {
<a name="l02121"></a>02121                 <span class="keywordflow">case</span> 1:
<a name="l02122"></a>02122                         winsz = 1 &lt;&lt; 20;        <span class="comment">//1MB</span>
<a name="l02123"></a>02123                         <span class="keywordflow">break</span>;
<a name="l02124"></a>02124                 <span class="keywordflow">case</span> 2:
<a name="l02125"></a>02125                         winsz = 2 &lt;&lt; 20;        <span class="comment">//2MB</span>
<a name="l02126"></a>02126                         <span class="keywordflow">break</span>;
<a name="l02127"></a>02127                 <span class="keywordflow">case</span> 3:
<a name="l02128"></a>02128                         winsz = 4 &lt;&lt; 20;        <span class="comment">//4MB</span>
<a name="l02129"></a>02129                         <span class="keywordflow">break</span>;
<a name="l02130"></a>02130                 <span class="comment">// FIXME: What about the 8MB window?</span>
<a name="l02131"></a>02131         }
<a name="l02132"></a>02132 
<a name="l02133"></a>02133     <span class="comment">/* The LFB register has an enable bit */</span>
<a name="l02134"></a>02134     <span class="keywordflow">if</span> (!(vga.s3.reg_58 &amp; 0x10)) {
<a name="l02135"></a>02135         vga.lfb.page = (<span class="keywordtype">unsigned</span> int)vga.s3.la_window &lt;&lt; 4u;
<a name="l02136"></a>02136         vga.lfb.addr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.s3.la_window &lt;&lt; 16u;
<a name="l02137"></a>02137         vga.lfb.handler = NULL;
<a name="l02138"></a>02138         MEM_SetLFB(0,0,NULL,NULL);
<a name="l02139"></a>02139     }
<a name="l02140"></a>02140     <span class="comment">/* if the DOS application or Windows 3.1 driver attempts to put the linear framebuffer</span>
<a name="l02141"></a>02141 <span class="comment">         * below the top of memory, then we&#39;re probably entering a DOS VM and it&#39;s probably</span>
<a name="l02142"></a>02142 <span class="comment">         * a 64KB window. If it&#39;s not a 64KB window then print a warning. */</span>
<a name="l02143"></a>02143     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(vga.s3.la_window &lt;&lt; 4UL) &lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)MEM_TotalPages()) {
<a name="l02144"></a>02144                 <span class="keywordflow">if</span> (winsz != 0x10000) <span class="comment">// 64KB window normal for entering a DOS VM in Windows 3.1 or legacy bank switching in DOS</span>
<a name="l02145"></a>02145                         <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_WARN)(<span class="stringliteral">&quot;S3 warning: Window size != 64KB and address conflict with system RAM!&quot;</span>);
<a name="l02146"></a>02146 
<a name="l02147"></a>02147                 vga.lfb.page = (<span class="keywordtype">unsigned</span> int)vga.s3.la_window &lt;&lt; 4u;
<a name="l02148"></a>02148                 vga.lfb.addr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.s3.la_window &lt;&lt; 16u;
<a name="l02149"></a>02149                 vga.lfb.handler = NULL;
<a name="l02150"></a>02150                 MEM_SetLFB(0,0,NULL,NULL);
<a name="l02151"></a>02151         }
<a name="l02152"></a>02152         <span class="keywordflow">else</span> {
<a name="l02153"></a>02153                 vga.lfb.page = (<span class="keywordtype">unsigned</span> int)vga.s3.la_window &lt;&lt; 4u;
<a name="l02154"></a>02154                 vga.lfb.addr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.s3.la_window &lt;&lt; 16u;
<a name="l02155"></a>02155                 vga.lfb.handler = &amp;vgaph.lfb;
<a name="l02156"></a>02156                 MEM_SetLFB((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.s3.la_window &lt;&lt; 4u,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.mem.memsize/4096u, vga.lfb.handler, &amp;vgaph.mmio);
<a name="l02157"></a>02157         }
<a name="l02158"></a>02158 }
<a name="l02159"></a>02159 
<a name="l02160"></a>02160 <span class="keyword">static</span> <span class="keywordtype">bool</span> VGA_Memory_ShutDown_init = <span class="keyword">false</span>;
<a name="l02161"></a>02161 
<a name="l02162"></a>02162 <span class="keyword">static</span> <span class="keywordtype">void</span> VGA_Memory_ShutDown(<a class="code" href="classSection.html">Section</a> * <span class="comment">/*sec*/</span>) {
<a name="l02163"></a>02163         MEM_SetPageHandler(VGA_PAGE_A0,32,&amp;vgaph.empty);
<a name="l02164"></a>02164         PAGING_ClearTLB();
<a name="l02165"></a>02165 
<a name="l02166"></a>02166         <span class="keywordflow">if</span> (vga.mem.linear_orgptr != NULL) {
<a name="l02167"></a>02167                 <span class="keyword">delete</span>[] vga.mem.linear_orgptr;
<a name="l02168"></a>02168                 vga.mem.linear_orgptr = NULL;
<a name="l02169"></a>02169                 vga.mem.linear = NULL;
<a name="l02170"></a>02170         }
<a name="l02171"></a>02171 }
<a name="l02172"></a>02172 
<a name="l02173"></a>02173 <span class="keywordtype">void</span> VGAMEM_LoadState(<a class="code" href="classSection.html">Section</a> *sec) {
<a name="l02174"></a>02174     (void)sec;<span class="comment">//UNUSED</span>
<a name="l02175"></a>02175 
<a name="l02176"></a>02176     <span class="keywordflow">if</span> (MemBase != NULL) {
<a name="l02177"></a>02177         <a class="code" href="classZIPFileEntry.html">ZIPFileEntry</a> *ent = savestate_zip.get_entry(<span class="stringliteral">&quot;vga.memory.bin&quot;</span>);
<a name="l02178"></a>02178         <span class="keywordflow">if</span> (ent != NULL) {
<a name="l02179"></a>02179             ent-&gt;rewind();
<a name="l02180"></a>02180             <span class="keywordflow">if</span> (vga.mem.memsize == ent-&gt;file_length)
<a name="l02181"></a>02181                 ent-&gt;read(vga.mem.linear, vga.mem.memsize);
<a name="l02182"></a>02182             <span class="keywordflow">else</span>
<a name="l02183"></a>02183                 LOG_MSG(<span class="stringliteral">&quot;VGA Memory load state failure: VGA Memory size mismatch&quot;</span>);
<a name="l02184"></a>02184         }
<a name="l02185"></a>02185     }
<a name="l02186"></a>02186 }
<a name="l02187"></a>02187 
<a name="l02188"></a>02188 <span class="keywordtype">void</span> VGAMEM_SaveState(<a class="code" href="classSection.html">Section</a> *sec) {
<a name="l02189"></a>02189     (void)sec;<span class="comment">//UNUSED</span>
<a name="l02190"></a>02190 
<a name="l02191"></a>02191     <span class="keywordflow">if</span> (vga.mem.linear != NULL) {
<a name="l02192"></a>02192         <a class="code" href="classZIPFileEntry.html">ZIPFileEntry</a> *ent = savestate_zip.new_entry(<span class="stringliteral">&quot;vga.memory.bin&quot;</span>);
<a name="l02193"></a>02193         <span class="keywordflow">if</span> (ent != NULL) {
<a name="l02194"></a>02194             ent-&gt;write(vga.mem.linear, vga.mem.memsize);
<a name="l02195"></a>02195         }
<a name="l02196"></a>02196     }
<a name="l02197"></a>02197 }
<a name="l02198"></a>02198 
<a name="l02199"></a>02199 <span class="keywordtype">void</span> VGA_SetupMemory() {
<a name="l02200"></a>02200         vga.svga.bank_read = vga.svga.bank_write = 0;
<a name="l02201"></a>02201         vga.svga.bank_read_full = vga.svga.bank_write_full = 0;
<a name="l02202"></a>02202 
<a name="l02203"></a>02203     <span class="keywordflow">if</span> (vga.mem.linear == NULL) {
<a name="l02204"></a>02204         VGA_Memory_ShutDown(NULL);
<a name="l02205"></a>02205 
<a name="l02206"></a>02206         vga.mem.linear_orgptr = <span class="keyword">new</span> Bit8u[vga.mem.memsize+32u];
<a name="l02207"></a>02207         memset(vga.mem.linear_orgptr,0,vga.mem.memsize+32u);
<a name="l02208"></a>02208         vga.mem.linear=(Bit8u*)(((uintptr_t)vga.mem.linear_orgptr + 16ull-1ull) &amp; ~(16ull-1ull));
<a name="l02209"></a>02209 
<a name="l02210"></a>02210         <span class="comment">/* HACK. try to avoid stale pointers */</span>
<a name="l02211"></a>02211             vga.draw.linear_base = vga.mem.linear;
<a name="l02212"></a>02212         vga.tandy.draw_base = vga.mem.linear;
<a name="l02213"></a>02213         vga.tandy.mem_base = vga.mem.linear;
<a name="l02214"></a>02214 
<a name="l02215"></a>02215         <span class="comment">/* may be related */</span>
<a name="l02216"></a>02216         VGA_SetupHandlers();
<a name="l02217"></a>02217     }
<a name="l02218"></a>02218 
<a name="l02219"></a>02219         vga.svga.bank_read = vga.svga.bank_write = 0;
<a name="l02220"></a>02220         vga.svga.bank_read_full = vga.svga.bank_write_full = 0;
<a name="l02221"></a>02221         vga.svga.bank_size = 0x10000; <span class="comment">/* most common bank size is 64K */</span>
<a name="l02222"></a>02222 
<a name="l02223"></a>02223         <span class="keywordflow">if</span> (!VGA_Memory_ShutDown_init) {
<a name="l02224"></a>02224         AddVMEventFunction(VM_EVENT_LOAD_STATE,AddVMEventFunctionFuncPair(VGAMEM_LoadState));
<a name="l02225"></a>02225         AddVMEventFunction(VM_EVENT_SAVE_STATE,AddVMEventFunctionFuncPair(VGAMEM_SaveState));
<a name="l02226"></a>02226 
<a name="l02227"></a>02227                 AddExitFunction(AddExitFunctionFuncPair(VGA_Memory_ShutDown));
<a name="l02228"></a>02228                 VGA_Memory_ShutDown_init = <span class="keyword">true</span>;
<a name="l02229"></a>02229         }
<a name="l02230"></a>02230 
<a name="l02231"></a>02231         <span class="keywordflow">if</span> (machine==MCH_PCJR) {
<a name="l02232"></a>02232                 <span class="comment">/* PCJr does not have dedicated graphics memory but uses</span>
<a name="l02233"></a>02233 <span class="comment">                   conventional memory below 128k */</span>
<a name="l02234"></a>02234                 <span class="comment">//TODO map?     </span>
<a name="l02235"></a>02235         } 
<a name="l02236"></a>02236 }
<a name="l02237"></a>02237 
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Nov 2 2018 12:40:09 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
