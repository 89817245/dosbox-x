<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/hardware/vga_memory.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/hardware/vga_memory.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  Copyright (C) 2002-2015  The DOSBox Team</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  This program is free software; you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment"> *  (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *  This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment"> *  GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment"> *  along with this program; if not, write to the Free Software</span>
<a name="l00016"></a>00016 <span class="comment"> *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;dosbox.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;mem.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;vga.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;paging.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;pic.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;inout.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;setup.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;pc98_cg.h&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;pc98_gdc.h&quot;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="preprocessor">#ifndef C_VGARAM_CHECKED</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#define C_VGARAM_CHECKED 1</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="preprocessor">#if C_VGARAM_CHECKED</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="comment">// Checked linear offset</span>
<a name="l00041"></a>00041 <span class="preprocessor">#define CHECKED(v) ((v)&amp;(vga.vmemwrap-1))</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="comment">// Checked planar offset (latched access)</span>
<a name="l00043"></a>00043 <span class="preprocessor">#define CHECKED2(v) ((v)&amp;((vga.vmemwrap&gt;&gt;2)-1))</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#define CHECKED(v) (v)</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor">#define CHECKED2(v) (v)</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00049"></a>00049 <span class="preprocessor">#define CHECKED3(v) ((v)&amp;(vga.vmemwrap-1))</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#define CHECKED4(v) ((v)&amp;((vga.vmemwrap&gt;&gt;2)-1))</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 <span class="preprocessor">#define TANDY_VIDBASE(_X_)  &amp;MemBase[ 0x80000 + (_X_)]</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="comment">/* how much delay to add to VGA memory I/O in nanoseconds */</span>
<a name="l00055"></a>00055 <span class="keywordtype">int</span> vga_memio_delay_ns = 1000;
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="keywordtype">void</span> VGAMEM_USEC_read_delay() {
<a name="l00058"></a>00058         <span class="keywordflow">if</span> (vga_memio_delay_ns &gt; 0) {
<a name="l00059"></a>00059                 Bits delaycyc = (CPU_CycleMax * vga_memio_delay_ns) / 1000000;
<a name="l00060"></a>00060 <span class="comment">//              if(GCC_UNLIKELY(CPU_Cycles &lt; 3*delaycyc)) delaycyc = 0; //Else port acces will set cycles to 0. which might trigger problem with games which read 16 bit values</span>
<a name="l00061"></a>00061                 CPU_Cycles -= delaycyc;
<a name="l00062"></a>00062                 CPU_IODelayRemoved += delaycyc;
<a name="l00063"></a>00063         }
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="keywordtype">void</span> VGAMEM_USEC_write_delay() {
<a name="l00067"></a>00067         <span class="keywordflow">if</span> (vga_memio_delay_ns &gt; 0) {
<a name="l00068"></a>00068                 Bits delaycyc = (CPU_CycleMax * vga_memio_delay_ns * 3) / (1000000 * 4);
<a name="l00069"></a>00069 <span class="comment">//              if(GCC_UNLIKELY(CPU_Cycles &lt; 3*delaycyc)) delaycyc = 0; //Else port acces will set cycles to 0. which might trigger problem with games which read 16 bit values</span>
<a name="l00070"></a>00070                 CPU_Cycles -= delaycyc;
<a name="l00071"></a>00071                 CPU_IODelayRemoved += delaycyc;
<a name="l00072"></a>00072         }
<a name="l00073"></a>00073 }
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Size&gt;
<a name="l00076"></a>00076 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> hostWrite(HostPt off, Bitu val) {
<a name="l00077"></a>00077         <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 1)
<a name="l00078"></a>00078                 host_writeb( off, (Bit8u)val );
<a name="l00079"></a>00079         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 2)
<a name="l00080"></a>00080                 host_writew( off, (Bit16u)val );
<a name="l00081"></a>00081         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 4)
<a name="l00082"></a>00082                 host_writed( off, (Bit32u)val );
<a name="l00083"></a>00083 }
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Size&gt;
<a name="l00086"></a>00086 <span class="keyword">static</span> INLINE Bitu  hostRead(HostPt off ) {
<a name="l00087"></a>00087         <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 1)
<a name="l00088"></a>00088                 <span class="keywordflow">return</span> host_readb( off );
<a name="l00089"></a>00089         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 2)
<a name="l00090"></a>00090                 <span class="keywordflow">return</span> host_readw( off );
<a name="l00091"></a>00091         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 4)
<a name="l00092"></a>00092                 <span class="keywordflow">return</span> host_readd( off );
<a name="l00093"></a>00093         <span class="keywordflow">return</span> 0;
<a name="l00094"></a>00094 }
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="keywordtype">void</span> VGA_MapMMIO(<span class="keywordtype">void</span>);
<a name="l00098"></a>00098 <span class="comment">//Nice one from DosEmu</span>
<a name="l00099"></a>00099 INLINE <span class="keyword">static</span> Bit32u RasterOp(Bit32u input,Bit32u mask) {
<a name="l00100"></a>00100         <span class="keywordflow">switch</span> (vga.config.raster_op) {
<a name="l00101"></a>00101         <span class="keywordflow">case</span> 0x00:      <span class="comment">/* None */</span>
<a name="l00102"></a>00102                 <span class="keywordflow">return</span> (input &amp; mask) | (vga.latch.d &amp; ~mask);
<a name="l00103"></a>00103         <span class="keywordflow">case</span> 0x01:      <span class="comment">/* AND */</span>
<a name="l00104"></a>00104                 <span class="keywordflow">return</span> (input | ~mask) &amp; vga.latch.d;
<a name="l00105"></a>00105         <span class="keywordflow">case</span> 0x02:      <span class="comment">/* OR */</span>
<a name="l00106"></a>00106                 <span class="keywordflow">return</span> (input &amp; mask) | vga.latch.d;
<a name="l00107"></a>00107         <span class="keywordflow">case</span> 0x03:      <span class="comment">/* XOR */</span>
<a name="l00108"></a>00108                 <span class="keywordflow">return</span> (input &amp; mask) ^ vga.latch.d;
<a name="l00109"></a>00109         };
<a name="l00110"></a>00110         <span class="keywordflow">return</span> 0;
<a name="l00111"></a>00111 }
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 INLINE <span class="keyword">static</span> Bit32u ModeOperation(Bit8u val) {
<a name="l00114"></a>00114         Bit32u full;
<a name="l00115"></a>00115         <span class="keywordflow">switch</span> (vga.config.write_mode) {
<a name="l00116"></a>00116         <span class="keywordflow">case</span> 0x00:
<a name="l00117"></a>00117                 <span class="comment">// Write Mode 0: In this mode, the host data is first rotated as per the Rotate Count field, then the Enable Set/Reset mechanism selects data from this or the Set/Reset field. Then the selected Logical Operation is performed on the resulting data and the data in the latch register. Then the Bit Mask field is used to select which bits come from the resulting data and which come from the latch register. Finally, only the bit planes enabled by the Memory Plane Write Enable field are written to memory. </span>
<a name="l00118"></a>00118                 val=((val &gt;&gt; vga.config.data_rotate) | (val &lt;&lt; (8-vga.config.data_rotate)));
<a name="l00119"></a>00119                 full=ExpandTable[val];
<a name="l00120"></a>00120                 full=(full &amp; vga.config.full_not_enable_set_reset) | vga.config.full_enable_and_set_reset; 
<a name="l00121"></a>00121                 full=RasterOp(full,vga.config.full_bit_mask);
<a name="l00122"></a>00122                 <span class="keywordflow">break</span>;
<a name="l00123"></a>00123         <span class="keywordflow">case</span> 0x01:
<a name="l00124"></a>00124                 <span class="comment">// Write Mode 1: In this mode, data is transferred directly from the 32 bit latch register to display memory, affected only by the Memory Plane Write Enable field. The host data is not used in this mode. </span>
<a name="l00125"></a>00125                 full=vga.latch.d;
<a name="l00126"></a>00126                 <span class="keywordflow">break</span>;
<a name="l00127"></a>00127         <span class="keywordflow">case</span> 0x02:
<a name="l00128"></a>00128                 <span class="comment">//Write Mode 2: In this mode, the bits 3-0 of the host data are replicated across all 8 bits of their respective planes. Then the selected Logical Operation is performed on the resulting data and the data in the latch register. Then the Bit Mask field is used to select which bits come from the resulting data and which come from the latch register. Finally, only the bit planes enabled by the Memory Plane Write Enable field are written to memory. </span>
<a name="l00129"></a>00129                 full=RasterOp(FillTable[val&amp;0xF],vga.config.full_bit_mask);
<a name="l00130"></a>00130                 <span class="keywordflow">break</span>;
<a name="l00131"></a>00131         <span class="keywordflow">case</span> 0x03:
<a name="l00132"></a>00132                 <span class="comment">// Write Mode 3: In this mode, the data in the Set/Reset field is used as if the Enable Set/Reset field were set to 1111b. Then the host data is first rotated as per the Rotate Count field, then logical ANDed with the value of the Bit Mask field. The resulting value is used on the data obtained from the Set/Reset field in the same way that the Bit Mask field would ordinarily be used. to select which bits come from the expansion of the Set/Reset field and which come from the latch register. Finally, only the bit planes enabled by the Memory Plane Write Enable field are written to memory.</span>
<a name="l00133"></a>00133                 val=((val &gt;&gt; vga.config.data_rotate) | (val &lt;&lt; (8-vga.config.data_rotate)));
<a name="l00134"></a>00134                 full=RasterOp(vga.config.full_set_reset,ExpandTable[val] &amp; vga.config.full_bit_mask);
<a name="l00135"></a>00135                 <span class="keywordflow">break</span>;
<a name="l00136"></a>00136         <span class="keywordflow">default</span>:
<a name="l00137"></a>00137                 <a class="code" href="classLOG.html">LOG</a>(LOG_VGAMISC,LOG_NORMAL)(<span class="stringliteral">&quot;VGA:Unsupported write mode %d&quot;</span>,vga.config.write_mode);
<a name="l00138"></a>00138                 full=0;
<a name="l00139"></a>00139                 <span class="keywordflow">break</span>;
<a name="l00140"></a>00140         }
<a name="l00141"></a>00141         <span class="keywordflow">return</span> full;
<a name="l00142"></a>00142 }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="comment">/* Gonna assume that whoever maps vga memory, maps it on 32/64kb boundary */</span>
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="preprocessor">#define VGA_PAGES               (128/4)</span>
<a name="l00147"></a>00147 <span class="preprocessor"></span><span class="preprocessor">#define VGA_PAGE_A0             (0xA0000/4096)</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span><span class="preprocessor">#define VGA_PAGE_B0             (0xB0000/4096)</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span><span class="preprocessor">#define VGA_PAGE_B8             (0xB8000/4096)</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span>
<a name="l00151"></a>00151 <span class="keyword">static</span> <span class="keyword">struct </span>{
<a name="l00152"></a>00152         Bitu base, mask;
<a name="l00153"></a>00153 } vgapages;
<a name="l00154"></a>00154         
<a name="l00155"></a><a class="code" href="classVGA__UnchainedRead__Handler.html">00155</a> <span class="keyword">class </span><a class="code" href="classVGA__UnchainedRead__Handler.html">VGA_UnchainedRead_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00156"></a>00156 <span class="keyword">public</span>:
<a name="l00157"></a>00157         <a class="code" href="classVGA__UnchainedRead__Handler.html">VGA_UnchainedRead_Handler</a>(Bitu flags) : <a class="code" href="classPageHandler.html">PageHandler</a>(flags) {}
<a name="l00158"></a>00158         Bitu readHandler(PhysPt start) {
<a name="l00159"></a>00159                 PhysPt memstart = start;
<a name="l00160"></a>00160                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bplane;
<a name="l00161"></a>00161 
<a name="l00162"></a>00162                 <span class="keywordflow">if</span> (vga.gfx.miscellaneous&amp;2) <span class="comment">/* Odd/Even mode */</span>
<a name="l00163"></a>00163                         memstart &amp;= ~1;
<a name="l00164"></a>00164 
<a name="l00165"></a>00165                 vga.latch.d=((Bit32u*)vga.mem.linear)[memstart];
<a name="l00166"></a>00166                 <span class="keywordflow">switch</span> (vga.config.read_mode) {
<a name="l00167"></a>00167                         <span class="keywordflow">case</span> 0:
<a name="l00168"></a>00168                                 bplane = vga.config.read_map_select;
<a name="l00169"></a>00169                                 <span class="comment">/* NTS: We check the sequencer AND the GC to know whether we mask the bitplane line this,</span>
<a name="l00170"></a>00170 <span class="comment">                                 *      even though in TEXT mode we only check the sequencer. Without this extra check,</span>
<a name="l00171"></a>00171 <span class="comment">                                 *      Windows 95 and Windows 3.1 will exhibit glitches in the standard VGA 640x480x16</span>
<a name="l00172"></a>00172 <span class="comment">                                 *      planar mode */</span>
<a name="l00173"></a>00173                                 <span class="keywordflow">if</span> (!(vga.seq.memory_mode&amp;4) &amp;&amp; (vga.gfx.miscellaneous&amp;2)) <span class="comment">/* FIXME: How exactly do SVGA cards determine this? */</span>
<a name="l00174"></a>00174                                         bplane = (bplane &amp; ~1) + (start &amp; 1); <span class="comment">/* FIXME: Is this what VGA cards do? It makes sense to me */</span>
<a name="l00175"></a>00175                                 <span class="keywordflow">return</span> (vga.latch.b[bplane]);
<a name="l00176"></a>00176                         <span class="keywordflow">case</span> 1:
<a name="l00177"></a>00177                                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> templatch;
<a name="l00178"></a>00178                                 templatch.d=(vga.latch.d &amp; FillTable[vga.config.color_dont_care]) ^ FillTable[vga.config.color_compare &amp; vga.config.color_dont_care];
<a name="l00179"></a>00179                                 return (Bit8u)~(templatch.b[0] | templatch.b[1] | templatch.b[2] | templatch.b[3]);
<a name="l00180"></a>00180                 }
<a name="l00181"></a>00181                 <span class="keywordflow">return</span> 0;
<a name="l00182"></a>00182         }
<a name="l00183"></a>00183 <span class="keyword">public</span>:
<a name="l00184"></a>00184         Bitu readb(PhysPt addr) {
<a name="l00185"></a>00185                 VGAMEM_USEC_read_delay();
<a name="l00186"></a>00186                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00187"></a>00187                 addr += vga.svga.bank_read_full;
<a name="l00188"></a>00188                 addr = CHECKED2(addr);
<a name="l00189"></a>00189                 <span class="keywordflow">return</span> readHandler(addr);
<a name="l00190"></a>00190         }
<a name="l00191"></a>00191         Bitu readw(PhysPt addr) {
<a name="l00192"></a>00192                 VGAMEM_USEC_read_delay();
<a name="l00193"></a>00193                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00194"></a>00194                 addr += vga.svga.bank_read_full;
<a name="l00195"></a>00195                 addr = CHECKED2(addr);
<a name="l00196"></a>00196                 Bitu ret = (readHandler(addr+0) &lt;&lt; 0);
<a name="l00197"></a>00197                 ret     |= (readHandler(addr+1) &lt;&lt; 8);
<a name="l00198"></a>00198                 <span class="keywordflow">return</span>  ret;
<a name="l00199"></a>00199         }
<a name="l00200"></a>00200         Bitu readd(PhysPt addr) {
<a name="l00201"></a>00201                 VGAMEM_USEC_read_delay();
<a name="l00202"></a>00202                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00203"></a>00203                 addr += vga.svga.bank_read_full;
<a name="l00204"></a>00204                 addr = CHECKED2(addr);
<a name="l00205"></a>00205                 Bitu ret = (readHandler(addr+0) &lt;&lt; 0);
<a name="l00206"></a>00206                 ret     |= (readHandler(addr+1) &lt;&lt; 8);
<a name="l00207"></a>00207                 ret     |= (readHandler(addr+2) &lt;&lt; 16);
<a name="l00208"></a>00208                 ret     |= (readHandler(addr+3) &lt;&lt; 24);
<a name="l00209"></a>00209                 <span class="keywordflow">return</span> ret;
<a name="l00210"></a>00210         }
<a name="l00211"></a>00211 };
<a name="l00212"></a>00212 
<a name="l00213"></a><a class="code" href="classVGA__ChainedEGA__Handler.html">00213</a> <span class="keyword">class </span><a class="code" href="classVGA__ChainedEGA__Handler.html">VGA_ChainedEGA_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00214"></a>00214 <span class="keyword">public</span>:
<a name="l00215"></a>00215         Bitu readHandler(PhysPt addr) {
<a name="l00216"></a>00216                 <span class="keywordflow">return</span> vga.mem.linear[addr];
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218         <span class="keywordtype">void</span> writeHandler(PhysPt start, Bit8u val) {
<a name="l00219"></a>00219                 <span class="comment">/* FIXME: &quot;Chained EGA&quot; how does that work?? */</span>
<a name="l00220"></a>00220                 ModeOperation(val);
<a name="l00221"></a>00221                 <span class="comment">/* Update video memory and the pixel buffer */</span>
<a name="l00222"></a>00222                 vga.mem.linear[start] = val;
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224 <span class="keyword">public</span>: 
<a name="l00225"></a>00225         <a class="code" href="classVGA__ChainedEGA__Handler.html">VGA_ChainedEGA_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00226"></a>00226         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l00227"></a>00227                 VGAMEM_USEC_write_delay();
<a name="l00228"></a>00228                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00229"></a>00229                 addr += vga.svga.bank_write_full;
<a name="l00230"></a>00230                 addr = CHECKED(addr);
<a name="l00231"></a>00231                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00232"></a>00232         }
<a name="l00233"></a>00233         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00234"></a>00234                 VGAMEM_USEC_write_delay();
<a name="l00235"></a>00235                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00236"></a>00236                 addr += vga.svga.bank_write_full;
<a name="l00237"></a>00237                 addr = CHECKED(addr);
<a name="l00238"></a>00238                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00239"></a>00239                 writeHandler(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l00240"></a>00240         }
<a name="l00241"></a>00241         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00242"></a>00242                 VGAMEM_USEC_write_delay();
<a name="l00243"></a>00243                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00244"></a>00244                 addr += vga.svga.bank_write_full;
<a name="l00245"></a>00245                 addr = CHECKED(addr);
<a name="l00246"></a>00246                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00247"></a>00247                 writeHandler(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l00248"></a>00248                 writeHandler(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l00249"></a>00249                 writeHandler(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l00250"></a>00250         }
<a name="l00251"></a>00251         Bitu readb(PhysPt addr) {
<a name="l00252"></a>00252                 VGAMEM_USEC_read_delay();
<a name="l00253"></a>00253                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00254"></a>00254                 addr += vga.svga.bank_read_full;
<a name="l00255"></a>00255                 addr = CHECKED(addr);
<a name="l00256"></a>00256                 <span class="keywordflow">return</span> readHandler(addr);
<a name="l00257"></a>00257         }
<a name="l00258"></a>00258         Bitu readw(PhysPt addr) {
<a name="l00259"></a>00259                 VGAMEM_USEC_read_delay();
<a name="l00260"></a>00260                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00261"></a>00261                 addr += vga.svga.bank_read_full;
<a name="l00262"></a>00262                 addr = CHECKED(addr);
<a name="l00263"></a>00263                 Bitu ret = (readHandler(addr+0) &lt;&lt; 0);
<a name="l00264"></a>00264                 ret     |= (readHandler(addr+1) &lt;&lt; 8);
<a name="l00265"></a>00265                 <span class="keywordflow">return</span> ret;
<a name="l00266"></a>00266         }
<a name="l00267"></a>00267         Bitu readd(PhysPt addr) {
<a name="l00268"></a>00268                 VGAMEM_USEC_read_delay();
<a name="l00269"></a>00269                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00270"></a>00270                 addr += vga.svga.bank_read_full;
<a name="l00271"></a>00271                 addr = CHECKED(addr);
<a name="l00272"></a>00272                 Bitu ret = (readHandler(addr+0) &lt;&lt; 0);
<a name="l00273"></a>00273                 ret     |= (readHandler(addr+1) &lt;&lt; 8);
<a name="l00274"></a>00274                 ret     |= (readHandler(addr+2) &lt;&lt; 16);
<a name="l00275"></a>00275                 ret     |= (readHandler(addr+3) &lt;&lt; 24);
<a name="l00276"></a>00276                 <span class="keywordflow">return</span> ret;
<a name="l00277"></a>00277         }
<a name="l00278"></a>00278 };
<a name="l00279"></a>00279 
<a name="l00280"></a><a class="code" href="classVGA__UnchainedEGA__Handler.html">00280</a> <span class="keyword">class </span><a class="code" href="classVGA__UnchainedEGA__Handler.html">VGA_UnchainedEGA_Handler</a> : <span class="keyword">public</span> <a class="code" href="classVGA__UnchainedRead__Handler.html">VGA_UnchainedRead_Handler</a> {
<a name="l00281"></a>00281 <span class="keyword">public</span>:
<a name="l00282"></a>00282         <a class="code" href="classVGA__UnchainedEGA__Handler.html">VGA_UnchainedEGA_Handler</a>(Bitu flags) : <a class="code" href="classVGA__UnchainedRead__Handler.html">VGA_UnchainedRead_Handler</a>(flags) {}
<a name="l00283"></a>00283         <span class="keyword">template</span>&lt; <span class="keywordtype">bool</span> wrapping&gt;
<a name="l00284"></a>00284         <span class="keywordtype">void</span> writeHandler(PhysPt start, Bit8u val) {
<a name="l00285"></a>00285                 Bit32u data=ModeOperation(val);
<a name="l00286"></a>00286                 <span class="comment">/* Update video memory and the pixel buffer */</span>
<a name="l00287"></a>00287                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> pixels;
<a name="l00288"></a>00288                 pixels.d=((Bit32u*)vga.mem.linear)[start];
<a name="l00289"></a>00289                 pixels.d&amp;=vga.config.full_not_map_mask;
<a name="l00290"></a>00290                 pixels.d|=(data &amp; vga.config.full_map_mask);
<a name="l00291"></a>00291                 ((Bit32u*)vga.mem.linear)[start]=pixels.d;
<a name="l00292"></a>00292         }
<a name="l00293"></a>00293 <span class="keyword">public</span>: 
<a name="l00294"></a>00294         <a class="code" href="classVGA__UnchainedEGA__Handler.html">VGA_UnchainedEGA_Handler</a>() : <a class="code" href="classVGA__UnchainedRead__Handler.html">VGA_UnchainedRead_Handler</a>(PFLAG_NOCODE) {}
<a name="l00295"></a>00295         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l00296"></a>00296                 VGAMEM_USEC_write_delay();
<a name="l00297"></a>00297                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00298"></a>00298                 addr += vga.svga.bank_write_full;
<a name="l00299"></a>00299                 addr = CHECKED2(addr);
<a name="l00300"></a>00300                 writeHandler&lt;true&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00301"></a>00301         }
<a name="l00302"></a>00302         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00303"></a>00303                 VGAMEM_USEC_write_delay();
<a name="l00304"></a>00304                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00305"></a>00305                 addr += vga.svga.bank_write_full;
<a name="l00306"></a>00306                 addr = CHECKED2(addr);
<a name="l00307"></a>00307                 writeHandler&lt;true&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00308"></a>00308                 writeHandler&lt;true&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l00309"></a>00309         }
<a name="l00310"></a>00310         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00311"></a>00311                 VGAMEM_USEC_write_delay();
<a name="l00312"></a>00312                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00313"></a>00313                 addr += vga.svga.bank_write_full;
<a name="l00314"></a>00314                 addr = CHECKED2(addr);
<a name="l00315"></a>00315                 writeHandler&lt;true&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00316"></a>00316                 writeHandler&lt;true&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l00317"></a>00317                 writeHandler&lt;true&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l00318"></a>00318                 writeHandler&lt;true&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l00319"></a>00319         }
<a name="l00320"></a>00320 };
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 <span class="comment">// Slow accurate emulation.</span>
<a name="l00323"></a>00323 <span class="comment">// This version takes the Graphics Controller bitmask and ROPs into account.</span>
<a name="l00324"></a>00324 <span class="comment">// This is needed for demos that use the bitmask to do color combination or bitplane &quot;page flipping&quot; tricks.</span>
<a name="l00325"></a>00325 <span class="comment">// This code will kick in if running in a chained VGA mode and the graphics controller bitmask register is</span>
<a name="l00326"></a>00326 <span class="comment">// changed to anything other than 0xFF.</span>
<a name="l00327"></a>00327 <span class="comment">//</span>
<a name="l00328"></a>00328 <span class="comment">// Impact Studios &quot;Legend&quot;</span>
<a name="l00329"></a>00329 <span class="comment">//  - The rotating objects, rendered as dots, needs this hack because it uses a combination of masking off</span>
<a name="l00330"></a>00330 <span class="comment">//    bitplanes using the VGA DAC pel mask and drawing on the hidden bitplane using the Graphics Controller</span>
<a name="l00331"></a>00331 <span class="comment">//    bitmask. It also relies on loading the VGA latches with zeros as a form of &quot;overdraw&quot;. Without this</span>
<a name="l00332"></a>00332 <span class="comment">//    version the effect will instead become a glowing ball of flickering yellow/red.</span>
<a name="l00333"></a><a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">00333</a> <span class="keyword">class </span><a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">VGA_ChainedVGA_Slow_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00334"></a>00334 <span class="keyword">public</span>:
<a name="l00335"></a>00335         <a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">VGA_ChainedVGA_Slow_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00336"></a>00336         <span class="keyword">static</span> INLINE Bitu readHandler8(PhysPt addr ) {
<a name="l00337"></a>00337                 vga.latch.d=((Bit32u*)vga.mem.linear)[addr&amp;~3];
<a name="l00338"></a>00338                 <span class="keywordflow">return</span> vga.latch.b[addr&amp;3];
<a name="l00339"></a>00339         }
<a name="l00340"></a>00340         <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> writeHandler8(PhysPt addr, Bitu val) {
<a name="l00341"></a>00341                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> pixels;
<a name="l00342"></a>00342 
<a name="l00343"></a>00343                 <span class="comment">/* byte-sized template specialization with masking */</span>
<a name="l00344"></a>00344                 pixels.d = ModeOperation(val);
<a name="l00345"></a>00345                 <span class="comment">/* Update video memory and the pixel buffer */</span>
<a name="l00346"></a>00346                 hostWrite&lt;Bit8u&gt;( &amp;vga.mem.linear[((addr&amp;~3)&lt;&lt;2)+(addr&amp;3)], pixels.b[addr&amp;3] );
<a name="l00347"></a>00347         }
<a name="l00348"></a>00348         Bitu readb(PhysPt addr ) {
<a name="l00349"></a>00349                 VGAMEM_USEC_read_delay();
<a name="l00350"></a>00350                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00351"></a>00351                 addr += vga.svga.bank_read_full;
<a name="l00352"></a>00352                 addr = CHECKED(addr);
<a name="l00353"></a>00353                 <span class="keywordflow">return</span> readHandler8( addr );
<a name="l00354"></a>00354         }
<a name="l00355"></a>00355         Bitu readw(PhysPt addr ) {
<a name="l00356"></a>00356                 VGAMEM_USEC_read_delay();
<a name="l00357"></a>00357                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00358"></a>00358                 addr += vga.svga.bank_read_full;
<a name="l00359"></a>00359                 addr = CHECKED(addr);
<a name="l00360"></a>00360                 Bitu ret = (readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00361"></a>00361                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00362"></a>00362                 <span class="keywordflow">return</span> ret;
<a name="l00363"></a>00363         }
<a name="l00364"></a>00364         Bitu readd(PhysPt addr ) {
<a name="l00365"></a>00365                 VGAMEM_USEC_read_delay();
<a name="l00366"></a>00366                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00367"></a>00367                 addr += vga.svga.bank_read_full;
<a name="l00368"></a>00368                 addr = CHECKED(addr);
<a name="l00369"></a>00369                 Bitu ret = (readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00370"></a>00370                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00371"></a>00371                 ret     |= (readHandler8( addr+2 ) &lt;&lt; 16 );
<a name="l00372"></a>00372                 ret     |= (readHandler8( addr+3 ) &lt;&lt; 24 );
<a name="l00373"></a>00373                 <span class="keywordflow">return</span> ret;
<a name="l00374"></a>00374         }
<a name="l00375"></a>00375         <span class="keywordtype">void</span> writeb(PhysPt addr, Bitu val ) {
<a name="l00376"></a>00376                 VGAMEM_USEC_write_delay();
<a name="l00377"></a>00377                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00378"></a>00378                 addr += vga.svga.bank_write_full;
<a name="l00379"></a>00379                 addr = CHECKED(addr);
<a name="l00380"></a>00380                 writeHandler8( addr, val );
<a name="l00381"></a>00381         }
<a name="l00382"></a>00382         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00383"></a>00383                 VGAMEM_USEC_write_delay();
<a name="l00384"></a>00384                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00385"></a>00385                 addr += vga.svga.bank_write_full;
<a name="l00386"></a>00386                 addr = CHECKED(addr);
<a name="l00387"></a>00387                 writeHandler8( addr+0, val &gt;&gt; 0 );
<a name="l00388"></a>00388                 writeHandler8( addr+1, val &gt;&gt; 8 );
<a name="l00389"></a>00389         }
<a name="l00390"></a>00390         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00391"></a>00391                 VGAMEM_USEC_write_delay();
<a name="l00392"></a>00392                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00393"></a>00393                 addr += vga.svga.bank_write_full;
<a name="l00394"></a>00394                 addr = CHECKED(addr);
<a name="l00395"></a>00395                 writeHandler8( addr+0, val &gt;&gt; 0 );
<a name="l00396"></a>00396                 writeHandler8( addr+1, val &gt;&gt; 8 );
<a name="l00397"></a>00397                 writeHandler8( addr+2, val &gt;&gt; 16 );
<a name="l00398"></a>00398                 writeHandler8( addr+3, val &gt;&gt; 24 );
<a name="l00399"></a>00399         }
<a name="l00400"></a>00400 };
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 <span class="comment">//Slighly unusual version, will directly write 8,16,32 bits values</span>
<a name="l00403"></a><a class="code" href="classVGA__ChainedVGA__Handler.html">00403</a> <span class="keyword">class </span><a class="code" href="classVGA__ChainedVGA__Handler.html">VGA_ChainedVGA_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00404"></a>00404 <span class="keyword">public</span>:
<a name="l00405"></a>00405         <a class="code" href="classVGA__ChainedVGA__Handler.html">VGA_ChainedVGA_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00406"></a>00406         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Size&gt;
<a name="l00407"></a>00407         <span class="keyword">static</span> INLINE Bitu readHandler(PhysPt addr ) {
<a name="l00408"></a>00408                 <span class="keywordflow">return</span> hostRead&lt;Size&gt;( &amp;vga.mem.linear[((addr&amp;0xFFFC)&lt;&lt;2)+(addr&amp;3)] );
<a name="l00409"></a>00409         }
<a name="l00410"></a>00410         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Size&gt;
<a name="l00411"></a>00411         <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> writeHandler(PhysPt addr, Bitu val) {
<a name="l00412"></a>00412                 <span class="comment">// No need to check for compatible chains here, this one is only enabled if that bit is set</span>
<a name="l00413"></a>00413                 hostWrite&lt;Size&gt;( &amp;vga.mem.linear[((addr&amp;0xFFFC)&lt;&lt;2)+(addr&amp;3)], val );
<a name="l00414"></a>00414         }
<a name="l00415"></a>00415         Bitu readb(PhysPt addr ) {
<a name="l00416"></a>00416                 VGAMEM_USEC_read_delay();
<a name="l00417"></a>00417                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00418"></a>00418                 addr += vga.svga.bank_read_full;
<a name="l00419"></a>00419                 addr = CHECKED(addr);
<a name="l00420"></a>00420                 <span class="keywordflow">return</span> readHandler&lt;Bit8u&gt;( addr );
<a name="l00421"></a>00421         }
<a name="l00422"></a>00422         Bitu readw(PhysPt addr ) {
<a name="l00423"></a>00423                 VGAMEM_USEC_read_delay();
<a name="l00424"></a>00424                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00425"></a>00425                 addr += vga.svga.bank_read_full;
<a name="l00426"></a>00426                 addr = CHECKED(addr);
<a name="l00427"></a>00427                 <span class="keywordflow">if</span> (GCC_UNLIKELY(addr &amp; 1)) {
<a name="l00428"></a>00428                         Bitu ret = (readHandler&lt;Bit8u&gt;( addr+0 ) &lt;&lt; 0 );
<a name="l00429"></a>00429                         ret     |= (readHandler&lt;Bit8u&gt;( addr+1 ) &lt;&lt; 8 );
<a name="l00430"></a>00430                         <span class="keywordflow">return</span> ret;
<a name="l00431"></a>00431                 } <span class="keywordflow">else</span>
<a name="l00432"></a>00432                         <span class="keywordflow">return</span> readHandler&lt;Bit16u&gt;( addr );
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434         Bitu readd(PhysPt addr ) {
<a name="l00435"></a>00435                 VGAMEM_USEC_read_delay();
<a name="l00436"></a>00436                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00437"></a>00437                 addr += vga.svga.bank_read_full;
<a name="l00438"></a>00438                 addr = CHECKED(addr);
<a name="l00439"></a>00439                 <span class="keywordflow">if</span> (GCC_UNLIKELY(addr &amp; 3)) {
<a name="l00440"></a>00440                         Bitu ret = (readHandler&lt;Bit8u&gt;( addr+0 ) &lt;&lt; 0 );
<a name="l00441"></a>00441                         ret     |= (readHandler&lt;Bit8u&gt;( addr+1 ) &lt;&lt; 8 );
<a name="l00442"></a>00442                         ret     |= (readHandler&lt;Bit8u&gt;( addr+2 ) &lt;&lt; 16 );
<a name="l00443"></a>00443                         ret     |= (readHandler&lt;Bit8u&gt;( addr+3 ) &lt;&lt; 24 );
<a name="l00444"></a>00444                         <span class="keywordflow">return</span> ret;
<a name="l00445"></a>00445                 } <span class="keywordflow">else</span>
<a name="l00446"></a>00446                         <span class="keywordflow">return</span> readHandler&lt;Bit32u&gt;( addr );
<a name="l00447"></a>00447         }
<a name="l00448"></a>00448         <span class="keywordtype">void</span> writeb(PhysPt addr, Bitu val ) {
<a name="l00449"></a>00449                 VGAMEM_USEC_write_delay();
<a name="l00450"></a>00450                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00451"></a>00451                 addr += vga.svga.bank_write_full;
<a name="l00452"></a>00452                 addr = CHECKED(addr);
<a name="l00453"></a>00453                 writeHandler&lt;Bit8u&gt;( addr, val );
<a name="l00454"></a>00454         }
<a name="l00455"></a>00455         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00456"></a>00456                 VGAMEM_USEC_write_delay();
<a name="l00457"></a>00457                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00458"></a>00458                 addr += vga.svga.bank_write_full;
<a name="l00459"></a>00459                 addr = CHECKED(addr);
<a name="l00460"></a>00460                 <span class="keywordflow">if</span> (GCC_UNLIKELY(addr &amp; 1)) {
<a name="l00461"></a>00461                         writeHandler&lt;Bit8u&gt;( addr+0, val &gt;&gt; 0 );
<a name="l00462"></a>00462                         writeHandler&lt;Bit8u&gt;( addr+1, val &gt;&gt; 8 );
<a name="l00463"></a>00463                 } <span class="keywordflow">else</span> {
<a name="l00464"></a>00464                         writeHandler&lt;Bit16u&gt;( addr, val );
<a name="l00465"></a>00465                 }
<a name="l00466"></a>00466         }
<a name="l00467"></a>00467         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00468"></a>00468                 VGAMEM_USEC_write_delay();
<a name="l00469"></a>00469                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00470"></a>00470                 addr += vga.svga.bank_write_full;
<a name="l00471"></a>00471                 addr = CHECKED(addr);
<a name="l00472"></a>00472                 <span class="keywordflow">if</span> (GCC_UNLIKELY(addr &amp; 3)) {
<a name="l00473"></a>00473                         writeHandler&lt;Bit8u&gt;( addr+0, val &gt;&gt; 0 );
<a name="l00474"></a>00474                         writeHandler&lt;Bit8u&gt;( addr+1, val &gt;&gt; 8 );
<a name="l00475"></a>00475                         writeHandler&lt;Bit8u&gt;( addr+2, val &gt;&gt; 16 );
<a name="l00476"></a>00476                         writeHandler&lt;Bit8u&gt;( addr+3, val &gt;&gt; 24 );
<a name="l00477"></a>00477                 } <span class="keywordflow">else</span> {
<a name="l00478"></a>00478                         writeHandler&lt;Bit32u&gt;( addr, val );
<a name="l00479"></a>00479                 }
<a name="l00480"></a>00480         }
<a name="l00481"></a>00481 };
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 <span class="comment">// alternate version for ET4000 emulation.</span>
<a name="l00484"></a>00484 <span class="comment">// ET4000 cards implement 256-color chain-4 differently than most cards.</span>
<a name="l00485"></a><a class="code" href="classVGA__ET4000__ChainedVGA__Handler.html">00485</a> <span class="keyword">class </span><a class="code" href="classVGA__ET4000__ChainedVGA__Handler.html">VGA_ET4000_ChainedVGA_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00486"></a>00486 <span class="keyword">public</span>:
<a name="l00487"></a>00487         <a class="code" href="classVGA__ET4000__ChainedVGA__Handler.html">VGA_ET4000_ChainedVGA_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00488"></a>00488         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Size&gt;
<a name="l00489"></a>00489         <span class="keyword">static</span> INLINE Bitu readHandler(PhysPt addr ) {
<a name="l00490"></a>00490                 <span class="keywordflow">return</span> hostRead&lt;Size&gt;( &amp;vga.mem.linear[addr] );
<a name="l00491"></a>00491         }
<a name="l00492"></a>00492         <span class="keyword">template</span> &lt;<span class="keyword">class</span> Size&gt;
<a name="l00493"></a>00493         <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> writeHandler(PhysPt addr, Bitu val) {
<a name="l00494"></a>00494                 <span class="comment">// No need to check for compatible chains here, this one is only enabled if that bit is set</span>
<a name="l00495"></a>00495                 hostWrite&lt;Size&gt;( &amp;vga.mem.linear[addr], val );
<a name="l00496"></a>00496         }
<a name="l00497"></a>00497         Bitu readb(PhysPt addr ) {
<a name="l00498"></a>00498                 VGAMEM_USEC_read_delay();
<a name="l00499"></a>00499                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00500"></a>00500                 addr += vga.svga.bank_read_full;
<a name="l00501"></a>00501                 addr = CHECKED(addr);
<a name="l00502"></a>00502                 <span class="keywordflow">return</span> readHandler&lt;Bit8u&gt;( addr );
<a name="l00503"></a>00503         }
<a name="l00504"></a>00504         Bitu readw(PhysPt addr ) {
<a name="l00505"></a>00505                 VGAMEM_USEC_read_delay();
<a name="l00506"></a>00506                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00507"></a>00507                 addr += vga.svga.bank_read_full;
<a name="l00508"></a>00508                 addr = CHECKED(addr);
<a name="l00509"></a>00509                 <span class="keywordflow">if</span> (GCC_UNLIKELY(addr &amp; 1)) {
<a name="l00510"></a>00510                         Bitu ret = (readHandler&lt;Bit8u&gt;( addr+0 ) &lt;&lt; 0 );
<a name="l00511"></a>00511                         ret     |= (readHandler&lt;Bit8u&gt;( addr+1 ) &lt;&lt; 8 );
<a name="l00512"></a>00512                         <span class="keywordflow">return</span> ret;
<a name="l00513"></a>00513                 } <span class="keywordflow">else</span>
<a name="l00514"></a>00514                         <span class="keywordflow">return</span> readHandler&lt;Bit16u&gt;( addr );
<a name="l00515"></a>00515         }
<a name="l00516"></a>00516         Bitu readd(PhysPt addr ) {
<a name="l00517"></a>00517                 VGAMEM_USEC_read_delay();
<a name="l00518"></a>00518                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00519"></a>00519                 addr += vga.svga.bank_read_full;
<a name="l00520"></a>00520                 addr = CHECKED(addr);
<a name="l00521"></a>00521                 <span class="keywordflow">if</span> (GCC_UNLIKELY(addr &amp; 3)) {
<a name="l00522"></a>00522                         Bitu ret = (readHandler&lt;Bit8u&gt;( addr+0 ) &lt;&lt; 0 );
<a name="l00523"></a>00523                         ret     |= (readHandler&lt;Bit8u&gt;( addr+1 ) &lt;&lt; 8 );
<a name="l00524"></a>00524                         ret     |= (readHandler&lt;Bit8u&gt;( addr+2 ) &lt;&lt; 16 );
<a name="l00525"></a>00525                         ret     |= (readHandler&lt;Bit8u&gt;( addr+3 ) &lt;&lt; 24 );
<a name="l00526"></a>00526                         <span class="keywordflow">return</span> ret;
<a name="l00527"></a>00527                 } <span class="keywordflow">else</span>
<a name="l00528"></a>00528                         <span class="keywordflow">return</span> readHandler&lt;Bit32u&gt;( addr );
<a name="l00529"></a>00529         }
<a name="l00530"></a>00530         <span class="keywordtype">void</span> writeb(PhysPt addr, Bitu val ) {
<a name="l00531"></a>00531                 VGAMEM_USEC_write_delay();
<a name="l00532"></a>00532                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00533"></a>00533                 addr += vga.svga.bank_write_full;
<a name="l00534"></a>00534                 addr = CHECKED(addr);
<a name="l00535"></a>00535                 writeHandler&lt;Bit8u&gt;( addr, val );
<a name="l00536"></a>00536         }
<a name="l00537"></a>00537         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00538"></a>00538                 VGAMEM_USEC_write_delay();
<a name="l00539"></a>00539                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00540"></a>00540                 addr += vga.svga.bank_write_full;
<a name="l00541"></a>00541                 addr = CHECKED(addr);
<a name="l00542"></a>00542                 <span class="keywordflow">if</span> (GCC_UNLIKELY(addr &amp; 1)) {
<a name="l00543"></a>00543                         writeHandler&lt;Bit8u&gt;( addr+0, val &gt;&gt; 0 );
<a name="l00544"></a>00544                         writeHandler&lt;Bit8u&gt;( addr+1, val &gt;&gt; 8 );
<a name="l00545"></a>00545                 } <span class="keywordflow">else</span> {
<a name="l00546"></a>00546                         writeHandler&lt;Bit16u&gt;( addr, val );
<a name="l00547"></a>00547                 }
<a name="l00548"></a>00548         }
<a name="l00549"></a>00549         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00550"></a>00550                 VGAMEM_USEC_write_delay();
<a name="l00551"></a>00551                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00552"></a>00552                 addr += vga.svga.bank_write_full;
<a name="l00553"></a>00553                 addr = CHECKED(addr);
<a name="l00554"></a>00554                 <span class="keywordflow">if</span> (GCC_UNLIKELY(addr &amp; 3)) {
<a name="l00555"></a>00555                         writeHandler&lt;Bit8u&gt;( addr+0, val &gt;&gt; 0 );
<a name="l00556"></a>00556                         writeHandler&lt;Bit8u&gt;( addr+1, val &gt;&gt; 8 );
<a name="l00557"></a>00557                         writeHandler&lt;Bit8u&gt;( addr+2, val &gt;&gt; 16 );
<a name="l00558"></a>00558                         writeHandler&lt;Bit8u&gt;( addr+3, val &gt;&gt; 24 );
<a name="l00559"></a>00559                 } <span class="keywordflow">else</span> {
<a name="l00560"></a>00560                         writeHandler&lt;Bit32u&gt;( addr, val );
<a name="l00561"></a>00561                 }
<a name="l00562"></a>00562         }
<a name="l00563"></a>00563 };
<a name="l00564"></a>00564 
<a name="l00565"></a><a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">00565</a> <span class="keyword">class </span><a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">VGA_ET4000_ChainedVGA_Slow_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00566"></a>00566 <span class="keyword">public</span>:
<a name="l00567"></a>00567         <a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">VGA_ET4000_ChainedVGA_Slow_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00568"></a>00568         <span class="keyword">static</span> INLINE Bitu readHandler8(PhysPt addr ) {
<a name="l00569"></a>00569                 vga.latch.d=((Bit32u*)vga.mem.linear)[addr&gt;&gt;2];
<a name="l00570"></a>00570                 <span class="keywordflow">return</span> vga.latch.b[addr&amp;3];
<a name="l00571"></a>00571         }
<a name="l00572"></a>00572         <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> writeHandler8(PhysPt addr, Bitu val) {
<a name="l00573"></a>00573                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> pixels;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575                 <span class="comment">/* byte-sized template specialization with masking */</span>
<a name="l00576"></a>00576                 pixels.d = ModeOperation(val);
<a name="l00577"></a>00577                 <span class="comment">/* Update video memory and the pixel buffer */</span>
<a name="l00578"></a>00578                 hostWrite&lt;Bit8u&gt;( &amp;vga.mem.linear[addr], pixels.b[addr&amp;3] );
<a name="l00579"></a>00579         }
<a name="l00580"></a>00580         Bitu readb(PhysPt addr ) {
<a name="l00581"></a>00581                 VGAMEM_USEC_read_delay();
<a name="l00582"></a>00582                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00583"></a>00583                 addr += vga.svga.bank_read_full;
<a name="l00584"></a>00584                 addr = CHECKED(addr);
<a name="l00585"></a>00585                 <span class="keywordflow">return</span> readHandler8( addr );
<a name="l00586"></a>00586         }
<a name="l00587"></a>00587         Bitu readw(PhysPt addr ) {
<a name="l00588"></a>00588                 VGAMEM_USEC_read_delay();
<a name="l00589"></a>00589                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00590"></a>00590                 addr += vga.svga.bank_read_full;
<a name="l00591"></a>00591                 addr = CHECKED(addr);
<a name="l00592"></a>00592                 Bitu ret = (readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00593"></a>00593                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00594"></a>00594                 <span class="keywordflow">return</span> ret;
<a name="l00595"></a>00595         }
<a name="l00596"></a>00596         Bitu readd(PhysPt addr ) {
<a name="l00597"></a>00597                 VGAMEM_USEC_read_delay();
<a name="l00598"></a>00598                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00599"></a>00599                 addr += vga.svga.bank_read_full;
<a name="l00600"></a>00600                 addr = CHECKED(addr);
<a name="l00601"></a>00601                 Bitu ret = (readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00602"></a>00602                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00603"></a>00603                 ret     |= (readHandler8( addr+2 ) &lt;&lt; 16 );
<a name="l00604"></a>00604                 ret     |= (readHandler8( addr+3 ) &lt;&lt; 24 );
<a name="l00605"></a>00605                 <span class="keywordflow">return</span> ret;
<a name="l00606"></a>00606         }
<a name="l00607"></a>00607         <span class="keywordtype">void</span> writeb(PhysPt addr, Bitu val ) {
<a name="l00608"></a>00608                 VGAMEM_USEC_write_delay();
<a name="l00609"></a>00609                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00610"></a>00610                 addr += vga.svga.bank_write_full;
<a name="l00611"></a>00611                 addr = CHECKED(addr);
<a name="l00612"></a>00612                 writeHandler8( addr, val );
<a name="l00613"></a>00613         }
<a name="l00614"></a>00614         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00615"></a>00615                 VGAMEM_USEC_write_delay();
<a name="l00616"></a>00616                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00617"></a>00617                 addr += vga.svga.bank_write_full;
<a name="l00618"></a>00618                 addr = CHECKED(addr);
<a name="l00619"></a>00619                 writeHandler8( addr+0, val &gt;&gt; 0 );
<a name="l00620"></a>00620                 writeHandler8( addr+1, val &gt;&gt; 8 );
<a name="l00621"></a>00621         }
<a name="l00622"></a>00622         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00623"></a>00623                 VGAMEM_USEC_write_delay();
<a name="l00624"></a>00624                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00625"></a>00625                 addr += vga.svga.bank_write_full;
<a name="l00626"></a>00626                 addr = CHECKED(addr);
<a name="l00627"></a>00627                 writeHandler8( addr+0, val &gt;&gt; 0 );
<a name="l00628"></a>00628                 writeHandler8( addr+1, val &gt;&gt; 8 );
<a name="l00629"></a>00629                 writeHandler8( addr+2, val &gt;&gt; 16 );
<a name="l00630"></a>00630                 writeHandler8( addr+3, val &gt;&gt; 24 );
<a name="l00631"></a>00631         }
<a name="l00632"></a>00632 };
<a name="l00633"></a>00633 
<a name="l00634"></a><a class="code" href="classVGA__UnchainedVGA__Handler.html">00634</a> <span class="keyword">class </span><a class="code" href="classVGA__UnchainedVGA__Handler.html">VGA_UnchainedVGA_Handler</a> : <span class="keyword">public</span> <a class="code" href="classVGA__UnchainedRead__Handler.html">VGA_UnchainedRead_Handler</a> {
<a name="l00635"></a>00635 <span class="keyword">public</span>:
<a name="l00636"></a>00636         <span class="keywordtype">void</span> writeHandler( PhysPt addr, Bit8u val ) {
<a name="l00637"></a>00637                 PhysPt memaddr = addr;
<a name="l00638"></a>00638                 Bit32u data=ModeOperation(val);
<a name="l00639"></a>00639                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> pixels;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641                 <span class="keywordflow">if</span> (vga.gfx.miscellaneous&amp;2) <span class="comment">/* Odd/Even mode masks off A0 */</span>
<a name="l00642"></a>00642                         memaddr &amp;= ~1;
<a name="l00643"></a>00643 
<a name="l00644"></a>00644                 pixels.d=((Bit32u*)vga.mem.linear)[memaddr];
<a name="l00645"></a>00645 
<a name="l00646"></a>00646                 <span class="comment">/* Odd/even emulation, emulation fix for Windows 95&#39;s boot screen */</span>
<a name="l00647"></a>00647                 <span class="keywordflow">if</span> (!(vga.seq.memory_mode&amp;4)) {
<a name="l00648"></a>00648                         <span class="comment">/* You&#39;re probably wondering what the hell odd/even mode has to do with Windows 95&#39;s boot</span>
<a name="l00649"></a>00649 <span class="comment">                         * screen, right? Well, hopefully you won&#39;t puke when you read the following...</span>
<a name="l00650"></a>00650 <span class="comment">                         * </span>
<a name="l00651"></a>00651 <span class="comment">                         * When Windows 95 starts up and shows it&#39;s boot logo, it calls INT 10h to set mode 0x13.</span>
<a name="l00652"></a>00652 <span class="comment">                         * But it calls INT 10h with AX=0x93 which means set mode 0x13 and don&#39;t clear VRAM. Then,</span>
<a name="l00653"></a>00653 <span class="comment">                         * it uses mode X to write the logo to the BOTTOM half of VGA RAM, at 0x8000 to be exact,</span>
<a name="l00654"></a>00654 <span class="comment">                         * and of course, reprograms the CRTC offset register to make that visible.</span>
<a name="l00655"></a>00655 <span class="comment">                         * THEN, it reprograms the registers to map VRAM at 0xB800, disable Chain 4, re-enable</span>
<a name="l00656"></a>00656 <span class="comment">                         * odd/even mode, and then allows both DOS and the BIOS to write to the top half of VRAM</span>
<a name="l00657"></a>00657 <span class="comment">                         * as if still running in 80x25 alphanumeric text mode. It even sets the video mode byte</span>
<a name="l00658"></a>00658 <span class="comment">                         * at 0x40:0x49 to 0x03 to continue the illusion!</span>
<a name="l00659"></a>00659 <span class="comment">                         *</span>
<a name="l00660"></a>00660 <span class="comment">                         * When Windows 95 is ready to restore text mode, it just switches back (this time, calling</span>
<a name="l00661"></a>00661 <span class="comment">                         * the saved INT 10h pointer directly) again without clearing VRAM.</span>
<a name="l00662"></a>00662 <span class="comment">                         *</span>
<a name="l00663"></a>00663 <span class="comment">                         * So if you wonder why I would spend time implementing odd/even emulation for VGA unchained</span>
<a name="l00664"></a>00664 <span class="comment">                         * mode... that&#39;s why. You can thank Microsoft for that. */</span>
<a name="l00665"></a>00665                         <span class="keywordflow">if</span> (addr &amp; 1) {
<a name="l00666"></a>00666                                 <span class="keywordflow">if</span> (vga.seq.map_mask &amp; 0x2) <span class="comment">/* bitplane 1: attribute RAM */</span>
<a name="l00667"></a>00667                                         pixels.b[1] = data &gt;&gt; 8;
<a name="l00668"></a>00668                                 <span class="keywordflow">if</span> (vga.seq.map_mask &amp; 0x8) <span class="comment">/* bitplane 3: unused RAM */</span>
<a name="l00669"></a>00669                                         pixels.b[3] = data &gt;&gt; 24;
<a name="l00670"></a>00670                         }
<a name="l00671"></a>00671                         <span class="keywordflow">else</span> {
<a name="l00672"></a>00672                                 <span class="keywordflow">if</span> (vga.seq.map_mask &amp; 0x1) <span class="comment">/* bitplane 0: character RAM */</span>
<a name="l00673"></a>00673                                         pixels.b[0] = data;
<a name="l00674"></a>00674                                 <span class="keywordflow">if</span> (vga.seq.map_mask &amp; 0x4) { <span class="comment">/* bitplane 2: font RAM */</span>
<a name="l00675"></a>00675                                         pixels.b[2] = data &gt;&gt; 16;
<a name="l00676"></a>00676                                         vga.draw.font[memaddr] = data &gt;&gt; 16;
<a name="l00677"></a>00677                                 }
<a name="l00678"></a>00678                         }
<a name="l00679"></a>00679                 }
<a name="l00680"></a>00680                 <span class="keywordflow">else</span> {
<a name="l00681"></a>00681                         pixels.d&amp;=vga.config.full_not_map_mask;
<a name="l00682"></a>00682                         pixels.d|=(data &amp; vga.config.full_map_mask);
<a name="l00683"></a>00683                 }
<a name="l00684"></a>00684 
<a name="l00685"></a>00685                 ((Bit32u*)vga.mem.linear)[memaddr]=pixels.d;
<a name="l00686"></a>00686         }
<a name="l00687"></a>00687 <span class="keyword">public</span>:
<a name="l00688"></a>00688         <a class="code" href="classVGA__UnchainedVGA__Handler.html">VGA_UnchainedVGA_Handler</a>() : <a class="code" href="classVGA__UnchainedRead__Handler.html">VGA_UnchainedRead_Handler</a>(PFLAG_NOCODE) {}
<a name="l00689"></a>00689         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l00690"></a>00690                 VGAMEM_USEC_write_delay();
<a name="l00691"></a>00691                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00692"></a>00692                 addr += vga.svga.bank_write_full;
<a name="l00693"></a>00693                 addr = CHECKED2(addr);
<a name="l00694"></a>00694                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00695"></a>00695         }
<a name="l00696"></a>00696         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00697"></a>00697                 VGAMEM_USEC_write_delay();
<a name="l00698"></a>00698                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00699"></a>00699                 addr += vga.svga.bank_write_full;
<a name="l00700"></a>00700                 addr = CHECKED2(addr);
<a name="l00701"></a>00701                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00702"></a>00702                 writeHandler(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l00703"></a>00703         }
<a name="l00704"></a>00704         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00705"></a>00705                 VGAMEM_USEC_write_delay();
<a name="l00706"></a>00706                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00707"></a>00707                 addr += vga.svga.bank_write_full;
<a name="l00708"></a>00708                 addr = CHECKED2(addr);
<a name="l00709"></a>00709                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00710"></a>00710                 writeHandler(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l00711"></a>00711                 writeHandler(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l00712"></a>00712                 writeHandler(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l00713"></a>00713         }
<a name="l00714"></a>00714 };
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00717"></a>00717 
<a name="l00718"></a><a class="code" href="classVGA__CGATEXT__PageHandler.html">00718</a> <span class="keyword">class </span><a class="code" href="classVGA__CGATEXT__PageHandler.html">VGA_CGATEXT_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00719"></a>00719 <span class="keyword">public</span>:
<a name="l00720"></a>00720         <a class="code" href="classVGA__CGATEXT__PageHandler.html">VGA_CGATEXT_PageHandler</a>() {
<a name="l00721"></a>00721                 flags=PFLAG_NOCODE;
<a name="l00722"></a>00722         }
<a name="l00723"></a>00723         Bitu readb(PhysPt addr) {
<a name="l00724"></a>00724                 addr = PAGING_GetPhysicalAddress(addr) &amp; 0x3FFF;
<a name="l00725"></a>00725                 VGAMEM_USEC_read_delay();
<a name="l00726"></a>00726                 <span class="keywordflow">return</span> vga.tandy.mem_base[addr];
<a name="l00727"></a>00727         }
<a name="l00728"></a>00728         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val){
<a name="l00729"></a>00729                 VGAMEM_USEC_write_delay();
<a name="l00730"></a>00730 
<a name="l00731"></a>00731                 <span class="keywordflow">if</span> (enableCGASnow) {
<a name="l00732"></a>00732                         <span class="comment">/* NTS: We can&#39;t use PIC_FullIndex() exclusively because it&#39;s not precise enough</span>
<a name="l00733"></a>00733 <span class="comment">                         *      with respect to when DOSBox CPU emulation is writing. We have to use other</span>
<a name="l00734"></a>00734 <span class="comment">                         *      variables like CPU_Cycles to gain additional precision */</span>
<a name="l00735"></a>00735                         <span class="keywordtype">double</span> timeInFrame = PIC_FullIndex()-vga.draw.delay.framestart;
<a name="l00736"></a>00736                         <span class="keywordtype">double</span> timeInLine = fmod(timeInFrame,vga.draw.delay.htotal);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738                         <span class="comment">/* we&#39;re in active area. which column should the snow show up on? */</span>
<a name="l00739"></a>00739                         Bit32u x = (Bit32u)((timeInLine * 80) / vga.draw.delay.hblkstart);
<a name="l00740"></a>00740                         <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span>)x &lt; 80) vga.draw.cga_snow[x] = val;
<a name="l00741"></a>00741                 }
<a name="l00742"></a>00742 
<a name="l00743"></a>00743                 addr = PAGING_GetPhysicalAddress(addr) &amp; 0x3FFF;
<a name="l00744"></a>00744                 vga.tandy.mem_base[addr] = val;
<a name="l00745"></a>00745         }
<a name="l00746"></a>00746 };
<a name="l00747"></a>00747 
<a name="l00748"></a>00748 <span class="keyword">extern</span> uint8_t pc98_egc_srcmask[2]; <span class="comment">/* host given (Neko: egc.srcmask) */</span>
<a name="l00749"></a>00749 <span class="keyword">extern</span> uint8_t pc98_egc_maskef[2]; <span class="comment">/* effective (Neko: egc.mask2) */</span>
<a name="l00750"></a>00750 <span class="keyword">extern</span> uint8_t pc98_egc_mask[2]; <span class="comment">/* host given (Neko: egc.mask) */</span>
<a name="l00751"></a>00751 <span class="keyword">extern</span> uint8_t pc98_egc_access;
<a name="l00752"></a>00752 <span class="keyword">extern</span> uint8_t pc98_egc_fgc;
<a name="l00753"></a>00753 <span class="keyword">extern</span> uint8_t pc98_egc_foreground_color;
<a name="l00754"></a>00754 <span class="keyword">extern</span> uint8_t pc98_egc_background_color;
<a name="l00755"></a>00755 <span class="keyword">extern</span> uint8_t pc98_egc_lead_plane;
<a name="l00756"></a>00756 <span class="keyword">extern</span> uint8_t pc98_egc_compare_lead;
<a name="l00757"></a>00757 <span class="keyword">extern</span> uint8_t pc98_egc_lightsource;
<a name="l00758"></a>00758 <span class="keyword">extern</span> uint8_t pc98_egc_shiftinput;
<a name="l00759"></a>00759 <span class="keyword">extern</span> uint8_t pc98_egc_regload;
<a name="l00760"></a>00760 <span class="keyword">extern</span> uint8_t pc98_egc_rop;
<a name="l00761"></a>00761 
<a name="l00762"></a>00762 <span class="keyword">extern</span> <span class="keywordtype">bool</span> pc98_egc_shift_descend;
<a name="l00763"></a>00763 <span class="keyword">extern</span> uint8_t pc98_egc_shift_destbit;
<a name="l00764"></a>00764 <span class="keyword">extern</span> uint8_t pc98_egc_shift_srcbit;
<a name="l00765"></a>00765 <span class="keyword">extern</span> uint16_t pc98_egc_shift_length;
<a name="l00766"></a>00766 
<a name="l00767"></a>00767 <span class="comment">/* I don&#39;t think we necessarily need the full 4096 bit buffer</span>
<a name="l00768"></a>00768 <span class="comment"> * Neko Project II uses to render things, though that is</span>
<a name="l00769"></a>00769 <span class="comment"> * probably faster to execute. It makes it hard to make sense</span>
<a name="l00770"></a>00770 <span class="comment"> * of the code though. */</span>
<a name="l00771"></a><a class="code" href="structpc98__egc__shifter.html">00771</a> <span class="keyword">struct </span><a class="code" href="structpc98__egc__shifter.html">pc98_egc_shifter</a> {
<a name="l00772"></a>00772     <a class="code" href="structpc98__egc__shifter.html">pc98_egc_shifter</a>() : decrement(<span class="keyword">false</span>), remain(0x10), srcbit(0), dstbit(0) { }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774     <span class="keywordtype">void</span> reinit(<span class="keywordtype">void</span>) { <span class="comment">/* from global vars set by guest */</span>
<a name="l00775"></a>00775         decrement = pc98_egc_shift_descend;
<a name="l00776"></a>00776         remain = pc98_egc_shift_length + 1; <span class="comment">/* the register is length - 1 apparently */</span>
<a name="l00777"></a>00777         dstbit = pc98_egc_shift_destbit;
<a name="l00778"></a>00778         srcbit = pc98_egc_shift_srcbit;
<a name="l00779"></a>00779         bufi = bufo = decrement ? (<span class="keyword">sizeof</span>(buffer) + 3 - (4*4)) : 0;
<a name="l00780"></a>00780 
<a name="l00781"></a>00781         <span class="keywordflow">if</span> ((srcbit&amp;7) &lt; (dstbit&amp;7)) {
<a name="l00782"></a>00782             shft8bitr = (dstbit&amp;7) - (srcbit&amp;7);
<a name="l00783"></a>00783             shft8bitl = 8 - shft8bitr;
<a name="l00784"></a>00784         }
<a name="l00785"></a>00785         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((srcbit&amp;7) &gt; (dstbit&amp;7)) {
<a name="l00786"></a>00786             shft8bitl = (srcbit&amp;7) - (dstbit&amp;7);
<a name="l00787"></a>00787             shft8bitr = 8 - shft8bitl;
<a name="l00788"></a>00788         }
<a name="l00789"></a>00789         <span class="keywordflow">else</span> {
<a name="l00790"></a>00790             shft8bitr = 0;
<a name="l00791"></a>00791             shft8bitl = 0;
<a name="l00792"></a>00792         }
<a name="l00793"></a>00793 
<a name="l00794"></a>00794         shft8load = 0;
<a name="l00795"></a>00795         o_srcbit = srcbit &amp; 7;
<a name="l00796"></a>00796         o_dstbit = dstbit &amp; 7;
<a name="l00797"></a>00797     }
<a name="l00798"></a>00798 
<a name="l00799"></a>00799     <span class="keywordtype">bool</span>                decrement;
<a name="l00800"></a>00800     uint16_t            remain;
<a name="l00801"></a>00801     uint16_t            srcbit;
<a name="l00802"></a>00802     uint16_t            dstbit;
<a name="l00803"></a>00803     uint16_t            o_srcbit;
<a name="l00804"></a>00804     uint16_t            o_dstbit;
<a name="l00805"></a>00805 
<a name="l00806"></a>00806     uint8_t             buffer[512]; <span class="comment">/* 4096/8 = 512 */</span>
<a name="l00807"></a>00807     uint16_t            bufi,bufo;
<a name="l00808"></a>00808 
<a name="l00809"></a>00809     uint8_t             shft8load;
<a name="l00810"></a>00810     uint8_t             shft8bitr;
<a name="l00811"></a>00811     uint8_t             shft8bitl;
<a name="l00812"></a>00812 
<a name="l00813"></a>00813     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> bi(<span class="keyword">const</span> uint16_t ofs,<span class="keyword">const</span> AWT val) {
<a name="l00814"></a>00814         <span class="keywordtype">size_t</span> ip = (bufi + ofs) &amp; (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00815"></a>00815 
<a name="l00816"></a>00816         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; <span class="keyword">sizeof</span>(AWT);) {
<a name="l00817"></a>00817             buffer[ip] = (uint8_t)(val &gt;&gt; ((AWT)(i * 8U)));
<a name="l00818"></a>00818             <span class="keywordflow">if</span> ((++ip) == <span class="keyword">sizeof</span>(buffer)) ip = 0;
<a name="l00819"></a>00819             i++;
<a name="l00820"></a>00820         }
<a name="l00821"></a>00821     }
<a name="l00822"></a>00822 
<a name="l00823"></a>00823     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> bi_adv(<span class="keywordtype">void</span>) {
<a name="l00824"></a>00824         bufi += pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) - <span class="keyword">sizeof</span>(AWT)) : <span class="keyword">sizeof</span>(AWT);
<a name="l00825"></a>00825         bufi &amp;= (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00826"></a>00826     }
<a name="l00827"></a>00827 
<a name="l00828"></a>00828     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> AWT bo(<span class="keyword">const</span> uint16_t ofs) {
<a name="l00829"></a>00829         <span class="keywordtype">size_t</span> op = (bufo + ofs) &amp; (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00830"></a>00830         AWT ret = 0;
<a name="l00831"></a>00831 
<a name="l00832"></a>00832         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; <span class="keyword">sizeof</span>(AWT);) {
<a name="l00833"></a>00833             ret += ((AWT)buffer[op]) &lt;&lt; ((AWT)(i * 8U));
<a name="l00834"></a>00834             <span class="keywordflow">if</span> ((++op) == <span class="keyword">sizeof</span>(buffer)) op = 0;
<a name="l00835"></a>00835             i++;
<a name="l00836"></a>00836         }
<a name="l00837"></a>00837 
<a name="l00838"></a>00838         <span class="keywordflow">return</span> ret;
<a name="l00839"></a>00839     }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> bo_adv(<span class="keywordtype">void</span>) {
<a name="l00842"></a>00842         bufo += pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) - <span class="keyword">sizeof</span>(AWT)) : <span class="keyword">sizeof</span>(AWT);
<a name="l00843"></a>00843         bufo &amp;= (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00844"></a>00844     }
<a name="l00845"></a>00845 
<a name="l00846"></a>00846     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> input(<span class="keyword">const</span> AWT a,<span class="keyword">const</span> AWT b,<span class="keyword">const</span> AWT c,<span class="keyword">const</span> AWT d,uint8_t odd) {
<a name="l00847"></a>00847         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 0,a);
<a name="l00848"></a>00848         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 4,b);
<a name="l00849"></a>00849         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 8,c);
<a name="l00850"></a>00850         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 12,d);
<a name="l00851"></a>00851 
<a name="l00852"></a>00852         <span class="keywordflow">if</span> (shft8load &lt;= 16) {
<a name="l00853"></a>00853             bi_adv&lt;AWT&gt;();
<a name="l00854"></a>00854 
<a name="l00855"></a>00855             <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) == 2) {
<a name="l00856"></a>00856                 <span class="keywordflow">if</span> (srcbit &gt;= 8) bo_adv&lt;uint8_t&gt;();
<a name="l00857"></a>00857                 shft8load += (16 - srcbit);
<a name="l00858"></a>00858                 srcbit = 0;
<a name="l00859"></a>00859             }
<a name="l00860"></a>00860             <span class="keywordflow">else</span> {
<a name="l00861"></a>00861                 <span class="keywordflow">if</span> (srcbit &gt;= 8)
<a name="l00862"></a>00862                     srcbit -= 8;
<a name="l00863"></a>00863                 <span class="keywordflow">else</span> {
<a name="l00864"></a>00864                     shft8load += (8 - srcbit);
<a name="l00865"></a>00865                     srcbit = 0;
<a name="l00866"></a>00866                 }
<a name="l00867"></a>00867             }
<a name="l00868"></a>00868         }
<a name="l00869"></a>00869 
<a name="l00870"></a>00870         *((AWT*)(pc98_egc_srcmask+odd)) = ~0;
<a name="l00871"></a>00871     }
<a name="l00872"></a>00872 
<a name="l00873"></a>00873     <span class="keyword">inline</span> uint8_t dstbit_mask(<span class="keywordtype">void</span>) {
<a name="l00874"></a>00874         uint8_t mb;
<a name="l00875"></a>00875 
<a name="l00876"></a>00876         <span class="comment">/* assume remain &gt; 0 */</span>
<a name="l00877"></a>00877         <span class="keywordflow">if</span> (remain &gt;= 8)
<a name="l00878"></a>00878             mb = 0xFF;
<a name="l00879"></a>00879         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pc98_egc_shift_descend)
<a name="l00880"></a>00880             mb = 0xFF &lt;&lt; (uint8_t)(8 - remain); <span class="comment">/* 0x80 0xC0 0xE0 0xF0 ... */</span>
<a name="l00881"></a>00881         <span class="keywordflow">else</span>
<a name="l00882"></a>00882             mb = 0xFF &gt;&gt; (uint8_t)(8 - remain); <span class="comment">/* 0x01 0x03 0x07 0x0F ... */</span>
<a name="l00883"></a>00883 
<a name="l00884"></a>00884         <span class="comment">/* assume dstbit &lt; 8 */</span>
<a name="l00885"></a>00885         <span class="keywordflow">if</span> (!pc98_egc_shift_descend)
<a name="l00886"></a>00886             <span class="keywordflow">return</span> mb &gt;&gt; (uint8_t)dstbit; <span class="comment">/* 0xFF 0x7F 0x3F 0x1F ... */</span>
<a name="l00887"></a>00887         <span class="keywordflow">else</span>
<a name="l00888"></a>00888             <span class="keywordflow">return</span> mb &lt;&lt; (uint8_t)dstbit; <span class="comment">/* 0xFF 0xFE 0xFC 0xF8 ... */</span>
<a name="l00889"></a>00889     }
<a name="l00890"></a>00890 
<a name="l00891"></a>00891     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> output(AWT &amp;a,AWT &amp;b,AWT &amp;c,AWT &amp;d,uint8_t odd,<span class="keywordtype">bool</span> recursive=<span class="keyword">false</span>) {
<a name="l00892"></a>00892         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) == 2) {
<a name="l00893"></a>00893             <span class="keywordflow">if</span> (shft8load &lt; (16 - dstbit)) {
<a name="l00894"></a>00894                 *((AWT*)(pc98_egc_srcmask+odd)) = 0;
<a name="l00895"></a>00895                 <span class="keywordflow">return</span>;
<a name="l00896"></a>00896             }
<a name="l00897"></a>00897             shft8load -= (16 - dstbit);
<a name="l00898"></a>00898 
<a name="l00899"></a>00899             <span class="comment">/* assume odd == false and output is to even byte offset */</span>
<a name="l00900"></a>00900             <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00901"></a>00901                 output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[1],((uint8_t*)(&amp;b))[1],((uint8_t*)(&amp;c))[1],((uint8_t*)(&amp;d))[1],1,<span class="keyword">true</span>);
<a name="l00902"></a>00902                 <span class="keywordflow">if</span> (remain != 0) output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[0],((uint8_t*)(&amp;b))[0],((uint8_t*)(&amp;c))[0],((uint8_t*)(&amp;d))[0],0,<span class="keyword">true</span>);
<a name="l00903"></a>00903                 <span class="keywordflow">else</span> pc98_egc_srcmask[0] = 0;
<a name="l00904"></a>00904             }
<a name="l00905"></a>00905             <span class="keywordflow">else</span> {
<a name="l00906"></a>00906                 output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[0],((uint8_t*)(&amp;b))[0],((uint8_t*)(&amp;c))[0],((uint8_t*)(&amp;d))[0],0,<span class="keyword">true</span>);
<a name="l00907"></a>00907                 <span class="keywordflow">if</span> (remain != 0) output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[1],((uint8_t*)(&amp;b))[1],((uint8_t*)(&amp;c))[1],((uint8_t*)(&amp;d))[1],1,<span class="keyword">true</span>);
<a name="l00908"></a>00908                 <span class="keywordflow">else</span> pc98_egc_srcmask[1] = 0;
<a name="l00909"></a>00909             }
<a name="l00910"></a>00910 
<a name="l00911"></a>00911             <span class="keywordflow">if</span> (remain == 0)
<a name="l00912"></a>00912                 reinit();
<a name="l00913"></a>00913 
<a name="l00914"></a>00914             <span class="keywordflow">return</span>;
<a name="l00915"></a>00915         }
<a name="l00916"></a>00916 
<a name="l00917"></a>00917         <span class="keywordflow">if</span> (!recursive) {
<a name="l00918"></a>00918             <span class="keywordflow">if</span> (shft8load &lt; (8 - dstbit)) {
<a name="l00919"></a>00919                 *((AWT*)(pc98_egc_srcmask+odd)) = 0;
<a name="l00920"></a>00920                 <span class="keywordflow">return</span>;
<a name="l00921"></a>00921             }
<a name="l00922"></a>00922             shft8load -= (8 - dstbit);
<a name="l00923"></a>00923         }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925         <span class="keywordflow">if</span> (dstbit &gt;= 8) {
<a name="l00926"></a>00926             dstbit -= 8;
<a name="l00927"></a>00927             *((AWT*)(pc98_egc_srcmask+odd)) = 0;
<a name="l00928"></a>00928             <span class="keywordflow">return</span>;
<a name="l00929"></a>00929         }
<a name="l00930"></a>00930 
<a name="l00931"></a>00931         *((AWT*)(pc98_egc_srcmask+odd)) = dstbit_mask();
<a name="l00932"></a>00932 
<a name="l00933"></a>00933         <span class="keywordflow">if</span> (dstbit &gt; 0) {
<a name="l00934"></a>00934             <span class="keyword">const</span> uint8_t bc = 8 - dstbit;
<a name="l00935"></a>00935 
<a name="l00936"></a>00936             <span class="keywordflow">if</span> (remain &gt;= bc)
<a name="l00937"></a>00937                 remain -= bc;
<a name="l00938"></a>00938             <span class="keywordflow">else</span>
<a name="l00939"></a>00939                 remain = 0;
<a name="l00940"></a>00940         }
<a name="l00941"></a>00941         <span class="keywordflow">else</span> {
<a name="l00942"></a>00942             <span class="keywordflow">if</span> (remain &gt;= 8)
<a name="l00943"></a>00943                 remain -= 8;
<a name="l00944"></a>00944             <span class="keywordflow">else</span>
<a name="l00945"></a>00945                 remain = 0;
<a name="l00946"></a>00946         }
<a name="l00947"></a>00947 
<a name="l00948"></a>00948         <span class="keywordflow">if</span> (o_srcbit &lt; o_dstbit) {
<a name="l00949"></a>00949             <span class="keywordflow">if</span> (dstbit != 0) {
<a name="l00950"></a>00950                 <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00951"></a>00951                     a = bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitr;
<a name="l00952"></a>00952                     b = bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitr;
<a name="l00953"></a>00953                     c = bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitr;
<a name="l00954"></a>00954                     d = bo&lt;AWT&gt;(12) &lt;&lt; shft8bitr;
<a name="l00955"></a>00955                 }
<a name="l00956"></a>00956                 <span class="keywordflow">else</span> {
<a name="l00957"></a>00957                     a = bo&lt;AWT&gt;( 0) &gt;&gt; shft8bitr;
<a name="l00958"></a>00958                     b = bo&lt;AWT&gt;( 4) &gt;&gt; shft8bitr;
<a name="l00959"></a>00959                     c = bo&lt;AWT&gt;( 8) &gt;&gt; shft8bitr;
<a name="l00960"></a>00960                     d = bo&lt;AWT&gt;(12) &gt;&gt; shft8bitr;
<a name="l00961"></a>00961                 }
<a name="l00962"></a>00962 
<a name="l00963"></a>00963                 dstbit = 0;
<a name="l00964"></a>00964             }
<a name="l00965"></a>00965             <span class="keywordflow">else</span> {
<a name="l00966"></a>00966                 <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00967"></a>00967                     bo_adv&lt;AWT&gt;();
<a name="l00968"></a>00968                     a = (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitr);
<a name="l00969"></a>00969                     b = (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitr);
<a name="l00970"></a>00970                     c = (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitr);
<a name="l00971"></a>00971                     d = (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitr);
<a name="l00972"></a>00972                 }
<a name="l00973"></a>00973                 <span class="keywordflow">else</span> {
<a name="l00974"></a>00974                     a = (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitr);
<a name="l00975"></a>00975                     b = (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitr);
<a name="l00976"></a>00976                     c = (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitr);
<a name="l00977"></a>00977                     d = (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitr);
<a name="l00978"></a>00978                     bo_adv&lt;AWT&gt;();
<a name="l00979"></a>00979                 }
<a name="l00980"></a>00980             }
<a name="l00981"></a>00981         }
<a name="l00982"></a>00982         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (o_srcbit &gt; o_dstbit) {
<a name="l00983"></a>00983             dstbit = 0;
<a name="l00984"></a>00984 
<a name="l00985"></a>00985             <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00986"></a>00986                 bo_adv&lt;AWT&gt;();
<a name="l00987"></a>00987                 a = (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitr);
<a name="l00988"></a>00988                 b = (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitr);
<a name="l00989"></a>00989                 c = (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitr);
<a name="l00990"></a>00990                 d = (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitr);
<a name="l00991"></a>00991             }
<a name="l00992"></a>00992             <span class="keywordflow">else</span> {
<a name="l00993"></a>00993                 a = (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitr);
<a name="l00994"></a>00994                 b = (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitr);
<a name="l00995"></a>00995                 c = (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitr);
<a name="l00996"></a>00996                 d = (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitr);
<a name="l00997"></a>00997                 bo_adv&lt;AWT&gt;();
<a name="l00998"></a>00998             }
<a name="l00999"></a>00999         }
<a name="l01000"></a>01000         <span class="keywordflow">else</span> {
<a name="l01001"></a>01001             dstbit = 0;
<a name="l01002"></a>01002 
<a name="l01003"></a>01003             a = bo&lt;AWT&gt;( 0);
<a name="l01004"></a>01004             b = bo&lt;AWT&gt;( 4);
<a name="l01005"></a>01005             c = bo&lt;AWT&gt;( 8);
<a name="l01006"></a>01006             d = bo&lt;AWT&gt;(12);
<a name="l01007"></a>01007             bo_adv&lt;AWT&gt;();
<a name="l01008"></a>01008         }
<a name="l01009"></a>01009 
<a name="l01010"></a>01010         <span class="keywordflow">if</span> (!recursive &amp;&amp; remain == 0)
<a name="l01011"></a>01011             reinit();
<a name="l01012"></a>01012     }
<a name="l01013"></a>01013 };
<a name="l01014"></a>01014 
<a name="l01015"></a>01015 egc_quad pc98_egc_src;
<a name="l01016"></a>01016 egc_quad pc98_egc_bgcm;
<a name="l01017"></a>01017 egc_quad pc98_egc_fgcm;
<a name="l01018"></a>01018 egc_quad pc98_egc_data;
<a name="l01019"></a>01019 egc_quad pc98_egc_last_vram;
<a name="l01020"></a>01020 
<a name="l01021"></a>01021 <a class="code" href="structpc98__egc__shifter.html">pc98_egc_shifter</a> pc98_egc_shift;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023 <span class="keyword">typedef</span> egc_quad &amp; (*PC98_OPEFN)(uint8_t ope, <span class="keyword">const</span> PhysPt ad);
<a name="l01024"></a>01024 
<a name="l01025"></a>01025 <span class="keywordtype">void</span> pc98_egc_shift_reinit() {
<a name="l01026"></a>01026     pc98_egc_shift.reinit();
<a name="l01027"></a>01027 }
<a name="l01028"></a>01028 
<a name="l01029"></a>01029 <span class="keyword">static</span> egc_quad &amp;ope_xx(uint8_t ope, <span class="keyword">const</span> PhysPt ad) {
<a name="l01030"></a>01030     LOG_MSG(<span class="stringliteral">&quot;EGC ROP 0x%2x not impl&quot;</span>,ope);
<a name="l01031"></a>01031     <span class="keywordflow">return</span> pc98_egc_last_vram;
<a name="l01032"></a>01032 }
<a name="l01033"></a>01033 
<a name="l01034"></a>01034 <span class="keyword">static</span> egc_quad &amp;ope_np(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l01035"></a>01035         egc_quad dst;
<a name="l01036"></a>01036 
<a name="l01037"></a>01037         dst[0].w = *((uint16_t*)(vga.mem.linear+vramoff+0x08000));
<a name="l01038"></a>01038         dst[1].w = *((uint16_t*)(vga.mem.linear+vramoff+0x10000));
<a name="l01039"></a>01039         dst[2].w = *((uint16_t*)(vga.mem.linear+vramoff+0x18000));
<a name="l01040"></a>01040         dst[3].w = *((uint16_t*)(vga.mem.linear+vramoff+0x20000));
<a name="l01041"></a>01041 
<a name="l01042"></a>01042         pc98_egc_data[0].w = 0;
<a name="l01043"></a>01043         pc98_egc_data[1].w = 0;
<a name="l01044"></a>01044         pc98_egc_data[2].w = 0;
<a name="l01045"></a>01045         pc98_egc_data[3].w = 0;
<a name="l01046"></a>01046 
<a name="l01047"></a>01047         <span class="keywordflow">if</span> (ope &amp; 0x80) {
<a name="l01048"></a>01048         pc98_egc_data[0].w |= (pc98_egc_src[0].w &amp; dst[0].w);
<a name="l01049"></a>01049         pc98_egc_data[1].w |= (pc98_egc_src[1].w &amp; dst[1].w);
<a name="l01050"></a>01050         pc98_egc_data[2].w |= (pc98_egc_src[2].w &amp; dst[2].w);
<a name="l01051"></a>01051         pc98_egc_data[3].w |= (pc98_egc_src[3].w &amp; dst[3].w);
<a name="l01052"></a>01052     }
<a name="l01053"></a>01053         <span class="keywordflow">if</span> (ope &amp; 0x20) {
<a name="l01054"></a>01054         pc98_egc_data[0].w |= (pc98_egc_src[0].w &amp; (~dst[0].w));
<a name="l01055"></a>01055         pc98_egc_data[1].w |= (pc98_egc_src[1].w &amp; (~dst[1].w));
<a name="l01056"></a>01056         pc98_egc_data[2].w |= (pc98_egc_src[2].w &amp; (~dst[2].w));
<a name="l01057"></a>01057         pc98_egc_data[3].w |= (pc98_egc_src[3].w &amp; (~dst[3].w));
<a name="l01058"></a>01058         }
<a name="l01059"></a>01059         <span class="keywordflow">if</span> (ope &amp; 0x08) {
<a name="l01060"></a>01060         pc98_egc_data[0].w |= ((~pc98_egc_src[0].w) &amp; dst[0].w);
<a name="l01061"></a>01061         pc98_egc_data[1].w |= ((~pc98_egc_src[1].w) &amp; dst[1].w);
<a name="l01062"></a>01062         pc98_egc_data[2].w |= ((~pc98_egc_src[2].w) &amp; dst[2].w);
<a name="l01063"></a>01063         pc98_egc_data[3].w |= ((~pc98_egc_src[3].w) &amp; dst[3].w);
<a name="l01064"></a>01064         }
<a name="l01065"></a>01065         <span class="keywordflow">if</span> (ope &amp; 0x02) {
<a name="l01066"></a>01066         pc98_egc_data[0].w |= ((~pc98_egc_src[0].w) &amp; (~dst[0].w));
<a name="l01067"></a>01067         pc98_egc_data[1].w |= ((~pc98_egc_src[1].w) &amp; (~dst[1].w));
<a name="l01068"></a>01068         pc98_egc_data[2].w |= ((~pc98_egc_src[2].w) &amp; (~dst[2].w));
<a name="l01069"></a>01069         pc98_egc_data[3].w |= ((~pc98_egc_src[3].w) &amp; (~dst[3].w));
<a name="l01070"></a>01070         }
<a name="l01071"></a>01071 
<a name="l01072"></a>01072         (void)ope;
<a name="l01073"></a>01073         (void)vramoff;
<a name="l01074"></a>01074         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01075"></a>01075 }
<a name="l01076"></a>01076 
<a name="l01077"></a>01077 <span class="keyword">static</span> egc_quad &amp;ope_c0(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l01078"></a>01078         egc_quad dst;
<a name="l01079"></a>01079 
<a name="l01080"></a>01080     <span class="comment">/* assume: ad is word aligned */</span>
<a name="l01081"></a>01081 
<a name="l01082"></a>01082         dst[0].w = *((uint16_t*)(vga.mem.linear+vramoff+0x08000));
<a name="l01083"></a>01083         dst[1].w = *((uint16_t*)(vga.mem.linear+vramoff+0x10000));
<a name="l01084"></a>01084         dst[2].w = *((uint16_t*)(vga.mem.linear+vramoff+0x18000));
<a name="l01085"></a>01085         dst[3].w = *((uint16_t*)(vga.mem.linear+vramoff+0x20000));
<a name="l01086"></a>01086 
<a name="l01087"></a>01087         pc98_egc_data[0].w = pc98_egc_src[0].w &amp; dst[0].w;
<a name="l01088"></a>01088         pc98_egc_data[1].w = pc98_egc_src[1].w &amp; dst[1].w;
<a name="l01089"></a>01089         pc98_egc_data[2].w = pc98_egc_src[2].w &amp; dst[2].w;
<a name="l01090"></a>01090         pc98_egc_data[3].w = pc98_egc_src[3].w &amp; dst[3].w;
<a name="l01091"></a>01091 
<a name="l01092"></a>01092         (void)ope;
<a name="l01093"></a>01093         (void)vramoff;
<a name="l01094"></a>01094         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01095"></a>01095 }
<a name="l01096"></a>01096 
<a name="l01097"></a>01097 <span class="keyword">static</span> egc_quad &amp;ope_f0(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l01098"></a>01098         (void)ope;
<a name="l01099"></a>01099         (void)vramoff;
<a name="l01100"></a>01100         <span class="keywordflow">return</span> pc98_egc_src;
<a name="l01101"></a>01101 }
<a name="l01102"></a>01102 
<a name="l01103"></a>01103 <span class="keyword">static</span> egc_quad &amp;ope_fc(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l01104"></a>01104         egc_quad dst;
<a name="l01105"></a>01105 
<a name="l01106"></a>01106     <span class="comment">/* assume: ad is word aligned */</span>
<a name="l01107"></a>01107 
<a name="l01108"></a>01108         dst[0].w = *((uint16_t*)(vga.mem.linear+vramoff+0x08000));
<a name="l01109"></a>01109         dst[1].w = *((uint16_t*)(vga.mem.linear+vramoff+0x10000));
<a name="l01110"></a>01110         dst[2].w = *((uint16_t*)(vga.mem.linear+vramoff+0x18000));
<a name="l01111"></a>01111         dst[3].w = *((uint16_t*)(vga.mem.linear+vramoff+0x20000));
<a name="l01112"></a>01112 
<a name="l01113"></a>01113         pc98_egc_data[0].w  =    pc98_egc_src[0].w;
<a name="l01114"></a>01114         pc98_egc_data[0].w |= ((~pc98_egc_src[0].w) &amp; dst[0].w);
<a name="l01115"></a>01115         pc98_egc_data[1].w  =    pc98_egc_src[1].w;
<a name="l01116"></a>01116         pc98_egc_data[1].w |= ((~pc98_egc_src[1].w) &amp; dst[1].w);
<a name="l01117"></a>01117         pc98_egc_data[2].w  =    pc98_egc_src[2].w;
<a name="l01118"></a>01118         pc98_egc_data[2].w |= ((~pc98_egc_src[2].w) &amp; dst[2].w);
<a name="l01119"></a>01119         pc98_egc_data[3].w  =    pc98_egc_src[3].w;
<a name="l01120"></a>01120         pc98_egc_data[3].w |= ((~pc98_egc_src[3].w) &amp; dst[3].w);
<a name="l01121"></a>01121 
<a name="l01122"></a>01122         (void)ope;
<a name="l01123"></a>01123         (void)vramoff;
<a name="l01124"></a>01124         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01125"></a>01125 }
<a name="l01126"></a>01126 
<a name="l01127"></a>01127 <span class="keyword">static</span> egc_quad &amp;ope_gg(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l01128"></a>01128     egc_quad pat,dst;
<a name="l01129"></a>01129 
<a name="l01130"></a>01130         <span class="keywordflow">switch</span>(pc98_egc_fgc) {
<a name="l01131"></a>01131                 <span class="keywordflow">case</span> 1:
<a name="l01132"></a>01132                         pat[0].w = pc98_egc_bgcm[0].w;
<a name="l01133"></a>01133                         pat[1].w = pc98_egc_bgcm[1].w;
<a name="l01134"></a>01134                         pat[2].w = pc98_egc_bgcm[2].w;
<a name="l01135"></a>01135                         pat[3].w = pc98_egc_bgcm[3].w;
<a name="l01136"></a>01136                         <span class="keywordflow">break</span>;
<a name="l01137"></a>01137 
<a name="l01138"></a>01138                 <span class="keywordflow">case</span> 2:
<a name="l01139"></a>01139                         pat[0].w = pc98_egc_fgcm[0].w;
<a name="l01140"></a>01140                         pat[1].w = pc98_egc_fgcm[1].w;
<a name="l01141"></a>01141                         pat[2].w = pc98_egc_fgcm[2].w;
<a name="l01142"></a>01142                         pat[3].w = pc98_egc_fgcm[3].w;
<a name="l01143"></a>01143                         <span class="keywordflow">break</span>;
<a name="l01144"></a>01144 
<a name="l01145"></a>01145                 <span class="keywordflow">default</span>:
<a name="l01146"></a>01146                         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 1) {
<a name="l01147"></a>01147                                 pat[0].w = pc98_egc_src[0].w;
<a name="l01148"></a>01148                                 pat[1].w = pc98_egc_src[1].w;
<a name="l01149"></a>01149                                 pat[2].w = pc98_egc_src[2].w;
<a name="l01150"></a>01150                                 pat[3].w = pc98_egc_src[3].w;
<a name="l01151"></a>01151                         }
<a name="l01152"></a>01152                         <span class="keywordflow">else</span> {
<a name="l01153"></a>01153                                 pat[0].w = pc98_gdc_tiles[0].w;
<a name="l01154"></a>01154                                 pat[1].w = pc98_gdc_tiles[1].w;
<a name="l01155"></a>01155                                 pat[2].w = pc98_gdc_tiles[2].w;
<a name="l01156"></a>01156                                 pat[3].w = pc98_gdc_tiles[3].w;
<a name="l01157"></a>01157                         }
<a name="l01158"></a>01158                         <span class="keywordflow">break</span>;
<a name="l01159"></a>01159         }
<a name="l01160"></a>01160 
<a name="l01161"></a>01161         dst[0].w = *((uint16_t*)(vga.mem.linear+vramoff+0x08000));
<a name="l01162"></a>01162         dst[1].w = *((uint16_t*)(vga.mem.linear+vramoff+0x10000));
<a name="l01163"></a>01163         dst[2].w = *((uint16_t*)(vga.mem.linear+vramoff+0x18000));
<a name="l01164"></a>01164         dst[3].w = *((uint16_t*)(vga.mem.linear+vramoff+0x20000));
<a name="l01165"></a>01165 
<a name="l01166"></a>01166         pc98_egc_data[0].w = 0;
<a name="l01167"></a>01167         pc98_egc_data[1].w = 0;
<a name="l01168"></a>01168         pc98_egc_data[2].w = 0;
<a name="l01169"></a>01169         pc98_egc_data[3].w = 0;
<a name="l01170"></a>01170 
<a name="l01171"></a>01171         <span class="keywordflow">if</span> (ope &amp; 0x80) {
<a name="l01172"></a>01172                 pc98_egc_data[0].w |=  ( pat[0].w  &amp;   pc98_egc_src[0].w &amp;    dst[0].w);
<a name="l01173"></a>01173                 pc98_egc_data[1].w |=  ( pat[1].w  &amp;   pc98_egc_src[1].w &amp;    dst[1].w);
<a name="l01174"></a>01174                 pc98_egc_data[2].w |=  ( pat[2].w  &amp;   pc98_egc_src[2].w &amp;    dst[2].w);
<a name="l01175"></a>01175                 pc98_egc_data[3].w |=  ( pat[3].w  &amp;   pc98_egc_src[3].w &amp;    dst[3].w);
<a name="l01176"></a>01176         }
<a name="l01177"></a>01177         <span class="keywordflow">if</span> (ope &amp; 0x40) {
<a name="l01178"></a>01178                 pc98_egc_data[0].w |= ((~pat[0].w) &amp;   pc98_egc_src[0].w &amp;    dst[0].w);
<a name="l01179"></a>01179                 pc98_egc_data[1].w |= ((~pat[1].w) &amp;   pc98_egc_src[1].w &amp;    dst[1].w);
<a name="l01180"></a>01180                 pc98_egc_data[2].w |= ((~pat[2].w) &amp;   pc98_egc_src[2].w &amp;    dst[2].w);
<a name="l01181"></a>01181                 pc98_egc_data[3].w |= ((~pat[3].w) &amp;   pc98_egc_src[3].w &amp;    dst[3].w);
<a name="l01182"></a>01182         }
<a name="l01183"></a>01183         <span class="keywordflow">if</span> (ope &amp; 0x20) {
<a name="l01184"></a>01184                 pc98_egc_data[0].w |= (  pat[0].w  &amp;   pc98_egc_src[0].w &amp;  (~dst[0].w));
<a name="l01185"></a>01185                 pc98_egc_data[1].w |= (  pat[1].w  &amp;   pc98_egc_src[1].w &amp;  (~dst[1].w));
<a name="l01186"></a>01186                 pc98_egc_data[2].w |= (  pat[2].w  &amp;   pc98_egc_src[2].w &amp;  (~dst[2].w));
<a name="l01187"></a>01187                 pc98_egc_data[3].w |= (  pat[3].w  &amp;   pc98_egc_src[3].w &amp;  (~dst[3].w));
<a name="l01188"></a>01188         }
<a name="l01189"></a>01189         <span class="keywordflow">if</span> (ope &amp; 0x10) {
<a name="l01190"></a>01190                 pc98_egc_data[0].w |= ((~pat[0].w) &amp;   pc98_egc_src[0].w &amp;  (~dst[0].w));
<a name="l01191"></a>01191                 pc98_egc_data[1].w |= ((~pat[1].w) &amp;   pc98_egc_src[1].w &amp;  (~dst[1].w));
<a name="l01192"></a>01192                 pc98_egc_data[2].w |= ((~pat[2].w) &amp;   pc98_egc_src[2].w &amp;  (~dst[2].w));
<a name="l01193"></a>01193                 pc98_egc_data[3].w |= ((~pat[3].w) &amp;   pc98_egc_src[3].w &amp;  (~dst[3].w));
<a name="l01194"></a>01194         }
<a name="l01195"></a>01195         <span class="keywordflow">if</span> (ope &amp; 0x08) {
<a name="l01196"></a>01196                 pc98_egc_data[0].w |= (  pat[0].w  &amp; (~pc98_egc_src[0].w) &amp;   dst[0].w);
<a name="l01197"></a>01197                 pc98_egc_data[1].w |= (  pat[1].w  &amp; (~pc98_egc_src[1].w) &amp;   dst[1].w);
<a name="l01198"></a>01198                 pc98_egc_data[2].w |= (  pat[2].w  &amp; (~pc98_egc_src[2].w) &amp;   dst[2].w);
<a name="l01199"></a>01199                 pc98_egc_data[3].w |= (  pat[3].w  &amp; (~pc98_egc_src[3].w) &amp;   dst[3].w);
<a name="l01200"></a>01200         }
<a name="l01201"></a>01201         <span class="keywordflow">if</span> (ope &amp; 0x04) {
<a name="l01202"></a>01202                 pc98_egc_data[0].w |= ((~pat[0].w) &amp; (~pc98_egc_src[0].w) &amp;   dst[0].w);
<a name="l01203"></a>01203                 pc98_egc_data[1].w |= ((~pat[1].w) &amp; (~pc98_egc_src[1].w) &amp;   dst[1].w);
<a name="l01204"></a>01204                 pc98_egc_data[2].w |= ((~pat[2].w) &amp; (~pc98_egc_src[2].w) &amp;   dst[2].w);
<a name="l01205"></a>01205                 pc98_egc_data[3].w |= ((~pat[3].w) &amp; (~pc98_egc_src[3].w) &amp;   dst[3].w);
<a name="l01206"></a>01206         }
<a name="l01207"></a>01207         <span class="keywordflow">if</span> (ope &amp; 0x02) {
<a name="l01208"></a>01208                 pc98_egc_data[0].w |= (  pat[0].w  &amp; (~pc98_egc_src[0].w) &amp; (~dst[0].w));
<a name="l01209"></a>01209                 pc98_egc_data[1].w |= (  pat[1].w  &amp; (~pc98_egc_src[1].w) &amp; (~dst[1].w));
<a name="l01210"></a>01210                 pc98_egc_data[2].w |= (  pat[2].w  &amp; (~pc98_egc_src[2].w) &amp; (~dst[2].w));
<a name="l01211"></a>01211                 pc98_egc_data[3].w |= (  pat[3].w  &amp; (~pc98_egc_src[3].w) &amp; (~dst[3].w));
<a name="l01212"></a>01212         }
<a name="l01213"></a>01213         <span class="keywordflow">if</span> (ope &amp; 0x01) {
<a name="l01214"></a>01214                 pc98_egc_data[0].w |= ((~pat[0].w) &amp; (~pc98_egc_src[0].w) &amp; (~dst[0].w));
<a name="l01215"></a>01215                 pc98_egc_data[1].w |= ((~pat[1].w) &amp; (~pc98_egc_src[1].w) &amp; (~dst[1].w));
<a name="l01216"></a>01216                 pc98_egc_data[2].w |= ((~pat[2].w) &amp; (~pc98_egc_src[2].w) &amp; (~dst[2].w));
<a name="l01217"></a>01217                 pc98_egc_data[3].w |= ((~pat[3].w) &amp; (~pc98_egc_src[3].w) &amp; (~dst[3].w));
<a name="l01218"></a>01218         }
<a name="l01219"></a>01219 
<a name="l01220"></a>01220         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01221"></a>01221 }
<a name="l01222"></a>01222 
<a name="l01223"></a>01223 <span class="keyword">static</span> <span class="keyword">const</span> PC98_OPEFN pc98_egc_opfn[256] = {
<a name="l01224"></a>01224                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01225"></a>01225                         ope_xx, ope_xx, ope_xx, ope_xx, ope_np, ope_xx, ope_xx, ope_xx,
<a name="l01226"></a>01226                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01227"></a>01227                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01228"></a>01228                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01229"></a>01229                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01230"></a>01230                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01231"></a>01231                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01232"></a>01232                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01233"></a>01233                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01234"></a>01234                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01235"></a>01235                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01236"></a>01236                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01237"></a>01237                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01238"></a>01238                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01239"></a>01239                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01240"></a>01240                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01241"></a>01241                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01242"></a>01242                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01243"></a>01243                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01244"></a>01244                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01245"></a>01245                         ope_xx, ope_xx, ope_xx, ope_xx, ope_gg, ope_xx, ope_xx, ope_xx,
<a name="l01246"></a>01246                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01247"></a>01247                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01248"></a>01248                         ope_c0, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01249"></a>01249                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01250"></a>01250                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01251"></a>01251                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01252"></a>01252                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01253"></a>01253                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01254"></a>01254                         ope_f0, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01255"></a>01255                         ope_xx, ope_xx, ope_xx, ope_xx, ope_fc, ope_xx, ope_xx, ope_xx};
<a name="l01256"></a>01256 
<a name="l01257"></a>01257 <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> egc_quad &amp;egc_ope(<span class="keyword">const</span> PhysPt vramoff, <span class="keyword">const</span> AWT val) {
<a name="l01258"></a>01258     *((uint16_t*)pc98_egc_maskef) = *((uint16_t*)pc98_egc_mask);
<a name="l01259"></a>01259 
<a name="l01260"></a>01260     <span class="comment">/* 4A4h</span>
<a name="l01261"></a>01261 <span class="comment">     * bits [12:11] = light source</span>
<a name="l01262"></a>01262 <span class="comment">     *    11 = invalid</span>
<a name="l01263"></a>01263 <span class="comment">     *    10 = write the contents of the palette register</span>
<a name="l01264"></a>01264 <span class="comment">     *    01 = write the result of the raster operation</span>
<a name="l01265"></a>01265 <span class="comment">     *    00 = write CPU data</span>
<a name="l01266"></a>01266 <span class="comment">     *</span>
<a name="l01267"></a>01267 <span class="comment">     * 4A2h</span>
<a name="l01268"></a>01268 <span class="comment">     * bits [14:13] = foreground, background color</span>
<a name="l01269"></a>01269 <span class="comment">     *    11 = invalid</span>
<a name="l01270"></a>01270 <span class="comment">     *    10 = foreground color</span>
<a name="l01271"></a>01271 <span class="comment">     *    01 = background color</span>
<a name="l01272"></a>01272 <span class="comment">     *    00 = pattern register</span>
<a name="l01273"></a>01273 <span class="comment">     */</span>
<a name="l01274"></a>01274     <span class="keywordflow">switch</span> (pc98_egc_lightsource) {
<a name="l01275"></a>01275         <span class="keywordflow">case</span> 1: <span class="comment">/* 0x0800 */</span>
<a name="l01276"></a>01276             <span class="keywordflow">if</span> (pc98_egc_shiftinput) {
<a name="l01277"></a>01277                 pc98_egc_shift.input&lt;AWT&gt;(
<a name="l01278"></a>01278                     val,
<a name="l01279"></a>01279                     val,
<a name="l01280"></a>01280                     val,
<a name="l01281"></a>01281                     val,
<a name="l01282"></a>01282                     vramoff&amp;1);
<a name="l01283"></a>01283 
<a name="l01284"></a>01284                 pc98_egc_shift.output&lt;AWT&gt;(
<a name="l01285"></a>01285                     *((AWT*)(pc98_egc_src[0].b+(vramoff&amp;1))),
<a name="l01286"></a>01286                     *((AWT*)(pc98_egc_src[1].b+(vramoff&amp;1))),
<a name="l01287"></a>01287                     *((AWT*)(pc98_egc_src[2].b+(vramoff&amp;1))),
<a name="l01288"></a>01288                     *((AWT*)(pc98_egc_src[3].b+(vramoff&amp;1))),
<a name="l01289"></a>01289                     vramoff&amp;1);
<a name="l01290"></a>01290             }
<a name="l01291"></a>01291 
<a name="l01292"></a>01292             *((uint16_t*)pc98_egc_maskef) &amp;= *((uint16_t*)pc98_egc_srcmask);
<a name="l01293"></a>01293             <span class="keywordflow">return</span> pc98_egc_opfn[pc98_egc_rop](pc98_egc_rop, vramoff &amp; (~1U));
<a name="l01294"></a>01294         <span class="keywordflow">case</span> 2: <span class="comment">/* 0x1000 */</span>
<a name="l01295"></a>01295             <span class="keywordflow">if</span> (pc98_egc_fgc == 1)
<a name="l01296"></a>01296                 <span class="keywordflow">return</span> pc98_egc_bgcm;
<a name="l01297"></a>01297             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pc98_egc_fgc == 2)
<a name="l01298"></a>01298                 <span class="keywordflow">return</span> pc98_egc_fgcm;
<a name="l01299"></a>01299 
<a name="l01300"></a>01300             <span class="keywordflow">if</span> (pc98_egc_shiftinput) {
<a name="l01301"></a>01301                 pc98_egc_shift.input&lt;AWT&gt;(
<a name="l01302"></a>01302                     val,
<a name="l01303"></a>01303                     val,
<a name="l01304"></a>01304                     val,
<a name="l01305"></a>01305                     val,
<a name="l01306"></a>01306                     vramoff&amp;1);
<a name="l01307"></a>01307 
<a name="l01308"></a>01308                 pc98_egc_shift.output&lt;AWT&gt;(
<a name="l01309"></a>01309                     *((AWT*)(pc98_egc_src[0].b+(vramoff&amp;1))),
<a name="l01310"></a>01310                     *((AWT*)(pc98_egc_src[1].b+(vramoff&amp;1))),
<a name="l01311"></a>01311                     *((AWT*)(pc98_egc_src[2].b+(vramoff&amp;1))),
<a name="l01312"></a>01312                     *((AWT*)(pc98_egc_src[3].b+(vramoff&amp;1))),
<a name="l01313"></a>01313                     vramoff&amp;1);
<a name="l01314"></a>01314             }
<a name="l01315"></a>01315  
<a name="l01316"></a>01316             *((uint16_t*)pc98_egc_maskef) &amp;= *((uint16_t*)pc98_egc_srcmask);
<a name="l01317"></a>01317             <span class="keywordflow">return</span> pc98_egc_src;
<a name="l01318"></a>01318         <span class="keywordflow">default</span>: {
<a name="l01319"></a>01319             uint16_t tmp = (uint16_t)val;
<a name="l01320"></a>01320 
<a name="l01321"></a>01321             <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &lt; 2) {
<a name="l01322"></a>01322                 tmp &amp;= 0xFFU;
<a name="l01323"></a>01323                 tmp |= tmp &lt;&lt; 8U;
<a name="l01324"></a>01324             }
<a name="l01325"></a>01325 
<a name="l01326"></a>01326             pc98_egc_data[0].w = tmp;
<a name="l01327"></a>01327             pc98_egc_data[1].w = tmp;
<a name="l01328"></a>01328             pc98_egc_data[2].w = tmp;
<a name="l01329"></a>01329             pc98_egc_data[3].w = tmp;
<a name="l01330"></a>01330             } <span class="keywordflow">break</span>;
<a name="l01331"></a>01331     };
<a name="l01332"></a>01332 
<a name="l01333"></a>01333     <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01334"></a>01334 }
<a name="l01335"></a>01335 
<a name="l01336"></a>01336 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pc98_mem_msw_m[8] = {0};
<a name="l01337"></a>01337 
<a name="l01338"></a>01338 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pc98_mem_msw(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> which) {
<a name="l01339"></a>01339     <span class="keywordflow">return</span> pc98_mem_msw_m[which&amp;7];
<a name="l01340"></a>01340 }
<a name="l01341"></a>01341 
<a name="l01342"></a>01342 <span class="comment">/* The NEC display is documented to have:</span>
<a name="l01343"></a>01343 <span class="comment"> *</span>
<a name="l01344"></a>01344 <span class="comment"> * A0000-A3FFF      T-RAM (text) (8KB WORDs)</span>
<a name="l01345"></a>01345 <span class="comment"> *   A0000-A1FFF      Characters (4KB WORDs)</span>
<a name="l01346"></a>01346 <span class="comment"> *   A2000-A3FFF      Attributes (4KB WORDs). For each 16-bit WORD only the lower 8 bits are read/writeable.</span>
<a name="l01347"></a>01347 <span class="comment"> *   A4000-A5FFF      Unknown ?? (4KB WORDs)</span>
<a name="l01348"></a>01348 <span class="comment"> *   A6000-A7FFF      Not present (4KB WORDs)</span>
<a name="l01349"></a>01349 <span class="comment"> * A8000-BFFFF      G-RAM (graphics) (96KB)</span>
<a name="l01350"></a>01350 <span class="comment"> *</span>
<a name="l01351"></a>01351 <span class="comment"> * T-RAM character display RAM is 16-bits per character.</span>
<a name="l01352"></a>01352 <span class="comment"> * ASCII text has upper 8 bits zero.</span>
<a name="l01353"></a>01353 <span class="comment"> * SHIFT-JIS doublewide characters use the upper byte for non-ASCII. */</span>
<a name="l01354"></a>01354 
<a name="l01355"></a><a class="code" href="classVGA__PC98__PageHandler.html">01355</a> <span class="keyword">class </span><a class="code" href="classVGA__PC98__PageHandler.html">VGA_PC98_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01356"></a>01356 <span class="keyword">public</span>:
<a name="l01357"></a>01357         <a class="code" href="classVGA__PC98__PageHandler.html">VGA_PC98_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01358"></a>01358     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> check_align(<span class="keyword">const</span> PhysPt addr) {
<a name="l01359"></a>01359         <span class="comment">/* DEBUG: address must be aligned to datatype.</span>
<a name="l01360"></a>01360 <span class="comment">         *        Code that calls us must enforce that or subdivide</span>
<a name="l01361"></a>01361 <span class="comment">         *        to a small datatype that can follow this rule. */</span>
<a name="l01362"></a>01362         PhysPt chk = (1UL &lt;&lt; (<span class="keyword">sizeof</span>(AWT) - 1)) - 1;
<a name="l01363"></a>01363         <span class="comment">/* uint8_t:  chk = 0</span>
<a name="l01364"></a>01364 <span class="comment">         * uint16_t: chk = 1</span>
<a name="l01365"></a>01365 <span class="comment">         * TODO: Do you suppose later generation PC-9821&#39;s supported DWORD size bitplane transfers?</span>
<a name="l01366"></a>01366 <span class="comment">         *       Or did NEC just give up on anything past 16-bit and focus on the SVGA side of things? */</span>
<a name="l01367"></a>01367         assert((addr&amp;chk) == 0);
<a name="l01368"></a>01368     }
<a name="l01369"></a>01369 
<a name="l01370"></a>01370     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> AWT mode8_r(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane,<span class="keyword">const</span> PhysPt vramoff) {
<a name="l01371"></a>01371         AWT r,b;
<a name="l01372"></a>01372 
<a name="l01373"></a>01373         b = *((AWT*)(vga.mem.linear + vramoff));
<a name="l01374"></a>01374         r = b ^ *((AWT*)pc98_gdc_tiles[plane].b);
<a name="l01375"></a>01375 
<a name="l01376"></a>01376         <span class="keywordflow">return</span> r;
<a name="l01377"></a>01377     }
<a name="l01378"></a>01378 
<a name="l01379"></a>01379     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> mode8_w(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane,<span class="keyword">const</span> PhysPt vramoff) {
<a name="l01380"></a>01380         <span class="comment">/* Neko Project II code suggests that the first byte is repeated. */</span>
<a name="l01381"></a>01381         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &gt; 1)
<a name="l01382"></a>01382             pc98_gdc_tiles[plane].b[1] = pc98_gdc_tiles[plane].b[0];
<a name="l01383"></a>01383 
<a name="l01384"></a>01384         *((AWT*)(vga.mem.linear + vramoff)) = *((AWT*)pc98_gdc_tiles[plane].b);
<a name="l01385"></a>01385     }
<a name="l01386"></a>01386 
<a name="l01387"></a>01387     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> modeC_w(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane,<span class="keyword">const</span> PhysPt vramoff,<span class="keyword">const</span> AWT mask,<span class="keyword">const</span> AWT val) {
<a name="l01388"></a>01388         AWT t;
<a name="l01389"></a>01389 
<a name="l01390"></a>01390         <span class="comment">/* Neko Project II code suggests that the first byte is repeated. */</span>
<a name="l01391"></a>01391         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &gt; 1)
<a name="l01392"></a>01392             pc98_gdc_tiles[plane].b[1] = pc98_gdc_tiles[plane].b[0];
<a name="l01393"></a>01393 
<a name="l01394"></a>01394         t  = *((AWT*)(vga.mem.linear + vramoff)) &amp; mask;
<a name="l01395"></a>01395         t |= val &amp; *((AWT*)pc98_gdc_tiles[plane].b);
<a name="l01396"></a>01396         *((AWT*)(vga.mem.linear + vramoff)) = t;
<a name="l01397"></a>01397     }
<a name="l01398"></a>01398 
<a name="l01399"></a>01399     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> AWT modeEGC_r(<span class="keyword">const</span> PhysPt vramoff,<span class="keyword">const</span> PhysPt fulloff) {
<a name="l01400"></a>01400         <span class="comment">/* assume: vramoff is even IF AWT is 16-bit wide */</span>
<a name="l01401"></a>01401         *((AWT*)(pc98_egc_last_vram[0].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x08000));
<a name="l01402"></a>01402         *((AWT*)(pc98_egc_last_vram[1].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x10000));
<a name="l01403"></a>01403         *((AWT*)(pc98_egc_last_vram[2].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x18000));
<a name="l01404"></a>01404         *((AWT*)(pc98_egc_last_vram[3].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x20000));
<a name="l01405"></a>01405 
<a name="l01406"></a>01406         <span class="comment">/* bits [10:10] = read source</span>
<a name="l01407"></a>01407 <span class="comment">         *    1 = shifter input is CPU write data</span>
<a name="l01408"></a>01408 <span class="comment">         *    0 = shifter input is VRAM data */</span>
<a name="l01409"></a>01409         <span class="comment">/* Neko Project II: if ((egc.ope &amp; 0x0400) == 0) ... */</span>
<a name="l01410"></a>01410         <span class="keywordflow">if</span> (!pc98_egc_shiftinput) {
<a name="l01411"></a>01411             pc98_egc_shift.input&lt;AWT&gt;(
<a name="l01412"></a>01412                 *((AWT*)(pc98_egc_last_vram[0].b+(vramoff&amp;1))),
<a name="l01413"></a>01413                 *((AWT*)(pc98_egc_last_vram[1].b+(vramoff&amp;1))),
<a name="l01414"></a>01414                 *((AWT*)(pc98_egc_last_vram[2].b+(vramoff&amp;1))),
<a name="l01415"></a>01415                 *((AWT*)(pc98_egc_last_vram[3].b+(vramoff&amp;1))),
<a name="l01416"></a>01416                 vramoff&amp;1);
<a name="l01417"></a>01417 
<a name="l01418"></a>01418             pc98_egc_shift.output&lt;AWT&gt;(
<a name="l01419"></a>01419                 *((AWT*)(pc98_egc_src[0].b+(vramoff&amp;1))),
<a name="l01420"></a>01420                 *((AWT*)(pc98_egc_src[1].b+(vramoff&amp;1))),
<a name="l01421"></a>01421                 *((AWT*)(pc98_egc_src[2].b+(vramoff&amp;1))),
<a name="l01422"></a>01422                 *((AWT*)(pc98_egc_src[3].b+(vramoff&amp;1))),
<a name="l01423"></a>01423                 vramoff&amp;1);
<a name="l01424"></a>01424         }
<a name="l01425"></a>01425 
<a name="l01426"></a>01426         <span class="comment">/* 0x4A4:</span>
<a name="l01427"></a>01427 <span class="comment">         * ...</span>
<a name="l01428"></a>01428 <span class="comment">         * bits [9:8] = register load (pc98_egc_regload[1:0])</span>
<a name="l01429"></a>01429 <span class="comment">         *    11 = invalid</span>
<a name="l01430"></a>01430 <span class="comment">         *    10 = load VRAM data before writing on VRAM write</span>
<a name="l01431"></a>01431 <span class="comment">         *    01 = load VRAM data into pattern/tile register on VRAM read</span>
<a name="l01432"></a>01432 <span class="comment">         *    00 = Do not change pattern/tile register</span>
<a name="l01433"></a>01433 <span class="comment">         * ...</span>
<a name="l01434"></a>01434 <span class="comment">         *</span>
<a name="l01435"></a>01435 <span class="comment">         * pc98_egc_regload = (val &gt;&gt; 8) &amp; 3;</span>
<a name="l01436"></a>01436 <span class="comment">         */</span>
<a name="l01437"></a>01437         <span class="comment">/* Neko Project II: if ((egc.ope &amp; 0x0300) == 0x0100) ... */</span>
<a name="l01438"></a>01438         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 1) { <span class="comment">/* load VRAM data into pattern/tile... (or INVALID) */</span>
<a name="l01439"></a>01439             *((AWT*)(pc98_gdc_tiles[0].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[0].b+(vramoff&amp;1)));
<a name="l01440"></a>01440             *((AWT*)(pc98_gdc_tiles[1].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[1].b+(vramoff&amp;1)));
<a name="l01441"></a>01441             *((AWT*)(pc98_gdc_tiles[2].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[2].b+(vramoff&amp;1)));
<a name="l01442"></a>01442             *((AWT*)(pc98_gdc_tiles[3].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[3].b+(vramoff&amp;1)));
<a name="l01443"></a>01443         }
<a name="l01444"></a>01444 
<a name="l01445"></a>01445         <span class="comment">/* 0x4A4:</span>
<a name="l01446"></a>01446 <span class="comment">         * bits [13:13] = 0=compare lead plane  1=don&#39;t</span>
<a name="l01447"></a>01447 <span class="comment">         *</span>
<a name="l01448"></a>01448 <span class="comment">         * bits [10:10] = read source</span>
<a name="l01449"></a>01449 <span class="comment">         *    1 = shifter input is CPU write data</span>
<a name="l01450"></a>01450 <span class="comment">         *    0 = shifter input is VRAM data */</span>
<a name="l01451"></a>01451         <span class="keywordflow">if</span> (pc98_egc_compare_lead) {
<a name="l01452"></a>01452             <span class="keywordflow">if</span> (!pc98_egc_shiftinput)
<a name="l01453"></a>01453                 <span class="keywordflow">return</span> *((AWT*)(pc98_egc_src[pc98_egc_lead_plane&amp;3].b));
<a name="l01454"></a>01454             <span class="keywordflow">else</span>
<a name="l01455"></a>01455                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+vramoff+0x08000+((pc98_egc_lead_plane&amp;3)*0x8000)));
<a name="l01456"></a>01456         }
<a name="l01457"></a>01457 
<a name="l01458"></a>01458         <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+fulloff));
<a name="l01459"></a>01459     }
<a name="l01460"></a>01460 
<a name="l01461"></a>01461     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> modeEGC_w(<span class="keyword">const</span> PhysPt vramoff,<span class="keyword">const</span> PhysPt fulloff,<span class="keyword">const</span> AWT val) {
<a name="l01462"></a>01462         <span class="comment">/* assume: vramoff is even IF AWT is 16-bit wide */</span>
<a name="l01463"></a>01463 
<a name="l01464"></a>01464         <span class="comment">/* 0x4A4:</span>
<a name="l01465"></a>01465 <span class="comment">         * ...</span>
<a name="l01466"></a>01466 <span class="comment">         * bits [9:8] = register load (pc98_egc_regload[1:0])</span>
<a name="l01467"></a>01467 <span class="comment">         *    11 = invalid</span>
<a name="l01468"></a>01468 <span class="comment">         *    10 = load VRAM data before writing on VRAM write</span>
<a name="l01469"></a>01469 <span class="comment">         *    01 = load VRAM data into pattern/tile register on VRAM read</span>
<a name="l01470"></a>01470 <span class="comment">         *    00 = Do not change pattern/tile register</span>
<a name="l01471"></a>01471 <span class="comment">         * ...</span>
<a name="l01472"></a>01472 <span class="comment">         * pc98_egc_regload = (val &gt;&gt; 8) &amp; 3;</span>
<a name="l01473"></a>01473 <span class="comment">         */</span>
<a name="l01474"></a>01474         <span class="comment">/* Neko Project II: if ((egc.ope &amp; 0x0300) == 0x0200) ... */</span>
<a name="l01475"></a>01475         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 2) { <span class="comment">/* load VRAM data before writing on VRAM write (or INVALID) */</span>
<a name="l01476"></a>01476             *((AWT*)(pc98_gdc_tiles[0].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x08000));
<a name="l01477"></a>01477             *((AWT*)(pc98_gdc_tiles[1].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x10000));
<a name="l01478"></a>01478             *((AWT*)(pc98_gdc_tiles[2].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x18000));
<a name="l01479"></a>01479             *((AWT*)(pc98_gdc_tiles[3].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x20000));
<a name="l01480"></a>01480         }
<a name="l01481"></a>01481 
<a name="l01482"></a>01482         egc_quad &amp;ropdata = egc_ope&lt;AWT&gt;(vramoff, val);
<a name="l01483"></a>01483 
<a name="l01484"></a>01484         <span class="keyword">const</span> AWT accmask = *((AWT*)(pc98_egc_maskef+(vramoff&amp;1)));
<a name="l01485"></a>01485 
<a name="l01486"></a>01486         <span class="keywordflow">if</span> (accmask != 0) {
<a name="l01487"></a>01487             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 1)) {
<a name="l01488"></a>01488                 *((AWT*)(vga.mem.linear+vramoff+0x08000)) &amp;= ~accmask;
<a name="l01489"></a>01489                 *((AWT*)(vga.mem.linear+vramoff+0x08000)) |=  accmask &amp; *((AWT*)(ropdata[0].b+(vramoff&amp;1)));
<a name="l01490"></a>01490             }
<a name="l01491"></a>01491             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 2)) {
<a name="l01492"></a>01492                 *((AWT*)(vga.mem.linear+vramoff+0x10000)) &amp;= ~accmask;
<a name="l01493"></a>01493                 *((AWT*)(vga.mem.linear+vramoff+0x10000)) |=  accmask &amp; *((AWT*)(ropdata[1].b+(vramoff&amp;1)));
<a name="l01494"></a>01494             }
<a name="l01495"></a>01495             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 4)) {
<a name="l01496"></a>01496                 *((AWT*)(vga.mem.linear+vramoff+0x18000)) &amp;= ~accmask;
<a name="l01497"></a>01497                 *((AWT*)(vga.mem.linear+vramoff+0x18000)) |=  accmask &amp; *((AWT*)(ropdata[2].b+(vramoff&amp;1)));
<a name="l01498"></a>01498             }
<a name="l01499"></a>01499             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 8)) {
<a name="l01500"></a>01500                 *((AWT*)(vga.mem.linear+vramoff+0x20000)) &amp;= ~accmask;
<a name="l01501"></a>01501                 *((AWT*)(vga.mem.linear+vramoff+0x20000)) |=  accmask &amp; *((AWT*)(ropdata[3].b+(vramoff&amp;1)));
<a name="l01502"></a>01502             }
<a name="l01503"></a>01503         }
<a name="l01504"></a>01504     }
<a name="l01505"></a>01505 
<a name="l01506"></a>01506     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; AWT readc(PhysPt addr) {
<a name="l01507"></a>01507         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vop_offset = 0;
<a name="l01508"></a>01508 
<a name="l01509"></a>01509                 addr = PAGING_GetPhysicalAddress(addr);
<a name="l01510"></a>01510 
<a name="l01511"></a>01511         check_align&lt;AWT&gt;(addr);
<a name="l01512"></a>01512 
<a name="l01513"></a>01513         <span class="keywordflow">if</span> ((addr &amp; (~0x1F)) == 0xA3FE0) {
<a name="l01514"></a>01514             <span class="comment">/* </span>
<a name="l01515"></a>01515 <span class="comment">             * 0xA3FE2      MSW1</span>
<a name="l01516"></a>01516 <span class="comment">             * 0xA3FE6      MSW2</span>
<a name="l01517"></a>01517 <span class="comment">             * 0xA3FEA      MSW3</span>
<a name="l01518"></a>01518 <span class="comment">             * 0xA3FEE      MSW4</span>
<a name="l01519"></a>01519 <span class="comment">             * 0xA3FF2      MSW5</span>
<a name="l01520"></a>01520 <span class="comment">             * 0xA3FF6      MSW6</span>
<a name="l01521"></a>01521 <span class="comment">             * 0xA3FFA      MSW7</span>
<a name="l01522"></a>01522 <span class="comment">             * 0xA3FFE      MSW8</span>
<a name="l01523"></a>01523 <span class="comment">             */</span>
<a name="l01524"></a>01524             <span class="keywordflow">return</span> pc98_mem_msw((addr &gt;&gt; 2) &amp; 7);
<a name="l01525"></a>01525         }
<a name="l01526"></a>01526 
<a name="l01527"></a>01527         <span class="keywordflow">if</span> (addr &gt;= 0xE0000) <span class="comment">/* the 4th bitplane (EGC 16-color mode) */</span>
<a name="l01528"></a>01528             addr = (addr &amp; 0x7FFF) + 0x20000;
<a name="l01529"></a>01529         <span class="keywordflow">else</span>
<a name="l01530"></a>01530             addr &amp;= 0x1FFFF;
<a name="l01531"></a>01531 
<a name="l01532"></a>01532         <span class="keywordflow">switch</span> (addr&gt;&gt;13) {
<a name="l01533"></a>01533             <span class="keywordflow">case</span> 0:     <span class="comment">/* A0000-A1FFF Character RAM */</span>
<a name="l01534"></a>01534                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr));
<a name="l01535"></a>01535             <span class="keywordflow">case</span> 1:     <span class="comment">/* A2000-A3FFF Attribute RAM */</span>
<a name="l01536"></a>01536                 <span class="keywordflow">if</span> (addr &amp; 1) <span class="keywordflow">return</span> ~0; <span class="comment">/* ignore odd bytes */</span>
<a name="l01537"></a>01537                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr)) | 0xFF00; <span class="comment">/* odd bytes 0xFF */</span>
<a name="l01538"></a>01538             <span class="keywordflow">case</span> 2:     <span class="comment">/* A4000-A5FFF Unknown ?? */</span>
<a name="l01539"></a>01539                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr));
<a name="l01540"></a>01540             <span class="keywordflow">case</span> 3:     <span class="comment">/* A6000-A7FFF Not present */</span>
<a name="l01541"></a>01541                 <span class="keywordflow">return</span> ~0;
<a name="l01542"></a>01542             <span class="keywordflow">default</span>:    <span class="comment">/* A8000-BFFFF G-RAM */</span>
<a name="l01543"></a>01543                 vop_offset = (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_ACCESS)) ? 0x20000 : 0;
<a name="l01544"></a>01544                 <span class="keywordflow">break</span>;
<a name="l01545"></a>01545         };
<a name="l01546"></a>01546 
<a name="l01547"></a>01547         <span class="keywordflow">switch</span> (pc98_gdc_vramop &amp; 0xF) {
<a name="l01548"></a>01548             <span class="keywordflow">case</span> 0x00:
<a name="l01549"></a>01549             <span class="keywordflow">case</span> 0x01:
<a name="l01550"></a>01550             <span class="keywordflow">case</span> 0x02:
<a name="l01551"></a>01551             <span class="keywordflow">case</span> 0x03:
<a name="l01552"></a>01552             <span class="keywordflow">case</span> 0x04:
<a name="l01553"></a>01553             <span class="keywordflow">case</span> 0x05:
<a name="l01554"></a>01554             <span class="keywordflow">case</span> 0x06:
<a name="l01555"></a>01555             <span class="keywordflow">case</span> 0x07:
<a name="l01556"></a>01556                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr+vop_offset));
<a name="l01557"></a>01557             <span class="keywordflow">case</span> 0x08: <span class="comment">/* TCR/TDW */</span>
<a name="l01558"></a>01558             <span class="keywordflow">case</span> 0x09:
<a name="l01559"></a>01559                 {
<a name="l01560"></a>01560                     AWT r = 0;
<a name="l01561"></a>01561 
<a name="l01562"></a>01562                     <span class="comment">/* this reads multiple bitplanes at once */</span>
<a name="l01563"></a>01563                     addr &amp;= 0x7FFF;
<a name="l01564"></a>01564 
<a name="l01565"></a>01565                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 1)) <span class="comment">// blue channel</span>
<a name="l01566"></a>01566                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>0,addr + 0x8000 + vop_offset);
<a name="l01567"></a>01567 
<a name="l01568"></a>01568                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 2)) <span class="comment">// red channel</span>
<a name="l01569"></a>01569                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>1,addr + 0x10000 + vop_offset);
<a name="l01570"></a>01570 
<a name="l01571"></a>01571                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 4)) <span class="comment">// green channel</span>
<a name="l01572"></a>01572                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>2,addr + 0x18000 + vop_offset);
<a name="l01573"></a>01573 
<a name="l01574"></a>01574                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 8)) <span class="comment">// extended channel</span>
<a name="l01575"></a>01575                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>3,addr + 0x20000 + vop_offset);
<a name="l01576"></a>01576 
<a name="l01577"></a>01577                     <span class="comment">/* NTS: Apparently returning this value correctly really matters to the</span>
<a name="l01578"></a>01578 <span class="comment">                     *      sprite engine in &quot;Edge&quot;, else visual errors occur. */</span>
<a name="l01579"></a>01579                     <span class="keywordflow">return</span> ~r;
<a name="l01580"></a>01580                 }
<a name="l01581"></a>01581             <span class="keywordflow">case</span> 0x0C:
<a name="l01582"></a>01582             <span class="keywordflow">case</span> 0x0D:
<a name="l01583"></a>01583                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr+vop_offset));
<a name="l01584"></a>01584             <span class="keywordflow">case</span> 0x0A: <span class="comment">/* EGC read */</span>
<a name="l01585"></a>01585             <span class="keywordflow">case</span> 0x0B:
<a name="l01586"></a>01586             <span class="keywordflow">case</span> 0x0E:
<a name="l01587"></a>01587             <span class="keywordflow">case</span> 0x0F:
<a name="l01588"></a>01588                 <span class="comment">/* this reads multiple bitplanes at once */</span>
<a name="l01589"></a>01589                 <span class="keywordflow">return</span> modeEGC_r&lt;AWT&gt;((addr&amp;0x7FFF) + vop_offset,addr + vop_offset);
<a name="l01590"></a>01590             <span class="keywordflow">default</span>: <span class="comment">/* should not happen */</span>
<a name="l01591"></a>01591                 LOG_MSG(<span class="stringliteral">&quot;PC-98 VRAM read warning: Unsupported opmode 0x%X&quot;</span>,pc98_gdc_vramop);
<a name="l01592"></a>01592                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr+vop_offset));
<a name="l01593"></a>01593         };
<a name="l01594"></a>01594 
<a name="l01595"></a>01595                 <span class="keywordflow">return</span> ~0;
<a name="l01596"></a>01596         }
<a name="l01597"></a>01597 
<a name="l01598"></a>01598         <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keywordtype">void</span> writec(PhysPt addr,AWT val){
<a name="l01599"></a>01599         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vop_offset = 0;
<a name="l01600"></a>01600 
<a name="l01601"></a>01601                 addr = PAGING_GetPhysicalAddress(addr);
<a name="l01602"></a>01602 
<a name="l01603"></a>01603         check_align&lt;AWT&gt;(addr);
<a name="l01604"></a>01604 
<a name="l01605"></a>01605         <span class="keywordflow">if</span> ((addr &amp; (~0x1F)) == 0xA3FE0)
<a name="l01606"></a>01606             <span class="keywordflow">return</span>;
<a name="l01607"></a>01607 
<a name="l01608"></a>01608         <span class="keywordflow">if</span> (addr &gt;= 0xE0000) <span class="comment">/* the 4th bitplane (EGC 16-color mode) */</span>
<a name="l01609"></a>01609             addr = (addr &amp; 0x7FFF) + 0x20000;
<a name="l01610"></a>01610         <span class="keywordflow">else</span>
<a name="l01611"></a>01611             addr &amp;= 0x1FFFF;
<a name="l01612"></a>01612 
<a name="l01613"></a>01613         <span class="keywordflow">switch</span> (addr&gt;&gt;13) {
<a name="l01614"></a>01614             <span class="keywordflow">case</span> 0:     <span class="comment">/* A0000-A1FFF Character RAM */</span>
<a name="l01615"></a>01615                 *((AWT*)(vga.mem.linear+addr)) = val;
<a name="l01616"></a>01616                 <span class="keywordflow">return</span>;
<a name="l01617"></a>01617             <span class="keywordflow">case</span> 1:     <span class="comment">/* A2000-A3FFF Attribute RAM */</span>
<a name="l01618"></a>01618                 <span class="keywordflow">if</span> (addr &amp; 1) <span class="keywordflow">return</span>; <span class="comment">/* ignore odd bytes */</span>
<a name="l01619"></a>01619                 *((AWT*)(vga.mem.linear+addr)) = val | 0xFF00;
<a name="l01620"></a>01620                 <span class="keywordflow">return</span>;
<a name="l01621"></a>01621             <span class="keywordflow">case</span> 2:     <span class="comment">/* A4000-A5FFF Unknown ?? */</span>
<a name="l01622"></a>01622                 *((AWT*)(vga.mem.linear+addr)) = val;
<a name="l01623"></a>01623                 <span class="keywordflow">return</span>;
<a name="l01624"></a>01624             <span class="keywordflow">case</span> 3:     <span class="comment">/* A6000-A7FFF Not present */</span>
<a name="l01625"></a>01625                 <span class="keywordflow">return</span>;
<a name="l01626"></a>01626             <span class="keywordflow">default</span>:    <span class="comment">/* A8000-BFFFF G-RAM */</span>
<a name="l01627"></a>01627                 vop_offset = (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_ACCESS)) ? 0x20000 : 0;
<a name="l01628"></a>01628                 <span class="keywordflow">break</span>;
<a name="l01629"></a>01629         };
<a name="l01630"></a>01630 
<a name="l01631"></a>01631         <span class="keywordflow">switch</span> (pc98_gdc_vramop &amp; 0xF) {
<a name="l01632"></a>01632             <span class="keywordflow">case</span> 0x00:
<a name="l01633"></a>01633             <span class="keywordflow">case</span> 0x01:
<a name="l01634"></a>01634             <span class="keywordflow">case</span> 0x02:
<a name="l01635"></a>01635             <span class="keywordflow">case</span> 0x03:
<a name="l01636"></a>01636             <span class="keywordflow">case</span> 0x04:
<a name="l01637"></a>01637             <span class="keywordflow">case</span> 0x05:
<a name="l01638"></a>01638             <span class="keywordflow">case</span> 0x06:
<a name="l01639"></a>01639             <span class="keywordflow">case</span> 0x07:
<a name="l01640"></a>01640                 *((AWT*)(vga.mem.linear+addr+vop_offset)) = val;
<a name="l01641"></a>01641                 <span class="keywordflow">break</span>;
<a name="l01642"></a>01642             <span class="keywordflow">case</span> 0x08:  <span class="comment">/* TCR/TDW write tile data, no masking */</span>
<a name="l01643"></a>01643             <span class="keywordflow">case</span> 0x09:
<a name="l01644"></a>01644                 {
<a name="l01645"></a>01645                     <span class="comment">/* this writes to multiple bitplanes at once.</span>
<a name="l01646"></a>01646 <span class="comment">                     * notice that the value written has no meaning, only the tile data and memory address. */</span>
<a name="l01647"></a>01647                     addr &amp;= 0x7FFF;
<a name="l01648"></a>01648 
<a name="l01649"></a>01649                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 1)) <span class="comment">// blue channel</span>
<a name="l01650"></a>01650                         mode8_w&lt;AWT&gt;(0<span class="comment">/*plane*/</span>,addr + 0x8000 + vop_offset);
<a name="l01651"></a>01651 
<a name="l01652"></a>01652                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 2)) <span class="comment">// red channel</span>
<a name="l01653"></a>01653                         mode8_w&lt;AWT&gt;(1<span class="comment">/*plane*/</span>,addr + 0x10000 + vop_offset);
<a name="l01654"></a>01654 
<a name="l01655"></a>01655                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 4)) <span class="comment">// green channel</span>
<a name="l01656"></a>01656                         mode8_w&lt;AWT&gt;(2<span class="comment">/*plane*/</span>,addr + 0x18000 + vop_offset);
<a name="l01657"></a>01657 
<a name="l01658"></a>01658                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 8)) <span class="comment">// extended channel</span>
<a name="l01659"></a>01659                         mode8_w&lt;AWT&gt;(3<span class="comment">/*plane*/</span>,addr + 0x20000 + vop_offset);
<a name="l01660"></a>01660                 }
<a name="l01661"></a>01661                 <span class="keywordflow">break</span>;
<a name="l01662"></a>01662             <span class="keywordflow">case</span> 0x0C:  <span class="comment">/* read/modify/write from tile with masking */</span>
<a name="l01663"></a>01663             <span class="keywordflow">case</span> 0x0D:  <span class="comment">/* a lot of PC-98 games seem to rely on this for sprite rendering */</span>
<a name="l01664"></a>01664                 {
<a name="l01665"></a>01665                     <span class="keyword">const</span> AWT mask = ~val;
<a name="l01666"></a>01666 
<a name="l01667"></a>01667                     <span class="comment">/* this writes to multiple bitplanes at once */</span>
<a name="l01668"></a>01668                     addr &amp;= 0x7FFF;
<a name="l01669"></a>01669 
<a name="l01670"></a>01670                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 1)) <span class="comment">// blue channel</span>
<a name="l01671"></a>01671                         modeC_w&lt;AWT&gt;(0<span class="comment">/*plane*/</span>,addr + 0x8000 + vop_offset,mask,val);
<a name="l01672"></a>01672 
<a name="l01673"></a>01673                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 2)) <span class="comment">// red channel</span>
<a name="l01674"></a>01674                         modeC_w&lt;AWT&gt;(1<span class="comment">/*plane*/</span>,addr + 0x10000 + vop_offset,mask,val);
<a name="l01675"></a>01675 
<a name="l01676"></a>01676                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 4)) <span class="comment">// green channel</span>
<a name="l01677"></a>01677                         modeC_w&lt;AWT&gt;(2<span class="comment">/*plane*/</span>,addr + 0x18000 + vop_offset,mask,val);
<a name="l01678"></a>01678 
<a name="l01679"></a>01679                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 8)) <span class="comment">// extended channel</span>
<a name="l01680"></a>01680                         modeC_w&lt;AWT&gt;(3<span class="comment">/*plane*/</span>,addr + 0x20000 + vop_offset,mask,val);
<a name="l01681"></a>01681                 }
<a name="l01682"></a>01682                 <span class="keywordflow">break</span>;
<a name="l01683"></a>01683             <span class="keywordflow">case</span> 0x0A: <span class="comment">/* EGC write */</span>
<a name="l01684"></a>01684             <span class="keywordflow">case</span> 0x0B:
<a name="l01685"></a>01685             <span class="keywordflow">case</span> 0x0E:
<a name="l01686"></a>01686             <span class="keywordflow">case</span> 0x0F:
<a name="l01687"></a>01687                 <span class="comment">/* this reads multiple bitplanes at once */</span>
<a name="l01688"></a>01688                 modeEGC_w&lt;AWT&gt;((addr&amp;0x7FFF) + vop_offset,addr + vop_offset,val);
<a name="l01689"></a>01689                 <span class="keywordflow">break</span>;
<a name="l01690"></a>01690             <span class="keywordflow">default</span>: <span class="comment">/* Should no longer happen */</span>
<a name="l01691"></a>01691                 LOG_MSG(<span class="stringliteral">&quot;PC-98 VRAM write warning: Unsupported opmode 0x%X&quot;</span>,pc98_gdc_vramop);
<a name="l01692"></a>01692                 *((AWT*)(vga.mem.linear+addr+vop_offset)) = val;
<a name="l01693"></a>01693                 <span class="keywordflow">break</span>;
<a name="l01694"></a>01694         };
<a name="l01695"></a>01695         }
<a name="l01696"></a>01696 
<a name="l01697"></a>01697     <span class="comment">/* byte-wise */</span>
<a name="l01698"></a>01698         Bitu readb(PhysPt addr) {
<a name="l01699"></a>01699         <span class="keywordflow">return</span> readc&lt;uint8_t&gt;(addr);
<a name="l01700"></a>01700     }
<a name="l01701"></a>01701         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l01702"></a>01702         writec&lt;uint8_t&gt;(addr,(uint8_t)val);
<a name="l01703"></a>01703     }
<a name="l01704"></a>01704 
<a name="l01705"></a>01705     <span class="comment">/* word-wise.</span>
<a name="l01706"></a>01706 <span class="comment">     * in the style of the 8086, non-word-aligned I/O is split into byte I/O */</span>
<a name="l01707"></a>01707         Bitu readw(PhysPt addr) {
<a name="l01708"></a>01708         <span class="keywordflow">if</span> (!(addr &amp; 1)) <span class="comment">/* if WORD aligned */</span>
<a name="l01709"></a>01709             <span class="keywordflow">return</span> readc&lt;uint16_t&gt;(addr);
<a name="l01710"></a>01710         <span class="keywordflow">else</span> {
<a name="l01711"></a>01711             <span class="keywordflow">return</span>   readc&lt;uint8_t&gt;(addr+0U) +
<a name="l01712"></a>01712                     (readc&lt;uint8_t&gt;(addr+1U) &lt;&lt; 8);
<a name="l01713"></a>01713         }
<a name="l01714"></a>01714     }
<a name="l01715"></a>01715         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l01716"></a>01716         <span class="keywordflow">if</span> (!(addr &amp; 1)) <span class="comment">/* if WORD aligned */</span>
<a name="l01717"></a>01717             writec&lt;uint16_t&gt;(addr,(uint16_t)val);
<a name="l01718"></a>01718         <span class="keywordflow">else</span> {
<a name="l01719"></a>01719             writec&lt;uint8_t&gt;(addr+0,(uint8_t)val);
<a name="l01720"></a>01720             writec&lt;uint8_t&gt;(addr+1,(uint8_t)(val &gt;&gt; 8U));
<a name="l01721"></a>01721         }
<a name="l01722"></a>01722     }
<a name="l01723"></a>01723 };
<a name="l01724"></a>01724 
<a name="l01725"></a><a class="code" href="classVGA__TEXT__PageHandler.html">01725</a> <span class="keyword">class </span><a class="code" href="classVGA__TEXT__PageHandler.html">VGA_TEXT_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01726"></a>01726 <span class="keyword">public</span>:
<a name="l01727"></a>01727         <a class="code" href="classVGA__TEXT__PageHandler.html">VGA_TEXT_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01728"></a>01728         Bitu readb(PhysPt addr) {
<a name="l01729"></a>01729                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bplane;
<a name="l01730"></a>01730 
<a name="l01731"></a>01731                 VGAMEM_USEC_read_delay();
<a name="l01732"></a>01732 
<a name="l01733"></a>01733                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l01734"></a>01734                 bplane = vga.gfx.read_map_select;
<a name="l01735"></a>01735 
<a name="l01736"></a>01736                 <span class="keywordflow">if</span> (!(vga.seq.memory_mode&amp;4))
<a name="l01737"></a>01737                         bplane = (bplane &amp; ~1) + (addr &amp; 1); <span class="comment">/* FIXME: Is this what VGA cards do? It makes sense to me */</span>
<a name="l01738"></a>01738                 <span class="keywordflow">if</span> (vga.gfx.miscellaneous&amp;2) <span class="comment">/* Odd/Even mode */</span>
<a name="l01739"></a>01739                         addr &amp;= ~1;
<a name="l01740"></a>01740 
<a name="l01741"></a>01741                 <span class="keywordflow">return</span> vga.mem.linear[CHECKED3(vga.svga.bank_read_full+(addr&lt;&lt;2)+bplane)];
<a name="l01742"></a>01742         }
<a name="l01743"></a>01743         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val){
<a name="l01744"></a>01744                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> pixels;
<a name="l01745"></a>01745                 Bitu memaddr;
<a name="l01746"></a>01746 
<a name="l01747"></a>01747                 VGAMEM_USEC_write_delay();
<a name="l01748"></a>01748 
<a name="l01749"></a>01749                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l01750"></a>01750                 memaddr = addr;
<a name="l01751"></a>01751 
<a name="l01752"></a>01752                 <span class="comment">/* Chain Odd/Even enable: A0 is replaced by a &quot;higher order bit&quot; (0 apparently) */</span>
<a name="l01753"></a>01753                 <span class="keywordflow">if</span> (vga.gfx.miscellaneous&amp;2)
<a name="l01754"></a>01754                         memaddr &amp;= ~1;
<a name="l01755"></a>01755 
<a name="l01756"></a>01756                 pixels.d=((Bit32u*)vga.mem.linear)[memaddr];
<a name="l01757"></a>01757 
<a name="l01758"></a>01758                 <span class="keywordflow">if</span> ((vga.seq.memory_mode&amp;4)<span class="comment">/*Odd/Even disable*/</span> || (addr &amp; 1)) {
<a name="l01759"></a>01759                         <span class="keywordflow">if</span> (vga.seq.map_mask &amp; 0x2) <span class="comment">/* bitplane 1: attribute RAM */</span>
<a name="l01760"></a>01760                                 pixels.b[1] = val;
<a name="l01761"></a>01761                         <span class="keywordflow">if</span> (vga.seq.map_mask &amp; 0x8) <span class="comment">/* bitplane 3: unused RAM */</span>
<a name="l01762"></a>01762                                 pixels.b[3] = val;
<a name="l01763"></a>01763                 }
<a name="l01764"></a>01764                 <span class="keywordflow">if</span> ((vga.seq.memory_mode&amp;4)<span class="comment">/*Odd/Even disable*/</span> || !(addr &amp; 1)) {
<a name="l01765"></a>01765                         <span class="keywordflow">if</span> (vga.seq.map_mask &amp; 0x1) <span class="comment">/* bitplane 0: character RAM */</span>
<a name="l01766"></a>01766                                 pixels.b[0] = val;
<a name="l01767"></a>01767                         <span class="keywordflow">if</span> (vga.seq.map_mask &amp; 0x4) { <span class="comment">/* bitplane 2: font RAM */</span>
<a name="l01768"></a>01768                                 pixels.b[2] = val;
<a name="l01769"></a>01769                                 vga.draw.font[memaddr] = val;
<a name="l01770"></a>01770                         }
<a name="l01771"></a>01771                 }
<a name="l01772"></a>01772 
<a name="l01773"></a>01773                 ((Bit32u*)vga.mem.linear)[memaddr]=pixels.d;
<a name="l01774"></a>01774         }
<a name="l01775"></a>01775 };
<a name="l01776"></a>01776 
<a name="l01777"></a><a class="code" href="classVGA__Map__Handler.html">01777</a> <span class="keyword">class </span><a class="code" href="classVGA__Map__Handler.html">VGA_Map_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01778"></a>01778 <span class="keyword">public</span>:
<a name="l01779"></a>01779         <a class="code" href="classVGA__Map__Handler.html">VGA_Map_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE|PFLAG_NOCODE) {}
<a name="l01780"></a>01780         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01781"></a>01781                 phys_page-=vgapages.base;
<a name="l01782"></a>01782                 <span class="keywordflow">return</span> &amp;vga.mem.linear[CHECKED3(vga.svga.bank_read_full+phys_page*4096)];
<a name="l01783"></a>01783         }
<a name="l01784"></a>01784         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01785"></a>01785                 phys_page-=vgapages.base;
<a name="l01786"></a>01786                 <span class="keywordflow">return</span> &amp;vga.mem.linear[CHECKED3(vga.svga.bank_write_full+phys_page*4096)];
<a name="l01787"></a>01787         }
<a name="l01788"></a>01788 };
<a name="l01789"></a>01789 
<a name="l01790"></a><a class="code" href="classVGA__Slow__CGA__Handler.html">01790</a> <span class="keyword">class </span><a class="code" href="classVGA__Slow__CGA__Handler.html">VGA_Slow_CGA_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01791"></a>01791 <span class="keyword">public</span>:
<a name="l01792"></a>01792         <a class="code" href="classVGA__Slow__CGA__Handler.html">VGA_Slow_CGA_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01793"></a>01793         <span class="keywordtype">void</span> delay() {
<a name="l01794"></a>01794                 Bits delaycyc = CPU_CycleMax/((Bit32u)(1024/2.80)); 
<a name="l01795"></a>01795                 <span class="keywordflow">if</span>(GCC_UNLIKELY(CPU_Cycles &lt; 3*delaycyc)) delaycyc=0;
<a name="l01796"></a>01796                 CPU_Cycles -= delaycyc;
<a name="l01797"></a>01797                 CPU_IODelayRemoved += delaycyc;
<a name="l01798"></a>01798         }
<a name="l01799"></a>01799 
<a name="l01800"></a>01800         Bitu readb(PhysPt addr) {
<a name="l01801"></a>01801                 delay();
<a name="l01802"></a>01802                 <span class="keywordflow">return</span> vga.tandy.mem_base[addr - 0xb8000];
<a name="l01803"></a>01803         }
<a name="l01804"></a>01804         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val){
<a name="l01805"></a>01805                 delay();
<a name="l01806"></a>01806                 vga.tandy.mem_base[addr - 0xb8000] = (Bit8u) val;
<a name="l01807"></a>01807         }
<a name="l01808"></a>01808         
<a name="l01809"></a>01809 };
<a name="l01810"></a>01810 
<a name="l01811"></a><a class="code" href="classVGA__LIN4__Handler.html">01811</a> <span class="keyword">class </span><a class="code" href="classVGA__LIN4__Handler.html">VGA_LIN4_Handler</a> : <span class="keyword">public</span> <a class="code" href="classVGA__UnchainedEGA__Handler.html">VGA_UnchainedEGA_Handler</a> {
<a name="l01812"></a>01812 <span class="keyword">public</span>:
<a name="l01813"></a>01813         <a class="code" href="classVGA__LIN4__Handler.html">VGA_LIN4_Handler</a>() : <a class="code" href="classVGA__UnchainedEGA__Handler.html">VGA_UnchainedEGA_Handler</a>(PFLAG_NOCODE) {}
<a name="l01814"></a>01814         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l01815"></a>01815                 VGAMEM_USEC_write_delay();
<a name="l01816"></a>01816                 addr = vga.svga.bank_write_full + (PAGING_GetPhysicalAddress(addr) &amp; 0xffff);
<a name="l01817"></a>01817                 addr = CHECKED4(addr);
<a name="l01818"></a>01818                 writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01819"></a>01819         }
<a name="l01820"></a>01820         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l01821"></a>01821                 VGAMEM_USEC_write_delay();
<a name="l01822"></a>01822                 addr = vga.svga.bank_write_full + (PAGING_GetPhysicalAddress(addr) &amp; 0xffff);
<a name="l01823"></a>01823                 addr = CHECKED4(addr);
<a name="l01824"></a>01824                 writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01825"></a>01825                 writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01826"></a>01826         }
<a name="l01827"></a>01827         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l01828"></a>01828                 VGAMEM_USEC_write_delay();
<a name="l01829"></a>01829                 addr = vga.svga.bank_write_full + (PAGING_GetPhysicalAddress(addr) &amp; 0xffff);
<a name="l01830"></a>01830                 addr = CHECKED4(addr);
<a name="l01831"></a>01831                 writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01832"></a>01832                 writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01833"></a>01833                 writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l01834"></a>01834                 writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l01835"></a>01835         }
<a name="l01836"></a>01836         Bitu readb(PhysPt addr) {
<a name="l01837"></a>01837                 VGAMEM_USEC_read_delay();
<a name="l01838"></a>01838                 addr = vga.svga.bank_read_full + (PAGING_GetPhysicalAddress(addr) &amp; 0xffff);
<a name="l01839"></a>01839                 addr = CHECKED4(addr);
<a name="l01840"></a>01840                 <span class="keywordflow">return</span> readHandler(addr);
<a name="l01841"></a>01841         }
<a name="l01842"></a>01842         Bitu readw(PhysPt addr) {
<a name="l01843"></a>01843                 VGAMEM_USEC_read_delay();
<a name="l01844"></a>01844                 addr = vga.svga.bank_read_full + (PAGING_GetPhysicalAddress(addr) &amp; 0xffff);
<a name="l01845"></a>01845                 addr = CHECKED4(addr);
<a name="l01846"></a>01846                 Bitu ret = (readHandler(addr+0) &lt;&lt; 0);
<a name="l01847"></a>01847                 ret     |= (readHandler(addr+1) &lt;&lt; 8);
<a name="l01848"></a>01848                 <span class="keywordflow">return</span> ret;
<a name="l01849"></a>01849         }
<a name="l01850"></a>01850         Bitu readd(PhysPt addr) {
<a name="l01851"></a>01851                 VGAMEM_USEC_read_delay();
<a name="l01852"></a>01852                 addr = vga.svga.bank_read_full + (PAGING_GetPhysicalAddress(addr) &amp; 0xffff);
<a name="l01853"></a>01853                 addr = CHECKED4(addr);
<a name="l01854"></a>01854                 Bitu ret = (readHandler(addr+0) &lt;&lt; 0);
<a name="l01855"></a>01855                 ret     |= (readHandler(addr+1) &lt;&lt; 8);
<a name="l01856"></a>01856                 ret     |= (readHandler(addr+2) &lt;&lt; 16);
<a name="l01857"></a>01857                 ret     |= (readHandler(addr+3) &lt;&lt; 24);
<a name="l01858"></a>01858                 <span class="keywordflow">return</span> ret;
<a name="l01859"></a>01859         }
<a name="l01860"></a>01860 };
<a name="l01861"></a>01861 
<a name="l01862"></a><a class="code" href="classVGA__LFB__Handler.html">01862</a> <span class="keyword">class </span><a class="code" href="classVGA__LFB__Handler.html">VGA_LFB_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01863"></a>01863 <span class="keyword">public</span>:
<a name="l01864"></a>01864         <a class="code" href="classVGA__LFB__Handler.html">VGA_LFB_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE|PFLAG_NOCODE) {}
<a name="l01865"></a>01865         HostPt GetHostReadPt( Bitu phys_page ) {
<a name="l01866"></a>01866                 phys_page -= vga.lfb.page;
<a name="l01867"></a>01867                 phys_page &amp;= (vga.vmemsize &gt;&gt; 12) - 1;
<a name="l01868"></a>01868                 <span class="keywordflow">return</span> &amp;vga.mem.linear[CHECKED3(phys_page * 4096)];
<a name="l01869"></a>01869         }
<a name="l01870"></a>01870         HostPt GetHostWritePt( Bitu phys_page ) {
<a name="l01871"></a>01871                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01872"></a>01872         }
<a name="l01873"></a>01873 };
<a name="l01874"></a>01874 
<a name="l01875"></a>01875 <span class="keyword">extern</span> <span class="keywordtype">void</span> XGA_Write(Bitu port, Bitu val, Bitu len);
<a name="l01876"></a>01876 <span class="keyword">extern</span> Bitu XGA_Read(Bitu port, Bitu len);
<a name="l01877"></a>01877 
<a name="l01878"></a><a class="code" href="classVGA__MMIO__Handler.html">01878</a> <span class="keyword">class </span><a class="code" href="classVGA__MMIO__Handler.html">VGA_MMIO_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01879"></a>01879 <span class="keyword">public</span>:
<a name="l01880"></a>01880         <a class="code" href="classVGA__MMIO__Handler.html">VGA_MMIO_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01881"></a>01881         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l01882"></a>01882                 VGAMEM_USEC_write_delay();
<a name="l01883"></a>01883                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01884"></a>01884                 XGA_Write(port, val, 1);
<a name="l01885"></a>01885         }
<a name="l01886"></a>01886         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l01887"></a>01887                 VGAMEM_USEC_write_delay();
<a name="l01888"></a>01888                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01889"></a>01889                 XGA_Write(port, val, 2);
<a name="l01890"></a>01890         }
<a name="l01891"></a>01891         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l01892"></a>01892                 VGAMEM_USEC_write_delay();
<a name="l01893"></a>01893                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01894"></a>01894                 XGA_Write(port, val, 4);
<a name="l01895"></a>01895         }
<a name="l01896"></a>01896 
<a name="l01897"></a>01897         Bitu readb(PhysPt addr) {
<a name="l01898"></a>01898                 VGAMEM_USEC_read_delay();
<a name="l01899"></a>01899                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01900"></a>01900                 <span class="keywordflow">return</span> XGA_Read(port, 1);
<a name="l01901"></a>01901         }
<a name="l01902"></a>01902         Bitu readw(PhysPt addr) {
<a name="l01903"></a>01903                 VGAMEM_USEC_read_delay();
<a name="l01904"></a>01904                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01905"></a>01905                 <span class="keywordflow">return</span> XGA_Read(port, 2);
<a name="l01906"></a>01906         }
<a name="l01907"></a>01907         Bitu readd(PhysPt addr) {
<a name="l01908"></a>01908                 VGAMEM_USEC_read_delay();
<a name="l01909"></a>01909                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01910"></a>01910                 <span class="keywordflow">return</span> XGA_Read(port, 4);
<a name="l01911"></a>01911         }
<a name="l01912"></a>01912 };
<a name="l01913"></a>01913 
<a name="l01914"></a><a class="code" href="classVGA__TANDY__PageHandler.html">01914</a> <span class="keyword">class </span><a class="code" href="classVGA__TANDY__PageHandler.html">VGA_TANDY_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01915"></a>01915 <span class="keyword">public</span>:
<a name="l01916"></a>01916         <a class="code" href="classVGA__TANDY__PageHandler.html">VGA_TANDY_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE) {}
<a name="l01917"></a>01917         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01918"></a>01918                 <span class="comment">// Odd banks are limited to 16kB and repeated</span>
<a name="l01919"></a>01919                 <span class="keywordflow">if</span> (vga.tandy.mem_bank &amp; 1) 
<a name="l01920"></a>01920                         phys_page&amp;=0x03;
<a name="l01921"></a>01921                 <span class="keywordflow">else</span> 
<a name="l01922"></a>01922                         phys_page&amp;=0x07;
<a name="l01923"></a>01923                 <span class="keywordflow">return</span> vga.tandy.mem_base + (phys_page * 4096);
<a name="l01924"></a>01924         }
<a name="l01925"></a>01925         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01926"></a>01926                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01927"></a>01927         }
<a name="l01928"></a>01928 };
<a name="l01929"></a>01929 
<a name="l01930"></a>01930 
<a name="l01931"></a><a class="code" href="classVGA__PCJR__Handler.html">01931</a> <span class="keyword">class </span><a class="code" href="classVGA__PCJR__Handler.html">VGA_PCJR_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01932"></a>01932 <span class="keyword">public</span>:
<a name="l01933"></a>01933         <a class="code" href="classVGA__PCJR__Handler.html">VGA_PCJR_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE) {}
<a name="l01934"></a>01934         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01935"></a>01935                 phys_page-=0xb8;
<a name="l01936"></a>01936                 <span class="comment">// The 16kB map area is repeated in the 32kB range</span>
<a name="l01937"></a>01937                 <span class="comment">// On CGA CPU A14 is not decoded so it repeats there too</span>
<a name="l01938"></a>01938                 phys_page&amp;=0x03;
<a name="l01939"></a>01939                 <span class="keywordflow">return</span> vga.tandy.mem_base + (phys_page * 4096);
<a name="l01940"></a>01940         }
<a name="l01941"></a>01941         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01942"></a>01942                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01943"></a>01943         }
<a name="l01944"></a>01944 };
<a name="l01945"></a>01945 
<a name="l01946"></a><a class="code" href="classVGA__AMS__Handler.html">01946</a> <span class="keyword">class </span><a class="code" href="classVGA__AMS__Handler.html">VGA_AMS_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01947"></a>01947 <span class="keyword">public</span>:
<a name="l01948"></a>01948         <span class="keyword">template</span>&lt; <span class="keywordtype">bool</span> wrapping&gt;
<a name="l01949"></a>01949         <span class="keywordtype">void</span> writeHandler(PhysPt start, Bit8u val) {
<a name="l01950"></a>01950                 vga.tandy.mem_base[ start ] = val;
<a name="l01951"></a>01951 <span class="preprocessor">#ifdef DIJDIJD</span>
<a name="l01952"></a>01952 <span class="preprocessor"></span>                Bit32u data=ModeOperation(val);
<a name="l01953"></a>01953                 <span class="comment">/* Update video memory and the pixel buffer */</span>
<a name="l01954"></a>01954                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> pixels;
<a name="l01955"></a>01955                 pixels.d=((Bit32u*)vga.mem.linear)[start];
<a name="l01956"></a>01956                 pixels.d&amp;=vga.config.full_not_map_mask;
<a name="l01957"></a>01957                 pixels.d|=(data &amp; vga.config.full_map_mask);
<a name="l01958"></a>01958                 ((Bit32u*)vga.mem.linear)[start]=pixels.d;
<a name="l01959"></a>01959                 Bit8u * write_pixels=&amp;vga.mem.linear[VGA_CACHE_OFFSET+(start&lt;&lt;3)];
<a name="l01960"></a>01960 
<a name="l01961"></a>01961                 Bit32u colors0_3, colors4_7;
<a name="l01962"></a>01962                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> temp;temp.d=(pixels.d&gt;&gt;4) &amp; 0x0f0f0f0f;
<a name="l01963"></a>01963                         colors0_3 = 
<a name="l01964"></a>01964                         Expand16Table[0][temp.b[0]] |
<a name="l01965"></a>01965                         Expand16Table[1][temp.b[1]] |
<a name="l01966"></a>01966                         Expand16Table[2][temp.b[2]] |
<a name="l01967"></a>01967                         Expand16Table[3][temp.b[3]];
<a name="l01968"></a>01968                 *(Bit32u *)write_pixels=colors0_3;
<a name="l01969"></a>01969                 temp.d=pixels.d &amp; 0x0f0f0f0f;
<a name="l01970"></a>01970                 colors4_7 = 
<a name="l01971"></a>01971                         Expand16Table[0][temp.b[0]] |
<a name="l01972"></a>01972                         Expand16Table[1][temp.b[1]] |
<a name="l01973"></a>01973                         Expand16Table[2][temp.b[2]] |
<a name="l01974"></a>01974                         Expand16Table[3][temp.b[3]];
<a name="l01975"></a>01975                 *(Bit32u *)(write_pixels+4)=colors4_7;
<a name="l01976"></a>01976                 <span class="keywordflow">if</span> (wrapping &amp;&amp; GCC_UNLIKELY( start &lt; 512)) {
<a name="l01977"></a>01977                         *(Bit32u *)(write_pixels+512*1024)=colors0_3;
<a name="l01978"></a>01978                         *(Bit32u *)(write_pixels+512*1024+4)=colors4_7;
<a name="l01979"></a>01979                 }
<a name="l01980"></a>01980 <span class="preprocessor">#endif</span>
<a name="l01981"></a>01981 <span class="preprocessor"></span>        }
<a name="l01982"></a>01982 <span class="comment">//      template&lt; bool wrapping&gt;</span>
<a name="l01983"></a>01983         Bit8u readHandler(PhysPt start) {
<a name="l01984"></a>01984                 <span class="keywordflow">return</span> vga.tandy.mem_base[ start ];
<a name="l01985"></a>01985         }
<a name="l01986"></a>01986 
<a name="l01987"></a>01987 <span class="keyword">public</span>:
<a name="l01988"></a>01988         <a class="code" href="classVGA__AMS__Handler.html">VGA_AMS_Handler</a>() {
<a name="l01989"></a>01989                 <span class="comment">//flags=PFLAG_READABLE|PFLAG_WRITEABLE;</span>
<a name="l01990"></a>01990                 flags=PFLAG_NOCODE;
<a name="l01991"></a>01991         }
<a name="l01992"></a>01992         <span class="keyword">inline</span> PhysPt wrAddr( PhysPt addr )
<a name="l01993"></a>01993         {
<a name="l01994"></a>01994                 <span class="keywordflow">if</span>( vga.mode != M_AMSTRAD )
<a name="l01995"></a>01995                 {
<a name="l01996"></a>01996                         addr -= 0xb8000;
<a name="l01997"></a>01997                         Bitu phys_page = addr &gt;&gt; 12;
<a name="l01998"></a>01998                         <span class="comment">//test for a unaliged bank, then replicate 2x16kb</span>
<a name="l01999"></a>01999                         <span class="keywordflow">if</span> (vga.tandy.mem_bank &amp; 1) 
<a name="l02000"></a>02000                                 phys_page&amp;=0x03;
<a name="l02001"></a>02001                         <span class="keywordflow">return</span> ( phys_page * 4096 ) + ( addr &amp; 0x0FFF );
<a name="l02002"></a>02002                 }
<a name="l02003"></a>02003                 <span class="keywordflow">return</span> ( (PAGING_GetPhysicalAddress(addr) &amp; 0xffff) - 0x8000 ) &amp; ( 32*1024-1 );
<a name="l02004"></a>02004         }
<a name="l02005"></a>02005 
<a name="l02006"></a>02006         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l02007"></a>02007                 VGAMEM_USEC_write_delay();
<a name="l02008"></a>02008                 addr = wrAddr( addr );
<a name="l02009"></a>02009                 Bitu plane = vga.mode==M_AMSTRAD ? vga.amstrad.write_plane : 0x01; <span class="comment">// 0x0F?</span>
<a name="l02010"></a>02010                 <span class="keywordflow">if</span>( plane &amp; 0x08 ) writeHandler&lt;false&gt;(addr+49152,(Bit8u)(val &gt;&gt; 0));
<a name="l02011"></a>02011                 <span class="keywordflow">if</span>( plane &amp; 0x04 ) writeHandler&lt;false&gt;(addr+32768,(Bit8u)(val &gt;&gt; 0));
<a name="l02012"></a>02012                 <span class="keywordflow">if</span>( plane &amp; 0x02 ) writeHandler&lt;false&gt;(addr+16384,(Bit8u)(val &gt;&gt; 0));
<a name="l02013"></a>02013                 <span class="keywordflow">if</span>( plane &amp; 0x01 ) writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02014"></a>02014         }
<a name="l02015"></a>02015         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l02016"></a>02016                 VGAMEM_USEC_write_delay();
<a name="l02017"></a>02017                 addr = wrAddr( addr );
<a name="l02018"></a>02018                 Bitu plane = vga.mode==M_AMSTRAD ? vga.amstrad.write_plane : 0x01; <span class="comment">// 0x0F?</span>
<a name="l02019"></a>02019                 <span class="keywordflow">if</span>( plane &amp; 0x01 )
<a name="l02020"></a>02020                 {
<a name="l02021"></a>02021                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02022"></a>02022                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02023"></a>02023                 }
<a name="l02024"></a>02024                 addr += 16384;
<a name="l02025"></a>02025                 <span class="keywordflow">if</span>( plane &amp; 0x02 )
<a name="l02026"></a>02026                 {
<a name="l02027"></a>02027                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02028"></a>02028                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02029"></a>02029                 }
<a name="l02030"></a>02030                 addr += 16384;
<a name="l02031"></a>02031                 <span class="keywordflow">if</span>( plane &amp; 0x04 )
<a name="l02032"></a>02032                 {
<a name="l02033"></a>02033                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02034"></a>02034                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02035"></a>02035                 }
<a name="l02036"></a>02036                 addr += 16384;
<a name="l02037"></a>02037                 <span class="keywordflow">if</span>( plane &amp; 0x08 )
<a name="l02038"></a>02038                 {
<a name="l02039"></a>02039                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02040"></a>02040                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02041"></a>02041                 }
<a name="l02042"></a>02042 
<a name="l02043"></a>02043         }
<a name="l02044"></a>02044         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l02045"></a>02045                 VGAMEM_USEC_write_delay();
<a name="l02046"></a>02046                 addr = wrAddr( addr );
<a name="l02047"></a>02047                 Bitu plane = vga.mode==M_AMSTRAD ? vga.amstrad.write_plane : 0x01; <span class="comment">// 0x0F?</span>
<a name="l02048"></a>02048                 <span class="keywordflow">if</span>( plane &amp; 0x01 )
<a name="l02049"></a>02049                 {
<a name="l02050"></a>02050                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02051"></a>02051                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02052"></a>02052                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l02053"></a>02053                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l02054"></a>02054                 }
<a name="l02055"></a>02055                 addr += 16384;
<a name="l02056"></a>02056                 <span class="keywordflow">if</span>( plane &amp; 0x02 )
<a name="l02057"></a>02057                 {
<a name="l02058"></a>02058                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02059"></a>02059                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02060"></a>02060                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l02061"></a>02061                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l02062"></a>02062                 }
<a name="l02063"></a>02063                 addr += 16384;
<a name="l02064"></a>02064                 <span class="keywordflow">if</span>( plane &amp; 0x04 )
<a name="l02065"></a>02065                 {
<a name="l02066"></a>02066                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02067"></a>02067                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02068"></a>02068                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l02069"></a>02069                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l02070"></a>02070                 }
<a name="l02071"></a>02071                 addr += 16384;
<a name="l02072"></a>02072                 <span class="keywordflow">if</span>( plane &amp; 0x08 )
<a name="l02073"></a>02073                 {
<a name="l02074"></a>02074                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l02075"></a>02075                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l02076"></a>02076                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l02077"></a>02077                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l02078"></a>02078                 }
<a name="l02079"></a>02079 
<a name="l02080"></a>02080         }
<a name="l02081"></a>02081         Bitu readb(PhysPt addr) {
<a name="l02082"></a>02082                 VGAMEM_USEC_read_delay();
<a name="l02083"></a>02083                 addr = wrAddr( addr ) + ( vga.amstrad.read_plane * 16384 );
<a name="l02084"></a>02084                 addr &amp;= (64*1024-1);
<a name="l02085"></a>02085                 <span class="keywordflow">return</span> readHandler(addr);
<a name="l02086"></a>02086         }
<a name="l02087"></a>02087         Bitu readw(PhysPt addr) {
<a name="l02088"></a>02088                 VGAMEM_USEC_read_delay();
<a name="l02089"></a>02089                 addr = wrAddr( addr ) + ( vga.amstrad.read_plane * 16384 );
<a name="l02090"></a>02090                 addr &amp;= (64*1024-1);
<a name="l02091"></a>02091                 <span class="keywordflow">return</span> 
<a name="l02092"></a>02092                         (readHandler(addr+0) &lt;&lt; 0) |
<a name="l02093"></a>02093                         (readHandler(addr+1) &lt;&lt; 8);
<a name="l02094"></a>02094         }
<a name="l02095"></a>02095         Bitu readd(PhysPt addr) {
<a name="l02096"></a>02096                 VGAMEM_USEC_read_delay();
<a name="l02097"></a>02097                 addr = wrAddr( addr ) + ( vga.amstrad.read_plane * 16384 );
<a name="l02098"></a>02098                 addr &amp;= (64*1024-1);
<a name="l02099"></a>02099                 <span class="keywordflow">return</span> 
<a name="l02100"></a>02100                         (readHandler(addr+0) &lt;&lt; 0)  |
<a name="l02101"></a>02101                         (readHandler(addr+1) &lt;&lt; 8)  |
<a name="l02102"></a>02102                         (readHandler(addr+2) &lt;&lt; 16) |
<a name="l02103"></a>02103                         (readHandler(addr+3) &lt;&lt; 24);
<a name="l02104"></a>02104         }
<a name="l02105"></a>02105 
<a name="l02106"></a>02106 <span class="comment">/*</span>
<a name="l02107"></a>02107 <span class="comment">        HostPt GetHostReadPt(Bitu phys_page)</span>
<a name="l02108"></a>02108 <span class="comment">        {</span>
<a name="l02109"></a>02109 <span class="comment">                if( vga.mode!=M_AMSTRAD )</span>
<a name="l02110"></a>02110 <span class="comment">                {</span>
<a name="l02111"></a>02111 <span class="comment">                        phys_page-=0xb8;</span>
<a name="l02112"></a>02112 <span class="comment">                        //test for a unaliged bank, then replicate 2x16kb</span>
<a name="l02113"></a>02113 <span class="comment">                        if (vga.tandy.mem_bank &amp; 1) </span>
<a name="l02114"></a>02114 <span class="comment">                                phys_page&amp;=0x03;</span>
<a name="l02115"></a>02115 <span class="comment">                        return vga.tandy.mem_base + (phys_page * 4096);</span>
<a name="l02116"></a>02116 <span class="comment">                }</span>
<a name="l02117"></a>02117 <span class="comment">                phys_page-=0xb8;</span>
<a name="l02118"></a>02118 <span class="comment">                return vga.tandy.mem_base + (phys_page*4096) + (vga.amstrad.read_plane * 16384) ;</span>
<a name="l02119"></a>02119 <span class="comment">        }</span>
<a name="l02120"></a>02120 <span class="comment">*/</span>
<a name="l02121"></a>02121 <span class="comment">/*</span>
<a name="l02122"></a>02122 <span class="comment">        HostPt GetHostWritePt(Bitu phys_page) {</span>
<a name="l02123"></a>02123 <span class="comment">                return GetHostReadPt( phys_page );</span>
<a name="l02124"></a>02124 <span class="comment">        }</span>
<a name="l02125"></a>02125 <span class="comment">*/</span>
<a name="l02126"></a>02126 };
<a name="l02127"></a>02127 
<a name="l02128"></a><a class="code" href="classVGA__HERC__Handler.html">02128</a> <span class="keyword">class </span><a class="code" href="classVGA__HERC__Handler.html">VGA_HERC_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l02129"></a>02129 <span class="keyword">public</span>:
<a name="l02130"></a>02130         <a class="code" href="classVGA__HERC__Handler.html">VGA_HERC_Handler</a>() {
<a name="l02131"></a>02131                 flags=PFLAG_READABLE|PFLAG_WRITEABLE;
<a name="l02132"></a>02132         }
<a name="l02133"></a>02133         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l02134"></a>02134                 <span class="comment">// The 4kB map area is repeated in the 32kB range</span>
<a name="l02135"></a>02135                 <span class="keywordflow">return</span> &amp;vga.mem.linear[0];
<a name="l02136"></a>02136         }
<a name="l02137"></a>02137         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l02138"></a>02138                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l02139"></a>02139         }
<a name="l02140"></a>02140 };
<a name="l02141"></a>02141 
<a name="l02142"></a><a class="code" href="classVGA__Empty__Handler.html">02142</a> <span class="keyword">class </span><a class="code" href="classVGA__Empty__Handler.html">VGA_Empty_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l02143"></a>02143 <span class="keyword">public</span>:
<a name="l02144"></a>02144         <a class="code" href="classVGA__Empty__Handler.html">VGA_Empty_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l02145"></a>02145         Bitu readb(PhysPt <span class="comment">/*addr*/</span>) {
<a name="l02146"></a>02146 <span class="comment">//              LOG(LOG_VGA, LOG_NORMAL ) ( &quot;Read from empty memory space at %x&quot;, addr );</span>
<a name="l02147"></a>02147                 <span class="keywordflow">return</span> 0xff;
<a name="l02148"></a>02148         } 
<a name="l02149"></a>02149         <span class="keywordtype">void</span> writeb(PhysPt <span class="comment">/*addr*/</span>,Bitu <span class="comment">/*val*/</span>) {
<a name="l02150"></a>02150 <span class="comment">//              LOG(LOG_VGA, LOG_NORMAL ) ( &quot;Write %x to empty memory space at %x&quot;, val, addr );</span>
<a name="l02151"></a>02151         }
<a name="l02152"></a>02152 };
<a name="l02153"></a>02153 
<a name="l02154"></a>02154 <span class="keyword">static</span> <span class="keyword">struct </span>vg {
<a name="l02155"></a>02155         <a class="code" href="classVGA__Map__Handler.html">VGA_Map_Handler</a>                         map;
<a name="l02156"></a>02156         <a class="code" href="classVGA__Slow__CGA__Handler.html">VGA_Slow_CGA_Handler</a>            slow;
<a name="l02157"></a>02157         <a class="code" href="classVGA__TEXT__PageHandler.html">VGA_TEXT_PageHandler</a>            text;
<a name="l02158"></a>02158         <a class="code" href="classVGA__CGATEXT__PageHandler.html">VGA_CGATEXT_PageHandler</a>         cgatext;
<a name="l02159"></a>02159         <a class="code" href="classVGA__TANDY__PageHandler.html">VGA_TANDY_PageHandler</a>           tandy;
<a name="l02160"></a>02160         <a class="code" href="classVGA__ChainedEGA__Handler.html">VGA_ChainedEGA_Handler</a>          cega;
<a name="l02161"></a>02161         <a class="code" href="classVGA__ChainedVGA__Handler.html">VGA_ChainedVGA_Handler</a>          cvga;
<a name="l02162"></a>02162         <a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">VGA_ChainedVGA_Slow_Handler</a>     cvga_slow;
<a name="l02163"></a>02163         <a class="code" href="classVGA__ET4000__ChainedVGA__Handler.html">VGA_ET4000_ChainedVGA_Handler</a>           cvga_et4000;
<a name="l02164"></a>02164         <a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">VGA_ET4000_ChainedVGA_Slow_Handler</a>      cvga_et4000_slow;
<a name="l02165"></a>02165         <a class="code" href="classVGA__UnchainedEGA__Handler.html">VGA_UnchainedEGA_Handler</a>        uega;
<a name="l02166"></a>02166         <a class="code" href="classVGA__UnchainedVGA__Handler.html">VGA_UnchainedVGA_Handler</a>        uvga;
<a name="l02167"></a>02167         <a class="code" href="classVGA__PCJR__Handler.html">VGA_PCJR_Handler</a>                        pcjr;
<a name="l02168"></a>02168         <a class="code" href="classVGA__HERC__Handler.html">VGA_HERC_Handler</a>                        herc;
<a name="l02169"></a>02169         <a class="code" href="classVGA__LIN4__Handler.html">VGA_LIN4_Handler</a>                        lin4;
<a name="l02170"></a>02170         <a class="code" href="classVGA__LFB__Handler.html">VGA_LFB_Handler</a>                         lfb;
<a name="l02171"></a>02171         <a class="code" href="classVGA__MMIO__Handler.html">VGA_MMIO_Handler</a>                        mmio;
<a name="l02172"></a>02172         <a class="code" href="classVGA__AMS__Handler.html">VGA_AMS_Handler</a>                         ams;
<a name="l02173"></a>02173     <a class="code" href="classVGA__PC98__PageHandler.html">VGA_PC98_PageHandler</a>        pc98;
<a name="l02174"></a>02174         <a class="code" href="classVGA__Empty__Handler.html">VGA_Empty_Handler</a>                       empty;
<a name="l02175"></a>02175 } vgaph;
<a name="l02176"></a>02176 
<a name="l02177"></a>02177 <span class="keywordtype">void</span> VGA_ChangedBank(<span class="keywordtype">void</span>) {
<a name="l02178"></a>02178         VGA_SetupHandlers();
<a name="l02179"></a>02179 }
<a name="l02180"></a>02180 
<a name="l02181"></a>02181 <span class="keywordtype">void</span> MEM_ResetPageHandler_Unmapped(Bitu phys_page, Bitu pages);
<a name="l02182"></a>02182 <span class="keywordtype">void</span> MEM_ResetPageHandler_RAM(Bitu phys_page, Bitu pages);
<a name="l02183"></a>02183 
<a name="l02184"></a>02184 <span class="keyword">extern</span> <span class="keywordtype">bool</span> adapter_rom_is_ram;
<a name="l02185"></a>02185 
<a name="l02186"></a>02186 <span class="keywordtype">void</span> VGA_SetupHandlers(<span class="keywordtype">void</span>) {
<a name="l02187"></a>02187         vga.svga.bank_read_full = vga.svga.bank_read*vga.svga.bank_size;
<a name="l02188"></a>02188         vga.svga.bank_write_full = vga.svga.bank_write*vga.svga.bank_size;
<a name="l02189"></a>02189 
<a name="l02190"></a>02190         <a class="code" href="classPageHandler.html">PageHandler</a> *newHandler;
<a name="l02191"></a>02191         <span class="keywordflow">switch</span> (machine) {
<a name="l02192"></a>02192         <span class="keywordflow">case</span> MCH_CGA:
<a name="l02193"></a>02193                 <span class="keywordflow">if</span> (enableCGASnow &amp;&amp; (vga.mode == M_TEXT || vga.mode == M_TANDY_TEXT))
<a name="l02194"></a>02194                         MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.cgatext );
<a name="l02195"></a>02195                 <span class="keywordflow">else</span>
<a name="l02196"></a>02196                         MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.slow );
<a name="l02197"></a>02197                 <span class="keywordflow">goto</span> range_done;
<a name="l02198"></a>02198         <span class="keywordflow">case</span> MCH_PCJR:
<a name="l02199"></a>02199                 MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.pcjr );
<a name="l02200"></a>02200                 <span class="keywordflow">goto</span> range_done;
<a name="l02201"></a>02201         <span class="keywordflow">case</span> MCH_HERC:
<a name="l02202"></a>02202                 vgapages.base=VGA_PAGE_B0;
<a name="l02203"></a>02203                 <span class="comment">/* NTS: Implemented according to [http://www.seasip.info/VintagePC/hercplus.html#regs] */</span>
<a name="l02204"></a>02204                 <span class="keywordflow">if</span> (vga.herc.enable_bits &amp; 0x2) { <span class="comment">/* bit 1: page in upper 32KB */</span>
<a name="l02205"></a>02205                         vgapages.mask=0xffff;
<a name="l02206"></a>02206                         <span class="comment">/* NTS: I don&#39;t know what Hercules graphics cards do if you set bit 1 but not bit 0.</span>
<a name="l02207"></a>02207 <span class="comment">                         *      For the time being, I&#39;m assuming that they respond to 0xB8000+ because of bit 1</span>
<a name="l02208"></a>02208 <span class="comment">                         *      but only map to the first 4KB because of bit 0. Basically, a configuration no</span>
<a name="l02209"></a>02209 <span class="comment">                         *      software would actually use. */</span>
<a name="l02210"></a>02210                         <span class="keywordflow">if</span> (vga.herc.enable_bits &amp; 0x1) <span class="comment">/* allow graphics and enable 0xB1000-0xB7FFF */</span>
<a name="l02211"></a>02211                                 MEM_SetPageHandler(VGA_PAGE_B0,16,&amp;vgaph.map);
<a name="l02212"></a>02212                         <span class="keywordflow">else</span>
<a name="l02213"></a>02213                                 MEM_SetPageHandler(VGA_PAGE_B0,16,&amp;vgaph.herc);
<a name="l02214"></a>02214                 } <span class="keywordflow">else</span> {
<a name="l02215"></a>02215                         vgapages.mask=0x7fff;
<a name="l02216"></a>02216                         <span class="comment">// With hercules in 32kB mode it leaves a memory hole on 0xb800</span>
<a name="l02217"></a>02217                         <span class="comment">// and has MDA-compatible address wrapping when graphics are disabled</span>
<a name="l02218"></a>02218                         <span class="keywordflow">if</span> (vga.herc.enable_bits &amp; 0x1)
<a name="l02219"></a>02219                                 MEM_SetPageHandler(VGA_PAGE_B0,8,&amp;vgaph.map);
<a name="l02220"></a>02220                         <span class="keywordflow">else</span>
<a name="l02221"></a>02221                                 MEM_SetPageHandler(VGA_PAGE_B0,8,&amp;vgaph.herc);
<a name="l02222"></a>02222                         MEM_SetPageHandler(VGA_PAGE_B8,8,&amp;vgaph.empty);
<a name="l02223"></a>02223                 }
<a name="l02224"></a>02224                 <span class="keywordflow">goto</span> range_done;
<a name="l02225"></a>02225         <span class="keywordflow">case</span> MCH_TANDY:
<a name="l02226"></a>02226                 <span class="comment">/* Always map 0xa000 - 0xbfff, might overwrite 0xb800 */</span>
<a name="l02227"></a>02227                 vgapages.base=VGA_PAGE_A0;
<a name="l02228"></a>02228                 vgapages.mask=0x1ffff;
<a name="l02229"></a>02229                 MEM_SetPageHandler(VGA_PAGE_A0, 32, &amp;vgaph.map );
<a name="l02230"></a>02230                 <span class="keywordflow">if</span> ( vga.tandy.extended_ram &amp; 1 ) {
<a name="l02231"></a>02231                         <span class="comment">//You seem to be able to also map different 64kb banks, but have to figure that out</span>
<a name="l02232"></a>02232                         <span class="comment">//This seems to work so far though</span>
<a name="l02233"></a>02233                         vga.tandy.draw_base = vga.mem.linear;
<a name="l02234"></a>02234                         vga.tandy.mem_base = vga.mem.linear;
<a name="l02235"></a>02235                 } <span class="keywordflow">else</span> {
<a name="l02236"></a>02236                         vga.tandy.draw_base = TANDY_VIDBASE( vga.tandy.draw_bank * 16 * 1024);
<a name="l02237"></a>02237                         vga.tandy.mem_base = TANDY_VIDBASE( vga.tandy.mem_bank * 16 * 1024);
<a name="l02238"></a>02238                         MEM_SetPageHandler( 0xb8, 8, &amp;vgaph.tandy );
<a name="l02239"></a>02239                 }
<a name="l02240"></a>02240                 <span class="keywordflow">goto</span> range_done;
<a name="l02241"></a>02241 <span class="comment">//              MEM_SetPageHandler(vga.tandy.mem_bank&lt;&lt;2,vga.tandy.is_32k_mode ? 0x08 : 0x04,range_handler);</span>
<a name="l02242"></a>02242         <span class="keywordflow">case</span> MCH_AMSTRAD: <span class="comment">// Memory handler.</span>
<a name="l02243"></a>02243                 MEM_SetPageHandler( 0xb8, 8, &amp;vgaph.ams );
<a name="l02244"></a>02244                 <span class="keywordflow">goto</span> range_done;
<a name="l02245"></a>02245         <span class="keywordflow">case</span> EGAVGA_ARCH_CASE:
<a name="l02246"></a>02246     <span class="keywordflow">case</span> PC98_ARCH_CASE:
<a name="l02247"></a>02247                 <span class="keywordflow">break</span>;
<a name="l02248"></a>02248         <span class="keywordflow">default</span>:
<a name="l02249"></a>02249                 LOG_MSG(<span class="stringliteral">&quot;Illegal machine type %d&quot;</span>, machine );
<a name="l02250"></a>02250                 <span class="keywordflow">return</span>;
<a name="l02251"></a>02251         }
<a name="l02252"></a>02252 
<a name="l02253"></a>02253         <span class="comment">/* This should be vga only */</span>
<a name="l02254"></a>02254         <span class="keywordflow">switch</span> (vga.mode) {
<a name="l02255"></a>02255         <span class="keywordflow">case</span> M_ERROR:
<a name="l02256"></a>02256         <span class="keywordflow">default</span>:
<a name="l02257"></a>02257                 <span class="keywordflow">return</span>;
<a name="l02258"></a>02258         <span class="keywordflow">case</span> M_LIN4:
<a name="l02259"></a>02259                 newHandler = &amp;vgaph.lin4;
<a name="l02260"></a>02260                 <span class="keywordflow">break</span>;  
<a name="l02261"></a>02261         <span class="keywordflow">case</span> M_LIN15:
<a name="l02262"></a>02262         <span class="keywordflow">case</span> M_LIN16:
<a name="l02263"></a>02263         <span class="keywordflow">case</span> M_LIN24:
<a name="l02264"></a>02264         <span class="keywordflow">case</span> M_LIN32:
<a name="l02265"></a>02265                 newHandler = &amp;vgaph.map;
<a name="l02266"></a>02266                 <span class="keywordflow">break</span>;
<a name="l02267"></a>02267         <span class="keywordflow">case</span> M_LIN8:
<a name="l02268"></a>02268         <span class="keywordflow">case</span> M_VGA:
<a name="l02269"></a>02269                 <span class="keywordflow">if</span> (vga.config.chained) {
<a name="l02270"></a>02270                         <span class="keywordtype">bool</span> slow = <span class="keyword">false</span>;
<a name="l02271"></a>02271 
<a name="l02272"></a>02272                         <span class="comment">/* NTS: Most demos and games do not use the Graphics Controller ROPs or bitmask in chained</span>
<a name="l02273"></a>02273 <span class="comment">                         *      VGA modes. But, for the few that do, we have a &quot;slow and accurate&quot; implementation</span>
<a name="l02274"></a>02274 <span class="comment">                         *      that will handle these demos properly at the expense of some emulation speed.</span>
<a name="l02275"></a>02275 <span class="comment">                         *</span>
<a name="l02276"></a>02276 <span class="comment">                         *      This fixes:</span>
<a name="l02277"></a>02277 <span class="comment">                         *        Impact Studios &#39;Legend&#39; demo (1993) */</span>
<a name="l02278"></a>02278                         <span class="keywordflow">if</span> (vga.config.full_bit_mask != 0xFFFFFFFF)
<a name="l02279"></a>02279                                 slow = <span class="keyword">true</span>;
<a name="l02280"></a>02280 
<a name="l02281"></a>02281                         <span class="keywordflow">if</span> (slow || vga.config.compatible_chain4) {
<a name="l02282"></a>02282                                 <span class="comment">/* NTS: ET4000AX cards appear to have a different chain4 implementation from everyone else:</span>
<a name="l02283"></a>02283 <span class="comment">                                 *      the planar memory byte address is address &gt;&gt; 2 and bits A0-A1 select the plane,</span>
<a name="l02284"></a>02284 <span class="comment">                                 *      where all other clones I&#39;ve tested seem to write planar memory byte (address &amp; ~3)</span>
<a name="l02285"></a>02285 <span class="comment">                                 *      (one byte per 4 bytes) and bits A0-A1 select the plane. */</span>
<a name="l02286"></a>02286                                 <span class="comment">/* FIXME: Different chain4 implementation on ET4000 noted---is it true also for ET3000? */</span>
<a name="l02287"></a>02287                                 <span class="keywordflow">if</span> (svgaCard == SVGA_TsengET3K || svgaCard == SVGA_TsengET4K)
<a name="l02288"></a>02288                                         newHandler = slow ? ((<a class="code" href="classPageHandler.html">PageHandler</a>*)(&amp;vgaph.cvga_et4000_slow)) : ((<a class="code" href="classPageHandler.html">PageHandler</a>*)(&amp;vgaph.cvga_et4000));
<a name="l02289"></a>02289                                 <span class="keywordflow">else</span>
<a name="l02290"></a>02290                                         newHandler = slow ? ((<a class="code" href="classPageHandler.html">PageHandler</a>*)(&amp;vgaph.cvga_slow)) : ((<a class="code" href="classPageHandler.html">PageHandler</a>*)(&amp;vgaph.cvga));
<a name="l02291"></a>02291                         }
<a name="l02292"></a>02292                         <span class="keywordflow">else</span> {
<a name="l02293"></a>02293                                 newHandler = &amp;vgaph.map;
<a name="l02294"></a>02294                         }
<a name="l02295"></a>02295                 } <span class="keywordflow">else</span> {
<a name="l02296"></a>02296                         newHandler = &amp;vgaph.uvga;
<a name="l02297"></a>02297                 }
<a name="l02298"></a>02298                 <span class="keywordflow">break</span>;
<a name="l02299"></a>02299         <span class="keywordflow">case</span> M_EGA:
<a name="l02300"></a>02300                 <span class="keywordflow">if</span> (vga.config.chained) 
<a name="l02301"></a>02301                         newHandler = &amp;vgaph.cega;
<a name="l02302"></a>02302                 <span class="keywordflow">else</span>
<a name="l02303"></a>02303                         newHandler = &amp;vgaph.uega;
<a name="l02304"></a>02304                 <span class="keywordflow">break</span>;  
<a name="l02305"></a>02305         <span class="keywordflow">case</span> M_TEXT:
<a name="l02306"></a>02306         <span class="keywordflow">case</span> M_CGA2:
<a name="l02307"></a>02307         <span class="keywordflow">case</span> M_CGA4:
<a name="l02308"></a>02308                 newHandler = &amp;vgaph.text;
<a name="l02309"></a>02309                 <span class="keywordflow">break</span>;
<a name="l02310"></a>02310     <span class="keywordflow">case</span> M_PC98:
<a name="l02311"></a>02311                 newHandler = &amp;vgaph.pc98;
<a name="l02312"></a>02312 
<a name="l02313"></a>02313         <span class="comment">/* We need something to catch access to E0000-E7FFF IF 16/256-color mode */</span>
<a name="l02314"></a>02314         <span class="keywordflow">if</span> (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_ANALOG))
<a name="l02315"></a>02315             MEM_SetPageHandler(0xE0, 8, newHandler );
<a name="l02316"></a>02316         <span class="keywordflow">else</span>
<a name="l02317"></a>02317             MEM_ResetPageHandler_Unmapped(0xE0, 8);
<a name="l02318"></a>02318 
<a name="l02319"></a>02319         <span class="keywordflow">break</span>;
<a name="l02320"></a>02320         <span class="keywordflow">case</span> M_AMSTRAD:
<a name="l02321"></a>02321                 newHandler = &amp;vgaph.map;
<a name="l02322"></a>02322                 <span class="keywordflow">break</span>;
<a name="l02323"></a>02323         }
<a name="l02324"></a>02324         <span class="keywordflow">switch</span> ((vga.gfx.miscellaneous &gt;&gt; 2) &amp; 3) {
<a name="l02325"></a>02325         <span class="keywordflow">case</span> 0:
<a name="l02326"></a>02326                 vgapages.base = VGA_PAGE_A0;
<a name="l02327"></a>02327                 <span class="keywordflow">switch</span> (svgaCard) {
<a name="l02328"></a>02328                 <span class="keywordflow">case</span> SVGA_TsengET3K:
<a name="l02329"></a>02329                         <span class="keywordflow">break</span>;
<a name="l02330"></a>02330                 <span class="comment">/* NTS: Looking at the official ET4000 programming guide, it does in fact support the full 128KB */</span>
<a name="l02331"></a>02331                 <span class="keywordflow">case</span> SVGA_S3Trio:
<a name="l02332"></a>02332                 <span class="keywordflow">default</span>:
<a name="l02333"></a>02333                         vgapages.mask = 0x1ffff;
<a name="l02334"></a>02334                         <span class="keywordflow">break</span>;
<a name="l02335"></a>02335                 }
<a name="l02336"></a>02336                 MEM_SetPageHandler(VGA_PAGE_A0, 32, newHandler );
<a name="l02337"></a>02337                 <span class="keywordflow">break</span>;
<a name="l02338"></a>02338         <span class="keywordflow">case</span> 1:
<a name="l02339"></a>02339                 vgapages.base = VGA_PAGE_A0;
<a name="l02340"></a>02340                 vgapages.mask = 0xffff;
<a name="l02341"></a>02341                 MEM_SetPageHandler( VGA_PAGE_A0, 16, newHandler );
<a name="l02342"></a>02342                 <span class="keywordflow">if</span> (adapter_rom_is_ram) MEM_ResetPageHandler_RAM( VGA_PAGE_B0, 16);
<a name="l02343"></a>02343                 <span class="keywordflow">else</span> MEM_ResetPageHandler_Unmapped( VGA_PAGE_B0, 16);
<a name="l02344"></a>02344                 <span class="keywordflow">break</span>;
<a name="l02345"></a>02345         <span class="keywordflow">case</span> 2:
<a name="l02346"></a>02346                 vgapages.base = VGA_PAGE_B0;
<a name="l02347"></a>02347                 vgapages.mask = 0x7fff;
<a name="l02348"></a>02348                 MEM_SetPageHandler( VGA_PAGE_B0, 8, newHandler );
<a name="l02349"></a>02349                 <span class="keywordflow">if</span> (adapter_rom_is_ram) {
<a name="l02350"></a>02350                         MEM_ResetPageHandler_RAM( VGA_PAGE_A0, 16 );
<a name="l02351"></a>02351                         MEM_ResetPageHandler_RAM( VGA_PAGE_B8, 8 );
<a name="l02352"></a>02352                 }
<a name="l02353"></a>02353                 <span class="keywordflow">else</span> {
<a name="l02354"></a>02354                         MEM_ResetPageHandler_Unmapped( VGA_PAGE_A0, 16 );
<a name="l02355"></a>02355                         MEM_ResetPageHandler_Unmapped( VGA_PAGE_B8, 8 );
<a name="l02356"></a>02356                 }
<a name="l02357"></a>02357                 <span class="keywordflow">break</span>;
<a name="l02358"></a>02358         <span class="keywordflow">case</span> 3:
<a name="l02359"></a>02359                 vgapages.base = VGA_PAGE_B8;
<a name="l02360"></a>02360                 vgapages.mask = 0x7fff;
<a name="l02361"></a>02361                 MEM_SetPageHandler( VGA_PAGE_B8, 8, newHandler );
<a name="l02362"></a>02362                 <span class="keywordflow">if</span> (adapter_rom_is_ram) {
<a name="l02363"></a>02363                         MEM_ResetPageHandler_RAM( VGA_PAGE_A0, 16 );
<a name="l02364"></a>02364                         MEM_ResetPageHandler_RAM( VGA_PAGE_B0, 8 );
<a name="l02365"></a>02365                 }
<a name="l02366"></a>02366                 <span class="keywordflow">else</span> {
<a name="l02367"></a>02367                         MEM_ResetPageHandler_Unmapped( VGA_PAGE_A0, 16 );
<a name="l02368"></a>02368                         MEM_ResetPageHandler_Unmapped( VGA_PAGE_B0, 8 );
<a name="l02369"></a>02369                 }
<a name="l02370"></a>02370                 <span class="keywordflow">break</span>;
<a name="l02371"></a>02371         }
<a name="l02372"></a>02372         <span class="keywordflow">if</span>(svgaCard == SVGA_S3Trio &amp;&amp; (vga.s3.ext_mem_ctrl &amp; 0x10))
<a name="l02373"></a>02373                 MEM_SetPageHandler(VGA_PAGE_A0, 16, &amp;vgaph.mmio);
<a name="l02374"></a>02374 range_done:
<a name="l02375"></a>02375         PAGING_ClearTLB();
<a name="l02376"></a>02376 }
<a name="l02377"></a>02377 
<a name="l02378"></a>02378 <span class="keywordtype">void</span> VGA_StartUpdateLFB(<span class="keywordtype">void</span>) {
<a name="l02379"></a>02379         <span class="comment">/* please obey the Linear Address Window Size register!</span>
<a name="l02380"></a>02380 <span class="comment">         * Windows 3.1 S3 driver will reprogram the linear framebuffer down to 0xA0000 when entering a DOSBox</span>
<a name="l02381"></a>02381 <span class="comment">         * and assuming the full VRAM size will cause a LOT of problems! */</span>
<a name="l02382"></a>02382         Bitu winsz = 0x10000;
<a name="l02383"></a>02383 
<a name="l02384"></a>02384         <span class="keywordflow">switch</span> (vga.s3.reg_58&amp;3) {
<a name="l02385"></a>02385                 <span class="keywordflow">case</span> 1:
<a name="l02386"></a>02386                         winsz = 1 &lt;&lt; 20;        <span class="comment">//1MB</span>
<a name="l02387"></a>02387                         <span class="keywordflow">break</span>;
<a name="l02388"></a>02388                 <span class="keywordflow">case</span> 2:
<a name="l02389"></a>02389                         winsz = 2 &lt;&lt; 20;        <span class="comment">//2MB</span>
<a name="l02390"></a>02390                         <span class="keywordflow">break</span>;
<a name="l02391"></a>02391                 <span class="keywordflow">case</span> 3:
<a name="l02392"></a>02392                         winsz = 4 &lt;&lt; 20;        <span class="comment">//4MB</span>
<a name="l02393"></a>02393                         <span class="keywordflow">break</span>;
<a name="l02394"></a>02394                 <span class="comment">// FIXME: What about the 8MB window?</span>
<a name="l02395"></a>02395         }
<a name="l02396"></a>02396 
<a name="l02397"></a>02397         <span class="comment">/* if the DOS application or Windows 3.1 driver attempts to put the linear framebuffer</span>
<a name="l02398"></a>02398 <span class="comment">         * below the top of memory, then we&#39;re probably entering a DOS VM and it&#39;s probably</span>
<a name="l02399"></a>02399 <span class="comment">         * a 64KB window. If it&#39;s not a 64KB window then print a warning. */</span>
<a name="l02400"></a>02400         <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(vga.s3.la_window &lt;&lt; 4UL) &lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)MEM_TotalPages()) {
<a name="l02401"></a>02401                 <span class="keywordflow">if</span> (winsz != 0x10000) <span class="comment">// 64KB window normal for entering a DOS VM in Windows 3.1 or legacy bank switching in DOS</span>
<a name="l02402"></a>02402                         <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_WARN)(<span class="stringliteral">&quot;S3 warning: Window size != 64KB and address conflict with system RAM!&quot;</span>);
<a name="l02403"></a>02403 
<a name="l02404"></a>02404                 vga.lfb.page = vga.s3.la_window &lt;&lt; 4;
<a name="l02405"></a>02405                 vga.lfb.addr = vga.s3.la_window &lt;&lt; 16;
<a name="l02406"></a>02406                 vga.lfb.handler = NULL;
<a name="l02407"></a>02407                 MEM_SetLFB(0,0,NULL,NULL);
<a name="l02408"></a>02408         }
<a name="l02409"></a>02409         <span class="keywordflow">else</span> {
<a name="l02410"></a>02410                 vga.lfb.page = vga.s3.la_window &lt;&lt; 4;
<a name="l02411"></a>02411                 vga.lfb.addr = vga.s3.la_window &lt;&lt; 16;
<a name="l02412"></a>02412                 vga.lfb.handler = &amp;vgaph.lfb;
<a name="l02413"></a>02413                 MEM_SetLFB(vga.s3.la_window &lt;&lt; 4 ,vga.vmemsize/4096, vga.lfb.handler, &amp;vgaph.mmio);
<a name="l02414"></a>02414         }
<a name="l02415"></a>02415 }
<a name="l02416"></a>02416 
<a name="l02417"></a>02417 <span class="keyword">static</span> <span class="keywordtype">bool</span> VGA_Memory_ShutDown_init = <span class="keyword">false</span>;
<a name="l02418"></a>02418 
<a name="l02419"></a>02419 <span class="keyword">static</span> <span class="keywordtype">void</span> VGA_Memory_ShutDown(<a class="code" href="classSection.html">Section</a> * <span class="comment">/*sec*/</span>) {
<a name="l02420"></a>02420         MEM_SetPageHandler(VGA_PAGE_A0,32,&amp;vgaph.empty);
<a name="l02421"></a>02421         PAGING_ClearTLB();
<a name="l02422"></a>02422 
<a name="l02423"></a>02423         <span class="keywordflow">if</span> (vga.mem.linear_orgptr != NULL) {
<a name="l02424"></a>02424                 <span class="keyword">delete</span>[] vga.mem.linear_orgptr;
<a name="l02425"></a>02425                 vga.mem.linear_orgptr = NULL;
<a name="l02426"></a>02426                 vga.mem.linear = NULL;
<a name="l02427"></a>02427         }
<a name="l02428"></a>02428 }
<a name="l02429"></a>02429 
<a name="l02430"></a>02430 <span class="keywordtype">void</span> VGA_SetupMemory() {
<a name="l02431"></a>02431         vga.svga.bank_read = vga.svga.bank_write = 0;
<a name="l02432"></a>02432         vga.svga.bank_read_full = vga.svga.bank_write_full = 0;
<a name="l02433"></a>02433 
<a name="l02434"></a>02434     <span class="keywordflow">if</span> (1 || vga.vmemsize_alloced != vga.vmemsize) {
<a name="l02435"></a>02435         VGA_Memory_ShutDown(NULL);
<a name="l02436"></a>02436 
<a name="l02437"></a>02437         vga.mem.linear_orgptr = <span class="keyword">new</span> Bit8u[vga.vmemsize+32];
<a name="l02438"></a>02438         memset(vga.mem.linear_orgptr,0,vga.vmemsize+32);
<a name="l02439"></a>02439         vga.mem.linear=(Bit8u*)(((uintptr_t)vga.mem.linear_orgptr + 16-1) &amp; ~(16-1));
<a name="l02440"></a>02440         vga.vmemsize_alloced = vga.vmemsize;
<a name="l02441"></a>02441 
<a name="l02442"></a>02442         <span class="comment">/* HACK. try to avoid stale pointers */</span>
<a name="l02443"></a>02443             vga.draw.linear_base = vga.mem.linear;
<a name="l02444"></a>02444         vga.tandy.draw_base = vga.mem.linear;
<a name="l02445"></a>02445         vga.tandy.mem_base = vga.mem.linear;
<a name="l02446"></a>02446 
<a name="l02447"></a>02447         <span class="comment">/* may be related */</span>
<a name="l02448"></a>02448         VGA_SetupHandlers();
<a name="l02449"></a>02449     }
<a name="l02450"></a>02450 
<a name="l02451"></a>02451         <span class="comment">// In most cases these values stay the same. Assumptions: vmemwrap is power of 2, vmemwrap &lt;= vmemsize</span>
<a name="l02452"></a>02452         vga.vmemwrap = vga.vmemsize;
<a name="l02453"></a>02453 
<a name="l02454"></a>02454         vga.svga.bank_read = vga.svga.bank_write = 0;
<a name="l02455"></a>02455         vga.svga.bank_read_full = vga.svga.bank_write_full = 0;
<a name="l02456"></a>02456         vga.svga.bank_size = 0x10000; <span class="comment">/* most common bank size is 64K */</span>
<a name="l02457"></a>02457 
<a name="l02458"></a>02458         <span class="keywordflow">if</span> (!VGA_Memory_ShutDown_init) {
<a name="l02459"></a>02459                 AddExitFunction(AddExitFunctionFuncPair(VGA_Memory_ShutDown));
<a name="l02460"></a>02460                 VGA_Memory_ShutDown_init = <span class="keyword">true</span>;
<a name="l02461"></a>02461         }
<a name="l02462"></a>02462 
<a name="l02463"></a>02463         <span class="keywordflow">if</span> (machine==MCH_PCJR) {
<a name="l02464"></a>02464                 <span class="comment">/* PCJr does not have dedicated graphics memory but uses</span>
<a name="l02465"></a>02465 <span class="comment">                   conventional memory below 128k */</span>
<a name="l02466"></a>02466                 <span class="comment">//TODO map?     </span>
<a name="l02467"></a>02467         } 
<a name="l02468"></a>02468 }
<a name="l02469"></a>02469 
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 20 2018 12:41:04 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
