<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/hardware/vga_memory.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/hardware/vga_memory.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  Copyright (C) 2002-2015  The DOSBox Team</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  This program is free software; you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment"> *  (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *  This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment"> *  GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment"> *  along with this program; if not, write to the Free Software</span>
<a name="l00016"></a>00016 <span class="comment"> *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;dosbox.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;mem.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;vga.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;paging.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;pic.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;inout.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;setup.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;pc98_cg.h&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;pc98_gdc.h&quot;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="keyword">extern</span> <span class="keywordtype">bool</span> non_cga_ignore_oddeven;
<a name="l00036"></a>00036 <span class="keyword">extern</span> <span class="keywordtype">bool</span> non_cga_ignore_oddeven_engage;
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#ifndef C_VGARAM_CHECKED</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#define C_VGARAM_CHECKED 1</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span>
<a name="l00042"></a>00042 <span class="preprocessor">#if C_VGARAM_CHECKED</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="comment">// Checked linear offset</span>
<a name="l00044"></a>00044 <span class="preprocessor">#define CHECKED(v) ((v)&amp;vga.mem.memmask)</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="comment">// Checked planar offset (latched access)</span>
<a name="l00046"></a>00046 <span class="preprocessor">#define CHECKED2(v) ((v)&amp;(vga.mem.memmask&gt;&gt;2))</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#define CHECKED(v) (v)</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#define CHECKED2(v) (v)</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a>00052 <span class="preprocessor">#define CHECKED3(v) ((v)&amp;vga.mem.memmask)</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#define CHECKED4(v) ((v)&amp;(vga.mem.memmask&gt;&gt;2))</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span>
<a name="l00055"></a>00055 <span class="preprocessor">#define TANDY_VIDBASE(_X_)  &amp;MemBase[ 0x80000 + (_X_)]</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>
<a name="l00057"></a>00057 <span class="comment">/* how much delay to add to VGA memory I/O in nanoseconds */</span>
<a name="l00058"></a>00058 <span class="keywordtype">int</span> vga_memio_delay_ns = 1000;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="keywordtype">void</span> VGAMEM_USEC_read_delay() {
<a name="l00061"></a>00061         <span class="keywordflow">if</span> (vga_memio_delay_ns &gt; 0) {
<a name="l00062"></a>00062                 Bits delaycyc = (CPU_CycleMax * vga_memio_delay_ns) / 1000000;
<a name="l00063"></a>00063 <span class="comment">//              if(GCC_UNLIKELY(CPU_Cycles &lt; 3*delaycyc)) delaycyc = 0; //Else port acces will set cycles to 0. which might trigger problem with games which read 16 bit values</span>
<a name="l00064"></a>00064                 CPU_Cycles -= delaycyc;
<a name="l00065"></a>00065                 CPU_IODelayRemoved += delaycyc;
<a name="l00066"></a>00066         }
<a name="l00067"></a>00067 }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="keywordtype">void</span> VGAMEM_USEC_write_delay() {
<a name="l00070"></a>00070         <span class="keywordflow">if</span> (vga_memio_delay_ns &gt; 0) {
<a name="l00071"></a>00071                 Bits delaycyc = (CPU_CycleMax * vga_memio_delay_ns * 3) / (1000000 * 4);
<a name="l00072"></a>00072 <span class="comment">//              if(GCC_UNLIKELY(CPU_Cycles &lt; 3*delaycyc)) delaycyc = 0; //Else port acces will set cycles to 0. which might trigger problem with games which read 16 bit values</span>
<a name="l00073"></a>00073                 CPU_Cycles -= delaycyc;
<a name="l00074"></a>00074                 CPU_IODelayRemoved += delaycyc;
<a name="l00075"></a>00075         }
<a name="l00076"></a>00076 }
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Size&gt;
<a name="l00079"></a>00079 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> hostWrite(HostPt off, Bitu val) {
<a name="l00080"></a>00080         <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 1)
<a name="l00081"></a>00081                 host_writeb( off, (Bit8u)val );
<a name="l00082"></a>00082         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 2)
<a name="l00083"></a>00083                 host_writew( off, (Bit16u)val );
<a name="l00084"></a>00084         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 4)
<a name="l00085"></a>00085                 host_writed( off, (Bit32u)val );
<a name="l00086"></a>00086 }
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Size&gt;
<a name="l00089"></a>00089 <span class="keyword">static</span> INLINE Bitu  hostRead(HostPt off ) {
<a name="l00090"></a>00090         <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 1)
<a name="l00091"></a>00091                 <span class="keywordflow">return</span> host_readb( off );
<a name="l00092"></a>00092         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 2)
<a name="l00093"></a>00093                 <span class="keywordflow">return</span> host_readw( off );
<a name="l00094"></a>00094         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <span class="keyword">sizeof</span>( <a class="code" href="namespaceGUI.html#a10b6232e08729baa0bd211a86a69ce36" title="A type which holds size values that can be very large.">Size</a> ) == 4)
<a name="l00095"></a>00095                 <span class="keywordflow">return</span> host_readd( off );
<a name="l00096"></a>00096         <span class="keywordflow">return</span> 0;
<a name="l00097"></a>00097 }
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="keywordtype">void</span> VGA_MapMMIO(<span class="keywordtype">void</span>);
<a name="l00101"></a>00101 <span class="comment">//Nice one from DosEmu</span>
<a name="l00102"></a>00102 INLINE <span class="keyword">static</span> Bit32u RasterOp(Bit32u input,Bit32u mask) {
<a name="l00103"></a>00103         <span class="keywordflow">switch</span> (vga.config.raster_op) {
<a name="l00104"></a>00104         <span class="keywordflow">case</span> 0x00:      <span class="comment">/* None */</span>
<a name="l00105"></a>00105                 <span class="keywordflow">return</span> (input &amp; mask) | (vga.latch.d &amp; ~mask);
<a name="l00106"></a>00106         <span class="keywordflow">case</span> 0x01:      <span class="comment">/* AND */</span>
<a name="l00107"></a>00107                 <span class="keywordflow">return</span> (input | ~mask) &amp; vga.latch.d;
<a name="l00108"></a>00108         <span class="keywordflow">case</span> 0x02:      <span class="comment">/* OR */</span>
<a name="l00109"></a>00109                 <span class="keywordflow">return</span> (input &amp; mask) | vga.latch.d;
<a name="l00110"></a>00110         <span class="keywordflow">case</span> 0x03:      <span class="comment">/* XOR */</span>
<a name="l00111"></a>00111                 <span class="keywordflow">return</span> (input &amp; mask) ^ vga.latch.d;
<a name="l00112"></a>00112         };
<a name="l00113"></a>00113         <span class="keywordflow">return</span> 0;
<a name="l00114"></a>00114 }
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 INLINE <span class="keyword">static</span> Bit32u ModeOperation(Bit8u val) {
<a name="l00117"></a>00117         Bit32u full;
<a name="l00118"></a>00118         <span class="keywordflow">switch</span> (vga.config.write_mode) {
<a name="l00119"></a>00119         <span class="keywordflow">case</span> 0x00:
<a name="l00120"></a>00120                 <span class="comment">// Write Mode 0: In this mode, the host data is first rotated as per the Rotate Count field, then the Enable Set/Reset mechanism selects data from this or the Set/Reset field. Then the selected Logical Operation is performed on the resulting data and the data in the latch register. Then the Bit Mask field is used to select which bits come from the resulting data and which come from the latch register. Finally, only the bit planes enabled by the Memory Plane Write Enable field are written to memory. </span>
<a name="l00121"></a>00121                 val=((val &gt;&gt; vga.config.data_rotate) | (val &lt;&lt; (8-vga.config.data_rotate)));
<a name="l00122"></a>00122                 full=ExpandTable[val];
<a name="l00123"></a>00123                 full=(full &amp; vga.config.full_not_enable_set_reset) | vga.config.full_enable_and_set_reset; 
<a name="l00124"></a>00124                 full=RasterOp(full,vga.config.full_bit_mask);
<a name="l00125"></a>00125                 <span class="keywordflow">break</span>;
<a name="l00126"></a>00126         <span class="keywordflow">case</span> 0x01:
<a name="l00127"></a>00127                 <span class="comment">// Write Mode 1: In this mode, data is transferred directly from the 32 bit latch register to display memory, affected only by the Memory Plane Write Enable field. The host data is not used in this mode. </span>
<a name="l00128"></a>00128                 full=vga.latch.d;
<a name="l00129"></a>00129                 <span class="keywordflow">break</span>;
<a name="l00130"></a>00130         <span class="keywordflow">case</span> 0x02:
<a name="l00131"></a>00131                 <span class="comment">//Write Mode 2: In this mode, the bits 3-0 of the host data are replicated across all 8 bits of their respective planes. Then the selected Logical Operation is performed on the resulting data and the data in the latch register. Then the Bit Mask field is used to select which bits come from the resulting data and which come from the latch register. Finally, only the bit planes enabled by the Memory Plane Write Enable field are written to memory. </span>
<a name="l00132"></a>00132                 full=RasterOp(FillTable[val&amp;0xF],vga.config.full_bit_mask);
<a name="l00133"></a>00133                 <span class="keywordflow">break</span>;
<a name="l00134"></a>00134         <span class="keywordflow">case</span> 0x03:
<a name="l00135"></a>00135                 <span class="comment">// Write Mode 3: In this mode, the data in the Set/Reset field is used as if the Enable Set/Reset field were set to 1111b. Then the host data is first rotated as per the Rotate Count field, then logical ANDed with the value of the Bit Mask field. The resulting value is used on the data obtained from the Set/Reset field in the same way that the Bit Mask field would ordinarily be used. to select which bits come from the expansion of the Set/Reset field and which come from the latch register. Finally, only the bit planes enabled by the Memory Plane Write Enable field are written to memory.</span>
<a name="l00136"></a>00136                 val=((val &gt;&gt; vga.config.data_rotate) | (val &lt;&lt; (8-vga.config.data_rotate)));
<a name="l00137"></a>00137                 full=RasterOp(vga.config.full_set_reset,ExpandTable[val] &amp; vga.config.full_bit_mask);
<a name="l00138"></a>00138                 <span class="keywordflow">break</span>;
<a name="l00139"></a>00139         <span class="keywordflow">default</span>:
<a name="l00140"></a>00140                 <a class="code" href="classLOG.html">LOG</a>(LOG_VGAMISC,LOG_NORMAL)(<span class="stringliteral">&quot;VGA:Unsupported write mode %d&quot;</span>,vga.config.write_mode);
<a name="l00141"></a>00141                 full=0;
<a name="l00142"></a>00142                 <span class="keywordflow">break</span>;
<a name="l00143"></a>00143         }
<a name="l00144"></a>00144         <span class="keywordflow">return</span> full;
<a name="l00145"></a>00145 }
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="comment">/* Gonna assume that whoever maps vga memory, maps it on 32/64kb boundary */</span>
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="preprocessor">#define VGA_PAGES               (128/4)</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span><span class="preprocessor">#define VGA_PAGE_A0             (0xA0000/4096)</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span><span class="preprocessor">#define VGA_PAGE_B0             (0xB0000/4096)</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span><span class="preprocessor">#define VGA_PAGE_B8             (0xB8000/4096)</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span>
<a name="l00154"></a>00154 <span class="keyword">static</span> <span class="keyword">struct </span>{
<a name="l00155"></a>00155         Bitu base, mask;
<a name="l00156"></a>00156 } vgapages;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="keyword">static</span> <span class="keyword">inline</span> Bitu VGA_Generic_Read_Handler(PhysPt planeaddr,PhysPt rawaddr,<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> plane) {
<a name="l00159"></a>00159     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hobit_n = (vga.seq.memory_mode&amp;2<span class="comment">/*Extended Memory*/</span>) ? 16u : 14u;
<a name="l00160"></a>00160 
<a name="l00161"></a>00161     <span class="comment">/* Sequencer Memory Mode Register (04h)</span>
<a name="l00162"></a>00162 <span class="comment">     * bits[3:3] = Chain 4 enable</span>
<a name="l00163"></a>00163 <span class="comment">     * bits[2:2] = Odd/Even Host Memory Write Addressing Disable</span>
<a name="l00164"></a>00164 <span class="comment">     * bits[1:1] = Extended memory (when EGA cards have &gt; 64KB of RAM)</span>
<a name="l00165"></a>00165 <span class="comment">     * </span>
<a name="l00166"></a>00166 <span class="comment">     * NTS: Real hardware experience says that despite the name, the Odd/Even bit affects reading as well */</span>
<a name="l00167"></a>00167     <span class="keywordflow">if</span> (!(vga.seq.memory_mode&amp;4) &amp;&amp; !non_cga_ignore_oddeven_engage)<span class="comment">/* Odd Even Host Memory Write Addressing Disable (is not set) */</span>
<a name="l00168"></a>00168         plane = (plane &amp; ~1u) + (rawaddr &amp; 1u);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170     <span class="comment">/* Graphics Controller: Miscellaneous Graphics Register register (06h)</span>
<a name="l00171"></a>00171 <span class="comment">     * bits[3:2] = memory map select</span>
<a name="l00172"></a>00172 <span class="comment">     * bits[1:1] = Chain Odd/Even Enable</span>
<a name="l00173"></a>00173 <span class="comment">     * bits[0:0] = Alphanumeric Mode Disable</span>
<a name="l00174"></a>00174 <span class="comment">     *</span>
<a name="l00175"></a>00175 <span class="comment">     * http://www.osdever.net/FreeVGA/vga/graphreg.htm</span>
<a name="l00176"></a>00176 <span class="comment">     *</span>
<a name="l00177"></a>00177 <span class="comment">     * When enabled, address bit A0 (bit 0) becomes bit 0 of the plane index.</span>
<a name="l00178"></a>00178 <span class="comment">     * Then when addressing VRAM A0 is replaced by a &quot;higher order bit&quot;, which is</span>
<a name="l00179"></a>00179 <span class="comment">     * probably A14 or A16 depending on Extended Memory bit 1 in Sequencer register 04h memory mode */</span>
<a name="l00180"></a>00180     <span class="keywordflow">if</span> ((vga.gfx.miscellaneous&amp;2) &amp;&amp; !non_cga_ignore_oddeven_engage) {<span class="comment">/* Odd/Even enable */</span>
<a name="l00181"></a>00181         <span class="keyword">const</span> PhysPt mask = (1u &lt;&lt; hobit_n) - 2u;
<a name="l00182"></a>00182         <span class="keyword">const</span> PhysPt hobit = (planeaddr &gt;&gt; hobit_n) &amp; 1u;
<a name="l00183"></a>00183         <span class="comment">/* 1 &lt;&lt; 14 =     0x4000</span>
<a name="l00184"></a>00184 <span class="comment">         * 1 &lt;&lt; 14 - 1 = 0x3FFF</span>
<a name="l00185"></a>00185 <span class="comment">         * 1 &lt;&lt; 14 - 2 = 0x3FFE</span>
<a name="l00186"></a>00186 <span class="comment">         * The point is to mask upper bit AND the LSB */</span>
<a name="l00187"></a>00187         planeaddr = (planeaddr &amp; mask &amp; (vga.mem.memmask &gt;&gt; 2u)) + hobit;
<a name="l00188"></a>00188     }
<a name="l00189"></a>00189     <span class="keywordflow">else</span> {
<a name="l00190"></a>00190         <span class="keyword">const</span> PhysPt mask = (1u &lt;&lt; hobit_n) - 1u;
<a name="l00191"></a>00191         planeaddr &amp;= mask &amp; (vga.mem.memmask &gt;&gt; 2u);
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194     vga.latch.d=((Bit32u*)vga.mem.linear)[planeaddr];
<a name="l00195"></a>00195     <span class="keywordflow">switch</span> (vga.config.read_mode) {
<a name="l00196"></a>00196         <span class="keywordflow">case</span> 0:
<a name="l00197"></a>00197             <span class="keywordflow">return</span> (vga.latch.b[plane]);
<a name="l00198"></a>00198         <span class="keywordflow">case</span> 1:
<a name="l00199"></a>00199             <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> templatch;
<a name="l00200"></a>00200             templatch.d=(vga.latch.d &amp; FillTable[vga.config.color_dont_care]) ^ FillTable[vga.config.color_compare &amp; vga.config.color_dont_care];
<a name="l00201"></a>00201             return (Bit8u)~(templatch.b[0] | templatch.b[1] | templatch.b[2] | templatch.b[3]);
<a name="l00202"></a>00202     }
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     <span class="keywordflow">return</span> 0;
<a name="l00205"></a>00205 }
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <span class="keyword">template</span> &lt;const <span class="keywordtype">bool</span> chained&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> VGA_Generic_Write_Handler(PhysPt planeaddr,PhysPt rawaddr,Bit8u val) {
<a name="l00208"></a>00208     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hobit_n = (vga.seq.memory_mode&amp;2<span class="comment">/*Extended Memory*/</span>) ? 16u : 14u;
<a name="l00209"></a>00209     Bit32u mask = vga.config.full_map_mask;
<a name="l00210"></a>00210 
<a name="l00211"></a>00211     <span class="comment">/* Sequencer Memory Mode Register (04h)</span>
<a name="l00212"></a>00212 <span class="comment">     * bits[3:3] = Chain 4 enable</span>
<a name="l00213"></a>00213 <span class="comment">     * bits[2:2] = Odd/Even Host Memory Write Addressing Disable</span>
<a name="l00214"></a>00214 <span class="comment">     * bits[1:1] = Extended memory (when EGA cards have &gt; 64KB of RAM)</span>
<a name="l00215"></a>00215 <span class="comment">     * </span>
<a name="l00216"></a>00216 <span class="comment">     * NTS: Real hardware experience says that despite the name, the Odd/Even bit affects reading as well */</span>
<a name="l00217"></a>00217     <span class="keywordflow">if</span> (chained) {
<a name="l00218"></a>00218         <span class="keywordflow">if</span> (!(vga.seq.memory_mode&amp;4) &amp;&amp; !non_cga_ignore_oddeven_engage)<span class="comment">/* Odd Even Host Memory Write Addressing Disable (is not set) */</span>
<a name="l00219"></a>00219             mask &amp;= 0xFF00FFu &lt;&lt; ((rawaddr &amp; 1u) * 8u);
<a name="l00220"></a>00220         <span class="keywordflow">else</span>
<a name="l00221"></a>00221             mask &amp;= 0xFFu &lt;&lt; ((rawaddr &amp; 3u) * 8u);
<a name="l00222"></a>00222     }
<a name="l00223"></a>00223     <span class="keywordflow">else</span> {
<a name="l00224"></a>00224         <span class="keywordflow">if</span> (!(vga.seq.memory_mode&amp;4) &amp;&amp; !non_cga_ignore_oddeven_engage)<span class="comment">/* Odd Even Host Memory Write Addressing Disable (is not set) */</span>
<a name="l00225"></a>00225             mask &amp;= 0xFF00FFu &lt;&lt; ((rawaddr &amp; 1u) * 8u);
<a name="l00226"></a>00226     }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228     <span class="comment">/* Graphics Controller: Miscellaneous Graphics Register register (06h)</span>
<a name="l00229"></a>00229 <span class="comment">     * bits[3:2] = memory map select</span>
<a name="l00230"></a>00230 <span class="comment">     * bits[1:1] = Chain Odd/Even Enable</span>
<a name="l00231"></a>00231 <span class="comment">     * bits[0:0] = Alphanumeric Mode Disable</span>
<a name="l00232"></a>00232 <span class="comment">     *</span>
<a name="l00233"></a>00233 <span class="comment">     * http://www.osdever.net/FreeVGA/vga/graphreg.htm</span>
<a name="l00234"></a>00234 <span class="comment">     *</span>
<a name="l00235"></a>00235 <span class="comment">     * When enabled, address bit A0 (bit 0) becomes bit 0 of the plane index.</span>
<a name="l00236"></a>00236 <span class="comment">     * Then when addressing VRAM A0 is replaced by a &quot;higher order bit&quot;, which is</span>
<a name="l00237"></a>00237 <span class="comment">     * probably A14 or A16 depending on Extended Memory bit 1 in Sequencer register 04h memory mode */</span>
<a name="l00238"></a>00238     <span class="keywordflow">if</span> ((vga.gfx.miscellaneous&amp;2) &amp;&amp; !non_cga_ignore_oddeven_engage) {<span class="comment">/* Odd/Even enable */</span>
<a name="l00239"></a>00239         <span class="keyword">const</span> PhysPt mask = (1u &lt;&lt; hobit_n) - 2u;
<a name="l00240"></a>00240         <span class="keyword">const</span> PhysPt hobit = (planeaddr &gt;&gt; hobit_n) &amp; 1u;
<a name="l00241"></a>00241         <span class="comment">/* 1 &lt;&lt; 14 =     0x4000</span>
<a name="l00242"></a>00242 <span class="comment">         * 1 &lt;&lt; 14 - 1 = 0x3FFF</span>
<a name="l00243"></a>00243 <span class="comment">         * 1 &lt;&lt; 14 - 2 = 0x3FFE</span>
<a name="l00244"></a>00244 <span class="comment">         * The point is to mask upper bit AND the LSB */</span>
<a name="l00245"></a>00245         planeaddr = (planeaddr &amp; mask &amp; (vga.mem.memmask &gt;&gt; 2u)) + hobit;
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247     <span class="keywordflow">else</span> {
<a name="l00248"></a>00248         <span class="keyword">const</span> PhysPt mask = (1u &lt;&lt; hobit_n) - 1u;
<a name="l00249"></a>00249         planeaddr &amp;= mask &amp; (vga.mem.memmask &gt;&gt; 2u);
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     Bit32u data=ModeOperation(val);
<a name="l00253"></a>00253     <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> pixels;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     pixels.d =((Bit32u*)vga.mem.linear)[planeaddr];
<a name="l00256"></a>00256     pixels.d&amp;=~mask;
<a name="l00257"></a>00257     pixels.d|=(data &amp; mask);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259     <span class="comment">/* FIXME: A better method (I think) is to have the VGA text drawing code</span>
<a name="l00260"></a>00260 <span class="comment">     *        directly reference the font data in bitplane #2 instead of</span>
<a name="l00261"></a>00261 <span class="comment">     *        this hack */</span>
<a name="l00262"></a>00262     vga.draw.font[planeaddr] = pixels.b[2];
<a name="l00263"></a>00263 
<a name="l00264"></a>00264     ((Bit32u*)vga.mem.linear)[planeaddr]=pixels.d;
<a name="l00265"></a>00265 }
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 <span class="comment">// Slow accurate emulation.</span>
<a name="l00268"></a>00268 <span class="comment">// This version takes the Graphics Controller bitmask and ROPs into account.</span>
<a name="l00269"></a>00269 <span class="comment">// This is needed for demos that use the bitmask to do color combination or bitplane &quot;page flipping&quot; tricks.</span>
<a name="l00270"></a>00270 <span class="comment">// This code will kick in if running in a chained VGA mode and the graphics controller bitmask register is</span>
<a name="l00271"></a>00271 <span class="comment">// changed to anything other than 0xFF.</span>
<a name="l00272"></a>00272 <span class="comment">//</span>
<a name="l00273"></a>00273 <span class="comment">// Impact Studios &quot;Legend&quot;</span>
<a name="l00274"></a>00274 <span class="comment">//  - The rotating objects, rendered as dots, needs this hack because it uses a combination of masking off</span>
<a name="l00275"></a>00275 <span class="comment">//    bitplanes using the VGA DAC pel mask and drawing on the hidden bitplane using the Graphics Controller</span>
<a name="l00276"></a>00276 <span class="comment">//    bitmask. It also relies on loading the VGA latches with zeros as a form of &quot;overdraw&quot;. Without this</span>
<a name="l00277"></a>00277 <span class="comment">//    version the effect will instead become a glowing ball of flickering yellow/red.</span>
<a name="l00278"></a><a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">00278</a> <span class="keyword">class </span><a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">VGA_ChainedVGA_Slow_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00279"></a>00279 <span class="keyword">public</span>:
<a name="l00280"></a>00280         <a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">VGA_ChainedVGA_Slow_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00281"></a>00281         <span class="keyword">static</span> INLINE Bitu readHandler8(PhysPt addr ) {
<a name="l00282"></a>00282         <span class="comment">// planar byte offset = addr &amp; ~3u      (discard low 2 bits)</span>
<a name="l00283"></a>00283         <span class="comment">// planer index = addr &amp; 3u             (use low 2 bits as plane index)</span>
<a name="l00284"></a>00284         <span class="comment">// FIXME: Does chained mode use the lower 2 bits of the CPU address or does it use the read mode select???</span>
<a name="l00285"></a>00285         <span class="keywordflow">return</span> VGA_Generic_Read_Handler(addr&amp;~3u, addr, addr&amp;3u);
<a name="l00286"></a>00286         }
<a name="l00287"></a>00287         <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> writeHandler8(PhysPt addr, Bitu val) {
<a name="l00288"></a>00288         <span class="comment">// planar byte offset = addr &amp; ~3u      (discard low 2 bits)</span>
<a name="l00289"></a>00289         <span class="comment">// planer index = addr &amp; 3u             (use low 2 bits as plane index)</span>
<a name="l00290"></a>00290         <span class="keywordflow">return</span> VGA_Generic_Write_Handler&lt;<span class="keyword">true</span><span class="comment">/*chained*/</span>&gt;(addr&amp;~3u, addr, val);
<a name="l00291"></a>00291         }
<a name="l00292"></a>00292         Bitu readb(PhysPt addr ) {
<a name="l00293"></a>00293                 VGAMEM_USEC_read_delay();
<a name="l00294"></a>00294                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00295"></a>00295                 addr += vga.svga.bank_read_full;
<a name="l00296"></a>00296 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00297"></a>00297                 <span class="keywordflow">return</span> readHandler8( addr );
<a name="l00298"></a>00298         }
<a name="l00299"></a>00299         Bitu readw(PhysPt addr ) {
<a name="l00300"></a>00300                 VGAMEM_USEC_read_delay();
<a name="l00301"></a>00301                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00302"></a>00302                 addr += vga.svga.bank_read_full;
<a name="l00303"></a>00303 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00304"></a>00304                 Bitu ret = (readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00305"></a>00305                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00306"></a>00306                 <span class="keywordflow">return</span> ret;
<a name="l00307"></a>00307         }
<a name="l00308"></a>00308         Bitu readd(PhysPt addr ) {
<a name="l00309"></a>00309                 VGAMEM_USEC_read_delay();
<a name="l00310"></a>00310                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00311"></a>00311                 addr += vga.svga.bank_read_full;
<a name="l00312"></a>00312 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00313"></a>00313                 Bitu ret = (readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00314"></a>00314                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00315"></a>00315                 ret     |= (readHandler8( addr+2 ) &lt;&lt; 16 );
<a name="l00316"></a>00316                 ret     |= (readHandler8( addr+3 ) &lt;&lt; 24 );
<a name="l00317"></a>00317                 <span class="keywordflow">return</span> ret;
<a name="l00318"></a>00318         }
<a name="l00319"></a>00319         <span class="keywordtype">void</span> writeb(PhysPt addr, Bitu val ) {
<a name="l00320"></a>00320                 VGAMEM_USEC_write_delay();
<a name="l00321"></a>00321                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00322"></a>00322                 addr += vga.svga.bank_write_full;
<a name="l00323"></a>00323 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00324"></a>00324                 writeHandler8( addr, val );
<a name="l00325"></a>00325         }
<a name="l00326"></a>00326         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00327"></a>00327                 VGAMEM_USEC_write_delay();
<a name="l00328"></a>00328                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00329"></a>00329                 addr += vga.svga.bank_write_full;
<a name="l00330"></a>00330 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00331"></a>00331                 writeHandler8( addr+0, val &gt;&gt; 0 );
<a name="l00332"></a>00332                 writeHandler8( addr+1, val &gt;&gt; 8 );
<a name="l00333"></a>00333         }
<a name="l00334"></a>00334         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00335"></a>00335                 VGAMEM_USEC_write_delay();
<a name="l00336"></a>00336                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00337"></a>00337                 addr += vga.svga.bank_write_full;
<a name="l00338"></a>00338 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00339"></a>00339                 writeHandler8( addr+0, val &gt;&gt; 0 );
<a name="l00340"></a>00340                 writeHandler8( addr+1, val &gt;&gt; 8 );
<a name="l00341"></a>00341                 writeHandler8( addr+2, val &gt;&gt; 16 );
<a name="l00342"></a>00342                 writeHandler8( addr+3, val &gt;&gt; 24 );
<a name="l00343"></a>00343         }
<a name="l00344"></a>00344 };
<a name="l00345"></a>00345 
<a name="l00346"></a><a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">00346</a> <span class="keyword">class </span><a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">VGA_ET4000_ChainedVGA_Slow_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00347"></a>00347 <span class="keyword">public</span>:
<a name="l00348"></a>00348         <a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">VGA_ET4000_ChainedVGA_Slow_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00349"></a>00349         <span class="keyword">static</span> INLINE Bitu readHandler8(PhysPt addr ) {
<a name="l00350"></a>00350         <span class="comment">// planar byte offset = addr &gt;&gt; 2       (shift 2 bits to the right)</span>
<a name="l00351"></a>00351         <span class="comment">// planer index = addr &amp; 3u             (use low 2 bits as plane index)</span>
<a name="l00352"></a>00352         <span class="keywordflow">return</span> VGA_Generic_Read_Handler(addr&gt;&gt;2u, addr, addr&amp;3u);
<a name="l00353"></a>00353         }
<a name="l00354"></a>00354         <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> writeHandler8(PhysPt addr, Bitu val) {
<a name="l00355"></a>00355         <span class="comment">// planar byte offset = addr &gt;&gt; 2       (shift 2 bits to the right)</span>
<a name="l00356"></a>00356         <span class="comment">// planer index = addr &amp; 3u             (use low 2 bits as plane index)</span>
<a name="l00357"></a>00357         <span class="keywordflow">return</span> VGA_Generic_Write_Handler&lt;<span class="keyword">true</span><span class="comment">/*chained*/</span>&gt;(addr&gt;&gt;2u, addr, val);
<a name="l00358"></a>00358         }
<a name="l00359"></a>00359         Bitu readb(PhysPt addr ) {
<a name="l00360"></a>00360                 VGAMEM_USEC_read_delay();
<a name="l00361"></a>00361                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00362"></a>00362                 addr += vga.svga.bank_read_full;
<a name="l00363"></a>00363 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00364"></a>00364                 <span class="keywordflow">return</span> readHandler8( addr );
<a name="l00365"></a>00365         }
<a name="l00366"></a>00366         Bitu readw(PhysPt addr ) {
<a name="l00367"></a>00367                 VGAMEM_USEC_read_delay();
<a name="l00368"></a>00368                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00369"></a>00369                 addr += vga.svga.bank_read_full;
<a name="l00370"></a>00370 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00371"></a>00371                 Bitu ret = (readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00372"></a>00372                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00373"></a>00373                 <span class="keywordflow">return</span> ret;
<a name="l00374"></a>00374         }
<a name="l00375"></a>00375         Bitu readd(PhysPt addr ) {
<a name="l00376"></a>00376                 VGAMEM_USEC_read_delay();
<a name="l00377"></a>00377                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00378"></a>00378                 addr += vga.svga.bank_read_full;
<a name="l00379"></a>00379 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00380"></a>00380                 Bitu ret = (readHandler8( addr+0 ) &lt;&lt; 0 );
<a name="l00381"></a>00381                 ret     |= (readHandler8( addr+1 ) &lt;&lt; 8 );
<a name="l00382"></a>00382                 ret     |= (readHandler8( addr+2 ) &lt;&lt; 16 );
<a name="l00383"></a>00383                 ret     |= (readHandler8( addr+3 ) &lt;&lt; 24 );
<a name="l00384"></a>00384                 <span class="keywordflow">return</span> ret;
<a name="l00385"></a>00385         }
<a name="l00386"></a>00386         <span class="keywordtype">void</span> writeb(PhysPt addr, Bitu val ) {
<a name="l00387"></a>00387                 VGAMEM_USEC_write_delay();
<a name="l00388"></a>00388                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00389"></a>00389                 addr += vga.svga.bank_write_full;
<a name="l00390"></a>00390 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00391"></a>00391                 writeHandler8( addr, val );
<a name="l00392"></a>00392         }
<a name="l00393"></a>00393         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00394"></a>00394                 VGAMEM_USEC_write_delay();
<a name="l00395"></a>00395                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00396"></a>00396                 addr += vga.svga.bank_write_full;
<a name="l00397"></a>00397 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00398"></a>00398                 writeHandler8( addr+0, val &gt;&gt; 0 );
<a name="l00399"></a>00399                 writeHandler8( addr+1, val &gt;&gt; 8 );
<a name="l00400"></a>00400         }
<a name="l00401"></a>00401         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00402"></a>00402                 VGAMEM_USEC_write_delay();
<a name="l00403"></a>00403                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00404"></a>00404                 addr += vga.svga.bank_write_full;
<a name="l00405"></a>00405 <span class="comment">//              addr = CHECKED(addr);</span>
<a name="l00406"></a>00406                 writeHandler8( addr+0, val &gt;&gt; 0 );
<a name="l00407"></a>00407                 writeHandler8( addr+1, val &gt;&gt; 8 );
<a name="l00408"></a>00408                 writeHandler8( addr+2, val &gt;&gt; 16 );
<a name="l00409"></a>00409                 writeHandler8( addr+3, val &gt;&gt; 24 );
<a name="l00410"></a>00410         }
<a name="l00411"></a>00411 };
<a name="l00412"></a>00412 
<a name="l00413"></a><a class="code" href="classVGA__UnchainedVGA__Handler.html">00413</a> <span class="keyword">class </span><a class="code" href="classVGA__UnchainedVGA__Handler.html">VGA_UnchainedVGA_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00414"></a>00414 <span class="keyword">public</span>:
<a name="l00415"></a>00415         Bitu readHandler(PhysPt start) {
<a name="l00416"></a>00416         <span class="keywordflow">return</span> VGA_Generic_Read_Handler(start, start, vga.config.read_map_select);
<a name="l00417"></a>00417         }
<a name="l00418"></a>00418 <span class="keyword">public</span>:
<a name="l00419"></a>00419         Bitu readb(PhysPt addr) {
<a name="l00420"></a>00420                 VGAMEM_USEC_read_delay();
<a name="l00421"></a>00421                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00422"></a>00422                 addr += vga.svga.bank_read_full;
<a name="l00423"></a>00423 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00424"></a>00424                 <span class="keywordflow">return</span> readHandler(addr);
<a name="l00425"></a>00425         }
<a name="l00426"></a>00426         Bitu readw(PhysPt addr) {
<a name="l00427"></a>00427                 VGAMEM_USEC_read_delay();
<a name="l00428"></a>00428                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00429"></a>00429                 addr += vga.svga.bank_read_full;
<a name="l00430"></a>00430 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00431"></a>00431                 Bitu ret = (readHandler(addr+0) &lt;&lt; 0);
<a name="l00432"></a>00432                 ret     |= (readHandler(addr+1) &lt;&lt; 8);
<a name="l00433"></a>00433                 <span class="keywordflow">return</span>  ret;
<a name="l00434"></a>00434         }
<a name="l00435"></a>00435         Bitu readd(PhysPt addr) {
<a name="l00436"></a>00436                 VGAMEM_USEC_read_delay();
<a name="l00437"></a>00437                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00438"></a>00438                 addr += vga.svga.bank_read_full;
<a name="l00439"></a>00439 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00440"></a>00440                 Bitu ret = (readHandler(addr+0) &lt;&lt; 0);
<a name="l00441"></a>00441                 ret     |= (readHandler(addr+1) &lt;&lt; 8);
<a name="l00442"></a>00442                 ret     |= (readHandler(addr+2) &lt;&lt; 16);
<a name="l00443"></a>00443                 ret     |= (readHandler(addr+3) &lt;&lt; 24);
<a name="l00444"></a>00444                 <span class="keywordflow">return</span> ret;
<a name="l00445"></a>00445         }
<a name="l00446"></a>00446 <span class="keyword">public</span>:
<a name="l00447"></a>00447         <span class="keywordtype">void</span> writeHandler(PhysPt start, Bit8u val) {
<a name="l00448"></a>00448         VGA_Generic_Write_Handler&lt;<span class="keyword">false</span><span class="comment">/*chained*/</span>&gt;(start, start, val);
<a name="l00449"></a>00449         }
<a name="l00450"></a>00450 <span class="keyword">public</span>:
<a name="l00451"></a>00451         <a class="code" href="classVGA__UnchainedVGA__Handler.html">VGA_UnchainedVGA_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l00452"></a>00452         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l00453"></a>00453                 VGAMEM_USEC_write_delay();
<a name="l00454"></a>00454                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00455"></a>00455                 addr += vga.svga.bank_write_full;
<a name="l00456"></a>00456 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00457"></a>00457                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00458"></a>00458         }
<a name="l00459"></a>00459         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l00460"></a>00460                 VGAMEM_USEC_write_delay();
<a name="l00461"></a>00461                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00462"></a>00462                 addr += vga.svga.bank_write_full;
<a name="l00463"></a>00463 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00464"></a>00464                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00465"></a>00465                 writeHandler(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l00466"></a>00466         }
<a name="l00467"></a>00467         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l00468"></a>00468                 VGAMEM_USEC_write_delay();
<a name="l00469"></a>00469                 addr = PAGING_GetPhysicalAddress(addr) &amp; vgapages.mask;
<a name="l00470"></a>00470                 addr += vga.svga.bank_write_full;
<a name="l00471"></a>00471 <span class="comment">//              addr = CHECKED2(addr);</span>
<a name="l00472"></a>00472                 writeHandler(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l00473"></a>00473                 writeHandler(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l00474"></a>00474                 writeHandler(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l00475"></a>00475                 writeHandler(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l00476"></a>00476         }
<a name="l00477"></a>00477 };
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00480"></a>00480 
<a name="l00481"></a><a class="code" href="classVGA__CGATEXT__PageHandler.html">00481</a> <span class="keyword">class </span><a class="code" href="classVGA__CGATEXT__PageHandler.html">VGA_CGATEXT_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l00482"></a>00482 <span class="keyword">public</span>:
<a name="l00483"></a>00483         <a class="code" href="classVGA__CGATEXT__PageHandler.html">VGA_CGATEXT_PageHandler</a>() {
<a name="l00484"></a>00484                 flags=PFLAG_NOCODE;
<a name="l00485"></a>00485         }
<a name="l00486"></a>00486         Bitu readb(PhysPt addr) {
<a name="l00487"></a>00487                 addr = PAGING_GetPhysicalAddress(addr) &amp; 0x3FFF;
<a name="l00488"></a>00488                 VGAMEM_USEC_read_delay();
<a name="l00489"></a>00489                 <span class="keywordflow">return</span> vga.tandy.mem_base[addr];
<a name="l00490"></a>00490         }
<a name="l00491"></a>00491         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val){
<a name="l00492"></a>00492                 VGAMEM_USEC_write_delay();
<a name="l00493"></a>00493 
<a name="l00494"></a>00494                 <span class="keywordflow">if</span> (enableCGASnow) {
<a name="l00495"></a>00495                         <span class="comment">/* NTS: We can&#39;t use PIC_FullIndex() exclusively because it&#39;s not precise enough</span>
<a name="l00496"></a>00496 <span class="comment">                         *      with respect to when DOSBox CPU emulation is writing. We have to use other</span>
<a name="l00497"></a>00497 <span class="comment">                         *      variables like CPU_Cycles to gain additional precision */</span>
<a name="l00498"></a>00498                         <span class="keywordtype">double</span> timeInFrame = PIC_FullIndex()-vga.draw.delay.framestart;
<a name="l00499"></a>00499                         <span class="keywordtype">double</span> timeInLine = fmod(timeInFrame,vga.draw.delay.htotal);
<a name="l00500"></a>00500 
<a name="l00501"></a>00501                         <span class="comment">/* we&#39;re in active area. which column should the snow show up on? */</span>
<a name="l00502"></a>00502                         Bit32u x = (Bit32u)((timeInLine * 80) / vga.draw.delay.hblkstart);
<a name="l00503"></a>00503                         <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span>)x &lt; 80) vga.draw.cga_snow[x] = val;
<a name="l00504"></a>00504                 }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506                 addr = PAGING_GetPhysicalAddress(addr) &amp; 0x3FFF;
<a name="l00507"></a>00507                 vga.tandy.mem_base[addr] = val;
<a name="l00508"></a>00508         }
<a name="l00509"></a>00509 };
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 <span class="keyword">extern</span> uint8_t pc98_egc_srcmask[2]; <span class="comment">/* host given (Neko: egc.srcmask) */</span>
<a name="l00512"></a>00512 <span class="keyword">extern</span> uint8_t pc98_egc_maskef[2]; <span class="comment">/* effective (Neko: egc.mask2) */</span>
<a name="l00513"></a>00513 <span class="keyword">extern</span> uint8_t pc98_egc_mask[2]; <span class="comment">/* host given (Neko: egc.mask) */</span>
<a name="l00514"></a>00514 <span class="keyword">extern</span> uint8_t pc98_egc_access;
<a name="l00515"></a>00515 <span class="keyword">extern</span> uint8_t pc98_egc_fgc;
<a name="l00516"></a>00516 <span class="keyword">extern</span> uint8_t pc98_egc_foreground_color;
<a name="l00517"></a>00517 <span class="keyword">extern</span> uint8_t pc98_egc_background_color;
<a name="l00518"></a>00518 <span class="keyword">extern</span> uint8_t pc98_egc_lead_plane;
<a name="l00519"></a>00519 <span class="keyword">extern</span> uint8_t pc98_egc_compare_lead;
<a name="l00520"></a>00520 <span class="keyword">extern</span> uint8_t pc98_egc_lightsource;
<a name="l00521"></a>00521 <span class="keyword">extern</span> uint8_t pc98_egc_shiftinput;
<a name="l00522"></a>00522 <span class="keyword">extern</span> uint8_t pc98_egc_regload;
<a name="l00523"></a>00523 <span class="keyword">extern</span> uint8_t pc98_egc_rop;
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 <span class="keyword">extern</span> <span class="keywordtype">bool</span> pc98_egc_shift_descend;
<a name="l00526"></a>00526 <span class="keyword">extern</span> uint8_t pc98_egc_shift_destbit;
<a name="l00527"></a>00527 <span class="keyword">extern</span> uint8_t pc98_egc_shift_srcbit;
<a name="l00528"></a>00528 <span class="keyword">extern</span> uint16_t pc98_egc_shift_length;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="comment">/* I don&#39;t think we necessarily need the full 4096 bit buffer</span>
<a name="l00531"></a>00531 <span class="comment"> * Neko Project II uses to render things, though that is</span>
<a name="l00532"></a>00532 <span class="comment"> * probably faster to execute. It makes it hard to make sense</span>
<a name="l00533"></a>00533 <span class="comment"> * of the code though. */</span>
<a name="l00534"></a><a class="code" href="structpc98__egc__shifter.html">00534</a> <span class="keyword">struct </span><a class="code" href="structpc98__egc__shifter.html">pc98_egc_shifter</a> {
<a name="l00535"></a>00535     <a class="code" href="structpc98__egc__shifter.html">pc98_egc_shifter</a>() : decrement(<span class="keyword">false</span>), remain(0x10), srcbit(0), dstbit(0) { }
<a name="l00536"></a>00536 
<a name="l00537"></a>00537     <span class="keywordtype">void</span> reinit(<span class="keywordtype">void</span>) { <span class="comment">/* from global vars set by guest */</span>
<a name="l00538"></a>00538         decrement = pc98_egc_shift_descend;
<a name="l00539"></a>00539         remain = pc98_egc_shift_length + 1; <span class="comment">/* the register is length - 1 apparently */</span>
<a name="l00540"></a>00540         dstbit = pc98_egc_shift_destbit;
<a name="l00541"></a>00541         srcbit = pc98_egc_shift_srcbit;
<a name="l00542"></a>00542         bufi = bufo = decrement ? (<span class="keyword">sizeof</span>(buffer) + 3 - (4*4)) : 0;
<a name="l00543"></a>00543 
<a name="l00544"></a>00544         <span class="keywordflow">if</span> ((srcbit&amp;7) &lt; (dstbit&amp;7)) {
<a name="l00545"></a>00545             shft8bitr = (dstbit&amp;7) - (srcbit&amp;7);
<a name="l00546"></a>00546             shft8bitl = 8 - shft8bitr;
<a name="l00547"></a>00547         }
<a name="l00548"></a>00548         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((srcbit&amp;7) &gt; (dstbit&amp;7)) {
<a name="l00549"></a>00549             shft8bitl = (srcbit&amp;7) - (dstbit&amp;7);
<a name="l00550"></a>00550             shft8bitr = 8 - shft8bitl;
<a name="l00551"></a>00551         }
<a name="l00552"></a>00552         <span class="keywordflow">else</span> {
<a name="l00553"></a>00553             shft8bitr = 0;
<a name="l00554"></a>00554             shft8bitl = 0;
<a name="l00555"></a>00555         }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         shft8load = 0;
<a name="l00558"></a>00558         o_srcbit = srcbit &amp; 7;
<a name="l00559"></a>00559         o_dstbit = dstbit &amp; 7;
<a name="l00560"></a>00560     }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562     <span class="keywordtype">bool</span>                decrement;
<a name="l00563"></a>00563     uint16_t            remain;
<a name="l00564"></a>00564     uint16_t            srcbit;
<a name="l00565"></a>00565     uint16_t            dstbit;
<a name="l00566"></a>00566     uint16_t            o_srcbit;
<a name="l00567"></a>00567     uint16_t            o_dstbit;
<a name="l00568"></a>00568 
<a name="l00569"></a>00569     uint8_t             buffer[512]; <span class="comment">/* 4096/8 = 512 */</span>
<a name="l00570"></a>00570     uint16_t            bufi,bufo;
<a name="l00571"></a>00571 
<a name="l00572"></a>00572     uint8_t             shft8load;
<a name="l00573"></a>00573     uint8_t             shft8bitr;
<a name="l00574"></a>00574     uint8_t             shft8bitl;
<a name="l00575"></a>00575 
<a name="l00576"></a>00576     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> bi(<span class="keyword">const</span> uint16_t ofs,<span class="keyword">const</span> AWT val) {
<a name="l00577"></a>00577         <span class="keywordtype">size_t</span> ip = (bufi + ofs) &amp; (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00578"></a>00578 
<a name="l00579"></a>00579         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; <span class="keyword">sizeof</span>(AWT);) {
<a name="l00580"></a>00580             buffer[ip] = (uint8_t)(val &gt;&gt; ((AWT)(i * 8U)));
<a name="l00581"></a>00581             <span class="keywordflow">if</span> ((++ip) == <span class="keyword">sizeof</span>(buffer)) ip = 0;
<a name="l00582"></a>00582             i++;
<a name="l00583"></a>00583         }
<a name="l00584"></a>00584     }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> bi_adv(<span class="keywordtype">void</span>) {
<a name="l00587"></a>00587         bufi += pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) - <span class="keyword">sizeof</span>(AWT)) : <span class="keyword">sizeof</span>(AWT);
<a name="l00588"></a>00588         bufi &amp;= (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00589"></a>00589     }
<a name="l00590"></a>00590 
<a name="l00591"></a>00591     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> AWT bo(<span class="keyword">const</span> uint16_t ofs) {
<a name="l00592"></a>00592         <span class="keywordtype">size_t</span> op = (bufo + ofs) &amp; (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00593"></a>00593         AWT ret = 0;
<a name="l00594"></a>00594 
<a name="l00595"></a>00595         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; <span class="keyword">sizeof</span>(AWT);) {
<a name="l00596"></a>00596             ret += ((AWT)buffer[op]) &lt;&lt; ((AWT)(i * 8U));
<a name="l00597"></a>00597             <span class="keywordflow">if</span> ((++op) == <span class="keyword">sizeof</span>(buffer)) op = 0;
<a name="l00598"></a>00598             i++;
<a name="l00599"></a>00599         }
<a name="l00600"></a>00600 
<a name="l00601"></a>00601         <span class="keywordflow">return</span> ret;
<a name="l00602"></a>00602     }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> bo_adv(<span class="keywordtype">void</span>) {
<a name="l00605"></a>00605         bufo += pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) - <span class="keyword">sizeof</span>(AWT)) : <span class="keyword">sizeof</span>(AWT);
<a name="l00606"></a>00606         bufo &amp;= (<span class="keyword">sizeof</span>(buffer) - 1);
<a name="l00607"></a>00607     }
<a name="l00608"></a>00608 
<a name="l00609"></a>00609     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> input(<span class="keyword">const</span> AWT a,<span class="keyword">const</span> AWT b,<span class="keyword">const</span> AWT c,<span class="keyword">const</span> AWT d,uint8_t odd) {
<a name="l00610"></a>00610         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 0,a);
<a name="l00611"></a>00611         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 4,b);
<a name="l00612"></a>00612         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 8,c);
<a name="l00613"></a>00613         bi&lt;AWT&gt;((pc98_egc_shift_descend ? (<span class="keyword">sizeof</span>(buffer) + 1 - <span class="keyword">sizeof</span>(AWT)) : 0) + 12,d);
<a name="l00614"></a>00614 
<a name="l00615"></a>00615         <span class="keywordflow">if</span> (shft8load &lt;= 16) {
<a name="l00616"></a>00616             bi_adv&lt;AWT&gt;();
<a name="l00617"></a>00617 
<a name="l00618"></a>00618             <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) == 2) {
<a name="l00619"></a>00619                 <span class="keywordflow">if</span> (srcbit &gt;= 8) bo_adv&lt;uint8_t&gt;();
<a name="l00620"></a>00620                 shft8load += (16 - srcbit);
<a name="l00621"></a>00621                 srcbit = 0;
<a name="l00622"></a>00622             }
<a name="l00623"></a>00623             <span class="keywordflow">else</span> {
<a name="l00624"></a>00624                 <span class="keywordflow">if</span> (srcbit &gt;= 8)
<a name="l00625"></a>00625                     srcbit -= 8;
<a name="l00626"></a>00626                 <span class="keywordflow">else</span> {
<a name="l00627"></a>00627                     shft8load += (8 - srcbit);
<a name="l00628"></a>00628                     srcbit = 0;
<a name="l00629"></a>00629                 }
<a name="l00630"></a>00630             }
<a name="l00631"></a>00631         }
<a name="l00632"></a>00632 
<a name="l00633"></a>00633         *((AWT*)(pc98_egc_srcmask+odd)) = (AWT)(~0ull);
<a name="l00634"></a>00634     }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636     <span class="keyword">inline</span> uint8_t dstbit_mask(<span class="keywordtype">void</span>) {
<a name="l00637"></a>00637         uint8_t mb;
<a name="l00638"></a>00638 
<a name="l00639"></a>00639         <span class="comment">/* assume remain &gt; 0 */</span>
<a name="l00640"></a>00640         <span class="keywordflow">if</span> (remain &gt;= 8)
<a name="l00641"></a>00641             mb = 0xFF;
<a name="l00642"></a>00642         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pc98_egc_shift_descend)
<a name="l00643"></a>00643             mb = 0xFF &lt;&lt; (uint8_t)(8 - remain); <span class="comment">/* 0x80 0xC0 0xE0 0xF0 ... */</span>
<a name="l00644"></a>00644         <span class="keywordflow">else</span>
<a name="l00645"></a>00645             mb = 0xFF &gt;&gt; (uint8_t)(8 - remain); <span class="comment">/* 0x01 0x03 0x07 0x0F ... */</span>
<a name="l00646"></a>00646 
<a name="l00647"></a>00647         <span class="comment">/* assume dstbit &lt; 8 */</span>
<a name="l00648"></a>00648         <span class="keywordflow">if</span> (!pc98_egc_shift_descend)
<a name="l00649"></a>00649             <span class="keywordflow">return</span> mb &gt;&gt; (uint8_t)dstbit; <span class="comment">/* 0xFF 0x7F 0x3F 0x1F ... */</span>
<a name="l00650"></a>00650         <span class="keywordflow">else</span>
<a name="l00651"></a>00651             <span class="keywordflow">return</span> mb &lt;&lt; (uint8_t)dstbit; <span class="comment">/* 0xFF 0xFE 0xFC 0xF8 ... */</span>
<a name="l00652"></a>00652     }
<a name="l00653"></a>00653 
<a name="l00654"></a>00654     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> output(AWT &amp;a,AWT &amp;b,AWT &amp;c,AWT &amp;d,uint8_t odd,<span class="keywordtype">bool</span> recursive=<span class="keyword">false</span>) {
<a name="l00655"></a>00655         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) == 2) {
<a name="l00656"></a>00656             <span class="keywordflow">if</span> (shft8load &lt; (16 - dstbit)) {
<a name="l00657"></a>00657                 *((AWT*)(pc98_egc_srcmask+odd)) = 0;
<a name="l00658"></a>00658                 <span class="keywordflow">return</span>;
<a name="l00659"></a>00659             }
<a name="l00660"></a>00660             shft8load -= (16 - dstbit);
<a name="l00661"></a>00661 
<a name="l00662"></a>00662             <span class="comment">/* assume odd == false and output is to even byte offset */</span>
<a name="l00663"></a>00663             <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00664"></a>00664                 output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[1],((uint8_t*)(&amp;b))[1],((uint8_t*)(&amp;c))[1],((uint8_t*)(&amp;d))[1],1,<span class="keyword">true</span>);
<a name="l00665"></a>00665                 <span class="keywordflow">if</span> (remain != 0) output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[0],((uint8_t*)(&amp;b))[0],((uint8_t*)(&amp;c))[0],((uint8_t*)(&amp;d))[0],0,<span class="keyword">true</span>);
<a name="l00666"></a>00666                 <span class="keywordflow">else</span> pc98_egc_srcmask[0] = 0;
<a name="l00667"></a>00667             }
<a name="l00668"></a>00668             <span class="keywordflow">else</span> {
<a name="l00669"></a>00669                 output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[0],((uint8_t*)(&amp;b))[0],((uint8_t*)(&amp;c))[0],((uint8_t*)(&amp;d))[0],0,<span class="keyword">true</span>);
<a name="l00670"></a>00670                 <span class="keywordflow">if</span> (remain != 0) output&lt;uint8_t&gt;(((uint8_t*)(&amp;a))[1],((uint8_t*)(&amp;b))[1],((uint8_t*)(&amp;c))[1],((uint8_t*)(&amp;d))[1],1,<span class="keyword">true</span>);
<a name="l00671"></a>00671                 <span class="keywordflow">else</span> pc98_egc_srcmask[1] = 0;
<a name="l00672"></a>00672             }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674             <span class="keywordflow">if</span> (remain == 0)
<a name="l00675"></a>00675                 reinit();
<a name="l00676"></a>00676 
<a name="l00677"></a>00677             <span class="keywordflow">return</span>;
<a name="l00678"></a>00678         }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680         <span class="keywordflow">if</span> (!recursive) {
<a name="l00681"></a>00681             <span class="keywordflow">if</span> (shft8load &lt; (8 - dstbit)) {
<a name="l00682"></a>00682                 *((AWT*)(pc98_egc_srcmask+odd)) = 0;
<a name="l00683"></a>00683                 <span class="keywordflow">return</span>;
<a name="l00684"></a>00684             }
<a name="l00685"></a>00685             shft8load -= (8 - dstbit);
<a name="l00686"></a>00686         }
<a name="l00687"></a>00687 
<a name="l00688"></a>00688         <span class="keywordflow">if</span> (dstbit &gt;= 8) {
<a name="l00689"></a>00689             dstbit -= 8;
<a name="l00690"></a>00690             *((AWT*)(pc98_egc_srcmask+odd)) = 0;
<a name="l00691"></a>00691             <span class="keywordflow">return</span>;
<a name="l00692"></a>00692         }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694         *((AWT*)(pc98_egc_srcmask+odd)) = dstbit_mask();
<a name="l00695"></a>00695 
<a name="l00696"></a>00696         <span class="keywordflow">if</span> (dstbit &gt; 0) {
<a name="l00697"></a>00697             <span class="keyword">const</span> uint8_t bc = 8 - dstbit;
<a name="l00698"></a>00698 
<a name="l00699"></a>00699             <span class="keywordflow">if</span> (remain &gt;= bc)
<a name="l00700"></a>00700                 remain -= bc;
<a name="l00701"></a>00701             <span class="keywordflow">else</span>
<a name="l00702"></a>00702                 remain = 0;
<a name="l00703"></a>00703         }
<a name="l00704"></a>00704         <span class="keywordflow">else</span> {
<a name="l00705"></a>00705             <span class="keywordflow">if</span> (remain &gt;= 8)
<a name="l00706"></a>00706                 remain -= 8;
<a name="l00707"></a>00707             <span class="keywordflow">else</span>
<a name="l00708"></a>00708                 remain = 0;
<a name="l00709"></a>00709         }
<a name="l00710"></a>00710 
<a name="l00711"></a>00711         <span class="keywordflow">if</span> (o_srcbit &lt; o_dstbit) {
<a name="l00712"></a>00712             <span class="keywordflow">if</span> (dstbit != 0) {
<a name="l00713"></a>00713                 <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00714"></a>00714                     a = bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitr;
<a name="l00715"></a>00715                     b = bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitr;
<a name="l00716"></a>00716                     c = bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitr;
<a name="l00717"></a>00717                     d = bo&lt;AWT&gt;(12) &lt;&lt; shft8bitr;
<a name="l00718"></a>00718                 }
<a name="l00719"></a>00719                 <span class="keywordflow">else</span> {
<a name="l00720"></a>00720                     a = bo&lt;AWT&gt;( 0) &gt;&gt; shft8bitr;
<a name="l00721"></a>00721                     b = bo&lt;AWT&gt;( 4) &gt;&gt; shft8bitr;
<a name="l00722"></a>00722                     c = bo&lt;AWT&gt;( 8) &gt;&gt; shft8bitr;
<a name="l00723"></a>00723                     d = bo&lt;AWT&gt;(12) &gt;&gt; shft8bitr;
<a name="l00724"></a>00724                 }
<a name="l00725"></a>00725 
<a name="l00726"></a>00726                 dstbit = 0;
<a name="l00727"></a>00727             }
<a name="l00728"></a>00728             <span class="keywordflow">else</span> {
<a name="l00729"></a>00729                 <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00730"></a>00730                     bo_adv&lt;AWT&gt;();
<a name="l00731"></a>00731                     a = (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitr);
<a name="l00732"></a>00732                     b = (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitr);
<a name="l00733"></a>00733                     c = (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitr);
<a name="l00734"></a>00734                     d = (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitr);
<a name="l00735"></a>00735                 }
<a name="l00736"></a>00736                 <span class="keywordflow">else</span> {
<a name="l00737"></a>00737                     a = (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitr);
<a name="l00738"></a>00738                     b = (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitr);
<a name="l00739"></a>00739                     c = (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitr);
<a name="l00740"></a>00740                     d = (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitr);
<a name="l00741"></a>00741                     bo_adv&lt;AWT&gt;();
<a name="l00742"></a>00742                 }
<a name="l00743"></a>00743             }
<a name="l00744"></a>00744         }
<a name="l00745"></a>00745         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (o_srcbit &gt; o_dstbit) {
<a name="l00746"></a>00746             dstbit = 0;
<a name="l00747"></a>00747 
<a name="l00748"></a>00748             <span class="keywordflow">if</span> (pc98_egc_shift_descend) {
<a name="l00749"></a>00749                 bo_adv&lt;AWT&gt;();
<a name="l00750"></a>00750                 a = (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitr);
<a name="l00751"></a>00751                 b = (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitr);
<a name="l00752"></a>00752                 c = (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitr);
<a name="l00753"></a>00753                 d = (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitl) | (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitr);
<a name="l00754"></a>00754             }
<a name="l00755"></a>00755             <span class="keywordflow">else</span> {
<a name="l00756"></a>00756                 a = (bo&lt;AWT&gt;( 0) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 0+1) &gt;&gt; shft8bitr);
<a name="l00757"></a>00757                 b = (bo&lt;AWT&gt;( 4) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 4+1) &gt;&gt; shft8bitr);
<a name="l00758"></a>00758                 c = (bo&lt;AWT&gt;( 8) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;( 8+1) &gt;&gt; shft8bitr);
<a name="l00759"></a>00759                 d = (bo&lt;AWT&gt;(12) &lt;&lt; shft8bitl) | (bo&lt;AWT&gt;(12+1) &gt;&gt; shft8bitr);
<a name="l00760"></a>00760                 bo_adv&lt;AWT&gt;();
<a name="l00761"></a>00761             }
<a name="l00762"></a>00762         }
<a name="l00763"></a>00763         <span class="keywordflow">else</span> {
<a name="l00764"></a>00764             dstbit = 0;
<a name="l00765"></a>00765 
<a name="l00766"></a>00766             a = bo&lt;AWT&gt;( 0);
<a name="l00767"></a>00767             b = bo&lt;AWT&gt;( 4);
<a name="l00768"></a>00768             c = bo&lt;AWT&gt;( 8);
<a name="l00769"></a>00769             d = bo&lt;AWT&gt;(12);
<a name="l00770"></a>00770             bo_adv&lt;AWT&gt;();
<a name="l00771"></a>00771         }
<a name="l00772"></a>00772 
<a name="l00773"></a>00773         <span class="keywordflow">if</span> (!recursive &amp;&amp; remain == 0)
<a name="l00774"></a>00774             reinit();
<a name="l00775"></a>00775     }
<a name="l00776"></a>00776 };
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 egc_quad pc98_egc_src;
<a name="l00779"></a>00779 egc_quad pc98_egc_bgcm;
<a name="l00780"></a>00780 egc_quad pc98_egc_fgcm;
<a name="l00781"></a>00781 egc_quad pc98_egc_data;
<a name="l00782"></a>00782 egc_quad pc98_egc_last_vram;
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 <a class="code" href="structpc98__egc__shifter.html">pc98_egc_shifter</a> pc98_egc_shift;
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 <span class="keyword">typedef</span> egc_quad &amp; (*PC98_OPEFN)(uint8_t ope, <span class="keyword">const</span> PhysPt ad);
<a name="l00787"></a>00787 
<a name="l00788"></a>00788 <span class="keywordtype">void</span> pc98_egc_shift_reinit() {
<a name="l00789"></a>00789     pc98_egc_shift.reinit();
<a name="l00790"></a>00790 }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 <span class="keyword">static</span> egc_quad &amp;ope_xx(uint8_t ope, <span class="keyword">const</span> PhysPt ad) {
<a name="l00793"></a>00793     (void)ad;<span class="comment">//UNUSED</span>
<a name="l00794"></a>00794     LOG_MSG(<span class="stringliteral">&quot;EGC ROP 0x%2x not impl&quot;</span>,ope);
<a name="l00795"></a>00795     <span class="keywordflow">return</span> pc98_egc_last_vram;
<a name="l00796"></a>00796 }
<a name="l00797"></a>00797 
<a name="l00798"></a>00798 <span class="keyword">static</span> egc_quad &amp;ope_np(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00799"></a>00799         egc_quad dst;
<a name="l00800"></a>00800 
<a name="l00801"></a>00801         dst[0].w = *((uint16_t*)(vga.mem.linear+vramoff+0x08000));
<a name="l00802"></a>00802         dst[1].w = *((uint16_t*)(vga.mem.linear+vramoff+0x10000));
<a name="l00803"></a>00803         dst[2].w = *((uint16_t*)(vga.mem.linear+vramoff+0x18000));
<a name="l00804"></a>00804         dst[3].w = *((uint16_t*)(vga.mem.linear+vramoff+0x20000));
<a name="l00805"></a>00805 
<a name="l00806"></a>00806         pc98_egc_data[0].w = 0;
<a name="l00807"></a>00807         pc98_egc_data[1].w = 0;
<a name="l00808"></a>00808         pc98_egc_data[2].w = 0;
<a name="l00809"></a>00809         pc98_egc_data[3].w = 0;
<a name="l00810"></a>00810 
<a name="l00811"></a>00811         <span class="keywordflow">if</span> (ope &amp; 0x80) {
<a name="l00812"></a>00812         pc98_egc_data[0].w |= (pc98_egc_src[0].w &amp; dst[0].w);
<a name="l00813"></a>00813         pc98_egc_data[1].w |= (pc98_egc_src[1].w &amp; dst[1].w);
<a name="l00814"></a>00814         pc98_egc_data[2].w |= (pc98_egc_src[2].w &amp; dst[2].w);
<a name="l00815"></a>00815         pc98_egc_data[3].w |= (pc98_egc_src[3].w &amp; dst[3].w);
<a name="l00816"></a>00816     }
<a name="l00817"></a>00817         <span class="keywordflow">if</span> (ope &amp; 0x20) {
<a name="l00818"></a>00818         pc98_egc_data[0].w |= (pc98_egc_src[0].w &amp; (~dst[0].w));
<a name="l00819"></a>00819         pc98_egc_data[1].w |= (pc98_egc_src[1].w &amp; (~dst[1].w));
<a name="l00820"></a>00820         pc98_egc_data[2].w |= (pc98_egc_src[2].w &amp; (~dst[2].w));
<a name="l00821"></a>00821         pc98_egc_data[3].w |= (pc98_egc_src[3].w &amp; (~dst[3].w));
<a name="l00822"></a>00822         }
<a name="l00823"></a>00823         <span class="keywordflow">if</span> (ope &amp; 0x08) {
<a name="l00824"></a>00824         pc98_egc_data[0].w |= ((~pc98_egc_src[0].w) &amp; dst[0].w);
<a name="l00825"></a>00825         pc98_egc_data[1].w |= ((~pc98_egc_src[1].w) &amp; dst[1].w);
<a name="l00826"></a>00826         pc98_egc_data[2].w |= ((~pc98_egc_src[2].w) &amp; dst[2].w);
<a name="l00827"></a>00827         pc98_egc_data[3].w |= ((~pc98_egc_src[3].w) &amp; dst[3].w);
<a name="l00828"></a>00828         }
<a name="l00829"></a>00829         <span class="keywordflow">if</span> (ope &amp; 0x02) {
<a name="l00830"></a>00830         pc98_egc_data[0].w |= ((~pc98_egc_src[0].w) &amp; (~dst[0].w));
<a name="l00831"></a>00831         pc98_egc_data[1].w |= ((~pc98_egc_src[1].w) &amp; (~dst[1].w));
<a name="l00832"></a>00832         pc98_egc_data[2].w |= ((~pc98_egc_src[2].w) &amp; (~dst[2].w));
<a name="l00833"></a>00833         pc98_egc_data[3].w |= ((~pc98_egc_src[3].w) &amp; (~dst[3].w));
<a name="l00834"></a>00834         }
<a name="l00835"></a>00835 
<a name="l00836"></a>00836         (void)ope;
<a name="l00837"></a>00837         (void)vramoff;
<a name="l00838"></a>00838         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l00839"></a>00839 }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841 <span class="keyword">static</span> egc_quad &amp;ope_c0(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00842"></a>00842         egc_quad dst;
<a name="l00843"></a>00843 
<a name="l00844"></a>00844     <span class="comment">/* assume: ad is word aligned */</span>
<a name="l00845"></a>00845 
<a name="l00846"></a>00846         dst[0].w = *((uint16_t*)(vga.mem.linear+vramoff+0x08000));
<a name="l00847"></a>00847         dst[1].w = *((uint16_t*)(vga.mem.linear+vramoff+0x10000));
<a name="l00848"></a>00848         dst[2].w = *((uint16_t*)(vga.mem.linear+vramoff+0x18000));
<a name="l00849"></a>00849         dst[3].w = *((uint16_t*)(vga.mem.linear+vramoff+0x20000));
<a name="l00850"></a>00850 
<a name="l00851"></a>00851         pc98_egc_data[0].w = pc98_egc_src[0].w &amp; dst[0].w;
<a name="l00852"></a>00852         pc98_egc_data[1].w = pc98_egc_src[1].w &amp; dst[1].w;
<a name="l00853"></a>00853         pc98_egc_data[2].w = pc98_egc_src[2].w &amp; dst[2].w;
<a name="l00854"></a>00854         pc98_egc_data[3].w = pc98_egc_src[3].w &amp; dst[3].w;
<a name="l00855"></a>00855 
<a name="l00856"></a>00856         (void)ope;
<a name="l00857"></a>00857         (void)vramoff;
<a name="l00858"></a>00858         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l00859"></a>00859 }
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 <span class="keyword">static</span> egc_quad &amp;ope_f0(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00862"></a>00862         (void)ope;
<a name="l00863"></a>00863         (void)vramoff;
<a name="l00864"></a>00864         <span class="keywordflow">return</span> pc98_egc_src;
<a name="l00865"></a>00865 }
<a name="l00866"></a>00866 
<a name="l00867"></a>00867 <span class="keyword">static</span> egc_quad &amp;ope_fc(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00868"></a>00868         egc_quad dst;
<a name="l00869"></a>00869 
<a name="l00870"></a>00870     <span class="comment">/* assume: ad is word aligned */</span>
<a name="l00871"></a>00871 
<a name="l00872"></a>00872         dst[0].w = *((uint16_t*)(vga.mem.linear+vramoff+0x08000));
<a name="l00873"></a>00873         dst[1].w = *((uint16_t*)(vga.mem.linear+vramoff+0x10000));
<a name="l00874"></a>00874         dst[2].w = *((uint16_t*)(vga.mem.linear+vramoff+0x18000));
<a name="l00875"></a>00875         dst[3].w = *((uint16_t*)(vga.mem.linear+vramoff+0x20000));
<a name="l00876"></a>00876 
<a name="l00877"></a>00877         pc98_egc_data[0].w  =    pc98_egc_src[0].w;
<a name="l00878"></a>00878         pc98_egc_data[0].w |= ((~pc98_egc_src[0].w) &amp; dst[0].w);
<a name="l00879"></a>00879         pc98_egc_data[1].w  =    pc98_egc_src[1].w;
<a name="l00880"></a>00880         pc98_egc_data[1].w |= ((~pc98_egc_src[1].w) &amp; dst[1].w);
<a name="l00881"></a>00881         pc98_egc_data[2].w  =    pc98_egc_src[2].w;
<a name="l00882"></a>00882         pc98_egc_data[2].w |= ((~pc98_egc_src[2].w) &amp; dst[2].w);
<a name="l00883"></a>00883         pc98_egc_data[3].w  =    pc98_egc_src[3].w;
<a name="l00884"></a>00884         pc98_egc_data[3].w |= ((~pc98_egc_src[3].w) &amp; dst[3].w);
<a name="l00885"></a>00885 
<a name="l00886"></a>00886         (void)ope;
<a name="l00887"></a>00887         (void)vramoff;
<a name="l00888"></a>00888         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l00889"></a>00889 }
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 <span class="keyword">static</span> egc_quad &amp;ope_gg(uint8_t ope, <span class="keyword">const</span> PhysPt vramoff) {
<a name="l00892"></a>00892     egc_quad pat,dst;
<a name="l00893"></a>00893 
<a name="l00894"></a>00894         <span class="keywordflow">switch</span>(pc98_egc_fgc) {
<a name="l00895"></a>00895                 <span class="keywordflow">case</span> 1:
<a name="l00896"></a>00896                         pat[0].w = pc98_egc_bgcm[0].w;
<a name="l00897"></a>00897                         pat[1].w = pc98_egc_bgcm[1].w;
<a name="l00898"></a>00898                         pat[2].w = pc98_egc_bgcm[2].w;
<a name="l00899"></a>00899                         pat[3].w = pc98_egc_bgcm[3].w;
<a name="l00900"></a>00900                         <span class="keywordflow">break</span>;
<a name="l00901"></a>00901 
<a name="l00902"></a>00902                 <span class="keywordflow">case</span> 2:
<a name="l00903"></a>00903                         pat[0].w = pc98_egc_fgcm[0].w;
<a name="l00904"></a>00904                         pat[1].w = pc98_egc_fgcm[1].w;
<a name="l00905"></a>00905                         pat[2].w = pc98_egc_fgcm[2].w;
<a name="l00906"></a>00906                         pat[3].w = pc98_egc_fgcm[3].w;
<a name="l00907"></a>00907                         <span class="keywordflow">break</span>;
<a name="l00908"></a>00908 
<a name="l00909"></a>00909                 <span class="keywordflow">default</span>:
<a name="l00910"></a>00910                         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 1) {
<a name="l00911"></a>00911                                 pat[0].w = pc98_egc_src[0].w;
<a name="l00912"></a>00912                                 pat[1].w = pc98_egc_src[1].w;
<a name="l00913"></a>00913                                 pat[2].w = pc98_egc_src[2].w;
<a name="l00914"></a>00914                                 pat[3].w = pc98_egc_src[3].w;
<a name="l00915"></a>00915                         }
<a name="l00916"></a>00916                         <span class="keywordflow">else</span> {
<a name="l00917"></a>00917                                 pat[0].w = pc98_gdc_tiles[0].w;
<a name="l00918"></a>00918                                 pat[1].w = pc98_gdc_tiles[1].w;
<a name="l00919"></a>00919                                 pat[2].w = pc98_gdc_tiles[2].w;
<a name="l00920"></a>00920                                 pat[3].w = pc98_gdc_tiles[3].w;
<a name="l00921"></a>00921                         }
<a name="l00922"></a>00922                         <span class="keywordflow">break</span>;
<a name="l00923"></a>00923         }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925         dst[0].w = *((uint16_t*)(vga.mem.linear+vramoff+0x08000));
<a name="l00926"></a>00926         dst[1].w = *((uint16_t*)(vga.mem.linear+vramoff+0x10000));
<a name="l00927"></a>00927         dst[2].w = *((uint16_t*)(vga.mem.linear+vramoff+0x18000));
<a name="l00928"></a>00928         dst[3].w = *((uint16_t*)(vga.mem.linear+vramoff+0x20000));
<a name="l00929"></a>00929 
<a name="l00930"></a>00930         pc98_egc_data[0].w = 0;
<a name="l00931"></a>00931         pc98_egc_data[1].w = 0;
<a name="l00932"></a>00932         pc98_egc_data[2].w = 0;
<a name="l00933"></a>00933         pc98_egc_data[3].w = 0;
<a name="l00934"></a>00934 
<a name="l00935"></a>00935         <span class="keywordflow">if</span> (ope &amp; 0x80) {
<a name="l00936"></a>00936                 pc98_egc_data[0].w |=  ( pat[0].w  &amp;   pc98_egc_src[0].w &amp;    dst[0].w);
<a name="l00937"></a>00937                 pc98_egc_data[1].w |=  ( pat[1].w  &amp;   pc98_egc_src[1].w &amp;    dst[1].w);
<a name="l00938"></a>00938                 pc98_egc_data[2].w |=  ( pat[2].w  &amp;   pc98_egc_src[2].w &amp;    dst[2].w);
<a name="l00939"></a>00939                 pc98_egc_data[3].w |=  ( pat[3].w  &amp;   pc98_egc_src[3].w &amp;    dst[3].w);
<a name="l00940"></a>00940         }
<a name="l00941"></a>00941         <span class="keywordflow">if</span> (ope &amp; 0x40) {
<a name="l00942"></a>00942                 pc98_egc_data[0].w |= ((~pat[0].w) &amp;   pc98_egc_src[0].w &amp;    dst[0].w);
<a name="l00943"></a>00943                 pc98_egc_data[1].w |= ((~pat[1].w) &amp;   pc98_egc_src[1].w &amp;    dst[1].w);
<a name="l00944"></a>00944                 pc98_egc_data[2].w |= ((~pat[2].w) &amp;   pc98_egc_src[2].w &amp;    dst[2].w);
<a name="l00945"></a>00945                 pc98_egc_data[3].w |= ((~pat[3].w) &amp;   pc98_egc_src[3].w &amp;    dst[3].w);
<a name="l00946"></a>00946         }
<a name="l00947"></a>00947         <span class="keywordflow">if</span> (ope &amp; 0x20) {
<a name="l00948"></a>00948                 pc98_egc_data[0].w |= (  pat[0].w  &amp;   pc98_egc_src[0].w &amp;  (~dst[0].w));
<a name="l00949"></a>00949                 pc98_egc_data[1].w |= (  pat[1].w  &amp;   pc98_egc_src[1].w &amp;  (~dst[1].w));
<a name="l00950"></a>00950                 pc98_egc_data[2].w |= (  pat[2].w  &amp;   pc98_egc_src[2].w &amp;  (~dst[2].w));
<a name="l00951"></a>00951                 pc98_egc_data[3].w |= (  pat[3].w  &amp;   pc98_egc_src[3].w &amp;  (~dst[3].w));
<a name="l00952"></a>00952         }
<a name="l00953"></a>00953         <span class="keywordflow">if</span> (ope &amp; 0x10) {
<a name="l00954"></a>00954                 pc98_egc_data[0].w |= ((~pat[0].w) &amp;   pc98_egc_src[0].w &amp;  (~dst[0].w));
<a name="l00955"></a>00955                 pc98_egc_data[1].w |= ((~pat[1].w) &amp;   pc98_egc_src[1].w &amp;  (~dst[1].w));
<a name="l00956"></a>00956                 pc98_egc_data[2].w |= ((~pat[2].w) &amp;   pc98_egc_src[2].w &amp;  (~dst[2].w));
<a name="l00957"></a>00957                 pc98_egc_data[3].w |= ((~pat[3].w) &amp;   pc98_egc_src[3].w &amp;  (~dst[3].w));
<a name="l00958"></a>00958         }
<a name="l00959"></a>00959         <span class="keywordflow">if</span> (ope &amp; 0x08) {
<a name="l00960"></a>00960                 pc98_egc_data[0].w |= (  pat[0].w  &amp; (~pc98_egc_src[0].w) &amp;   dst[0].w);
<a name="l00961"></a>00961                 pc98_egc_data[1].w |= (  pat[1].w  &amp; (~pc98_egc_src[1].w) &amp;   dst[1].w);
<a name="l00962"></a>00962                 pc98_egc_data[2].w |= (  pat[2].w  &amp; (~pc98_egc_src[2].w) &amp;   dst[2].w);
<a name="l00963"></a>00963                 pc98_egc_data[3].w |= (  pat[3].w  &amp; (~pc98_egc_src[3].w) &amp;   dst[3].w);
<a name="l00964"></a>00964         }
<a name="l00965"></a>00965         <span class="keywordflow">if</span> (ope &amp; 0x04) {
<a name="l00966"></a>00966                 pc98_egc_data[0].w |= ((~pat[0].w) &amp; (~pc98_egc_src[0].w) &amp;   dst[0].w);
<a name="l00967"></a>00967                 pc98_egc_data[1].w |= ((~pat[1].w) &amp; (~pc98_egc_src[1].w) &amp;   dst[1].w);
<a name="l00968"></a>00968                 pc98_egc_data[2].w |= ((~pat[2].w) &amp; (~pc98_egc_src[2].w) &amp;   dst[2].w);
<a name="l00969"></a>00969                 pc98_egc_data[3].w |= ((~pat[3].w) &amp; (~pc98_egc_src[3].w) &amp;   dst[3].w);
<a name="l00970"></a>00970         }
<a name="l00971"></a>00971         <span class="keywordflow">if</span> (ope &amp; 0x02) {
<a name="l00972"></a>00972                 pc98_egc_data[0].w |= (  pat[0].w  &amp; (~pc98_egc_src[0].w) &amp; (~dst[0].w));
<a name="l00973"></a>00973                 pc98_egc_data[1].w |= (  pat[1].w  &amp; (~pc98_egc_src[1].w) &amp; (~dst[1].w));
<a name="l00974"></a>00974                 pc98_egc_data[2].w |= (  pat[2].w  &amp; (~pc98_egc_src[2].w) &amp; (~dst[2].w));
<a name="l00975"></a>00975                 pc98_egc_data[3].w |= (  pat[3].w  &amp; (~pc98_egc_src[3].w) &amp; (~dst[3].w));
<a name="l00976"></a>00976         }
<a name="l00977"></a>00977         <span class="keywordflow">if</span> (ope &amp; 0x01) {
<a name="l00978"></a>00978                 pc98_egc_data[0].w |= ((~pat[0].w) &amp; (~pc98_egc_src[0].w) &amp; (~dst[0].w));
<a name="l00979"></a>00979                 pc98_egc_data[1].w |= ((~pat[1].w) &amp; (~pc98_egc_src[1].w) &amp; (~dst[1].w));
<a name="l00980"></a>00980                 pc98_egc_data[2].w |= ((~pat[2].w) &amp; (~pc98_egc_src[2].w) &amp; (~dst[2].w));
<a name="l00981"></a>00981                 pc98_egc_data[3].w |= ((~pat[3].w) &amp; (~pc98_egc_src[3].w) &amp; (~dst[3].w));
<a name="l00982"></a>00982         }
<a name="l00983"></a>00983 
<a name="l00984"></a>00984         <span class="keywordflow">return</span> pc98_egc_data;
<a name="l00985"></a>00985 }
<a name="l00986"></a>00986 
<a name="l00987"></a>00987 <span class="keyword">static</span> <span class="keyword">const</span> PC98_OPEFN pc98_egc_opfn[256] = {
<a name="l00988"></a>00988                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l00989"></a>00989                         ope_xx, ope_xx, ope_xx, ope_xx, ope_np, ope_xx, ope_xx, ope_xx,
<a name="l00990"></a>00990                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l00991"></a>00991                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l00992"></a>00992                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l00993"></a>00993                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l00994"></a>00994                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l00995"></a>00995                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l00996"></a>00996                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l00997"></a>00997                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l00998"></a>00998                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l00999"></a>00999                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01000"></a>01000                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01001"></a>01001                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01002"></a>01002                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01003"></a>01003                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01004"></a>01004                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01005"></a>01005                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01006"></a>01006                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01007"></a>01007                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01008"></a>01008                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01009"></a>01009                         ope_xx, ope_xx, ope_xx, ope_xx, ope_gg, ope_xx, ope_xx, ope_xx,
<a name="l01010"></a>01010                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01011"></a>01011                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01012"></a>01012                         ope_c0, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01013"></a>01013                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01014"></a>01014                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01015"></a>01015                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01016"></a>01016                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01017"></a>01017                         ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01018"></a>01018                         ope_f0, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx, ope_xx,
<a name="l01019"></a>01019                         ope_xx, ope_xx, ope_xx, ope_xx, ope_fc, ope_xx, ope_xx, ope_xx};
<a name="l01020"></a>01020 
<a name="l01021"></a>01021 <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> egc_quad &amp;egc_ope(<span class="keyword">const</span> PhysPt vramoff, <span class="keyword">const</span> AWT val) {
<a name="l01022"></a>01022     *((uint16_t*)pc98_egc_maskef) = *((uint16_t*)pc98_egc_mask);
<a name="l01023"></a>01023 
<a name="l01024"></a>01024     <span class="comment">/* 4A4h</span>
<a name="l01025"></a>01025 <span class="comment">     * bits [12:11] = light source</span>
<a name="l01026"></a>01026 <span class="comment">     *    11 = invalid</span>
<a name="l01027"></a>01027 <span class="comment">     *    10 = write the contents of the palette register</span>
<a name="l01028"></a>01028 <span class="comment">     *    01 = write the result of the raster operation</span>
<a name="l01029"></a>01029 <span class="comment">     *    00 = write CPU data</span>
<a name="l01030"></a>01030 <span class="comment">     *</span>
<a name="l01031"></a>01031 <span class="comment">     * 4A2h</span>
<a name="l01032"></a>01032 <span class="comment">     * bits [14:13] = foreground, background color</span>
<a name="l01033"></a>01033 <span class="comment">     *    11 = invalid</span>
<a name="l01034"></a>01034 <span class="comment">     *    10 = foreground color</span>
<a name="l01035"></a>01035 <span class="comment">     *    01 = background color</span>
<a name="l01036"></a>01036 <span class="comment">     *    00 = pattern register</span>
<a name="l01037"></a>01037 <span class="comment">     */</span>
<a name="l01038"></a>01038     <span class="keywordflow">switch</span> (pc98_egc_lightsource) {
<a name="l01039"></a>01039         <span class="keywordflow">case</span> 1: <span class="comment">/* 0x0800 */</span>
<a name="l01040"></a>01040             <span class="keywordflow">if</span> (pc98_egc_shiftinput) {
<a name="l01041"></a>01041                 pc98_egc_shift.input&lt;AWT&gt;(
<a name="l01042"></a>01042                     val,
<a name="l01043"></a>01043                     val,
<a name="l01044"></a>01044                     val,
<a name="l01045"></a>01045                     val,
<a name="l01046"></a>01046                     vramoff&amp;1);
<a name="l01047"></a>01047 
<a name="l01048"></a>01048                 pc98_egc_shift.output&lt;AWT&gt;(
<a name="l01049"></a>01049                     *((AWT*)(pc98_egc_src[0].b+(vramoff&amp;1))),
<a name="l01050"></a>01050                     *((AWT*)(pc98_egc_src[1].b+(vramoff&amp;1))),
<a name="l01051"></a>01051                     *((AWT*)(pc98_egc_src[2].b+(vramoff&amp;1))),
<a name="l01052"></a>01052                     *((AWT*)(pc98_egc_src[3].b+(vramoff&amp;1))),
<a name="l01053"></a>01053                     vramoff&amp;1);
<a name="l01054"></a>01054             }
<a name="l01055"></a>01055 
<a name="l01056"></a>01056             *((uint16_t*)pc98_egc_maskef) &amp;= *((uint16_t*)pc98_egc_srcmask);
<a name="l01057"></a>01057             <span class="keywordflow">return</span> pc98_egc_opfn[pc98_egc_rop](pc98_egc_rop, vramoff &amp; (~1U));
<a name="l01058"></a>01058         <span class="keywordflow">case</span> 2: <span class="comment">/* 0x1000 */</span>
<a name="l01059"></a>01059             <span class="keywordflow">if</span> (pc98_egc_fgc == 1)
<a name="l01060"></a>01060                 <span class="keywordflow">return</span> pc98_egc_bgcm;
<a name="l01061"></a>01061             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pc98_egc_fgc == 2)
<a name="l01062"></a>01062                 <span class="keywordflow">return</span> pc98_egc_fgcm;
<a name="l01063"></a>01063 
<a name="l01064"></a>01064             <span class="keywordflow">if</span> (pc98_egc_shiftinput) {
<a name="l01065"></a>01065                 pc98_egc_shift.input&lt;AWT&gt;(
<a name="l01066"></a>01066                     val,
<a name="l01067"></a>01067                     val,
<a name="l01068"></a>01068                     val,
<a name="l01069"></a>01069                     val,
<a name="l01070"></a>01070                     vramoff&amp;1);
<a name="l01071"></a>01071 
<a name="l01072"></a>01072                 pc98_egc_shift.output&lt;AWT&gt;(
<a name="l01073"></a>01073                     *((AWT*)(pc98_egc_src[0].b+(vramoff&amp;1))),
<a name="l01074"></a>01074                     *((AWT*)(pc98_egc_src[1].b+(vramoff&amp;1))),
<a name="l01075"></a>01075                     *((AWT*)(pc98_egc_src[2].b+(vramoff&amp;1))),
<a name="l01076"></a>01076                     *((AWT*)(pc98_egc_src[3].b+(vramoff&amp;1))),
<a name="l01077"></a>01077                     vramoff&amp;1);
<a name="l01078"></a>01078             }
<a name="l01079"></a>01079  
<a name="l01080"></a>01080             *((uint16_t*)pc98_egc_maskef) &amp;= *((uint16_t*)pc98_egc_srcmask);
<a name="l01081"></a>01081             <span class="keywordflow">return</span> pc98_egc_src;
<a name="l01082"></a>01082         <span class="keywordflow">default</span>: {
<a name="l01083"></a>01083             uint16_t tmp = (uint16_t)val;
<a name="l01084"></a>01084 
<a name="l01085"></a>01085             <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &lt; 2) {
<a name="l01086"></a>01086                 tmp &amp;= 0xFFU;
<a name="l01087"></a>01087                 tmp |= tmp &lt;&lt; 8U;
<a name="l01088"></a>01088             }
<a name="l01089"></a>01089 
<a name="l01090"></a>01090             pc98_egc_data[0].w = tmp;
<a name="l01091"></a>01091             pc98_egc_data[1].w = tmp;
<a name="l01092"></a>01092             pc98_egc_data[2].w = tmp;
<a name="l01093"></a>01093             pc98_egc_data[3].w = tmp;
<a name="l01094"></a>01094             } <span class="keywordflow">break</span>;
<a name="l01095"></a>01095     };
<a name="l01096"></a>01096 
<a name="l01097"></a>01097     <span class="keywordflow">return</span> pc98_egc_data;
<a name="l01098"></a>01098 }
<a name="l01099"></a>01099 
<a name="l01100"></a>01100 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pc98_mem_msw_m[8] = {0};
<a name="l01101"></a>01101 
<a name="l01102"></a>01102 <span class="keywordtype">void</span> pc98_msw3_set_ramsize(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b) {
<a name="l01103"></a>01103     pc98_mem_msw_m[2<span class="comment">/*MSW3*/</span>] = b;
<a name="l01104"></a>01104 }
<a name="l01105"></a>01105 
<a name="l01106"></a>01106 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pc98_mem_msw(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> which) {
<a name="l01107"></a>01107     <span class="keywordflow">return</span> pc98_mem_msw_m[which&amp;7];
<a name="l01108"></a>01108 }
<a name="l01109"></a>01109 
<a name="l01110"></a>01110 <span class="comment">/* The NEC display is documented to have:</span>
<a name="l01111"></a>01111 <span class="comment"> *</span>
<a name="l01112"></a>01112 <span class="comment"> * A0000-A3FFF      T-RAM (text) (8KB WORDs)</span>
<a name="l01113"></a>01113 <span class="comment"> *   A0000-A1FFF      Characters (4KB WORDs)</span>
<a name="l01114"></a>01114 <span class="comment"> *   A2000-A3FFF      Attributes (4KB WORDs). For each 16-bit WORD only the lower 8 bits are read/writeable.</span>
<a name="l01115"></a>01115 <span class="comment"> *   A4000-A5FFF      Unknown ?? (4KB WORDs)</span>
<a name="l01116"></a>01116 <span class="comment"> *   A6000-A7FFF      Not present (4KB WORDs)</span>
<a name="l01117"></a>01117 <span class="comment"> * A8000-BFFFF      G-RAM (graphics) (96KB)</span>
<a name="l01118"></a>01118 <span class="comment"> *</span>
<a name="l01119"></a>01119 <span class="comment"> * T-RAM character display RAM is 16-bits per character.</span>
<a name="l01120"></a>01120 <span class="comment"> * ASCII text has upper 8 bits zero.</span>
<a name="l01121"></a>01121 <span class="comment"> * SHIFT-JIS doublewide characters use the upper byte for non-ASCII. */</span>
<a name="l01122"></a>01122 
<a name="l01123"></a><a class="code" href="classVGA__PC98__PageHandler.html">01123</a> <span class="keyword">class </span><a class="code" href="classVGA__PC98__PageHandler.html">VGA_PC98_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01124"></a>01124 <span class="keyword">public</span>:
<a name="l01125"></a>01125         <a class="code" href="classVGA__PC98__PageHandler.html">VGA_PC98_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01126"></a>01126     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> check_align(<span class="keyword">const</span> PhysPt addr) {
<a name="l01127"></a>01127         <span class="comment">/* DEBUG: address must be aligned to datatype.</span>
<a name="l01128"></a>01128 <span class="comment">         *        Code that calls us must enforce that or subdivide</span>
<a name="l01129"></a>01129 <span class="comment">         *        to a small datatype that can follow this rule. */</span>
<a name="l01130"></a>01130         PhysPt chk = (1UL &lt;&lt; (<span class="keyword">sizeof</span>(AWT) - 1)) - 1;
<a name="l01131"></a>01131         <span class="comment">/* uint8_t:  chk = 0</span>
<a name="l01132"></a>01132 <span class="comment">         * uint16_t: chk = 1</span>
<a name="l01133"></a>01133 <span class="comment">         * TODO: Do you suppose later generation PC-9821&#39;s supported DWORD size bitplane transfers?</span>
<a name="l01134"></a>01134 <span class="comment">         *       Or did NEC just give up on anything past 16-bit and focus on the SVGA side of things? */</span>
<a name="l01135"></a>01135         assert((addr&amp;chk) == 0);
<a name="l01136"></a>01136     }
<a name="l01137"></a>01137 
<a name="l01138"></a>01138     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> AWT mode8_r(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane,<span class="keyword">const</span> PhysPt vramoff) {
<a name="l01139"></a>01139         AWT r,b;
<a name="l01140"></a>01140 
<a name="l01141"></a>01141         b = *((AWT*)(vga.mem.linear + vramoff));
<a name="l01142"></a>01142         r = b ^ *((AWT*)pc98_gdc_tiles[plane].b);
<a name="l01143"></a>01143 
<a name="l01144"></a>01144         <span class="keywordflow">return</span> r;
<a name="l01145"></a>01145     }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> mode8_w(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane,<span class="keyword">const</span> PhysPt vramoff) {
<a name="l01148"></a>01148         <span class="comment">/* Neko Project II code suggests that the first byte is repeated. */</span>
<a name="l01149"></a>01149         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &gt; 1)
<a name="l01150"></a>01150             pc98_gdc_tiles[plane].b[1] = pc98_gdc_tiles[plane].b[0];
<a name="l01151"></a>01151 
<a name="l01152"></a>01152         *((AWT*)(vga.mem.linear + vramoff)) = *((AWT*)pc98_gdc_tiles[plane].b);
<a name="l01153"></a>01153     }
<a name="l01154"></a>01154 
<a name="l01155"></a>01155     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> modeC_w(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> plane,<span class="keyword">const</span> PhysPt vramoff,<span class="keyword">const</span> AWT mask,<span class="keyword">const</span> AWT val) {
<a name="l01156"></a>01156         AWT t;
<a name="l01157"></a>01157 
<a name="l01158"></a>01158         <span class="comment">/* Neko Project II code suggests that the first byte is repeated. */</span>
<a name="l01159"></a>01159         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(AWT) &gt; 1)
<a name="l01160"></a>01160             pc98_gdc_tiles[plane].b[1] = pc98_gdc_tiles[plane].b[0];
<a name="l01161"></a>01161 
<a name="l01162"></a>01162         t  = *((AWT*)(vga.mem.linear + vramoff)) &amp; mask;
<a name="l01163"></a>01163         t |= val &amp; *((AWT*)pc98_gdc_tiles[plane].b);
<a name="l01164"></a>01164         *((AWT*)(vga.mem.linear + vramoff)) = t;
<a name="l01165"></a>01165     }
<a name="l01166"></a>01166 
<a name="l01167"></a>01167     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> AWT modeEGC_r(<span class="keyword">const</span> PhysPt vramoff,<span class="keyword">const</span> PhysPt fulloff) {
<a name="l01168"></a>01168         <span class="comment">/* assume: vramoff is even IF AWT is 16-bit wide */</span>
<a name="l01169"></a>01169         *((AWT*)(pc98_egc_last_vram[0].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x08000));
<a name="l01170"></a>01170         *((AWT*)(pc98_egc_last_vram[1].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x10000));
<a name="l01171"></a>01171         *((AWT*)(pc98_egc_last_vram[2].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x18000));
<a name="l01172"></a>01172         *((AWT*)(pc98_egc_last_vram[3].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x20000));
<a name="l01173"></a>01173 
<a name="l01174"></a>01174         <span class="comment">/* bits [10:10] = read source</span>
<a name="l01175"></a>01175 <span class="comment">         *    1 = shifter input is CPU write data</span>
<a name="l01176"></a>01176 <span class="comment">         *    0 = shifter input is VRAM data */</span>
<a name="l01177"></a>01177         <span class="comment">/* Neko Project II: if ((egc.ope &amp; 0x0400) == 0) ... */</span>
<a name="l01178"></a>01178         <span class="keywordflow">if</span> (!pc98_egc_shiftinput) {
<a name="l01179"></a>01179             pc98_egc_shift.input&lt;AWT&gt;(
<a name="l01180"></a>01180                 *((AWT*)(pc98_egc_last_vram[0].b+(vramoff&amp;1))),
<a name="l01181"></a>01181                 *((AWT*)(pc98_egc_last_vram[1].b+(vramoff&amp;1))),
<a name="l01182"></a>01182                 *((AWT*)(pc98_egc_last_vram[2].b+(vramoff&amp;1))),
<a name="l01183"></a>01183                 *((AWT*)(pc98_egc_last_vram[3].b+(vramoff&amp;1))),
<a name="l01184"></a>01184                 vramoff&amp;1);
<a name="l01185"></a>01185 
<a name="l01186"></a>01186             pc98_egc_shift.output&lt;AWT&gt;(
<a name="l01187"></a>01187                 *((AWT*)(pc98_egc_src[0].b+(vramoff&amp;1))),
<a name="l01188"></a>01188                 *((AWT*)(pc98_egc_src[1].b+(vramoff&amp;1))),
<a name="l01189"></a>01189                 *((AWT*)(pc98_egc_src[2].b+(vramoff&amp;1))),
<a name="l01190"></a>01190                 *((AWT*)(pc98_egc_src[3].b+(vramoff&amp;1))),
<a name="l01191"></a>01191                 vramoff&amp;1);
<a name="l01192"></a>01192         }
<a name="l01193"></a>01193 
<a name="l01194"></a>01194         <span class="comment">/* 0x4A4:</span>
<a name="l01195"></a>01195 <span class="comment">         * ...</span>
<a name="l01196"></a>01196 <span class="comment">         * bits [9:8] = register load (pc98_egc_regload[1:0])</span>
<a name="l01197"></a>01197 <span class="comment">         *    11 = invalid</span>
<a name="l01198"></a>01198 <span class="comment">         *    10 = load VRAM data before writing on VRAM write</span>
<a name="l01199"></a>01199 <span class="comment">         *    01 = load VRAM data into pattern/tile register on VRAM read</span>
<a name="l01200"></a>01200 <span class="comment">         *    00 = Do not change pattern/tile register</span>
<a name="l01201"></a>01201 <span class="comment">         * ...</span>
<a name="l01202"></a>01202 <span class="comment">         *</span>
<a name="l01203"></a>01203 <span class="comment">         * pc98_egc_regload = (val &gt;&gt; 8) &amp; 3;</span>
<a name="l01204"></a>01204 <span class="comment">         */</span>
<a name="l01205"></a>01205         <span class="comment">/* Neko Project II: if ((egc.ope &amp; 0x0300) == 0x0100) ... */</span>
<a name="l01206"></a>01206         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 1) { <span class="comment">/* load VRAM data into pattern/tile... (or INVALID) */</span>
<a name="l01207"></a>01207             *((AWT*)(pc98_gdc_tiles[0].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[0].b+(vramoff&amp;1)));
<a name="l01208"></a>01208             *((AWT*)(pc98_gdc_tiles[1].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[1].b+(vramoff&amp;1)));
<a name="l01209"></a>01209             *((AWT*)(pc98_gdc_tiles[2].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[2].b+(vramoff&amp;1)));
<a name="l01210"></a>01210             *((AWT*)(pc98_gdc_tiles[3].b+(vramoff&amp;1))) = *((AWT*)(pc98_egc_last_vram[3].b+(vramoff&amp;1)));
<a name="l01211"></a>01211         }
<a name="l01212"></a>01212 
<a name="l01213"></a>01213         <span class="comment">/* 0x4A4:</span>
<a name="l01214"></a>01214 <span class="comment">         * bits [13:13] = 0=compare lead plane  1=don&#39;t</span>
<a name="l01215"></a>01215 <span class="comment">         *</span>
<a name="l01216"></a>01216 <span class="comment">         * bits [10:10] = read source</span>
<a name="l01217"></a>01217 <span class="comment">         *    1 = shifter input is CPU write data</span>
<a name="l01218"></a>01218 <span class="comment">         *    0 = shifter input is VRAM data */</span>
<a name="l01219"></a>01219         <span class="keywordflow">if</span> (pc98_egc_compare_lead) {
<a name="l01220"></a>01220             <span class="keywordflow">if</span> (!pc98_egc_shiftinput)
<a name="l01221"></a>01221                 <span class="keywordflow">return</span> *((AWT*)(pc98_egc_src[pc98_egc_lead_plane&amp;3].b));
<a name="l01222"></a>01222             <span class="keywordflow">else</span>
<a name="l01223"></a>01223                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+vramoff+0x08000+((pc98_egc_lead_plane&amp;3)*0x8000)));
<a name="l01224"></a>01224         }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226         <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+fulloff));
<a name="l01227"></a>01227     }
<a name="l01228"></a>01228 
<a name="l01229"></a>01229     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> modeEGC_w(<span class="keyword">const</span> PhysPt vramoff,<span class="keyword">const</span> PhysPt fulloff,<span class="keyword">const</span> AWT val) {
<a name="l01230"></a>01230         (void)fulloff;<span class="comment">//UNUSED</span>
<a name="l01231"></a>01231 
<a name="l01232"></a>01232         <span class="comment">/* assume: vramoff is even IF AWT is 16-bit wide */</span>
<a name="l01233"></a>01233 
<a name="l01234"></a>01234         <span class="comment">/* 0x4A4:</span>
<a name="l01235"></a>01235 <span class="comment">         * ...</span>
<a name="l01236"></a>01236 <span class="comment">         * bits [9:8] = register load (pc98_egc_regload[1:0])</span>
<a name="l01237"></a>01237 <span class="comment">         *    11 = invalid</span>
<a name="l01238"></a>01238 <span class="comment">         *    10 = load VRAM data before writing on VRAM write</span>
<a name="l01239"></a>01239 <span class="comment">         *    01 = load VRAM data into pattern/tile register on VRAM read</span>
<a name="l01240"></a>01240 <span class="comment">         *    00 = Do not change pattern/tile register</span>
<a name="l01241"></a>01241 <span class="comment">         * ...</span>
<a name="l01242"></a>01242 <span class="comment">         * pc98_egc_regload = (val &gt;&gt; 8) &amp; 3;</span>
<a name="l01243"></a>01243 <span class="comment">         */</span>
<a name="l01244"></a>01244         <span class="comment">/* Neko Project II: if ((egc.ope &amp; 0x0300) == 0x0200) ... */</span>
<a name="l01245"></a>01245         <span class="keywordflow">if</span> (pc98_egc_regload &amp; 2) { <span class="comment">/* load VRAM data before writing on VRAM write (or INVALID) */</span>
<a name="l01246"></a>01246             *((AWT*)(pc98_gdc_tiles[0].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x08000));
<a name="l01247"></a>01247             *((AWT*)(pc98_gdc_tiles[1].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x10000));
<a name="l01248"></a>01248             *((AWT*)(pc98_gdc_tiles[2].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x18000));
<a name="l01249"></a>01249             *((AWT*)(pc98_gdc_tiles[3].b+(vramoff&amp;1))) = *((AWT*)(vga.mem.linear+vramoff+0x20000));
<a name="l01250"></a>01250         }
<a name="l01251"></a>01251 
<a name="l01252"></a>01252         egc_quad &amp;ropdata = egc_ope&lt;AWT&gt;(vramoff, val);
<a name="l01253"></a>01253 
<a name="l01254"></a>01254         <span class="keyword">const</span> AWT accmask = *((AWT*)(pc98_egc_maskef+(vramoff&amp;1)));
<a name="l01255"></a>01255 
<a name="l01256"></a>01256         <span class="keywordflow">if</span> (accmask != 0) {
<a name="l01257"></a>01257             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 1)) {
<a name="l01258"></a>01258                 *((AWT*)(vga.mem.linear+vramoff+0x08000)) &amp;= ~accmask;
<a name="l01259"></a>01259                 *((AWT*)(vga.mem.linear+vramoff+0x08000)) |=  accmask &amp; *((AWT*)(ropdata[0].b+(vramoff&amp;1)));
<a name="l01260"></a>01260             }
<a name="l01261"></a>01261             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 2)) {
<a name="l01262"></a>01262                 *((AWT*)(vga.mem.linear+vramoff+0x10000)) &amp;= ~accmask;
<a name="l01263"></a>01263                 *((AWT*)(vga.mem.linear+vramoff+0x10000)) |=  accmask &amp; *((AWT*)(ropdata[1].b+(vramoff&amp;1)));
<a name="l01264"></a>01264             }
<a name="l01265"></a>01265             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 4)) {
<a name="l01266"></a>01266                 *((AWT*)(vga.mem.linear+vramoff+0x18000)) &amp;= ~accmask;
<a name="l01267"></a>01267                 *((AWT*)(vga.mem.linear+vramoff+0x18000)) |=  accmask &amp; *((AWT*)(ropdata[2].b+(vramoff&amp;1)));
<a name="l01268"></a>01268             }
<a name="l01269"></a>01269             <span class="keywordflow">if</span> (!(pc98_egc_access &amp; 8)) {
<a name="l01270"></a>01270                 *((AWT*)(vga.mem.linear+vramoff+0x20000)) &amp;= ~accmask;
<a name="l01271"></a>01271                 *((AWT*)(vga.mem.linear+vramoff+0x20000)) |=  accmask &amp; *((AWT*)(ropdata[3].b+(vramoff&amp;1)));
<a name="l01272"></a>01272             }
<a name="l01273"></a>01273         }
<a name="l01274"></a>01274     }
<a name="l01275"></a>01275 
<a name="l01276"></a>01276     <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; AWT readc(PhysPt addr) {
<a name="l01277"></a>01277         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vop_offset = 0;
<a name="l01278"></a>01278 
<a name="l01279"></a>01279                 addr = PAGING_GetPhysicalAddress(addr);
<a name="l01280"></a>01280 
<a name="l01281"></a>01281         check_align&lt;AWT&gt;(addr);
<a name="l01282"></a>01282 
<a name="l01283"></a>01283         <span class="keywordflow">if</span> ((addr &amp; (~0x1F)) == 0xA3FE0) {
<a name="l01284"></a>01284             <span class="comment">/* </span>
<a name="l01285"></a>01285 <span class="comment">             * 0xA3FE2      MSW1</span>
<a name="l01286"></a>01286 <span class="comment">             * 0xA3FE6      MSW2</span>
<a name="l01287"></a>01287 <span class="comment">             * 0xA3FEA      MSW3</span>
<a name="l01288"></a>01288 <span class="comment">             * 0xA3FEE      MSW4</span>
<a name="l01289"></a>01289 <span class="comment">             * 0xA3FF2      MSW5</span>
<a name="l01290"></a>01290 <span class="comment">             * 0xA3FF6      MSW6</span>
<a name="l01291"></a>01291 <span class="comment">             * 0xA3FFA      MSW7</span>
<a name="l01292"></a>01292 <span class="comment">             * 0xA3FFE      MSW8</span>
<a name="l01293"></a>01293 <span class="comment">             */</span>
<a name="l01294"></a>01294             <span class="keywordflow">return</span> pc98_mem_msw((addr &gt;&gt; 2) &amp; 7);
<a name="l01295"></a>01295         }
<a name="l01296"></a>01296 
<a name="l01297"></a>01297         <span class="keywordflow">if</span> (addr &gt;= 0xE0000) <span class="comment">/* the 4th bitplane (EGC 16-color mode) */</span>
<a name="l01298"></a>01298             addr = (addr &amp; 0x7FFF) + 0x20000;
<a name="l01299"></a>01299         <span class="keywordflow">else</span>
<a name="l01300"></a>01300             addr &amp;= 0x1FFFF;
<a name="l01301"></a>01301 
<a name="l01302"></a>01302         <span class="keywordflow">switch</span> (addr&gt;&gt;13) {
<a name="l01303"></a>01303             <span class="keywordflow">case</span> 0:     <span class="comment">/* A0000-A1FFF Character RAM */</span>
<a name="l01304"></a>01304                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr));
<a name="l01305"></a>01305             <span class="keywordflow">case</span> 1:     <span class="comment">/* A2000-A3FFF Attribute RAM */</span>
<a name="l01306"></a>01306                 <span class="keywordflow">if</span> (addr &amp; 1) <span class="keywordflow">return</span> (AWT)(~0ull); <span class="comment">/* ignore odd bytes */</span>
<a name="l01307"></a>01307                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr)) | 0xFF00; <span class="comment">/* odd bytes 0xFF */</span>
<a name="l01308"></a>01308             <span class="keywordflow">case</span> 2:     <span class="comment">/* A4000-A5FFF Unknown ?? */</span>
<a name="l01309"></a>01309                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr));
<a name="l01310"></a>01310             <span class="keywordflow">case</span> 3:     <span class="comment">/* A6000-A7FFF Not present */</span>
<a name="l01311"></a>01311                 <span class="keywordflow">return</span> (AWT)(~0ull);
<a name="l01312"></a>01312             <span class="keywordflow">default</span>:    <span class="comment">/* A8000-BFFFF G-RAM */</span>
<a name="l01313"></a>01313                 vop_offset = (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_ACCESS)) ? 0x20000 : 0;
<a name="l01314"></a>01314                 <span class="keywordflow">break</span>;
<a name="l01315"></a>01315         };
<a name="l01316"></a>01316 
<a name="l01317"></a>01317         <span class="keywordflow">switch</span> (pc98_gdc_vramop &amp; 0xF) {
<a name="l01318"></a>01318             <span class="keywordflow">case</span> 0x00:
<a name="l01319"></a>01319             <span class="keywordflow">case</span> 0x01:
<a name="l01320"></a>01320             <span class="keywordflow">case</span> 0x02:
<a name="l01321"></a>01321             <span class="keywordflow">case</span> 0x03:
<a name="l01322"></a>01322             <span class="keywordflow">case</span> 0x04:
<a name="l01323"></a>01323             <span class="keywordflow">case</span> 0x05:
<a name="l01324"></a>01324             <span class="keywordflow">case</span> 0x06:
<a name="l01325"></a>01325             <span class="keywordflow">case</span> 0x07:
<a name="l01326"></a>01326                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr+vop_offset));
<a name="l01327"></a>01327             <span class="keywordflow">case</span> 0x08: <span class="comment">/* TCR/TDW */</span>
<a name="l01328"></a>01328             <span class="keywordflow">case</span> 0x09:
<a name="l01329"></a>01329                 {
<a name="l01330"></a>01330                     AWT r = 0;
<a name="l01331"></a>01331 
<a name="l01332"></a>01332                     <span class="comment">/* this reads multiple bitplanes at once */</span>
<a name="l01333"></a>01333                     addr &amp;= 0x7FFF;
<a name="l01334"></a>01334 
<a name="l01335"></a>01335                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 1)) <span class="comment">// blue channel</span>
<a name="l01336"></a>01336                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>0,addr + 0x8000 + vop_offset);
<a name="l01337"></a>01337 
<a name="l01338"></a>01338                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 2)) <span class="comment">// red channel</span>
<a name="l01339"></a>01339                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>1,addr + 0x10000 + vop_offset);
<a name="l01340"></a>01340 
<a name="l01341"></a>01341                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 4)) <span class="comment">// green channel</span>
<a name="l01342"></a>01342                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>2,addr + 0x18000 + vop_offset);
<a name="l01343"></a>01343 
<a name="l01344"></a>01344                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 8)) <span class="comment">// extended channel</span>
<a name="l01345"></a>01345                         r |= mode8_r&lt;AWT&gt;(<span class="comment">/*plane*/</span>3,addr + 0x20000 + vop_offset);
<a name="l01346"></a>01346 
<a name="l01347"></a>01347                     <span class="comment">/* NTS: Apparently returning this value correctly really matters to the</span>
<a name="l01348"></a>01348 <span class="comment">                     *      sprite engine in &quot;Edge&quot;, else visual errors occur. */</span>
<a name="l01349"></a>01349                     <span class="keywordflow">return</span> ~r;
<a name="l01350"></a>01350                 }
<a name="l01351"></a>01351             <span class="keywordflow">case</span> 0x0C:
<a name="l01352"></a>01352             <span class="keywordflow">case</span> 0x0D:
<a name="l01353"></a>01353                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr+vop_offset));
<a name="l01354"></a>01354             <span class="keywordflow">case</span> 0x0A: <span class="comment">/* EGC read */</span>
<a name="l01355"></a>01355             <span class="keywordflow">case</span> 0x0B:
<a name="l01356"></a>01356             <span class="keywordflow">case</span> 0x0E:
<a name="l01357"></a>01357             <span class="keywordflow">case</span> 0x0F:
<a name="l01358"></a>01358                 <span class="comment">/* this reads multiple bitplanes at once */</span>
<a name="l01359"></a>01359                 <span class="keywordflow">return</span> modeEGC_r&lt;AWT&gt;((addr&amp;0x7FFF) + vop_offset,addr + vop_offset);
<a name="l01360"></a>01360             <span class="keywordflow">default</span>: <span class="comment">/* should not happen */</span>
<a name="l01361"></a>01361                 LOG_MSG(<span class="stringliteral">&quot;PC-98 VRAM read warning: Unsupported opmode 0x%X&quot;</span>,pc98_gdc_vramop);
<a name="l01362"></a>01362                 <span class="keywordflow">return</span> *((AWT*)(vga.mem.linear+addr+vop_offset));
<a name="l01363"></a>01363         };
<a name="l01364"></a>01364 
<a name="l01365"></a>01365                 <span class="keywordflow">return</span> (AWT)(~0ull);
<a name="l01366"></a>01366         }
<a name="l01367"></a>01367 
<a name="l01368"></a>01368         <span class="keyword">template</span> &lt;<span class="keyword">class</span> AWT&gt; <span class="keywordtype">void</span> writec(PhysPt addr,AWT val){
<a name="l01369"></a>01369         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vop_offset = 0;
<a name="l01370"></a>01370 
<a name="l01371"></a>01371                 addr = PAGING_GetPhysicalAddress(addr);
<a name="l01372"></a>01372 
<a name="l01373"></a>01373         check_align&lt;AWT&gt;(addr);
<a name="l01374"></a>01374 
<a name="l01375"></a>01375         <span class="keywordflow">if</span> ((addr &amp; (~0x1F)) == 0xA3FE0)
<a name="l01376"></a>01376             <span class="keywordflow">return</span>;
<a name="l01377"></a>01377 
<a name="l01378"></a>01378         <span class="keywordflow">if</span> (addr &gt;= 0xE0000) <span class="comment">/* the 4th bitplane (EGC 16-color mode) */</span>
<a name="l01379"></a>01379             addr = (addr &amp; 0x7FFF) + 0x20000;
<a name="l01380"></a>01380         <span class="keywordflow">else</span>
<a name="l01381"></a>01381             addr &amp;= 0x1FFFF;
<a name="l01382"></a>01382 
<a name="l01383"></a>01383         <span class="keywordflow">switch</span> (addr&gt;&gt;13) {
<a name="l01384"></a>01384             <span class="keywordflow">case</span> 0:     <span class="comment">/* A0000-A1FFF Character RAM */</span>
<a name="l01385"></a>01385                 *((AWT*)(vga.mem.linear+addr)) = val;
<a name="l01386"></a>01386                 <span class="keywordflow">return</span>;
<a name="l01387"></a>01387             <span class="keywordflow">case</span> 1:     <span class="comment">/* A2000-A3FFF Attribute RAM */</span>
<a name="l01388"></a>01388                 <span class="keywordflow">if</span> (addr &amp; 1) <span class="keywordflow">return</span>; <span class="comment">/* ignore odd bytes */</span>
<a name="l01389"></a>01389                 *((AWT*)(vga.mem.linear+addr)) = val | 0xFF00;
<a name="l01390"></a>01390                 <span class="keywordflow">return</span>;
<a name="l01391"></a>01391             <span class="keywordflow">case</span> 2:     <span class="comment">/* A4000-A5FFF Unknown ?? */</span>
<a name="l01392"></a>01392                 *((AWT*)(vga.mem.linear+addr)) = val;
<a name="l01393"></a>01393                 <span class="keywordflow">return</span>;
<a name="l01394"></a>01394             <span class="keywordflow">case</span> 3:     <span class="comment">/* A6000-A7FFF Not present */</span>
<a name="l01395"></a>01395                 <span class="keywordflow">return</span>;
<a name="l01396"></a>01396             <span class="keywordflow">default</span>:    <span class="comment">/* A8000-BFFFF G-RAM */</span>
<a name="l01397"></a>01397                 vop_offset = (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_ACCESS)) ? 0x20000 : 0;
<a name="l01398"></a>01398                 <span class="keywordflow">break</span>;
<a name="l01399"></a>01399         };
<a name="l01400"></a>01400 
<a name="l01401"></a>01401         <span class="keywordflow">switch</span> (pc98_gdc_vramop &amp; 0xF) {
<a name="l01402"></a>01402             <span class="keywordflow">case</span> 0x00:
<a name="l01403"></a>01403             <span class="keywordflow">case</span> 0x01:
<a name="l01404"></a>01404             <span class="keywordflow">case</span> 0x02:
<a name="l01405"></a>01405             <span class="keywordflow">case</span> 0x03:
<a name="l01406"></a>01406             <span class="keywordflow">case</span> 0x04:
<a name="l01407"></a>01407             <span class="keywordflow">case</span> 0x05:
<a name="l01408"></a>01408             <span class="keywordflow">case</span> 0x06:
<a name="l01409"></a>01409             <span class="keywordflow">case</span> 0x07:
<a name="l01410"></a>01410                 *((AWT*)(vga.mem.linear+addr+vop_offset)) = val;
<a name="l01411"></a>01411                 <span class="keywordflow">break</span>;
<a name="l01412"></a>01412             <span class="keywordflow">case</span> 0x08:  <span class="comment">/* TCR/TDW write tile data, no masking */</span>
<a name="l01413"></a>01413             <span class="keywordflow">case</span> 0x09:
<a name="l01414"></a>01414                 {
<a name="l01415"></a>01415                     <span class="comment">/* this writes to multiple bitplanes at once.</span>
<a name="l01416"></a>01416 <span class="comment">                     * notice that the value written has no meaning, only the tile data and memory address. */</span>
<a name="l01417"></a>01417                     addr &amp;= 0x7FFF;
<a name="l01418"></a>01418 
<a name="l01419"></a>01419                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 1)) <span class="comment">// blue channel</span>
<a name="l01420"></a>01420                         mode8_w&lt;AWT&gt;(0<span class="comment">/*plane*/</span>,addr + 0x8000 + vop_offset);
<a name="l01421"></a>01421 
<a name="l01422"></a>01422                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 2)) <span class="comment">// red channel</span>
<a name="l01423"></a>01423                         mode8_w&lt;AWT&gt;(1<span class="comment">/*plane*/</span>,addr + 0x10000 + vop_offset);
<a name="l01424"></a>01424 
<a name="l01425"></a>01425                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 4)) <span class="comment">// green channel</span>
<a name="l01426"></a>01426                         mode8_w&lt;AWT&gt;(2<span class="comment">/*plane*/</span>,addr + 0x18000 + vop_offset);
<a name="l01427"></a>01427 
<a name="l01428"></a>01428                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 8)) <span class="comment">// extended channel</span>
<a name="l01429"></a>01429                         mode8_w&lt;AWT&gt;(3<span class="comment">/*plane*/</span>,addr + 0x20000 + vop_offset);
<a name="l01430"></a>01430                 }
<a name="l01431"></a>01431                 <span class="keywordflow">break</span>;
<a name="l01432"></a>01432             <span class="keywordflow">case</span> 0x0C:  <span class="comment">/* read/modify/write from tile with masking */</span>
<a name="l01433"></a>01433             <span class="keywordflow">case</span> 0x0D:  <span class="comment">/* a lot of PC-98 games seem to rely on this for sprite rendering */</span>
<a name="l01434"></a>01434                 {
<a name="l01435"></a>01435                     <span class="keyword">const</span> AWT mask = ~val;
<a name="l01436"></a>01436 
<a name="l01437"></a>01437                     <span class="comment">/* this writes to multiple bitplanes at once */</span>
<a name="l01438"></a>01438                     addr &amp;= 0x7FFF;
<a name="l01439"></a>01439 
<a name="l01440"></a>01440                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 1)) <span class="comment">// blue channel</span>
<a name="l01441"></a>01441                         modeC_w&lt;AWT&gt;(0<span class="comment">/*plane*/</span>,addr + 0x8000 + vop_offset,mask,val);
<a name="l01442"></a>01442 
<a name="l01443"></a>01443                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 2)) <span class="comment">// red channel</span>
<a name="l01444"></a>01444                         modeC_w&lt;AWT&gt;(1<span class="comment">/*plane*/</span>,addr + 0x10000 + vop_offset,mask,val);
<a name="l01445"></a>01445 
<a name="l01446"></a>01446                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 4)) <span class="comment">// green channel</span>
<a name="l01447"></a>01447                         modeC_w&lt;AWT&gt;(2<span class="comment">/*plane*/</span>,addr + 0x18000 + vop_offset,mask,val);
<a name="l01448"></a>01448 
<a name="l01449"></a>01449                     <span class="keywordflow">if</span> (!(pc98_gdc_modereg &amp; 8)) <span class="comment">// extended channel</span>
<a name="l01450"></a>01450                         modeC_w&lt;AWT&gt;(3<span class="comment">/*plane*/</span>,addr + 0x20000 + vop_offset,mask,val);
<a name="l01451"></a>01451                 }
<a name="l01452"></a>01452                 <span class="keywordflow">break</span>;
<a name="l01453"></a>01453             <span class="keywordflow">case</span> 0x0A: <span class="comment">/* EGC write */</span>
<a name="l01454"></a>01454             <span class="keywordflow">case</span> 0x0B:
<a name="l01455"></a>01455             <span class="keywordflow">case</span> 0x0E:
<a name="l01456"></a>01456             <span class="keywordflow">case</span> 0x0F:
<a name="l01457"></a>01457                 <span class="comment">/* this reads multiple bitplanes at once */</span>
<a name="l01458"></a>01458                 modeEGC_w&lt;AWT&gt;((addr&amp;0x7FFF) + vop_offset,addr + vop_offset,val);
<a name="l01459"></a>01459                 <span class="keywordflow">break</span>;
<a name="l01460"></a>01460             <span class="keywordflow">default</span>: <span class="comment">/* Should no longer happen */</span>
<a name="l01461"></a>01461                 LOG_MSG(<span class="stringliteral">&quot;PC-98 VRAM write warning: Unsupported opmode 0x%X&quot;</span>,pc98_gdc_vramop);
<a name="l01462"></a>01462                 *((AWT*)(vga.mem.linear+addr+vop_offset)) = val;
<a name="l01463"></a>01463                 <span class="keywordflow">break</span>;
<a name="l01464"></a>01464         };
<a name="l01465"></a>01465         }
<a name="l01466"></a>01466 
<a name="l01467"></a>01467     <span class="comment">/* byte-wise */</span>
<a name="l01468"></a>01468         Bitu readb(PhysPt addr) {
<a name="l01469"></a>01469         <span class="keywordflow">return</span> readc&lt;uint8_t&gt;(addr);
<a name="l01470"></a>01470     }
<a name="l01471"></a>01471         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l01472"></a>01472         writec&lt;uint8_t&gt;(addr,(uint8_t)val);
<a name="l01473"></a>01473     }
<a name="l01474"></a>01474 
<a name="l01475"></a>01475     <span class="comment">/* word-wise.</span>
<a name="l01476"></a>01476 <span class="comment">     * in the style of the 8086, non-word-aligned I/O is split into byte I/O */</span>
<a name="l01477"></a>01477         Bitu readw(PhysPt addr) {
<a name="l01478"></a>01478         <span class="keywordflow">if</span> (!(addr &amp; 1)) <span class="comment">/* if WORD aligned */</span>
<a name="l01479"></a>01479             <span class="keywordflow">return</span> readc&lt;uint16_t&gt;(addr);
<a name="l01480"></a>01480         <span class="keywordflow">else</span> {
<a name="l01481"></a>01481             <span class="keywordflow">return</span>   (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)readc&lt;uint8_t&gt;(addr+0U) +
<a name="l01482"></a>01482                     ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)readc&lt;uint8_t&gt;(addr+1U) &lt;&lt; 8u);
<a name="l01483"></a>01483         }
<a name="l01484"></a>01484     }
<a name="l01485"></a>01485         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l01486"></a>01486         <span class="keywordflow">if</span> (!(addr &amp; 1)) <span class="comment">/* if WORD aligned */</span>
<a name="l01487"></a>01487             writec&lt;uint16_t&gt;(addr,(uint16_t)val);
<a name="l01488"></a>01488         <span class="keywordflow">else</span> {
<a name="l01489"></a>01489             writec&lt;uint8_t&gt;(addr+0,(uint8_t)val);
<a name="l01490"></a>01490             writec&lt;uint8_t&gt;(addr+1,(uint8_t)(val &gt;&gt; 8U));
<a name="l01491"></a>01491         }
<a name="l01492"></a>01492     }
<a name="l01493"></a>01493 };
<a name="l01494"></a>01494 
<a name="l01495"></a><a class="code" href="classVGA__Map__Handler.html">01495</a> <span class="keyword">class </span><a class="code" href="classVGA__Map__Handler.html">VGA_Map_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01496"></a>01496 <span class="keyword">public</span>:
<a name="l01497"></a>01497         <a class="code" href="classVGA__Map__Handler.html">VGA_Map_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE|PFLAG_NOCODE) {}
<a name="l01498"></a>01498         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01499"></a>01499                 phys_page-=vgapages.base;
<a name="l01500"></a>01500                 <span class="keywordflow">return</span> &amp;vga.mem.linear[CHECKED3(vga.svga.bank_read_full+phys_page*4096)];
<a name="l01501"></a>01501         }
<a name="l01502"></a>01502         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01503"></a>01503                 phys_page-=vgapages.base;
<a name="l01504"></a>01504                 <span class="keywordflow">return</span> &amp;vga.mem.linear[CHECKED3(vga.svga.bank_write_full+phys_page*4096)];
<a name="l01505"></a>01505         }
<a name="l01506"></a>01506 };
<a name="l01507"></a>01507 
<a name="l01508"></a><a class="code" href="classVGA__Slow__CGA__Handler.html">01508</a> <span class="keyword">class </span><a class="code" href="classVGA__Slow__CGA__Handler.html">VGA_Slow_CGA_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01509"></a>01509 <span class="keyword">public</span>:
<a name="l01510"></a>01510         <a class="code" href="classVGA__Slow__CGA__Handler.html">VGA_Slow_CGA_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01511"></a>01511         <span class="keywordtype">void</span> delay() {
<a name="l01512"></a>01512                 Bits delaycyc = CPU_CycleMax/((Bit32u)(1024/2.80)); 
<a name="l01513"></a>01513                 <span class="keywordflow">if</span>(GCC_UNLIKELY(CPU_Cycles &lt; 3*delaycyc)) delaycyc=0;
<a name="l01514"></a>01514                 CPU_Cycles -= delaycyc;
<a name="l01515"></a>01515                 CPU_IODelayRemoved += delaycyc;
<a name="l01516"></a>01516         }
<a name="l01517"></a>01517 
<a name="l01518"></a>01518         Bitu readb(PhysPt addr) {
<a name="l01519"></a>01519                 delay();
<a name="l01520"></a>01520                 <span class="keywordflow">return</span> vga.tandy.mem_base[addr - 0xb8000];
<a name="l01521"></a>01521         }
<a name="l01522"></a>01522         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val){
<a name="l01523"></a>01523                 delay();
<a name="l01524"></a>01524                 vga.tandy.mem_base[addr - 0xb8000] = (Bit8u) val;
<a name="l01525"></a>01525         }
<a name="l01526"></a>01526         
<a name="l01527"></a>01527 };
<a name="l01528"></a>01528 
<a name="l01529"></a><a class="code" href="classVGA__LFB__Handler.html">01529</a> <span class="keyword">class </span><a class="code" href="classVGA__LFB__Handler.html">VGA_LFB_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01530"></a>01530 <span class="keyword">public</span>:
<a name="l01531"></a>01531         <a class="code" href="classVGA__LFB__Handler.html">VGA_LFB_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE|PFLAG_NOCODE) {}
<a name="l01532"></a>01532         HostPt GetHostReadPt( Bitu phys_page ) {
<a name="l01533"></a>01533                 phys_page -= vga.lfb.page;
<a name="l01534"></a>01534                 phys_page &amp;= (vga.mem.memsize &gt;&gt; 12) - 1;
<a name="l01535"></a>01535                 <span class="keywordflow">return</span> &amp;vga.mem.linear[CHECKED3(phys_page * 4096)];
<a name="l01536"></a>01536         }
<a name="l01537"></a>01537         HostPt GetHostWritePt( Bitu phys_page ) {
<a name="l01538"></a>01538                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01539"></a>01539         }
<a name="l01540"></a>01540 };
<a name="l01541"></a>01541 
<a name="l01542"></a>01542 <span class="keyword">extern</span> <span class="keywordtype">void</span> XGA_Write(Bitu port, Bitu val, Bitu len);
<a name="l01543"></a>01543 <span class="keyword">extern</span> Bitu XGA_Read(Bitu port, Bitu len);
<a name="l01544"></a>01544 
<a name="l01545"></a><a class="code" href="classVGA__MMIO__Handler.html">01545</a> <span class="keyword">class </span><a class="code" href="classVGA__MMIO__Handler.html">VGA_MMIO_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01546"></a>01546 <span class="keyword">public</span>:
<a name="l01547"></a>01547         <a class="code" href="classVGA__MMIO__Handler.html">VGA_MMIO_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01548"></a>01548         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l01549"></a>01549                 VGAMEM_USEC_write_delay();
<a name="l01550"></a>01550                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01551"></a>01551                 XGA_Write(port, val, 1);
<a name="l01552"></a>01552         }
<a name="l01553"></a>01553         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l01554"></a>01554                 VGAMEM_USEC_write_delay();
<a name="l01555"></a>01555                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01556"></a>01556                 XGA_Write(port, val, 2);
<a name="l01557"></a>01557         }
<a name="l01558"></a>01558         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l01559"></a>01559                 VGAMEM_USEC_write_delay();
<a name="l01560"></a>01560                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01561"></a>01561                 XGA_Write(port, val, 4);
<a name="l01562"></a>01562         }
<a name="l01563"></a>01563 
<a name="l01564"></a>01564         Bitu readb(PhysPt addr) {
<a name="l01565"></a>01565                 VGAMEM_USEC_read_delay();
<a name="l01566"></a>01566                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01567"></a>01567                 <span class="keywordflow">return</span> XGA_Read(port, 1);
<a name="l01568"></a>01568         }
<a name="l01569"></a>01569         Bitu readw(PhysPt addr) {
<a name="l01570"></a>01570                 VGAMEM_USEC_read_delay();
<a name="l01571"></a>01571                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01572"></a>01572                 <span class="keywordflow">return</span> XGA_Read(port, 2);
<a name="l01573"></a>01573         }
<a name="l01574"></a>01574         Bitu readd(PhysPt addr) {
<a name="l01575"></a>01575                 VGAMEM_USEC_read_delay();
<a name="l01576"></a>01576                 Bitu port = PAGING_GetPhysicalAddress(addr) &amp; 0xffff;
<a name="l01577"></a>01577                 <span class="keywordflow">return</span> XGA_Read(port, 4);
<a name="l01578"></a>01578         }
<a name="l01579"></a>01579 };
<a name="l01580"></a>01580 
<a name="l01581"></a><a class="code" href="classVGA__TANDY__PageHandler.html">01581</a> <span class="keyword">class </span><a class="code" href="classVGA__TANDY__PageHandler.html">VGA_TANDY_PageHandler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01582"></a>01582 <span class="keyword">public</span>:
<a name="l01583"></a>01583         <a class="code" href="classVGA__TANDY__PageHandler.html">VGA_TANDY_PageHandler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE) {}
<a name="l01584"></a>01584         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01585"></a>01585                 <span class="comment">// Odd banks are limited to 16kB and repeated</span>
<a name="l01586"></a>01586                 <span class="keywordflow">if</span> (vga.tandy.mem_bank &amp; 1) 
<a name="l01587"></a>01587                         phys_page&amp;=0x03;
<a name="l01588"></a>01588                 <span class="keywordflow">else</span> 
<a name="l01589"></a>01589                         phys_page&amp;=0x07;
<a name="l01590"></a>01590                 <span class="keywordflow">return</span> vga.tandy.mem_base + (phys_page * 4096);
<a name="l01591"></a>01591         }
<a name="l01592"></a>01592         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01593"></a>01593                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01594"></a>01594         }
<a name="l01595"></a>01595 };
<a name="l01596"></a>01596 
<a name="l01597"></a>01597 
<a name="l01598"></a><a class="code" href="classVGA__PCJR__Handler.html">01598</a> <span class="keyword">class </span><a class="code" href="classVGA__PCJR__Handler.html">VGA_PCJR_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01599"></a>01599 <span class="keyword">public</span>:
<a name="l01600"></a>01600         <a class="code" href="classVGA__PCJR__Handler.html">VGA_PCJR_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_READABLE|PFLAG_WRITEABLE) {}
<a name="l01601"></a>01601         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01602"></a>01602                 phys_page-=0xb8;
<a name="l01603"></a>01603                 <span class="comment">// The 16kB map area is repeated in the 32kB range</span>
<a name="l01604"></a>01604                 <span class="comment">// On CGA CPU A14 is not decoded so it repeats there too</span>
<a name="l01605"></a>01605                 phys_page&amp;=0x03;
<a name="l01606"></a>01606                 <span class="keywordflow">return</span> vga.tandy.mem_base + (phys_page * 4096);
<a name="l01607"></a>01607         }
<a name="l01608"></a>01608         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01609"></a>01609                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01610"></a>01610         }
<a name="l01611"></a>01611 };
<a name="l01612"></a>01612 
<a name="l01613"></a><a class="code" href="classVGA__AMS__Handler.html">01613</a> <span class="keyword">class </span><a class="code" href="classVGA__AMS__Handler.html">VGA_AMS_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01614"></a>01614 <span class="keyword">public</span>:
<a name="l01615"></a>01615         <span class="keyword">template</span>&lt; <span class="keywordtype">bool</span> wrapping&gt;
<a name="l01616"></a>01616         <span class="keywordtype">void</span> writeHandler(PhysPt start, Bit8u val) {
<a name="l01617"></a>01617                 vga.tandy.mem_base[ start ] = val;
<a name="l01618"></a>01618 <span class="preprocessor">#ifdef DIJDIJD</span>
<a name="l01619"></a>01619 <span class="preprocessor"></span>                Bit32u data=ModeOperation(val);
<a name="l01620"></a>01620                 <span class="comment">/* Update video memory and the pixel buffer */</span>
<a name="l01621"></a>01621                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> pixels;
<a name="l01622"></a>01622                 pixels.d=((Bit32u*)vga.mem.linear)[start];
<a name="l01623"></a>01623                 pixels.d&amp;=vga.config.full_not_map_mask;
<a name="l01624"></a>01624                 pixels.d|=(data &amp; vga.config.full_map_mask);
<a name="l01625"></a>01625                 ((Bit32u*)vga.mem.linear)[start]=pixels.d;
<a name="l01626"></a>01626                 Bit8u * write_pixels=&amp;vga.mem.linear[VGA_CACHE_OFFSET+(start&lt;&lt;3)];
<a name="l01627"></a>01627 
<a name="l01628"></a>01628                 Bit32u colors0_3, colors4_7;
<a name="l01629"></a>01629                 <a class="code" href="unionVGA__Latch.html">VGA_Latch</a> temp;temp.d=(pixels.d&gt;&gt;4) &amp; 0x0f0f0f0f;
<a name="l01630"></a>01630                         colors0_3 = 
<a name="l01631"></a>01631                         Expand16Table[0][temp.b[0]] |
<a name="l01632"></a>01632                         Expand16Table[1][temp.b[1]] |
<a name="l01633"></a>01633                         Expand16Table[2][temp.b[2]] |
<a name="l01634"></a>01634                         Expand16Table[3][temp.b[3]];
<a name="l01635"></a>01635                 *(Bit32u *)write_pixels=colors0_3;
<a name="l01636"></a>01636                 temp.d=pixels.d &amp; 0x0f0f0f0f;
<a name="l01637"></a>01637                 colors4_7 = 
<a name="l01638"></a>01638                         Expand16Table[0][temp.b[0]] |
<a name="l01639"></a>01639                         Expand16Table[1][temp.b[1]] |
<a name="l01640"></a>01640                         Expand16Table[2][temp.b[2]] |
<a name="l01641"></a>01641                         Expand16Table[3][temp.b[3]];
<a name="l01642"></a>01642                 *(Bit32u *)(write_pixels+4)=colors4_7;
<a name="l01643"></a>01643                 <span class="keywordflow">if</span> (wrapping &amp;&amp; GCC_UNLIKELY( start &lt; 512)) {
<a name="l01644"></a>01644                         *(Bit32u *)(write_pixels+512*1024)=colors0_3;
<a name="l01645"></a>01645                         *(Bit32u *)(write_pixels+512*1024+4)=colors4_7;
<a name="l01646"></a>01646                 }
<a name="l01647"></a>01647 <span class="preprocessor">#endif</span>
<a name="l01648"></a>01648 <span class="preprocessor"></span>        }
<a name="l01649"></a>01649 <span class="comment">//      template&lt; bool wrapping&gt;</span>
<a name="l01650"></a>01650         Bit8u readHandler(PhysPt start) {
<a name="l01651"></a>01651                 <span class="keywordflow">return</span> vga.tandy.mem_base[ start ];
<a name="l01652"></a>01652         }
<a name="l01653"></a>01653 
<a name="l01654"></a>01654 <span class="keyword">public</span>:
<a name="l01655"></a>01655         <a class="code" href="classVGA__AMS__Handler.html">VGA_AMS_Handler</a>() {
<a name="l01656"></a>01656                 <span class="comment">//flags=PFLAG_READABLE|PFLAG_WRITEABLE;</span>
<a name="l01657"></a>01657                 flags=PFLAG_NOCODE;
<a name="l01658"></a>01658         }
<a name="l01659"></a>01659         <span class="keyword">inline</span> PhysPt wrAddr( PhysPt addr )
<a name="l01660"></a>01660         {
<a name="l01661"></a>01661                 <span class="keywordflow">if</span>( vga.mode != M_AMSTRAD )
<a name="l01662"></a>01662                 {
<a name="l01663"></a>01663                         addr -= 0xb8000;
<a name="l01664"></a>01664                         Bitu phys_page = addr &gt;&gt; 12;
<a name="l01665"></a>01665                         <span class="comment">//test for a unaliged bank, then replicate 2x16kb</span>
<a name="l01666"></a>01666                         <span class="keywordflow">if</span> (vga.tandy.mem_bank &amp; 1) 
<a name="l01667"></a>01667                                 phys_page&amp;=0x03;
<a name="l01668"></a>01668                         <span class="keywordflow">return</span> ( phys_page * 4096 ) + ( addr &amp; 0x0FFF );
<a name="l01669"></a>01669                 }
<a name="l01670"></a>01670                 <span class="keywordflow">return</span> ( (PAGING_GetPhysicalAddress(addr) &amp; 0xffff) - 0x8000 ) &amp; ( 32*1024-1 );
<a name="l01671"></a>01671         }
<a name="l01672"></a>01672 
<a name="l01673"></a>01673         <span class="keywordtype">void</span> writeb(PhysPt addr,Bitu val) {
<a name="l01674"></a>01674                 VGAMEM_USEC_write_delay();
<a name="l01675"></a>01675                 addr = wrAddr( addr );
<a name="l01676"></a>01676                 Bitu plane = vga.mode==M_AMSTRAD ? vga.amstrad.write_plane : 0x01; <span class="comment">// 0x0F?</span>
<a name="l01677"></a>01677                 <span class="keywordflow">if</span>( plane &amp; 0x08 ) writeHandler&lt;false&gt;(addr+49152,(Bit8u)(val &gt;&gt; 0));
<a name="l01678"></a>01678                 <span class="keywordflow">if</span>( plane &amp; 0x04 ) writeHandler&lt;false&gt;(addr+32768,(Bit8u)(val &gt;&gt; 0));
<a name="l01679"></a>01679                 <span class="keywordflow">if</span>( plane &amp; 0x02 ) writeHandler&lt;false&gt;(addr+16384,(Bit8u)(val &gt;&gt; 0));
<a name="l01680"></a>01680                 <span class="keywordflow">if</span>( plane &amp; 0x01 ) writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01681"></a>01681         }
<a name="l01682"></a>01682         <span class="keywordtype">void</span> writew(PhysPt addr,Bitu val) {
<a name="l01683"></a>01683                 VGAMEM_USEC_write_delay();
<a name="l01684"></a>01684                 addr = wrAddr( addr );
<a name="l01685"></a>01685                 Bitu plane = vga.mode==M_AMSTRAD ? vga.amstrad.write_plane : 0x01; <span class="comment">// 0x0F?</span>
<a name="l01686"></a>01686                 <span class="keywordflow">if</span>( plane &amp; 0x01 )
<a name="l01687"></a>01687                 {
<a name="l01688"></a>01688                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01689"></a>01689                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01690"></a>01690                 }
<a name="l01691"></a>01691                 addr += 16384;
<a name="l01692"></a>01692                 <span class="keywordflow">if</span>( plane &amp; 0x02 )
<a name="l01693"></a>01693                 {
<a name="l01694"></a>01694                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01695"></a>01695                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01696"></a>01696                 }
<a name="l01697"></a>01697                 addr += 16384;
<a name="l01698"></a>01698                 <span class="keywordflow">if</span>( plane &amp; 0x04 )
<a name="l01699"></a>01699                 {
<a name="l01700"></a>01700                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01701"></a>01701                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01702"></a>01702                 }
<a name="l01703"></a>01703                 addr += 16384;
<a name="l01704"></a>01704                 <span class="keywordflow">if</span>( plane &amp; 0x08 )
<a name="l01705"></a>01705                 {
<a name="l01706"></a>01706                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01707"></a>01707                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01708"></a>01708                 }
<a name="l01709"></a>01709 
<a name="l01710"></a>01710         }
<a name="l01711"></a>01711         <span class="keywordtype">void</span> writed(PhysPt addr,Bitu val) {
<a name="l01712"></a>01712                 VGAMEM_USEC_write_delay();
<a name="l01713"></a>01713                 addr = wrAddr( addr );
<a name="l01714"></a>01714                 Bitu plane = vga.mode==M_AMSTRAD ? vga.amstrad.write_plane : 0x01; <span class="comment">// 0x0F?</span>
<a name="l01715"></a>01715                 <span class="keywordflow">if</span>( plane &amp; 0x01 )
<a name="l01716"></a>01716                 {
<a name="l01717"></a>01717                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01718"></a>01718                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01719"></a>01719                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l01720"></a>01720                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l01721"></a>01721                 }
<a name="l01722"></a>01722                 addr += 16384;
<a name="l01723"></a>01723                 <span class="keywordflow">if</span>( plane &amp; 0x02 )
<a name="l01724"></a>01724                 {
<a name="l01725"></a>01725                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01726"></a>01726                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01727"></a>01727                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l01728"></a>01728                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l01729"></a>01729                 }
<a name="l01730"></a>01730                 addr += 16384;
<a name="l01731"></a>01731                 <span class="keywordflow">if</span>( plane &amp; 0x04 )
<a name="l01732"></a>01732                 {
<a name="l01733"></a>01733                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01734"></a>01734                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01735"></a>01735                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l01736"></a>01736                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l01737"></a>01737                 }
<a name="l01738"></a>01738                 addr += 16384;
<a name="l01739"></a>01739                 <span class="keywordflow">if</span>( plane &amp; 0x08 )
<a name="l01740"></a>01740                 {
<a name="l01741"></a>01741                         writeHandler&lt;false&gt;(addr+0,(Bit8u)(val &gt;&gt; 0));
<a name="l01742"></a>01742                         writeHandler&lt;false&gt;(addr+1,(Bit8u)(val &gt;&gt; 8));
<a name="l01743"></a>01743                         writeHandler&lt;false&gt;(addr+2,(Bit8u)(val &gt;&gt; 16));
<a name="l01744"></a>01744                         writeHandler&lt;false&gt;(addr+3,(Bit8u)(val &gt;&gt; 24));
<a name="l01745"></a>01745                 }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747         }
<a name="l01748"></a>01748         Bitu readb(PhysPt addr) {
<a name="l01749"></a>01749                 VGAMEM_USEC_read_delay();
<a name="l01750"></a>01750                 addr = wrAddr( addr ) + ( vga.amstrad.read_plane * 16384u );
<a name="l01751"></a>01751                 addr &amp;= (64u*1024u-1u);
<a name="l01752"></a>01752                 <span class="keywordflow">return</span> readHandler(addr);
<a name="l01753"></a>01753         }
<a name="l01754"></a>01754         Bitu readw(PhysPt addr) {
<a name="l01755"></a>01755                 VGAMEM_USEC_read_delay();
<a name="l01756"></a>01756                 addr = wrAddr( addr ) + ( vga.amstrad.read_plane * 16384u );
<a name="l01757"></a>01757                 addr &amp;= (64u*1024u-1u);
<a name="l01758"></a>01758                 <span class="keywordflow">return</span> 
<a name="l01759"></a>01759                         ((Bitu)readHandler(addr+0) &lt;&lt; 0u) |
<a name="l01760"></a>01760                         ((Bitu)readHandler(addr+1) &lt;&lt; 8u);
<a name="l01761"></a>01761         }
<a name="l01762"></a>01762         Bitu readd(PhysPt addr) {
<a name="l01763"></a>01763                 VGAMEM_USEC_read_delay();
<a name="l01764"></a>01764                 addr = wrAddr( addr ) + ( vga.amstrad.read_plane * 16384u );
<a name="l01765"></a>01765                 addr &amp;= (64u*1024u-1u);
<a name="l01766"></a>01766                 <span class="keywordflow">return</span> 
<a name="l01767"></a>01767                         ((Bitu)readHandler(addr+0) &lt;&lt; 0u)  |
<a name="l01768"></a>01768                         ((Bitu)readHandler(addr+1) &lt;&lt; 8u)  |
<a name="l01769"></a>01769                         ((Bitu)readHandler(addr+2) &lt;&lt; 16u) |
<a name="l01770"></a>01770                         ((Bitu)readHandler(addr+3) &lt;&lt; 24u);
<a name="l01771"></a>01771         }
<a name="l01772"></a>01772 
<a name="l01773"></a>01773 <span class="comment">/*</span>
<a name="l01774"></a>01774 <span class="comment">        HostPt GetHostReadPt(Bitu phys_page)</span>
<a name="l01775"></a>01775 <span class="comment">        {</span>
<a name="l01776"></a>01776 <span class="comment">                if( vga.mode!=M_AMSTRAD )</span>
<a name="l01777"></a>01777 <span class="comment">                {</span>
<a name="l01778"></a>01778 <span class="comment">                        phys_page-=0xb8;</span>
<a name="l01779"></a>01779 <span class="comment">                        //test for a unaliged bank, then replicate 2x16kb</span>
<a name="l01780"></a>01780 <span class="comment">                        if (vga.tandy.mem_bank &amp; 1) </span>
<a name="l01781"></a>01781 <span class="comment">                                phys_page&amp;=0x03;</span>
<a name="l01782"></a>01782 <span class="comment">                        return vga.tandy.mem_base + (phys_page * 4096);</span>
<a name="l01783"></a>01783 <span class="comment">                }</span>
<a name="l01784"></a>01784 <span class="comment">                phys_page-=0xb8;</span>
<a name="l01785"></a>01785 <span class="comment">                return vga.tandy.mem_base + (phys_page*4096) + (vga.amstrad.read_plane * 16384) ;</span>
<a name="l01786"></a>01786 <span class="comment">        }</span>
<a name="l01787"></a>01787 <span class="comment">*/</span>
<a name="l01788"></a>01788 <span class="comment">/*</span>
<a name="l01789"></a>01789 <span class="comment">        HostPt GetHostWritePt(Bitu phys_page) {</span>
<a name="l01790"></a>01790 <span class="comment">                return GetHostReadPt( phys_page );</span>
<a name="l01791"></a>01791 <span class="comment">        }</span>
<a name="l01792"></a>01792 <span class="comment">*/</span>
<a name="l01793"></a>01793 };
<a name="l01794"></a>01794 
<a name="l01795"></a><a class="code" href="classVGA__HERC__Handler.html">01795</a> <span class="keyword">class </span><a class="code" href="classVGA__HERC__Handler.html">VGA_HERC_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01796"></a>01796 <span class="keyword">public</span>:
<a name="l01797"></a>01797         <a class="code" href="classVGA__HERC__Handler.html">VGA_HERC_Handler</a>() {
<a name="l01798"></a>01798                 flags=PFLAG_READABLE|PFLAG_WRITEABLE;
<a name="l01799"></a>01799         }
<a name="l01800"></a>01800         HostPt GetHostReadPt(Bitu phys_page) {
<a name="l01801"></a>01801         (void)phys_page;<span class="comment">//UNUSED</span>
<a name="l01802"></a>01802                 <span class="comment">// The 4kB map area is repeated in the 32kB range</span>
<a name="l01803"></a>01803                 <span class="keywordflow">return</span> &amp;vga.mem.linear[0];
<a name="l01804"></a>01804         }
<a name="l01805"></a>01805         HostPt GetHostWritePt(Bitu phys_page) {
<a name="l01806"></a>01806                 <span class="keywordflow">return</span> GetHostReadPt( phys_page );
<a name="l01807"></a>01807         }
<a name="l01808"></a>01808 };
<a name="l01809"></a>01809 
<a name="l01810"></a><a class="code" href="classVGA__Empty__Handler.html">01810</a> <span class="keyword">class </span><a class="code" href="classVGA__Empty__Handler.html">VGA_Empty_Handler</a> : <span class="keyword">public</span> <a class="code" href="classPageHandler.html">PageHandler</a> {
<a name="l01811"></a>01811 <span class="keyword">public</span>:
<a name="l01812"></a>01812         <a class="code" href="classVGA__Empty__Handler.html">VGA_Empty_Handler</a>() : <a class="code" href="classPageHandler.html">PageHandler</a>(PFLAG_NOCODE) {}
<a name="l01813"></a>01813         Bitu readb(PhysPt <span class="comment">/*addr*/</span>) {
<a name="l01814"></a>01814 <span class="comment">//              LOG(LOG_VGA, LOG_NORMAL ) ( &quot;Read from empty memory space at %x&quot;, addr );</span>
<a name="l01815"></a>01815                 <span class="keywordflow">return</span> 0xff;
<a name="l01816"></a>01816         } 
<a name="l01817"></a>01817         <span class="keywordtype">void</span> writeb(PhysPt <span class="comment">/*addr*/</span>,Bitu <span class="comment">/*val*/</span>) {
<a name="l01818"></a>01818 <span class="comment">//              LOG(LOG_VGA, LOG_NORMAL ) ( &quot;Write %x to empty memory space at %x&quot;, val, addr );</span>
<a name="l01819"></a>01819         }
<a name="l01820"></a>01820 };
<a name="l01821"></a>01821 
<a name="l01822"></a>01822 <span class="keyword">static</span> <span class="keyword">struct </span>vg {
<a name="l01823"></a>01823         <a class="code" href="classVGA__Map__Handler.html">VGA_Map_Handler</a>                         map;
<a name="l01824"></a>01824         <a class="code" href="classVGA__Slow__CGA__Handler.html">VGA_Slow_CGA_Handler</a>            slow;
<a name="l01825"></a>01825 <span class="comment">//      VGA_TEXT_PageHandler            text;</span>
<a name="l01826"></a>01826         <a class="code" href="classVGA__CGATEXT__PageHandler.html">VGA_CGATEXT_PageHandler</a>         cgatext;
<a name="l01827"></a>01827         <a class="code" href="classVGA__TANDY__PageHandler.html">VGA_TANDY_PageHandler</a>           tandy;
<a name="l01828"></a>01828 <span class="comment">//      VGA_ChainedEGA_Handler          cega;</span>
<a name="l01829"></a>01829 <span class="comment">//      VGA_ChainedVGA_Handler          cvga;</span>
<a name="l01830"></a>01830         <a class="code" href="classVGA__ChainedVGA__Slow__Handler.html">VGA_ChainedVGA_Slow_Handler</a>     cvga_slow;
<a name="l01831"></a>01831 <span class="comment">//      VGA_ET4000_ChainedVGA_Handler           cvga_et4000;</span>
<a name="l01832"></a>01832         <a class="code" href="classVGA__ET4000__ChainedVGA__Slow__Handler.html">VGA_ET4000_ChainedVGA_Slow_Handler</a>      cvga_et4000_slow;
<a name="l01833"></a>01833 <span class="comment">//      VGA_UnchainedEGA_Handler        uega;</span>
<a name="l01834"></a>01834         <a class="code" href="classVGA__UnchainedVGA__Handler.html">VGA_UnchainedVGA_Handler</a>        uvga;
<a name="l01835"></a>01835         <a class="code" href="classVGA__PCJR__Handler.html">VGA_PCJR_Handler</a>                        pcjr;
<a name="l01836"></a>01836         <a class="code" href="classVGA__HERC__Handler.html">VGA_HERC_Handler</a>                        herc;
<a name="l01837"></a>01837 <span class="comment">//      VGA_LIN4_Handler                        lin4;</span>
<a name="l01838"></a>01838         <a class="code" href="classVGA__LFB__Handler.html">VGA_LFB_Handler</a>                         lfb;
<a name="l01839"></a>01839         <a class="code" href="classVGA__MMIO__Handler.html">VGA_MMIO_Handler</a>                        mmio;
<a name="l01840"></a>01840         <a class="code" href="classVGA__AMS__Handler.html">VGA_AMS_Handler</a>                         ams;
<a name="l01841"></a>01841     <a class="code" href="classVGA__PC98__PageHandler.html">VGA_PC98_PageHandler</a>        pc98;
<a name="l01842"></a>01842         <a class="code" href="classVGA__Empty__Handler.html">VGA_Empty_Handler</a>                       empty;
<a name="l01843"></a>01843 } vgaph;
<a name="l01844"></a>01844 
<a name="l01845"></a>01845 <span class="keywordtype">void</span> VGA_ChangedBank(<span class="keywordtype">void</span>) {
<a name="l01846"></a>01846         VGA_SetupHandlers();
<a name="l01847"></a>01847 }
<a name="l01848"></a>01848 
<a name="l01849"></a>01849 <span class="keywordtype">void</span> MEM_ResetPageHandler_Unmapped(Bitu phys_page, Bitu pages);
<a name="l01850"></a>01850 <span class="keywordtype">void</span> MEM_ResetPageHandler_RAM(Bitu phys_page, Bitu pages);
<a name="l01851"></a>01851 
<a name="l01852"></a>01852 <span class="keywordtype">void</span> VGA_SetupHandlers(<span class="keywordtype">void</span>) {
<a name="l01853"></a>01853         vga.svga.bank_read_full = vga.svga.bank_read*vga.svga.bank_size;
<a name="l01854"></a>01854         vga.svga.bank_write_full = vga.svga.bank_write*vga.svga.bank_size;
<a name="l01855"></a>01855 
<a name="l01856"></a>01856         <a class="code" href="classPageHandler.html">PageHandler</a> *newHandler;
<a name="l01857"></a>01857         <span class="keywordflow">switch</span> (machine) {
<a name="l01858"></a>01858         <span class="keywordflow">case</span> MCH_CGA:
<a name="l01859"></a>01859                 <span class="keywordflow">if</span> (enableCGASnow &amp;&amp; (vga.mode == M_TEXT || vga.mode == M_TANDY_TEXT))
<a name="l01860"></a>01860                         MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.cgatext );
<a name="l01861"></a>01861                 <span class="keywordflow">else</span>
<a name="l01862"></a>01862                         MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.slow );
<a name="l01863"></a>01863                 <span class="keywordflow">goto</span> range_done;
<a name="l01864"></a>01864         <span class="keywordflow">case</span> MCH_PCJR:
<a name="l01865"></a>01865                 MEM_SetPageHandler( VGA_PAGE_B8, 8, &amp;vgaph.pcjr );
<a name="l01866"></a>01866                 <span class="keywordflow">goto</span> range_done;
<a name="l01867"></a>01867         <span class="keywordflow">case</span> MCH_HERC:
<a name="l01868"></a>01868                 vgapages.base=VGA_PAGE_B0;
<a name="l01869"></a>01869                 <span class="comment">/* NTS: Implemented according to [http://www.seasip.info/VintagePC/hercplus.html#regs] */</span>
<a name="l01870"></a>01870                 <span class="keywordflow">if</span> (vga.herc.enable_bits &amp; 0x2) { <span class="comment">/* bit 1: page in upper 32KB */</span>
<a name="l01871"></a>01871                         vgapages.mask=0xffff;
<a name="l01872"></a>01872                         <span class="comment">/* NTS: I don&#39;t know what Hercules graphics cards do if you set bit 1 but not bit 0.</span>
<a name="l01873"></a>01873 <span class="comment">                         *      For the time being, I&#39;m assuming that they respond to 0xB8000+ because of bit 1</span>
<a name="l01874"></a>01874 <span class="comment">                         *      but only map to the first 4KB because of bit 0. Basically, a configuration no</span>
<a name="l01875"></a>01875 <span class="comment">                         *      software would actually use. */</span>
<a name="l01876"></a>01876                         <span class="keywordflow">if</span> (vga.herc.enable_bits &amp; 0x1) <span class="comment">/* allow graphics and enable 0xB1000-0xB7FFF */</span>
<a name="l01877"></a>01877                                 MEM_SetPageHandler(VGA_PAGE_B0,16,&amp;vgaph.map);
<a name="l01878"></a>01878                         <span class="keywordflow">else</span>
<a name="l01879"></a>01879                                 MEM_SetPageHandler(VGA_PAGE_B0,16,&amp;vgaph.herc);
<a name="l01880"></a>01880                 } <span class="keywordflow">else</span> {
<a name="l01881"></a>01881                         vgapages.mask=0x7fff;
<a name="l01882"></a>01882                         <span class="comment">// With hercules in 32kB mode it leaves a memory hole on 0xb800</span>
<a name="l01883"></a>01883                         <span class="comment">// and has MDA-compatible address wrapping when graphics are disabled</span>
<a name="l01884"></a>01884                         <span class="keywordflow">if</span> (vga.herc.enable_bits &amp; 0x1)
<a name="l01885"></a>01885                                 MEM_SetPageHandler(VGA_PAGE_B0,8,&amp;vgaph.map);
<a name="l01886"></a>01886                         <span class="keywordflow">else</span>
<a name="l01887"></a>01887                                 MEM_SetPageHandler(VGA_PAGE_B0,8,&amp;vgaph.herc);
<a name="l01888"></a>01888                         MEM_SetPageHandler(VGA_PAGE_B8,8,&amp;vgaph.empty);
<a name="l01889"></a>01889                 }
<a name="l01890"></a>01890                 <span class="keywordflow">goto</span> range_done;
<a name="l01891"></a>01891         <span class="keywordflow">case</span> MCH_TANDY:
<a name="l01892"></a>01892                 <span class="comment">/* Always map 0xa000 - 0xbfff, might overwrite 0xb800 */</span>
<a name="l01893"></a>01893                 vgapages.base=VGA_PAGE_A0;
<a name="l01894"></a>01894                 vgapages.mask=0x1ffff;
<a name="l01895"></a>01895                 MEM_SetPageHandler(VGA_PAGE_A0, 32, &amp;vgaph.map );
<a name="l01896"></a>01896                 <span class="keywordflow">if</span> ( vga.tandy.extended_ram &amp; 1 ) {
<a name="l01897"></a>01897                         <span class="comment">//You seem to be able to also map different 64kb banks, but have to figure that out</span>
<a name="l01898"></a>01898                         <span class="comment">//This seems to work so far though</span>
<a name="l01899"></a>01899                         vga.tandy.draw_base = vga.mem.linear;
<a name="l01900"></a>01900                         vga.tandy.mem_base = vga.mem.linear;
<a name="l01901"></a>01901                 } <span class="keywordflow">else</span> {
<a name="l01902"></a>01902                         vga.tandy.draw_base = TANDY_VIDBASE( vga.tandy.draw_bank * 16 * 1024);
<a name="l01903"></a>01903                         vga.tandy.mem_base = TANDY_VIDBASE( vga.tandy.mem_bank * 16 * 1024);
<a name="l01904"></a>01904                         MEM_SetPageHandler( 0xb8, 8, &amp;vgaph.tandy );
<a name="l01905"></a>01905                 }
<a name="l01906"></a>01906                 <span class="keywordflow">goto</span> range_done;
<a name="l01907"></a>01907 <span class="comment">//              MEM_SetPageHandler(vga.tandy.mem_bank&lt;&lt;2,vga.tandy.is_32k_mode ? 0x08 : 0x04,range_handler);</span>
<a name="l01908"></a>01908         <span class="keywordflow">case</span> MCH_AMSTRAD: <span class="comment">// Memory handler.</span>
<a name="l01909"></a>01909                 MEM_SetPageHandler( 0xb8, 8, &amp;vgaph.ams );
<a name="l01910"></a>01910                 <span class="keywordflow">goto</span> range_done;
<a name="l01911"></a>01911         <span class="keywordflow">case</span> EGAVGA_ARCH_CASE:
<a name="l01912"></a>01912     <span class="keywordflow">case</span> PC98_ARCH_CASE:
<a name="l01913"></a>01913                 <span class="keywordflow">break</span>;
<a name="l01914"></a>01914         <span class="keywordflow">default</span>:
<a name="l01915"></a>01915                 LOG_MSG(<span class="stringliteral">&quot;Illegal machine type %d&quot;</span>, machine );
<a name="l01916"></a>01916                 <span class="keywordflow">return</span>;
<a name="l01917"></a>01917         }
<a name="l01918"></a>01918 
<a name="l01919"></a>01919         <span class="comment">/* This should be vga only */</span>
<a name="l01920"></a>01920         <span class="keywordflow">switch</span> (vga.mode) {
<a name="l01921"></a>01921         <span class="keywordflow">case</span> M_ERROR:
<a name="l01922"></a>01922         <span class="keywordflow">default</span>:
<a name="l01923"></a>01923                 <span class="keywordflow">return</span>;
<a name="l01924"></a>01924         <span class="keywordflow">case</span> M_LIN15:
<a name="l01925"></a>01925         <span class="keywordflow">case</span> M_LIN16:
<a name="l01926"></a>01926         <span class="keywordflow">case</span> M_LIN24:
<a name="l01927"></a>01927         <span class="keywordflow">case</span> M_LIN32:
<a name="l01928"></a>01928                 newHandler = &amp;vgaph.map;
<a name="l01929"></a>01929                 <span class="keywordflow">break</span>;
<a name="l01930"></a>01930         <span class="keywordflow">case</span> M_TEXT:
<a name="l01931"></a>01931         <span class="keywordflow">case</span> M_CGA2:
<a name="l01932"></a>01932         <span class="keywordflow">case</span> M_CGA4:
<a name="l01933"></a>01933         <span class="comment">/* EGA/VGA emulate CGA modes as chained */</span>
<a name="l01934"></a>01934         <span class="comment">/* fall through */</span>
<a name="l01935"></a>01935         <span class="keywordflow">case</span> M_LIN8:
<a name="l01936"></a>01936         <span class="keywordflow">case</span> M_LIN4:
<a name="l01937"></a>01937         <span class="keywordflow">case</span> M_VGA:
<a name="l01938"></a>01938         <span class="keywordflow">case</span> M_EGA:
<a name="l01939"></a>01939         <span class="keywordflow">if</span> (vga.config.chained) {
<a name="l01940"></a>01940             <span class="keywordflow">if</span> (vga.config.compatible_chain4) {
<a name="l01941"></a>01941                 <span class="comment">/* NTS: ET4000AX cards appear to have a different chain4 implementation from everyone else:</span>
<a name="l01942"></a>01942 <span class="comment">                 *      the planar memory byte address is address &gt;&gt; 2 and bits A0-A1 select the plane,</span>
<a name="l01943"></a>01943 <span class="comment">                 *      where all other clones I&#39;ve tested seem to write planar memory byte (address &amp; ~3)</span>
<a name="l01944"></a>01944 <span class="comment">                 *      (one byte per 4 bytes) and bits A0-A1 select the plane. */</span>
<a name="l01945"></a>01945                 <span class="comment">/* FIXME: Different chain4 implementation on ET4000 noted---is it true also for ET3000? */</span>
<a name="l01946"></a>01946                 <span class="keywordflow">if</span> (svgaCard == SVGA_TsengET3K || svgaCard == SVGA_TsengET4K)
<a name="l01947"></a>01947                     newHandler = &amp;vgaph.cvga_et4000_slow;
<a name="l01948"></a>01948                 <span class="keywordflow">else</span>
<a name="l01949"></a>01949                     newHandler = &amp;vgaph.cvga_slow;
<a name="l01950"></a>01950             }
<a name="l01951"></a>01951             <span class="keywordflow">else</span> {
<a name="l01952"></a>01952                 <span class="comment">/* this is needed for SVGA modes (Paradise, Tseng, S3) because SVGA</span>
<a name="l01953"></a>01953 <span class="comment">                 * modes do NOT use the chain4 configuration */</span>
<a name="l01954"></a>01954                 newHandler = &amp;vgaph.map;
<a name="l01955"></a>01955             }
<a name="l01956"></a>01956         } <span class="keywordflow">else</span> {
<a name="l01957"></a>01957             newHandler = &amp;vgaph.uvga;
<a name="l01958"></a>01958         }
<a name="l01959"></a>01959         <span class="keywordflow">break</span>;
<a name="l01960"></a>01960     <span class="keywordflow">case</span> M_PC98:
<a name="l01961"></a>01961                 newHandler = &amp;vgaph.pc98;
<a name="l01962"></a>01962 
<a name="l01963"></a>01963         <span class="comment">/* We need something to catch access to E0000-E7FFF IF 16/256-color mode */</span>
<a name="l01964"></a>01964         <span class="keywordflow">if</span> (pc98_gdc_vramop &amp; (1 &lt;&lt; VOPBIT_ANALOG))
<a name="l01965"></a>01965             MEM_SetPageHandler(0xE0, 8, newHandler );
<a name="l01966"></a>01966         <span class="keywordflow">else</span>
<a name="l01967"></a>01967             MEM_ResetPageHandler_Unmapped(0xE0, 8);
<a name="l01968"></a>01968 
<a name="l01969"></a>01969         <span class="keywordflow">break</span>;
<a name="l01970"></a>01970         <span class="keywordflow">case</span> M_AMSTRAD:
<a name="l01971"></a>01971                 newHandler = &amp;vgaph.map;
<a name="l01972"></a>01972                 <span class="keywordflow">break</span>;
<a name="l01973"></a>01973         }
<a name="l01974"></a>01974         <span class="keywordflow">switch</span> ((vga.gfx.miscellaneous &gt;&gt; 2) &amp; 3) {
<a name="l01975"></a>01975         <span class="keywordflow">case</span> 0:
<a name="l01976"></a>01976         vgapages.base = VGA_PAGE_A0;
<a name="l01977"></a>01977         <span class="keywordflow">switch</span> (svgaCard) {
<a name="l01978"></a>01978             <span class="keywordflow">case</span> SVGA_TsengET3K:
<a name="l01979"></a>01979             <span class="keywordflow">case</span> SVGA_TsengET4K:
<a name="l01980"></a>01980                 vgapages.mask = 0x1ffff &amp; vga.mem.memmask;
<a name="l01981"></a>01981                 <span class="keywordflow">break</span>;
<a name="l01982"></a>01982                 <span class="comment">/* NTS: Looking at the official ET4000 programming guide, it does in fact support the full 128KB */</span>
<a name="l01983"></a>01983             <span class="keywordflow">case</span> SVGA_S3Trio:
<a name="l01984"></a>01984             <span class="keywordflow">default</span>:
<a name="l01985"></a>01985                 vgapages.mask = 0xffff &amp; vga.mem.memmask;
<a name="l01986"></a>01986                 <span class="keywordflow">break</span>;
<a name="l01987"></a>01987                 }
<a name="l01988"></a>01988                 MEM_SetPageHandler(VGA_PAGE_A0, 32, newHandler );
<a name="l01989"></a>01989                 <span class="keywordflow">break</span>;
<a name="l01990"></a>01990         <span class="keywordflow">case</span> 1:
<a name="l01991"></a>01991                 vgapages.base = VGA_PAGE_A0;
<a name="l01992"></a>01992                 vgapages.mask = 0xffff &amp; vga.mem.memmask;
<a name="l01993"></a>01993                 MEM_SetPageHandler( VGA_PAGE_A0, 16, newHandler );
<a name="l01994"></a>01994                 MEM_ResetPageHandler_Unmapped( VGA_PAGE_B0, 16);
<a name="l01995"></a>01995                 <span class="keywordflow">break</span>;
<a name="l01996"></a>01996         <span class="keywordflow">case</span> 2:
<a name="l01997"></a>01997                 vgapages.base = VGA_PAGE_B0;
<a name="l01998"></a>01998                 vgapages.mask = 0x7fff &amp; vga.mem.memmask;
<a name="l01999"></a>01999                 MEM_SetPageHandler( VGA_PAGE_B0, 8, newHandler );
<a name="l02000"></a>02000         MEM_ResetPageHandler_Unmapped( VGA_PAGE_A0, 16 );
<a name="l02001"></a>02001         MEM_ResetPageHandler_Unmapped( VGA_PAGE_B8, 8 );
<a name="l02002"></a>02002         <span class="keywordflow">break</span>;
<a name="l02003"></a>02003         <span class="keywordflow">case</span> 3:
<a name="l02004"></a>02004                 vgapages.base = VGA_PAGE_B8;
<a name="l02005"></a>02005                 vgapages.mask = 0x7fff &amp; vga.mem.memmask;
<a name="l02006"></a>02006                 MEM_SetPageHandler( VGA_PAGE_B8, 8, newHandler );
<a name="l02007"></a>02007         MEM_ResetPageHandler_Unmapped( VGA_PAGE_A0, 16 );
<a name="l02008"></a>02008         MEM_ResetPageHandler_Unmapped( VGA_PAGE_B0, 8 );
<a name="l02009"></a>02009         <span class="keywordflow">break</span>;
<a name="l02010"></a>02010         }
<a name="l02011"></a>02011         <span class="keywordflow">if</span>(svgaCard == SVGA_S3Trio &amp;&amp; (vga.s3.ext_mem_ctrl &amp; 0x10))
<a name="l02012"></a>02012                 MEM_SetPageHandler(VGA_PAGE_A0, 16, &amp;vgaph.mmio);
<a name="l02013"></a>02013 
<a name="l02014"></a>02014     non_cga_ignore_oddeven_engage = (non_cga_ignore_oddeven &amp;&amp; !(vga.mode == M_TEXT || vga.mode == M_CGA2 || vga.mode == M_CGA4));
<a name="l02015"></a>02015 
<a name="l02016"></a>02016 range_done:
<a name="l02017"></a>02017         PAGING_ClearTLB();
<a name="l02018"></a>02018 }
<a name="l02019"></a>02019 
<a name="l02020"></a>02020 <span class="keywordtype">void</span> VGA_StartUpdateLFB(<span class="keywordtype">void</span>) {
<a name="l02021"></a>02021         <span class="comment">/* please obey the Linear Address Window Size register!</span>
<a name="l02022"></a>02022 <span class="comment">         * Windows 3.1 S3 driver will reprogram the linear framebuffer down to 0xA0000 when entering a DOSBox</span>
<a name="l02023"></a>02023 <span class="comment">         * and assuming the full VRAM size will cause a LOT of problems! */</span>
<a name="l02024"></a>02024         Bitu winsz = 0x10000;
<a name="l02025"></a>02025 
<a name="l02026"></a>02026         <span class="keywordflow">switch</span> (vga.s3.reg_58&amp;3) {
<a name="l02027"></a>02027                 <span class="keywordflow">case</span> 1:
<a name="l02028"></a>02028                         winsz = 1 &lt;&lt; 20;        <span class="comment">//1MB</span>
<a name="l02029"></a>02029                         <span class="keywordflow">break</span>;
<a name="l02030"></a>02030                 <span class="keywordflow">case</span> 2:
<a name="l02031"></a>02031                         winsz = 2 &lt;&lt; 20;        <span class="comment">//2MB</span>
<a name="l02032"></a>02032                         <span class="keywordflow">break</span>;
<a name="l02033"></a>02033                 <span class="keywordflow">case</span> 3:
<a name="l02034"></a>02034                         winsz = 4 &lt;&lt; 20;        <span class="comment">//4MB</span>
<a name="l02035"></a>02035                         <span class="keywordflow">break</span>;
<a name="l02036"></a>02036                 <span class="comment">// FIXME: What about the 8MB window?</span>
<a name="l02037"></a>02037         }
<a name="l02038"></a>02038 
<a name="l02039"></a>02039         <span class="comment">/* if the DOS application or Windows 3.1 driver attempts to put the linear framebuffer</span>
<a name="l02040"></a>02040 <span class="comment">         * below the top of memory, then we&#39;re probably entering a DOS VM and it&#39;s probably</span>
<a name="l02041"></a>02041 <span class="comment">         * a 64KB window. If it&#39;s not a 64KB window then print a warning. */</span>
<a name="l02042"></a>02042         <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(vga.s3.la_window &lt;&lt; 4UL) &lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)MEM_TotalPages()) {
<a name="l02043"></a>02043                 <span class="keywordflow">if</span> (winsz != 0x10000) <span class="comment">// 64KB window normal for entering a DOS VM in Windows 3.1 or legacy bank switching in DOS</span>
<a name="l02044"></a>02044                         <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_WARN)(<span class="stringliteral">&quot;S3 warning: Window size != 64KB and address conflict with system RAM!&quot;</span>);
<a name="l02045"></a>02045 
<a name="l02046"></a>02046                 vga.lfb.page = (<span class="keywordtype">unsigned</span> int)vga.s3.la_window &lt;&lt; 4u;
<a name="l02047"></a>02047                 vga.lfb.addr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.s3.la_window &lt;&lt; 16u;
<a name="l02048"></a>02048                 vga.lfb.handler = NULL;
<a name="l02049"></a>02049                 MEM_SetLFB(0,0,NULL,NULL);
<a name="l02050"></a>02050         }
<a name="l02051"></a>02051         <span class="keywordflow">else</span> {
<a name="l02052"></a>02052                 vga.lfb.page = (<span class="keywordtype">unsigned</span> int)vga.s3.la_window &lt;&lt; 4u;
<a name="l02053"></a>02053                 vga.lfb.addr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.s3.la_window &lt;&lt; 16u;
<a name="l02054"></a>02054                 vga.lfb.handler = &amp;vgaph.lfb;
<a name="l02055"></a>02055                 MEM_SetLFB((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.s3.la_window &lt;&lt; 4u,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)vga.mem.memsize/4096u, vga.lfb.handler, &amp;vgaph.mmio);
<a name="l02056"></a>02056         }
<a name="l02057"></a>02057 }
<a name="l02058"></a>02058 
<a name="l02059"></a>02059 <span class="keyword">static</span> <span class="keywordtype">bool</span> VGA_Memory_ShutDown_init = <span class="keyword">false</span>;
<a name="l02060"></a>02060 
<a name="l02061"></a>02061 <span class="keyword">static</span> <span class="keywordtype">void</span> VGA_Memory_ShutDown(<a class="code" href="classSection.html">Section</a> * <span class="comment">/*sec*/</span>) {
<a name="l02062"></a>02062         MEM_SetPageHandler(VGA_PAGE_A0,32,&amp;vgaph.empty);
<a name="l02063"></a>02063         PAGING_ClearTLB();
<a name="l02064"></a>02064 
<a name="l02065"></a>02065         <span class="keywordflow">if</span> (vga.mem.linear_orgptr != NULL) {
<a name="l02066"></a>02066                 <span class="keyword">delete</span>[] vga.mem.linear_orgptr;
<a name="l02067"></a>02067                 vga.mem.linear_orgptr = NULL;
<a name="l02068"></a>02068                 vga.mem.linear = NULL;
<a name="l02069"></a>02069         }
<a name="l02070"></a>02070 }
<a name="l02071"></a>02071 
<a name="l02072"></a>02072 <span class="keywordtype">void</span> VGA_SetupMemory() {
<a name="l02073"></a>02073         vga.svga.bank_read = vga.svga.bank_write = 0;
<a name="l02074"></a>02074         vga.svga.bank_read_full = vga.svga.bank_write_full = 0;
<a name="l02075"></a>02075 
<a name="l02076"></a>02076     <span class="keywordflow">if</span> (vga.mem.linear == NULL) {
<a name="l02077"></a>02077         VGA_Memory_ShutDown(NULL);
<a name="l02078"></a>02078 
<a name="l02079"></a>02079         vga.mem.linear_orgptr = <span class="keyword">new</span> Bit8u[vga.mem.memsize+32u];
<a name="l02080"></a>02080         memset(vga.mem.linear_orgptr,0,vga.mem.memsize+32u);
<a name="l02081"></a>02081         vga.mem.linear=(Bit8u*)(((uintptr_t)vga.mem.linear_orgptr + 16ull-1ull) &amp; ~(16ull-1ull));
<a name="l02082"></a>02082 
<a name="l02083"></a>02083         <span class="comment">/* HACK. try to avoid stale pointers */</span>
<a name="l02084"></a>02084             vga.draw.linear_base = vga.mem.linear;
<a name="l02085"></a>02085         vga.tandy.draw_base = vga.mem.linear;
<a name="l02086"></a>02086         vga.tandy.mem_base = vga.mem.linear;
<a name="l02087"></a>02087 
<a name="l02088"></a>02088         <span class="comment">/* may be related */</span>
<a name="l02089"></a>02089         VGA_SetupHandlers();
<a name="l02090"></a>02090     }
<a name="l02091"></a>02091 
<a name="l02092"></a>02092         vga.svga.bank_read = vga.svga.bank_write = 0;
<a name="l02093"></a>02093         vga.svga.bank_read_full = vga.svga.bank_write_full = 0;
<a name="l02094"></a>02094         vga.svga.bank_size = 0x10000; <span class="comment">/* most common bank size is 64K */</span>
<a name="l02095"></a>02095 
<a name="l02096"></a>02096         <span class="keywordflow">if</span> (!VGA_Memory_ShutDown_init) {
<a name="l02097"></a>02097                 AddExitFunction(AddExitFunctionFuncPair(VGA_Memory_ShutDown));
<a name="l02098"></a>02098                 VGA_Memory_ShutDown_init = <span class="keyword">true</span>;
<a name="l02099"></a>02099         }
<a name="l02100"></a>02100 
<a name="l02101"></a>02101         <span class="keywordflow">if</span> (machine==MCH_PCJR) {
<a name="l02102"></a>02102                 <span class="comment">/* PCJr does not have dedicated graphics memory but uses</span>
<a name="l02103"></a>02103 <span class="comment">                   conventional memory below 128k */</span>
<a name="l02104"></a>02104                 <span class="comment">//TODO map?     </span>
<a name="l02105"></a>02105         } 
<a name="l02106"></a>02106 }
<a name="l02107"></a>02107 
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 29 2018 08:09:03 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
