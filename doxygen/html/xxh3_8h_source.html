<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/libs/decoders/xxh3.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/libs/decoders/xxh3.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * xxHash - Extremely Fast Hash algorithm</span>
<a name="l00003"></a>00003 <span class="comment"> * Development source file for `xxh3`</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (C) 2019-2020 Yann Collet</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00009"></a>00009 <span class="comment"> * modification, are permitted provided that the following conditions are</span>
<a name="l00010"></a>00010 <span class="comment"> * met:</span>
<a name="l00011"></a>00011 <span class="comment"> *</span>
<a name="l00012"></a>00012 <span class="comment"> *    * Redistributions of source code must retain the above copyright</span>
<a name="l00013"></a>00013 <span class="comment"> *      notice, this list of conditions and the following disclaimer.</span>
<a name="l00014"></a>00014 <span class="comment"> *    * Redistributions in binary form must reproduce the above</span>
<a name="l00015"></a>00015 <span class="comment"> *      copyright notice, this list of conditions and the following disclaimer</span>
<a name="l00016"></a>00016 <span class="comment"> *      in the documentation and/or other materials provided with the</span>
<a name="l00017"></a>00017 <span class="comment"> *      distribution.</span>
<a name="l00018"></a>00018 <span class="comment"> *</span>
<a name="l00019"></a>00019 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00020"></a>00020 <span class="comment"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00021"></a>00021 <span class="comment"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00022"></a>00022 <span class="comment"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00023"></a>00023 <span class="comment"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00024"></a>00024 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00025"></a>00025 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00026"></a>00026 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00027"></a>00027 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00028"></a>00028 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<a name="l00029"></a>00029 <span class="comment"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031"></a>00031 <span class="comment"> * You can contact the author at:</span>
<a name="l00032"></a>00032 <span class="comment"> *   - xxHash homepage: https://www.xxhash.com</span>
<a name="l00033"></a>00033 <span class="comment"> *   - xxHash source repository: https://github.com/Cyan4973/xxHash</span>
<a name="l00034"></a>00034 <span class="comment"> */</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="comment">/*</span>
<a name="l00037"></a>00037 <span class="comment"> * Note: This file is separated for development purposes.</span>
<a name="l00038"></a>00038 <span class="comment"> * It will be integrated into `xxhash.h` when development stage is completed.</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> * Credit: most of the work on vectorial and asm variants comes from @easyaspi314</span>
<a name="l00041"></a>00041 <span class="comment"> */</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#ifndef XXH3_H_1397135465</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#define XXH3_H_1397135465</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 <span class="comment">/* ===   Dependencies   === */</span>
<a name="l00047"></a>00047 <span class="preprocessor">#ifndef XXHASH_H_5627135585666179</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="comment">/* special: when including `xxh3.h` directly, turn on XXH_INLINE_ALL */</span>
<a name="l00049"></a>00049 <span class="preprocessor">#  undef XXH_INLINE_ALL   </span><span class="comment">/* avoid redefinition */</span>
<a name="l00050"></a>00050 <span class="preprocessor">#  define XXH_INLINE_ALL</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#include &quot;xxhash.h&quot;</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="comment">/* ===   Compiler specifics   === */</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="preprocessor">#if defined (__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 199901L   </span><span class="comment">/* &gt;= C99 */</span>
<a name="l00058"></a>00058 <span class="preprocessor">#  define XXH_RESTRICT   restrict</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="comment">/* Note: it might be useful to define __restrict or __restrict__ for some C++ compilers */</span>
<a name="l00061"></a>00061 <span class="preprocessor">#  define XXH_RESTRICT   </span><span class="comment">/* disable */</span>
<a name="l00062"></a>00062 <span class="preprocessor">#endif</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>
<a name="l00064"></a>00064 <span class="preprocessor">#if (defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3))  \</span>
<a name="l00065"></a>00065 <span class="preprocessor">  || (defined(__INTEL_COMPILER) &amp;&amp; (__INTEL_COMPILER &gt;= 800)) \</span>
<a name="l00066"></a>00066 <span class="preprocessor">  || defined(__clang__)</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_likely(x) __builtin_expect(x, 1)</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_unlikely(x) __builtin_expect(x, 0)</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_likely(x) (x)</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_unlikely(x) (x)</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span>
<a name="l00074"></a>00074 <span class="preprocessor">#if defined(__GNUC__)</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#  if defined(__AVX2__)</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#    include &lt;immintrin.h&gt;</span>
<a name="l00077"></a>00077 <span class="preprocessor">#  elif defined(__SSE2__)</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span><span class="preprocessor">#    include &lt;emmintrin.h&gt;</span>
<a name="l00079"></a>00079 <span class="preprocessor">#  elif defined(__ARM_NEON__) || defined(__ARM_NEON)</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#    define inline __inline__  </span><span class="comment">/* clang bug */</span>
<a name="l00081"></a>00081 <span class="preprocessor">#    include &lt;arm_neon.h&gt;</span>
<a name="l00082"></a>00082 <span class="preprocessor">#    undef inline</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor">#elif defined(_MSC_VER)</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#  include &lt;intrin.h&gt;</span>
<a name="l00086"></a>00086 <span class="preprocessor">#endif</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>
<a name="l00088"></a>00088 <span class="comment">/*</span>
<a name="l00089"></a>00089 <span class="comment"> * One goal of XXH3 is to make it fast on both 32-bit and 64-bit, while</span>
<a name="l00090"></a>00090 <span class="comment"> * remaining a true 64-bit/128-bit hash function.</span>
<a name="l00091"></a>00091 <span class="comment"> *</span>
<a name="l00092"></a>00092 <span class="comment"> * This is done by prioritizing a subset of 64-bit operations that can be</span>
<a name="l00093"></a>00093 <span class="comment"> * emulated without too many steps on the average 32-bit machine.</span>
<a name="l00094"></a>00094 <span class="comment"> *</span>
<a name="l00095"></a>00095 <span class="comment"> * For example, these two lines seem similar, and run equally fast on 64-bit:</span>
<a name="l00096"></a>00096 <span class="comment"> *</span>
<a name="l00097"></a>00097 <span class="comment"> *   xxh_u64 x;</span>
<a name="l00098"></a>00098 <span class="comment"> *   x ^= (x &gt;&gt; 47); // good</span>
<a name="l00099"></a>00099 <span class="comment"> *   x ^= (x &gt;&gt; 13); // bad</span>
<a name="l00100"></a>00100 <span class="comment"> *</span>
<a name="l00101"></a>00101 <span class="comment"> * However, to a 32-bit machine, there is a major difference.</span>
<a name="l00102"></a>00102 <span class="comment"> *</span>
<a name="l00103"></a>00103 <span class="comment"> * x ^= (x &gt;&gt; 47) looks like this:</span>
<a name="l00104"></a>00104 <span class="comment"> *</span>
<a name="l00105"></a>00105 <span class="comment"> *   x.lo ^= (x.hi &gt;&gt; (47 - 32));</span>
<a name="l00106"></a>00106 <span class="comment"> *</span>
<a name="l00107"></a>00107 <span class="comment"> * while x ^= (x &gt;&gt; 13) looks like this:</span>
<a name="l00108"></a>00108 <span class="comment"> *</span>
<a name="l00109"></a>00109 <span class="comment"> *   // note: funnel shifts are not usually cheap.</span>
<a name="l00110"></a>00110 <span class="comment"> *   x.lo ^= (x.lo &gt;&gt; 13) | (x.hi &lt;&lt; (32 - 13));</span>
<a name="l00111"></a>00111 <span class="comment"> *   x.hi ^= (x.hi &gt;&gt; 13);</span>
<a name="l00112"></a>00112 <span class="comment"> *</span>
<a name="l00113"></a>00113 <span class="comment"> * The first one is significantly faster than the second, simply because the</span>
<a name="l00114"></a>00114 <span class="comment"> * shift is larger than 32. This means:</span>
<a name="l00115"></a>00115 <span class="comment"> *  - All the bits we need are in the upper 32 bits, so we can ignore the lower</span>
<a name="l00116"></a>00116 <span class="comment"> *    32 bits in the shift.</span>
<a name="l00117"></a>00117 <span class="comment"> *  - The shift result will always fit in the lower 32 bits, and therefore,</span>
<a name="l00118"></a>00118 <span class="comment"> *    we can ignore the upper 32 bits in the xor.</span>
<a name="l00119"></a>00119 <span class="comment"> *</span>
<a name="l00120"></a>00120 <span class="comment"> * Thanks to this optimization, XXH3 only requires these features to be efficient:</span>
<a name="l00121"></a>00121 <span class="comment"> *</span>
<a name="l00122"></a>00122 <span class="comment"> *  - Usable unaligned access</span>
<a name="l00123"></a>00123 <span class="comment"> *  - A 32-bit or 64-bit ALU</span>
<a name="l00124"></a>00124 <span class="comment"> *      - If 32-bit, a decent ADC instruction</span>
<a name="l00125"></a>00125 <span class="comment"> *  - A 32 or 64-bit multiply with a 64-bit result</span>
<a name="l00126"></a>00126 <span class="comment"> *  - For the 128-bit variant, a decent byteswap helps short inputs.</span>
<a name="l00127"></a>00127 <span class="comment"> *</span>
<a name="l00128"></a>00128 <span class="comment"> * The first two are already required by XXH32, and almost all 32-bit and 64-bit</span>
<a name="l00129"></a>00129 <span class="comment"> * platforms which can run XXH32 can run XXH3 efficiently.</span>
<a name="l00130"></a>00130 <span class="comment"> *</span>
<a name="l00131"></a>00131 <span class="comment"> * Thumb-1, the classic 16-bit only subset of ARM&#39;s instruction set, is one</span>
<a name="l00132"></a>00132 <span class="comment"> * notable exception.</span>
<a name="l00133"></a>00133 <span class="comment"> *</span>
<a name="l00134"></a>00134 <span class="comment"> * First of all, Thumb-1 lacks support for the UMULL instruction which</span>
<a name="l00135"></a>00135 <span class="comment"> * performs the important long multiply. This means numerous __aeabi_lmul</span>
<a name="l00136"></a>00136 <span class="comment"> * calls.</span>
<a name="l00137"></a>00137 <span class="comment"> *</span>
<a name="l00138"></a>00138 <span class="comment"> * Second of all, the 8 functional registers are just not enough.</span>
<a name="l00139"></a>00139 <span class="comment"> * Setup for __aeabi_lmul, byteshift loads, pointers, and all arithmetic need</span>
<a name="l00140"></a>00140 <span class="comment"> * Lo registers, and this shuffling results in thousands more MOVs than A32.</span>
<a name="l00141"></a>00141 <span class="comment"> *</span>
<a name="l00142"></a>00142 <span class="comment"> * A32 and T32 don&#39;t have this limitation. They can access all 14 registers,</span>
<a name="l00143"></a>00143 <span class="comment"> * do a 32-&gt;64 multiply with UMULL, and the flexible operand allowing free</span>
<a name="l00144"></a>00144 <span class="comment"> * shifts is helpful, too.</span>
<a name="l00145"></a>00145 <span class="comment"> *</span>
<a name="l00146"></a>00146 <span class="comment"> * Therefore, we do a quick sanity check.</span>
<a name="l00147"></a>00147 <span class="comment"> *</span>
<a name="l00148"></a>00148 <span class="comment"> * If compiling Thumb-1 for a target which supports ARM instructions, we will</span>
<a name="l00149"></a>00149 <span class="comment"> * emit a warning, as it is not a &quot;sane&quot; platform to compile for.</span>
<a name="l00150"></a>00150 <span class="comment"> *</span>
<a name="l00151"></a>00151 <span class="comment"> * Usually, if this happens, it is because of an accident and you probably need</span>
<a name="l00152"></a>00152 <span class="comment"> * to specify -march, as you likely meant to compile for a newer architecture.</span>
<a name="l00153"></a>00153 <span class="comment"> */</span>
<a name="l00154"></a>00154 <span class="preprocessor">#if defined(__thumb__) &amp;&amp; !defined(__thumb2__) &amp;&amp; defined(__ARM_ARCH_ISA_ARM)</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span><span class="preprocessor">#   warning &quot;XXH3 is highly inefficient without ARM or Thumb-2.&quot;</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span>
<a name="l00158"></a>00158 <span class="comment">/* ==========================================</span>
<a name="l00159"></a>00159 <span class="comment"> * Vectorization detection</span>
<a name="l00160"></a>00160 <span class="comment"> * ========================================== */</span>
<a name="l00161"></a>00161 <span class="preprocessor">#define XXH_SCALAR 0 </span><span class="comment">/* Portable scalar version */</span>
<a name="l00162"></a>00162 <span class="preprocessor">#define XXH_SSE2   1 </span><span class="comment">/* SSE2 for Pentium 4 and all x86_64 */</span>
<a name="l00163"></a>00163 <span class="preprocessor">#define XXH_AVX2   2 </span><span class="comment">/* AVX2 for Haswell and Bulldozer */</span>
<a name="l00164"></a>00164 <span class="preprocessor">#define XXH_NEON   3 </span><span class="comment">/* NEON for most ARMv7-A and all AArch64 */</span>
<a name="l00165"></a>00165 <span class="preprocessor">#define XXH_VSX    4 </span><span class="comment">/* VSX and ZVector for POWER8/z13 */</span>
<a name="l00166"></a>00166 <span class="preprocessor">#define XXH_AVX512 5 </span><span class="comment">/* AVX512 for Skylake and Icelake */</span>
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="preprocessor">#ifndef XXH_VECTOR    </span><span class="comment">/* can be defined on command line */</span>
<a name="l00169"></a>00169 <span class="preprocessor">#  if defined(__AVX512F__)</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_VECTOR XXH_AVX512</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span><span class="preprocessor">#  elif defined(__AVX2__)</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_VECTOR XXH_AVX2</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span><span class="preprocessor">#  elif defined(__SSE2__) || defined(_M_AMD64) || defined(_M_X64) || (defined(_M_IX86_FP) &amp;&amp; (_M_IX86_FP == 2))</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_VECTOR XXH_SSE2</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span><span class="preprocessor">#  elif defined(__GNUC__) </span><span class="comment">/* msvc support maybe later */</span> \
<a name="l00176"></a>00176   &amp;&amp; (defined(__ARM_NEON__) || defined(__ARM_NEON)) \
<a name="l00177"></a>00177   &amp;&amp; (defined(__LITTLE_ENDIAN__) <span class="comment">/* We only support little endian NEON */</span> \
<a name="l00178"></a>00178     || (defined(__BYTE_ORDER__) &amp;&amp; __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))
<a name="l00179"></a>00179 <span class="preprocessor">#    define XXH_VECTOR XXH_NEON</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span><span class="preprocessor">#  elif (defined(__PPC64__) &amp;&amp; defined(__POWER8_VECTOR__)) \</span>
<a name="l00181"></a>00181 <span class="preprocessor">     || (defined(__s390x__) &amp;&amp; defined(__VEC__)) \</span>
<a name="l00182"></a>00182 <span class="preprocessor">     &amp;&amp; defined(__GNUC__) </span><span class="comment">/* TODO: IBM XL */</span>
<a name="l00183"></a>00183 <span class="preprocessor">#    define XXH_VECTOR XXH_VSX</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span><span class="preprocessor">#  else</span>
<a name="l00185"></a>00185 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_VECTOR XXH_SCALAR</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span>
<a name="l00189"></a>00189 <span class="comment">/*</span>
<a name="l00190"></a>00190 <span class="comment"> * Controls the alignment of the accumulator.</span>
<a name="l00191"></a>00191 <span class="comment"> * This is for compatibility with aligned vector loads, which are usually faster.</span>
<a name="l00192"></a>00192 <span class="comment"> */</span>
<a name="l00193"></a>00193 <span class="preprocessor">#ifndef XXH_ACC_ALIGN</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span><span class="preprocessor">#  if XXH_VECTOR == XXH_SCALAR  </span><span class="comment">/* scalar */</span>
<a name="l00195"></a>00195 <span class="preprocessor">#     define XXH_ACC_ALIGN 8</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span><span class="preprocessor">#  elif XXH_VECTOR == XXH_SSE2  </span><span class="comment">/* sse2 */</span>
<a name="l00197"></a>00197 <span class="preprocessor">#     define XXH_ACC_ALIGN 16</span>
<a name="l00198"></a>00198 <span class="preprocessor"></span><span class="preprocessor">#  elif XXH_VECTOR == XXH_AVX2  </span><span class="comment">/* avx2 */</span>
<a name="l00199"></a>00199 <span class="preprocessor">#     define XXH_ACC_ALIGN 32</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span><span class="preprocessor">#  elif XXH_VECTOR == XXH_NEON  </span><span class="comment">/* neon */</span>
<a name="l00201"></a>00201 <span class="preprocessor">#     define XXH_ACC_ALIGN 16</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span><span class="preprocessor">#  elif XXH_VECTOR == XXH_VSX   </span><span class="comment">/* vsx */</span>
<a name="l00203"></a>00203 <span class="preprocessor">#     define XXH_ACC_ALIGN 16</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span><span class="preprocessor">#  elif XXH_VECTOR == XXH_AVX512 </span><span class="comment">/* avx512 */</span>
<a name="l00205"></a>00205 <span class="preprocessor">#     define XXH_ACC_ALIGN 64</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
<a name="l00207"></a>00207 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00208"></a>00208 <span class="preprocessor"></span>
<a name="l00209"></a>00209 <span class="comment">/*</span>
<a name="l00210"></a>00210 <span class="comment"> * UGLY HACK:</span>
<a name="l00211"></a>00211 <span class="comment"> * GCC usually generates the best code with -O3 for xxHash.</span>
<a name="l00212"></a>00212 <span class="comment"> *</span>
<a name="l00213"></a>00213 <span class="comment"> * However, when targeting AVX2, it is overzealous in its unrolling resulting</span>
<a name="l00214"></a>00214 <span class="comment"> * in code roughly 3/4 the speed of Clang.</span>
<a name="l00215"></a>00215 <span class="comment"> *</span>
<a name="l00216"></a>00216 <span class="comment"> * There are other issues, such as GCC splitting _mm256_loadu_si256 into</span>
<a name="l00217"></a>00217 <span class="comment"> * _mm_loadu_si128 + _mm256_inserti128_si256. This is an optimization which</span>
<a name="l00218"></a>00218 <span class="comment"> * only applies to Sandy and Ivy Bridge... which don&#39;t even support AVX2.</span>
<a name="l00219"></a>00219 <span class="comment"> *</span>
<a name="l00220"></a>00220 <span class="comment"> * That is why when compiling the AVX2 version, it is recommended to use either</span>
<a name="l00221"></a>00221 <span class="comment"> *   -O2 -mavx2 -march=haswell</span>
<a name="l00222"></a>00222 <span class="comment"> * or</span>
<a name="l00223"></a>00223 <span class="comment"> *   -O2 -mavx2 -mno-avx256-split-unaligned-load</span>
<a name="l00224"></a>00224 <span class="comment"> * for decent performance, or to use Clang instead.</span>
<a name="l00225"></a>00225 <span class="comment"> *</span>
<a name="l00226"></a>00226 <span class="comment"> * Fortunately, we can control the first one with a pragma that forces GCC into</span>
<a name="l00227"></a>00227 <span class="comment"> * -O2, but the other one we can&#39;t control without &quot;failed to inline always</span>
<a name="l00228"></a>00228 <span class="comment"> * inline function due to target mismatch&quot; warnings.</span>
<a name="l00229"></a>00229 <span class="comment"> */</span>
<a name="l00230"></a>00230 <span class="preprocessor">#if XXH_VECTOR == XXH_AVX2 </span><span class="comment">/* AVX2 */</span> \
<a name="l00231"></a>00231   &amp;&amp; defined(__GNUC__) &amp;&amp; !defined(__clang__) <span class="comment">/* GCC, not Clang */</span> \
<a name="l00232"></a>00232   &amp;&amp; defined(__OPTIMIZE__) &amp;&amp; !defined(__OPTIMIZE_SIZE__) <span class="comment">/* respect -O0 and -Os */</span>
<a name="l00233"></a>00233 <span class="preprocessor">#  pragma GCC push_options</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span><span class="preprocessor">#  pragma GCC optimize(&quot;-O2&quot;)</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00236"></a>00236 <span class="preprocessor"></span>
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="preprocessor">#if XXH_VECTOR == XXH_NEON</span>
<a name="l00239"></a>00239 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00240"></a>00240 <span class="comment"> * NEON&#39;s setup for vmlal_u32 is a little more complicated than it is on</span>
<a name="l00241"></a>00241 <span class="comment"> * SSE2, AVX2, and VSX.</span>
<a name="l00242"></a>00242 <span class="comment"> *</span>
<a name="l00243"></a>00243 <span class="comment"> * While PMULUDQ and VMULEUW both perform a mask, VMLAL.U32 performs an upcast.</span>
<a name="l00244"></a>00244 <span class="comment"> *</span>
<a name="l00245"></a>00245 <span class="comment"> * To do the same operation, the 128-bit &#39;Q&#39; register needs to be split into</span>
<a name="l00246"></a>00246 <span class="comment"> * two 64-bit &#39;D&#39; registers, performing this operation::</span>
<a name="l00247"></a>00247 <span class="comment"> *</span>
<a name="l00248"></a>00248 <span class="comment"> *   [                a                 |                 b                ]</span>
<a name="l00249"></a>00249 <span class="comment"> *            |              &#39;---------. .--------&#39;                |</span>
<a name="l00250"></a>00250 <span class="comment"> *            |                         x                          |</span>
<a name="l00251"></a>00251 <span class="comment"> *            |              .---------&#39; &#39;--------.                |</span>
<a name="l00252"></a>00252 <span class="comment"> *   [ a &amp; 0xFFFFFFFF | b &amp; 0xFFFFFFFF ],[    a &gt;&gt; 32     |     b &gt;&gt; 32    ]</span>
<a name="l00253"></a>00253 <span class="comment"> *</span>
<a name="l00254"></a>00254 <span class="comment"> * Due to significant changes in aarch64, the fastest method for aarch64 is</span>
<a name="l00255"></a>00255 <span class="comment"> * completely different than the fastest method for ARMv7-A.</span>
<a name="l00256"></a>00256 <span class="comment"> *</span>
<a name="l00257"></a>00257 <span class="comment"> * ARMv7-A treats D registers as unions overlaying Q registers, so modifying</span>
<a name="l00258"></a>00258 <span class="comment"> * D11 will modify the high half of Q5. This is similar to how modifying AH</span>
<a name="l00259"></a>00259 <span class="comment"> * will only affect bits 8-15 of AX on x86.</span>
<a name="l00260"></a>00260 <span class="comment"> *</span>
<a name="l00261"></a>00261 <span class="comment"> * VZIP takes two registers, and puts even lanes in one register and odd lanes</span>
<a name="l00262"></a>00262 <span class="comment"> * in the other.</span>
<a name="l00263"></a>00263 <span class="comment"> *</span>
<a name="l00264"></a>00264 <span class="comment"> * On ARMv7-A, this strangely modifies both parameters in place instead of</span>
<a name="l00265"></a>00265 <span class="comment"> * taking the usual 3-operand form.</span>
<a name="l00266"></a>00266 <span class="comment"> *</span>
<a name="l00267"></a>00267 <span class="comment"> * Therefore, if we want to do this, we can simply use a D-form VZIP.32 on the</span>
<a name="l00268"></a>00268 <span class="comment"> * lower and upper halves of the Q register to end up with the high and low</span>
<a name="l00269"></a>00269 <span class="comment"> * halves where we want - all in one instruction.</span>
<a name="l00270"></a>00270 <span class="comment"> *</span>
<a name="l00271"></a>00271 <span class="comment"> *   vzip.32   d10, d11       @ d10 = { d10[0], d11[0] }; d11 = { d10[1], d11[1] }</span>
<a name="l00272"></a>00272 <span class="comment"> *</span>
<a name="l00273"></a>00273 <span class="comment"> * Unfortunately we need inline assembly for this: Instructions modifying two</span>
<a name="l00274"></a>00274 <span class="comment"> * registers at once is not possible in GCC or Clang&#39;s IR, and they have to</span>
<a name="l00275"></a>00275 <span class="comment"> * create a copy.</span>
<a name="l00276"></a>00276 <span class="comment"> *</span>
<a name="l00277"></a>00277 <span class="comment"> * aarch64 requires a different approach.</span>
<a name="l00278"></a>00278 <span class="comment"> *</span>
<a name="l00279"></a>00279 <span class="comment"> * In order to make it easier to write a decent compiler for aarch64, many</span>
<a name="l00280"></a>00280 <span class="comment"> * quirks were removed, such as conditional execution.</span>
<a name="l00281"></a>00281 <span class="comment"> *</span>
<a name="l00282"></a>00282 <span class="comment"> * NEON was also affected by this.</span>
<a name="l00283"></a>00283 <span class="comment"> *</span>
<a name="l00284"></a>00284 <span class="comment"> * aarch64 cannot access the high bits of a Q-form register, and writes to a</span>
<a name="l00285"></a>00285 <span class="comment"> * D-form register zero the high bits, similar to how writes to W-form scalar</span>
<a name="l00286"></a>00286 <span class="comment"> * registers (or DWORD registers on x86_64) work.</span>
<a name="l00287"></a>00287 <span class="comment"> *</span>
<a name="l00288"></a>00288 <span class="comment"> * The formerly free vget_high intrinsics now require a vext (with a few</span>
<a name="l00289"></a>00289 <span class="comment"> * exceptions)</span>
<a name="l00290"></a>00290 <span class="comment"> *</span>
<a name="l00291"></a>00291 <span class="comment"> * Additionally, VZIP was replaced by ZIP1 and ZIP2, which are the equivalent</span>
<a name="l00292"></a>00292 <span class="comment"> * of PUNPCKL* and PUNPCKH* in SSE, respectively, in order to only modify one</span>
<a name="l00293"></a>00293 <span class="comment"> * operand.</span>
<a name="l00294"></a>00294 <span class="comment"> *</span>
<a name="l00295"></a>00295 <span class="comment"> * The equivalent of the VZIP.32 on the lower and upper halves would be this</span>
<a name="l00296"></a>00296 <span class="comment"> * mess:</span>
<a name="l00297"></a>00297 <span class="comment"> *</span>
<a name="l00298"></a>00298 <span class="comment"> *   ext     v2.4s, v0.4s, v0.4s, #2 // v2 = { v0[2], v0[3], v0[0], v0[1] }</span>
<a name="l00299"></a>00299 <span class="comment"> *   zip1    v1.2s, v0.2s, v2.2s     // v1 = { v0[0], v2[0] }</span>
<a name="l00300"></a>00300 <span class="comment"> *   zip2    v0.2s, v0.2s, v1.2s     // v0 = { v0[1], v2[1] }</span>
<a name="l00301"></a>00301 <span class="comment"> *</span>
<a name="l00302"></a>00302 <span class="comment"> * Instead, we use a literal downcast, vmovn_u64 (XTN), and vshrn_n_u64 (SHRN):</span>
<a name="l00303"></a>00303 <span class="comment"> *</span>
<a name="l00304"></a>00304 <span class="comment"> *   shrn    v1.2s, v0.2d, #32  // v1 = (uint32x2_t)(v0 &gt;&gt; 32);</span>
<a name="l00305"></a>00305 <span class="comment"> *   xtn     v0.2s, v0.2d       // v0 = (uint32x2_t)(v0 &amp; 0xFFFFFFFF);</span>
<a name="l00306"></a>00306 <span class="comment"> *</span>
<a name="l00307"></a>00307 <span class="comment"> * This is available on ARMv7-A, but is less efficient than a single VZIP.32.</span>
<a name="l00308"></a>00308 <span class="comment"> */</span>
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="comment">/*</span>
<a name="l00311"></a>00311 <span class="comment"> * Function-like macro:</span>
<a name="l00312"></a>00312 <span class="comment"> * void XXH_SPLIT_IN_PLACE(uint64x2_t &amp;in, uint32x2_t &amp;outLo, uint32x2_t &amp;outHi)</span>
<a name="l00313"></a>00313 <span class="comment"> * {</span>
<a name="l00314"></a>00314 <span class="comment"> *     outLo = (uint32x2_t)(in &amp; 0xFFFFFFFF);</span>
<a name="l00315"></a>00315 <span class="comment"> *     outHi = (uint32x2_t)(in &gt;&gt; 32);</span>
<a name="l00316"></a>00316 <span class="comment"> *     in = UNDEFINED;</span>
<a name="l00317"></a>00317 <span class="comment"> * }</span>
<a name="l00318"></a>00318 <span class="comment"> */</span>
<a name="l00319"></a>00319 <span class="preprocessor"># if !defined(XXH_NO_VZIP_HACK) </span><span class="comment">/* define to disable */</span> \
<a name="l00320"></a>00320    &amp;&amp; defined(__GNUC__) \
<a name="l00321"></a>00321    &amp;&amp; !defined(__aarch64__) &amp;&amp; !defined(__arm64__)
<a name="l00322"></a>00322 <span class="preprocessor">#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                              \</span>
<a name="l00323"></a>00323 <span class="preprocessor">    do {                                                                                    \</span>
<a name="l00324"></a>00324 <span class="preprocessor">      </span><span class="comment">/* Undocumented GCC/Clang operand modifier: %e0 = lower D half, %f0 = upper D half */</span> \
<a name="l00325"></a>00325       <span class="comment">/* https://github.com/gcc-mirror/gcc/blob/38cf91e5/gcc/config/arm/arm.c#L22486 */</span>     \
<a name="l00326"></a>00326       <span class="comment">/* https://github.com/llvm-mirror/llvm/blob/2c4ca683/lib/Target/ARM/ARMAsmPrinter.cpp#L399 */</span> \
<a name="l00327"></a>00327       __asm__(&quot;vzip.32  %e0, %f0&quot; : &quot;+w&quot; (in));                                             \
<a name="l00328"></a>00328       (outLo) = vget_low_u32 (vreinterpretq_u32_u64(in));                                   \
<a name="l00329"></a>00329       (outHi) = vget_high_u32(vreinterpretq_u32_u64(in));                                   \
<a name="l00330"></a>00330    } while (0)
<a name="l00331"></a>00331 <span class="preprocessor"># else</span>
<a name="l00332"></a>00332 <span class="preprocessor"></span><span class="preprocessor">#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                            \</span>
<a name="l00333"></a>00333 <span class="preprocessor">    do {                                                                                  \</span>
<a name="l00334"></a>00334 <span class="preprocessor">      (outLo) = vmovn_u64    (in);                                                        \</span>
<a name="l00335"></a>00335 <span class="preprocessor">      (outHi) = vshrn_n_u64  ((in), 32);                                                  \</span>
<a name="l00336"></a>00336 <span class="preprocessor">    } while (0)</span>
<a name="l00337"></a>00337 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00338"></a>00338 <span class="preprocessor"></span><span class="preprocessor">#endif  </span><span class="comment">/* XXH_VECTOR == XXH_NEON */</span>
<a name="l00339"></a>00339 
<a name="l00340"></a>00340 <span class="comment">/*</span>
<a name="l00341"></a>00341 <span class="comment"> * VSX and Z Vector helpers.</span>
<a name="l00342"></a>00342 <span class="comment"> *</span>
<a name="l00343"></a>00343 <span class="comment"> * This is very messy, and any pull requests to clean this up are welcome.</span>
<a name="l00344"></a>00344 <span class="comment"> *</span>
<a name="l00345"></a>00345 <span class="comment"> * There are a lot of problems with supporting VSX and s390x, due to</span>
<a name="l00346"></a>00346 <span class="comment"> * inconsistent intrinsics, spotty coverage, and multiple endiannesses.</span>
<a name="l00347"></a>00347 <span class="comment"> */</span>
<a name="l00348"></a>00348 <span class="preprocessor">#if XXH_VECTOR == XXH_VSX</span>
<a name="l00349"></a>00349 <span class="preprocessor"></span><span class="preprocessor">#  if defined(__s390x__)</span>
<a name="l00350"></a>00350 <span class="preprocessor"></span><span class="preprocessor">#    include &lt;s390intrin.h&gt;</span>
<a name="l00351"></a>00351 <span class="preprocessor">#  else</span>
<a name="l00352"></a>00352 <span class="preprocessor"></span><span class="preprocessor">#    include &lt;altivec.h&gt;</span>
<a name="l00353"></a>00353 <span class="preprocessor">#  endif</span>
<a name="l00354"></a>00354 <span class="preprocessor"></span>
<a name="l00355"></a>00355 <span class="preprocessor">#  undef vector </span><span class="comment">/* Undo the pollution */</span>
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 <span class="keyword">typedef</span> __vector <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> xxh_u64x2;
<a name="l00358"></a>00358 <span class="keyword">typedef</span> __vector <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> xxh_u8x16;
<a name="l00359"></a>00359 <span class="keyword">typedef</span> __vector <span class="keywordtype">unsigned</span> xxh_u32x4;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361 <span class="preprocessor"># ifndef XXH_VSX_BE</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span><span class="preprocessor">#  if defined(__BIG_ENDIAN__) \</span>
<a name="l00363"></a>00363 <span class="preprocessor">  || (defined(__BYTE_ORDER__) &amp;&amp; __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)</span>
<a name="l00364"></a>00364 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_VSX_BE 1</span>
<a name="l00365"></a>00365 <span class="preprocessor"></span><span class="preprocessor">#  elif defined(__VEC_ELEMENT_REG_ORDER__) &amp;&amp; __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__</span>
<a name="l00366"></a>00366 <span class="preprocessor"></span><span class="preprocessor">#    warning &quot;-maltivec=be is not recommended. Please use native endianness.&quot;</span>
<a name="l00367"></a>00367 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_VSX_BE 1</span>
<a name="l00368"></a>00368 <span class="preprocessor"></span><span class="preprocessor">#  else</span>
<a name="l00369"></a>00369 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_VSX_BE 0</span>
<a name="l00370"></a>00370 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
<a name="l00371"></a>00371 <span class="preprocessor"></span><span class="preprocessor"># endif </span><span class="comment">/* !defined(XXH_VSX_BE) */</span>
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="preprocessor"># if XXH_VSX_BE</span>
<a name="l00374"></a>00374 <span class="preprocessor"></span><span class="comment">/* A wrapper for POWER9&#39;s vec_revb. */</span>
<a name="l00375"></a>00375 <span class="preprocessor">#  if defined(__POWER9_VECTOR__) || (defined(__clang__) &amp;&amp; defined(__s390x__))</span>
<a name="l00376"></a>00376 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_vec_revb vec_revb</span>
<a name="l00377"></a>00377 <span class="preprocessor"></span><span class="preprocessor">#  else</span>
<a name="l00378"></a>00378 <span class="preprocessor"></span>XXH_FORCE_INLINE xxh_u64x2 XXH_vec_revb(xxh_u64x2 val)
<a name="l00379"></a>00379 {
<a name="l00380"></a>00380     xxh_u8x16 <span class="keyword">const</span> vByteSwap = { 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
<a name="l00381"></a>00381                                   0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08 };
<a name="l00382"></a>00382     <span class="keywordflow">return</span> vec_perm(val, val, vByteSwap);
<a name="l00383"></a>00383 }
<a name="l00384"></a>00384 <span class="preprocessor">#  endif</span>
<a name="l00385"></a>00385 <span class="preprocessor"></span><span class="preprocessor"># endif </span><span class="comment">/* XXH_VSX_BE */</span>
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 <span class="comment">/*</span>
<a name="l00388"></a>00388 <span class="comment"> * Performs an unaligned load and byte swaps it on big endian.</span>
<a name="l00389"></a>00389 <span class="comment"> */</span>
<a name="l00390"></a>00390 XXH_FORCE_INLINE xxh_u64x2 XXH_vec_loadu(<span class="keyword">const</span> <span class="keywordtype">void</span> *ptr)
<a name="l00391"></a>00391 {
<a name="l00392"></a>00392     xxh_u64x2 ret;
<a name="l00393"></a>00393     memcpy(&amp;ret, ptr, <span class="keyword">sizeof</span>(xxh_u64x2));
<a name="l00394"></a>00394 <span class="preprocessor"># if XXH_VSX_BE</span>
<a name="l00395"></a>00395 <span class="preprocessor"></span>    ret = XXH_vec_revb(ret);
<a name="l00396"></a>00396 <span class="preprocessor"># endif</span>
<a name="l00397"></a>00397 <span class="preprocessor"></span>    <span class="keywordflow">return</span> ret;
<a name="l00398"></a>00398 }
<a name="l00399"></a>00399 
<a name="l00400"></a>00400 <span class="comment">/*</span>
<a name="l00401"></a>00401 <span class="comment"> * vec_mulo and vec_mule are very problematic intrinsics on PowerPC</span>
<a name="l00402"></a>00402 <span class="comment"> *</span>
<a name="l00403"></a>00403 <span class="comment"> * These intrinsics weren&#39;t added until GCC 8, despite existing for a while,</span>
<a name="l00404"></a>00404 <span class="comment"> * and they are endian dependent. Also, their meaning swap depending on version.</span>
<a name="l00405"></a>00405 <span class="comment"> * */</span>
<a name="l00406"></a>00406 <span class="preprocessor"># if defined(__s390x__)</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span> <span class="comment">/* s390x is always big endian, no issue on this platform */</span>
<a name="l00408"></a>00408 <span class="preprocessor">#  define XXH_vec_mulo vec_mulo</span>
<a name="l00409"></a>00409 <span class="preprocessor"></span><span class="preprocessor">#  define XXH_vec_mule vec_mule</span>
<a name="l00410"></a>00410 <span class="preprocessor"></span><span class="preprocessor"># elif defined(__clang__) &amp;&amp; XXH_HAS_BUILTIN(__builtin_altivec_vmuleuw)</span>
<a name="l00411"></a>00411 <span class="preprocessor"></span><span class="comment">/* Clang has a better way to control this, we can just use the builtin which doesn&#39;t swap. */</span>
<a name="l00412"></a>00412 <span class="preprocessor">#  define XXH_vec_mulo __builtin_altivec_vmulouw</span>
<a name="l00413"></a>00413 <span class="preprocessor"></span><span class="preprocessor">#  define XXH_vec_mule __builtin_altivec_vmuleuw</span>
<a name="l00414"></a>00414 <span class="preprocessor"></span><span class="preprocessor"># else</span>
<a name="l00415"></a>00415 <span class="preprocessor"></span><span class="comment">/* gcc needs inline assembly */</span>
<a name="l00416"></a>00416 <span class="comment">/* Adapted from https://github.com/google/highwayhash/blob/master/highwayhash/hh_vsx.h. */</span>
<a name="l00417"></a>00417 XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mulo(xxh_u32x4 a, xxh_u32x4 b)
<a name="l00418"></a>00418 {
<a name="l00419"></a>00419     xxh_u64x2 result;
<a name="l00420"></a>00420     __asm__(<span class="stringliteral">&quot;vmulouw %0, %1, %2&quot;</span> : <span class="stringliteral">&quot;=v&quot;</span> (result) : <span class="stringliteral">&quot;v&quot;</span> (a), <span class="stringliteral">&quot;v&quot;</span> (b));
<a name="l00421"></a>00421     <span class="keywordflow">return</span> result;
<a name="l00422"></a>00422 }
<a name="l00423"></a>00423 XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mule(xxh_u32x4 a, xxh_u32x4 b)
<a name="l00424"></a>00424 {
<a name="l00425"></a>00425     xxh_u64x2 result;
<a name="l00426"></a>00426     __asm__(<span class="stringliteral">&quot;vmuleuw %0, %1, %2&quot;</span> : <span class="stringliteral">&quot;=v&quot;</span> (result) : <span class="stringliteral">&quot;v&quot;</span> (a), <span class="stringliteral">&quot;v&quot;</span> (b));
<a name="l00427"></a>00427     <span class="keywordflow">return</span> result;
<a name="l00428"></a>00428 }
<a name="l00429"></a>00429 <span class="preprocessor"># endif </span><span class="comment">/* XXH_vec_mulo, XXH_vec_mule */</span>
<a name="l00430"></a>00430 <span class="preprocessor">#endif </span><span class="comment">/* XXH_VECTOR == XXH_VSX */</span>
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 
<a name="l00433"></a>00433 <span class="comment">/* prefetch</span>
<a name="l00434"></a>00434 <span class="comment"> * can be disabled, by declaring XXH_NO_PREFETCH build macro */</span>
<a name="l00435"></a>00435 <span class="preprocessor">#if defined(XXH_NO_PREFETCH)</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span><span class="preprocessor">#  define XXH_PREFETCH(ptr)  (void)(ptr)  </span><span class="comment">/* disabled */</span>
<a name="l00437"></a>00437 <span class="preprocessor">#else</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span><span class="preprocessor">#  if defined(_MSC_VER) &amp;&amp; (defined(_M_X64) || defined(_M_I86))  </span><span class="comment">/* _mm_prefetch() is not defined outside of x86/x64 */</span>
<a name="l00439"></a>00439 <span class="preprocessor">#    include &lt;mmintrin.h&gt;</span>   <span class="comment">/* https://msdn.microsoft.com/fr-fr/library/84szxsww(v=vs.90).aspx */</span>
<a name="l00440"></a>00440 <span class="preprocessor">#    define XXH_PREFETCH(ptr)  _mm_prefetch((const char*)(ptr), _MM_HINT_T0)</span>
<a name="l00441"></a>00441 <span class="preprocessor"></span><span class="preprocessor">#  elif defined(__GNUC__) &amp;&amp; ( (__GNUC__ &gt;= 4) || ( (__GNUC__ == 3) &amp;&amp; (__GNUC_MINOR__ &gt;= 1) ) )</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_PREFETCH(ptr)  __builtin_prefetch((ptr), 0 </span><span class="comment">/* rw==read */</span>, 3 <span class="comment">/* locality */</span>)
<a name="l00443"></a>00443 <span class="preprocessor">#  else</span>
<a name="l00444"></a>00444 <span class="preprocessor"></span><span class="preprocessor">#    define XXH_PREFETCH(ptr) (void)(ptr)  </span><span class="comment">/* disabled */</span>
<a name="l00445"></a>00445 <span class="preprocessor">#  endif</span>
<a name="l00446"></a>00446 <span class="preprocessor"></span><span class="preprocessor">#endif  </span><span class="comment">/* XXH_NO_PREFETCH */</span>
<a name="l00447"></a>00447 
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 <span class="comment">/* ==========================================</span>
<a name="l00450"></a>00450 <span class="comment"> * XXH3 default settings</span>
<a name="l00451"></a>00451 <span class="comment"> * ========================================== */</span>
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 <span class="preprocessor">#define XXH_SECRET_DEFAULT_SIZE 192   </span><span class="comment">/* minimum XXH3_SECRET_SIZE_MIN */</span>
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 <span class="preprocessor">#if (XXH_SECRET_DEFAULT_SIZE &lt; XXH3_SECRET_SIZE_MIN)</span>
<a name="l00456"></a>00456 <span class="preprocessor"></span><span class="preprocessor">#  error &quot;default keyset is not large enough&quot;</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00458"></a>00458 <span class="preprocessor"></span>
<a name="l00459"></a>00459 <span class="comment">/* Pseudorandom secret taken directly from FARSH */</span>
<a name="l00460"></a>00460 XXH_ALIGN(64) static const xxh_u8 XXH3_kSecret[XXH_SECRET_DEFAULT_SIZE] = {
<a name="l00461"></a>00461     0xb8, 0xfe, 0x6c, 0x39, 0x23, 0xa4, 0x4b, 0xbe, 0x7c, 0x01, 0x81, 0x2c, 0xf7, 0x21, 0xad, 0x1c,
<a name="l00462"></a>00462     0xde, 0xd4, 0x6d, 0xe9, 0x83, 0x90, 0x97, 0xdb, 0x72, 0x40, 0xa4, 0xa4, 0xb7, 0xb3, 0x67, 0x1f,
<a name="l00463"></a>00463     0xcb, 0x79, 0xe6, 0x4e, 0xcc, 0xc0, 0xe5, 0x78, 0x82, 0x5a, 0xd0, 0x7d, 0xcc, 0xff, 0x72, 0x21,
<a name="l00464"></a>00464     0xb8, 0x08, 0x46, 0x74, 0xf7, 0x43, 0x24, 0x8e, 0xe0, 0x35, 0x90, 0xe6, 0x81, 0x3a, 0x26, 0x4c,
<a name="l00465"></a>00465     0x3c, 0x28, 0x52, 0xbb, 0x91, 0xc3, 0x00, 0xcb, 0x88, 0xd0, 0x65, 0x8b, 0x1b, 0x53, 0x2e, 0xa3,
<a name="l00466"></a>00466     0x71, 0x64, 0x48, 0x97, 0xa2, 0x0d, 0xf9, 0x4e, 0x38, 0x19, 0xef, 0x46, 0xa9, 0xde, 0xac, 0xd8,
<a name="l00467"></a>00467     0xa8, 0xfa, 0x76, 0x3f, 0xe3, 0x9c, 0x34, 0x3f, 0xf9, 0xdc, 0xbb, 0xc7, 0xc7, 0x0b, 0x4f, 0x1d,
<a name="l00468"></a>00468     0x8a, 0x51, 0xe0, 0x4b, 0xcd, 0xb4, 0x59, 0x31, 0xc8, 0x9f, 0x7e, 0xc9, 0xd9, 0x78, 0x73, 0x64,
<a name="l00469"></a>00469 
<a name="l00470"></a>00470     0xea, 0xc5, 0xac, 0x83, 0x34, 0xd3, 0xeb, 0xc3, 0xc5, 0x81, 0xa0, 0xff, 0xfa, 0x13, 0x63, 0xeb,
<a name="l00471"></a>00471     0x17, 0x0d, 0xdd, 0x51, 0xb7, 0xf0, 0xda, 0x49, 0xd3, 0x16, 0x55, 0x26, 0x29, 0xd4, 0x68, 0x9e,
<a name="l00472"></a>00472     0x2b, 0x16, 0xbe, 0x58, 0x7d, 0x47, 0xa1, 0xfc, 0x8f, 0xf8, 0xb8, 0xd1, 0x7a, 0xd0, 0x31, 0xce,
<a name="l00473"></a>00473     0x45, 0xcb, 0x3a, 0x8f, 0x95, 0x16, 0x04, 0x28, 0xaf, 0xd7, 0xfb, 0xca, 0xbb, 0x4b, 0x40, 0x7e,
<a name="l00474"></a>00474 };
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="preprocessor">#ifdef XXH_OLD_NAMES</span>
<a name="l00477"></a>00477 <span class="preprocessor"></span><span class="preprocessor">#  define kSecret XXH3_kSecret</span>
<a name="l00478"></a>00478 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span>
<a name="l00480"></a>00480 <span class="comment">/*</span>
<a name="l00481"></a>00481 <span class="comment"> * Calculates a 32-bit to 64-bit long multiply.</span>
<a name="l00482"></a>00482 <span class="comment"> *</span>
<a name="l00483"></a>00483 <span class="comment"> * Wraps __emulu on MSVC x86 because it tends to call __allmul when it doesn&#39;t</span>
<a name="l00484"></a>00484 <span class="comment"> * need to (but it shouldn&#39;t need to anyways, it is about 7 instructions to do</span>
<a name="l00485"></a>00485 <span class="comment"> * a 64x64 multiply...). Since we know that this will _always_ emit MULL, we</span>
<a name="l00486"></a>00486 <span class="comment"> * use that instead of the normal method.</span>
<a name="l00487"></a>00487 <span class="comment"> *</span>
<a name="l00488"></a>00488 <span class="comment"> * If you are compiling for platforms like Thumb-1 and don&#39;t have a better option,</span>
<a name="l00489"></a>00489 <span class="comment"> * you may also want to write your own long multiply routine here.</span>
<a name="l00490"></a>00490 <span class="comment"> *</span>
<a name="l00491"></a>00491 <span class="comment"> * XXH_FORCE_INLINE xxh_u64 XXH_mult32to64(xxh_u64 x, xxh_u64 y)</span>
<a name="l00492"></a>00492 <span class="comment"> * {</span>
<a name="l00493"></a>00493 <span class="comment"> *    return (x &amp; 0xFFFFFFFF) * (y &amp; 0xFFFFFFFF);</span>
<a name="l00494"></a>00494 <span class="comment"> * }</span>
<a name="l00495"></a>00495 <span class="comment"> */</span>
<a name="l00496"></a>00496 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; defined(_M_IX86)</span>
<a name="l00497"></a>00497 <span class="preprocessor"></span><span class="preprocessor">#    include &lt;intrin.h&gt;</span>
<a name="l00498"></a>00498 <span class="preprocessor">#    define XXH_mult32to64(x, y) __emulu((unsigned)(x), (unsigned)(y))</span>
<a name="l00499"></a>00499 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00500"></a>00500 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00501"></a>00501 <span class="comment"> * Downcast + upcast is usually better than masking on older compilers like</span>
<a name="l00502"></a>00502 <span class="comment"> * GCC 4.2 (especially 32-bit ones), all without affecting newer compilers.</span>
<a name="l00503"></a>00503 <span class="comment"> *</span>
<a name="l00504"></a>00504 <span class="comment"> * The other method, (x &amp; 0xFFFFFFFF) * (y &amp; 0xFFFFFFFF), will AND both operands</span>
<a name="l00505"></a>00505 <span class="comment"> * and perform a full 64x64 multiply -- entirely redundant on 32-bit.</span>
<a name="l00506"></a>00506 <span class="comment"> */</span>
<a name="l00507"></a>00507 <span class="preprocessor">#    define XXH_mult32to64(x, y) ((xxh_u64)(xxh_u32)(x) * (xxh_u64)(xxh_u32)(y))</span>
<a name="l00508"></a>00508 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00509"></a>00509 <span class="preprocessor"></span>
<a name="l00510"></a>00510 <span class="comment">/*</span>
<a name="l00511"></a>00511 <span class="comment"> * Calculates a 64-&gt;128-bit long multiply.</span>
<a name="l00512"></a>00512 <span class="comment"> *</span>
<a name="l00513"></a>00513 <span class="comment"> * Uses __uint128_t and _umul128 if available, otherwise uses a scalar version.</span>
<a name="l00514"></a>00514 <span class="comment"> */</span>
<a name="l00515"></a>00515 <span class="keyword">static</span> XXH128_hash_t
<a name="l00516"></a>00516 XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
<a name="l00517"></a>00517 {
<a name="l00518"></a>00518     <span class="comment">/*</span>
<a name="l00519"></a>00519 <span class="comment">     * GCC/Clang __uint128_t method.</span>
<a name="l00520"></a>00520 <span class="comment">     *</span>
<a name="l00521"></a>00521 <span class="comment">     * On most 64-bit targets, GCC and Clang define a __uint128_t type.</span>
<a name="l00522"></a>00522 <span class="comment">     * This is usually the best way as it usually uses a native long 64-bit</span>
<a name="l00523"></a>00523 <span class="comment">     * multiply, such as MULQ on x86_64 or MUL + UMULH on aarch64.</span>
<a name="l00524"></a>00524 <span class="comment">     *</span>
<a name="l00525"></a>00525 <span class="comment">     * Usually.</span>
<a name="l00526"></a>00526 <span class="comment">     *</span>
<a name="l00527"></a>00527 <span class="comment">     * Despite being a 32-bit platform, Clang (and emscripten) define this type</span>
<a name="l00528"></a>00528 <span class="comment">     * despite not having the arithmetic for it. This results in a laggy</span>
<a name="l00529"></a>00529 <span class="comment">     * compiler builtin call which calculates a full 128-bit multiply.</span>
<a name="l00530"></a>00530 <span class="comment">     * In that case it is best to use the portable one.</span>
<a name="l00531"></a>00531 <span class="comment">     * https://github.com/Cyan4973/xxHash/issues/211#issuecomment-515575677</span>
<a name="l00532"></a>00532 <span class="comment">     */</span>
<a name="l00533"></a>00533 <span class="preprocessor">#if defined(__GNUC__) &amp;&amp; !defined(__wasm__) \</span>
<a name="l00534"></a>00534 <span class="preprocessor">    &amp;&amp; defined(__SIZEOF_INT128__) \</span>
<a name="l00535"></a>00535 <span class="preprocessor">    || (defined(_INTEGRAL_MAX_BITS) &amp;&amp; _INTEGRAL_MAX_BITS &gt;= 128)</span>
<a name="l00536"></a>00536 <span class="preprocessor"></span>
<a name="l00537"></a>00537     __uint128_t <span class="keyword">const</span> product = (__uint128_t)lhs * (__uint128_t)rhs;
<a name="l00538"></a>00538     XXH128_hash_t r128;
<a name="l00539"></a>00539     r128.low64  = (xxh_u64)(product);
<a name="l00540"></a>00540     r128.high64 = (xxh_u64)(product &gt;&gt; 64);
<a name="l00541"></a>00541     <span class="keywordflow">return</span> r128;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543     <span class="comment">/*</span>
<a name="l00544"></a>00544 <span class="comment">     * MSVC for x64&#39;s _umul128 method.</span>
<a name="l00545"></a>00545 <span class="comment">     *</span>
<a name="l00546"></a>00546 <span class="comment">     * xxh_u64 _umul128(xxh_u64 Multiplier, xxh_u64 Multiplicand, xxh_u64 *HighProduct);</span>
<a name="l00547"></a>00547 <span class="comment">     *</span>
<a name="l00548"></a>00548 <span class="comment">     * This compiles to single operand MUL on x64.</span>
<a name="l00549"></a>00549 <span class="comment">     */</span>
<a name="l00550"></a>00550 <span class="preprocessor">#elif defined(_M_X64) || defined(_M_IA64)</span>
<a name="l00551"></a>00551 <span class="preprocessor"></span>
<a name="l00552"></a>00552 <span class="preprocessor">#ifndef _MSC_VER</span>
<a name="l00553"></a>00553 <span class="preprocessor"></span><span class="preprocessor">#   pragma intrinsic(_umul128)</span>
<a name="l00554"></a>00554 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00555"></a>00555 <span class="preprocessor"></span>    xxh_u64 product_high;
<a name="l00556"></a>00556     xxh_u64 <span class="keyword">const</span> product_low = _umul128(lhs, rhs, &amp;product_high);
<a name="l00557"></a>00557     XXH128_hash_t r128;
<a name="l00558"></a>00558     r128.low64  = product_low;
<a name="l00559"></a>00559     r128.high64 = product_high;
<a name="l00560"></a>00560     <span class="keywordflow">return</span> r128;
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="preprocessor">#else</span>
<a name="l00563"></a>00563 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l00564"></a>00564 <span class="comment">     * Portable scalar method. Optimized for 32-bit and 64-bit ALUs.</span>
<a name="l00565"></a>00565 <span class="comment">     *</span>
<a name="l00566"></a>00566 <span class="comment">     * This is a fast and simple grade school multiply, which is shown below</span>
<a name="l00567"></a>00567 <span class="comment">     * with base 10 arithmetic instead of base 0x100000000.</span>
<a name="l00568"></a>00568 <span class="comment">     *</span>
<a name="l00569"></a>00569 <span class="comment">     *           9 3 // D2 lhs = 93</span>
<a name="l00570"></a>00570 <span class="comment">     *         x 7 5 // D2 rhs = 75</span>
<a name="l00571"></a>00571 <span class="comment">     *     ----------</span>
<a name="l00572"></a>00572 <span class="comment">     *           1 5 // D2 lo_lo = (93 % 10) * (75 % 10) = 15</span>
<a name="l00573"></a>00573 <span class="comment">     *         4 5 | // D2 hi_lo = (93 / 10) * (75 % 10) = 45</span>
<a name="l00574"></a>00574 <span class="comment">     *         2 1 | // D2 lo_hi = (93 % 10) * (75 / 10) = 21</span>
<a name="l00575"></a>00575 <span class="comment">     *     + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10) = 63</span>
<a name="l00576"></a>00576 <span class="comment">     *     ---------</span>
<a name="l00577"></a>00577 <span class="comment">     *         2 7 | // D2 cross = (15 / 10) + (45 % 10) + 21 = 27</span>
<a name="l00578"></a>00578 <span class="comment">     *     + 6 7 | | // D2 upper = (27 / 10) + (45 / 10) + 63 = 67</span>
<a name="l00579"></a>00579 <span class="comment">     *     ---------</span>
<a name="l00580"></a>00580 <span class="comment">     *       6 9 7 5 // D4 res = (27 * 10) + (15 % 10) + (67 * 100) = 6975</span>
<a name="l00581"></a>00581 <span class="comment">     *</span>
<a name="l00582"></a>00582 <span class="comment">     * The reasons for adding the products like this are:</span>
<a name="l00583"></a>00583 <span class="comment">     *  1. It avoids manual carry tracking. Just like how</span>
<a name="l00584"></a>00584 <span class="comment">     *     (9 * 9) + 9 + 9 = 99, the same applies with this for UINT64_MAX.</span>
<a name="l00585"></a>00585 <span class="comment">     *     This avoids a lot of complexity.</span>
<a name="l00586"></a>00586 <span class="comment">     *</span>
<a name="l00587"></a>00587 <span class="comment">     *  2. It hints for, and on Clang, compiles to, the powerful UMAAL</span>
<a name="l00588"></a>00588 <span class="comment">     *     instruction available in ARM&#39;s Digital Signal Processing extension</span>
<a name="l00589"></a>00589 <span class="comment">     *     in 32-bit ARMv6 and later, which is shown below:</span>
<a name="l00590"></a>00590 <span class="comment">     *</span>
<a name="l00591"></a>00591 <span class="comment">     *         void UMAAL(xxh_u32 *RdLo, xxh_u32 *RdHi, xxh_u32 Rn, xxh_u32 Rm)</span>
<a name="l00592"></a>00592 <span class="comment">     *         {</span>
<a name="l00593"></a>00593 <span class="comment">     *             xxh_u64 product = (xxh_u64)*RdLo * (xxh_u64)*RdHi + Rn + Rm;</span>
<a name="l00594"></a>00594 <span class="comment">     *             *RdLo = (xxh_u32)(product &amp; 0xFFFFFFFF);</span>
<a name="l00595"></a>00595 <span class="comment">     *             *RdHi = (xxh_u32)(product &gt;&gt; 32);</span>
<a name="l00596"></a>00596 <span class="comment">     *         }</span>
<a name="l00597"></a>00597 <span class="comment">     *</span>
<a name="l00598"></a>00598 <span class="comment">     *     This instruction was designed for efficient long multiplication, and</span>
<a name="l00599"></a>00599 <span class="comment">     *     allows this to be calculated in only 4 instructions at speeds</span>
<a name="l00600"></a>00600 <span class="comment">     *     comparable to some 64-bit ALUs.</span>
<a name="l00601"></a>00601 <span class="comment">     *</span>
<a name="l00602"></a>00602 <span class="comment">     *  3. It isn&#39;t terrible on other platforms. Usually this will be a couple</span>
<a name="l00603"></a>00603 <span class="comment">     *     of 32-bit ADD/ADCs.</span>
<a name="l00604"></a>00604 <span class="comment">     */</span>
<a name="l00605"></a>00605 
<a name="l00606"></a>00606     <span class="comment">/* First calculate all of the cross products. */</span>
<a name="l00607"></a>00607     xxh_u64 <span class="keyword">const</span> lo_lo = XXH_mult32to64(lhs &amp; 0xFFFFFFFF, rhs &amp; 0xFFFFFFFF);
<a name="l00608"></a>00608     xxh_u64 <span class="keyword">const</span> hi_lo = XXH_mult32to64(lhs &gt;&gt; 32,        rhs &amp; 0xFFFFFFFF);
<a name="l00609"></a>00609     xxh_u64 <span class="keyword">const</span> lo_hi = XXH_mult32to64(lhs &amp; 0xFFFFFFFF, rhs &gt;&gt; 32);
<a name="l00610"></a>00610     xxh_u64 <span class="keyword">const</span> hi_hi = XXH_mult32to64(lhs &gt;&gt; 32,        rhs &gt;&gt; 32);
<a name="l00611"></a>00611 
<a name="l00612"></a>00612     <span class="comment">/* Now add the products together. These will never overflow. */</span>
<a name="l00613"></a>00613     xxh_u64 <span class="keyword">const</span> cross = (lo_lo &gt;&gt; 32) + (hi_lo &amp; 0xFFFFFFFF) + lo_hi;
<a name="l00614"></a>00614     xxh_u64 <span class="keyword">const</span> upper = (hi_lo &gt;&gt; 32) + (cross &gt;&gt; 32)        + hi_hi;
<a name="l00615"></a>00615     xxh_u64 <span class="keyword">const</span> lower = (cross &lt;&lt; 32) | (lo_lo &amp; 0xFFFFFFFF);
<a name="l00616"></a>00616 
<a name="l00617"></a>00617     XXH128_hash_t r128;
<a name="l00618"></a>00618     r128.low64  = lower;
<a name="l00619"></a>00619     r128.high64 = upper;
<a name="l00620"></a>00620     <span class="keywordflow">return</span> r128;
<a name="l00621"></a>00621 <span class="preprocessor">#endif</span>
<a name="l00622"></a>00622 <span class="preprocessor"></span>}
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 <span class="comment">/*</span>
<a name="l00625"></a>00625 <span class="comment"> * Does a 64-bit to 128-bit multiply, then XOR folds it.</span>
<a name="l00626"></a>00626 <span class="comment"> *</span>
<a name="l00627"></a>00627 <span class="comment"> * The reason for the separate function is to prevent passing too many structs</span>
<a name="l00628"></a>00628 <span class="comment"> * around by value. This will hopefully inline the multiply, but we don&#39;t force it.</span>
<a name="l00629"></a>00629 <span class="comment"> */</span>
<a name="l00630"></a>00630 <span class="keyword">static</span> xxh_u64
<a name="l00631"></a>00631 XXH3_mul128_fold64(xxh_u64 lhs, xxh_u64 rhs)
<a name="l00632"></a>00632 {
<a name="l00633"></a>00633     XXH128_hash_t product = XXH_mult64to128(lhs, rhs);
<a name="l00634"></a>00634     <span class="keywordflow">return</span> product.low64 ^ product.high64;
<a name="l00635"></a>00635 }
<a name="l00636"></a>00636 
<a name="l00637"></a>00637 <span class="comment">/* Seems to produce slightly better code on GCC for some reason. */</span>
<a name="l00638"></a>00638 XXH_FORCE_INLINE xxh_u64 XXH_xorshift64(xxh_u64 v64, <span class="keywordtype">int</span> shift)
<a name="l00639"></a>00639 {
<a name="l00640"></a>00640     XXH_ASSERT(0 &lt;= shift &amp;&amp; shift &lt; 64);
<a name="l00641"></a>00641     <span class="keywordflow">return</span> v64 ^ (v64 &gt;&gt; shift);
<a name="l00642"></a>00642 }
<a name="l00643"></a>00643 
<a name="l00644"></a>00644 <span class="comment">/*</span>
<a name="l00645"></a>00645 <span class="comment"> * We don&#39;t need to (or want to) mix as much as XXH64.</span>
<a name="l00646"></a>00646 <span class="comment"> *</span>
<a name="l00647"></a>00647 <span class="comment"> * Short hashes are more evenly distributed, so it isn&#39;t necessary.</span>
<a name="l00648"></a>00648 <span class="comment"> */</span>
<a name="l00649"></a>00649 <span class="keyword">static</span> XXH64_hash_t XXH3_avalanche(xxh_u64 h64)
<a name="l00650"></a>00650 {
<a name="l00651"></a>00651     h64 = XXH_xorshift64(h64, 37);
<a name="l00652"></a>00652     h64 *= 0x165667919E3779F9ULL;
<a name="l00653"></a>00653     h64 = XXH_xorshift64(h64, 32);
<a name="l00654"></a>00654     <span class="keywordflow">return</span> h64;
<a name="l00655"></a>00655 }
<a name="l00656"></a>00656 
<a name="l00657"></a>00657 
<a name="l00658"></a>00658 <span class="comment">/* ==========================================</span>
<a name="l00659"></a>00659 <span class="comment"> * Short keys</span>
<a name="l00660"></a>00660 <span class="comment"> * ==========================================</span>
<a name="l00661"></a>00661 <span class="comment"> * One of the shortcomings of XXH32 and XXH64 was that their performance was</span>
<a name="l00662"></a>00662 <span class="comment"> * sub-optimal on short lengths. It used an iterative algorithm which strongly</span>
<a name="l00663"></a>00663 <span class="comment"> * favored lengths that were a multiple of 4 or 8.</span>
<a name="l00664"></a>00664 <span class="comment"> *</span>
<a name="l00665"></a>00665 <span class="comment"> * Instead of iterating over individual inputs, we use a set of single shot</span>
<a name="l00666"></a>00666 <span class="comment"> * functions which piece together a range of lengths and operate in constant time.</span>
<a name="l00667"></a>00667 <span class="comment"> *</span>
<a name="l00668"></a>00668 <span class="comment"> * Additionally, the number of multiplies has been significantly reduced. This</span>
<a name="l00669"></a>00669 <span class="comment"> * reduces latency, especially when emulating 64-bit multiplies on 32-bit.</span>
<a name="l00670"></a>00670 <span class="comment"> *</span>
<a name="l00671"></a>00671 <span class="comment"> * Depending on the platform, this may or may not be faster than XXH32, but it</span>
<a name="l00672"></a>00672 <span class="comment"> * is almost guaranteed to be faster than XXH64.</span>
<a name="l00673"></a>00673 <span class="comment"> */</span>
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 <span class="comment">/*</span>
<a name="l00676"></a>00676 <span class="comment"> * At very short lengths, there isn&#39;t enough input to fully hide secrets, or use</span>
<a name="l00677"></a>00677 <span class="comment"> * the entire secret.</span>
<a name="l00678"></a>00678 <span class="comment"> *</span>
<a name="l00679"></a>00679 <span class="comment"> * There is also only a limited amount of mixing we can do before significantly</span>
<a name="l00680"></a>00680 <span class="comment"> * impacting performance.</span>
<a name="l00681"></a>00681 <span class="comment"> *</span>
<a name="l00682"></a>00682 <span class="comment"> * Therefore, we use different sections of the secret and always mix two secret</span>
<a name="l00683"></a>00683 <span class="comment"> * samples with an XOR. This should have no effect on performance on the</span>
<a name="l00684"></a>00684 <span class="comment"> * seedless or withSeed variants because everything _should_ be constant folded</span>
<a name="l00685"></a>00685 <span class="comment"> * by modern compilers.</span>
<a name="l00686"></a>00686 <span class="comment"> *</span>
<a name="l00687"></a>00687 <span class="comment"> * The XOR mixing hides individual parts of the secret and increases entropy.</span>
<a name="l00688"></a>00688 <span class="comment"> *</span>
<a name="l00689"></a>00689 <span class="comment"> * This adds an extra layer of strength for custom secrets.</span>
<a name="l00690"></a>00690 <span class="comment"> */</span>
<a name="l00691"></a>00691 XXH_FORCE_INLINE XXH64_hash_t
<a name="l00692"></a>00692 XXH3_len_1to3_64b(<span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> xxh_u8* secret, XXH64_hash_t seed)
<a name="l00693"></a>00693 {
<a name="l00694"></a>00694     XXH_ASSERT(input != NULL);
<a name="l00695"></a>00695     XXH_ASSERT(1 &lt;= len &amp;&amp; len &lt;= 3);
<a name="l00696"></a>00696     XXH_ASSERT(secret != NULL);
<a name="l00697"></a>00697     <span class="comment">/*</span>
<a name="l00698"></a>00698 <span class="comment">     * len = 1: combined = { input[0], 0x01, input[0], input[0] }</span>
<a name="l00699"></a>00699 <span class="comment">     * len = 2: combined = { input[1], 0x02, input[0], input[1] }</span>
<a name="l00700"></a>00700 <span class="comment">     * len = 3: combined = { input[2], 0x03, input[0], input[1] }</span>
<a name="l00701"></a>00701 <span class="comment">     */</span>
<a name="l00702"></a>00702     {   xxh_u8 <span class="keyword">const</span> c1 = input[0];
<a name="l00703"></a>00703         xxh_u8 <span class="keyword">const</span> c2 = input[len &gt;&gt; 1];
<a name="l00704"></a>00704         xxh_u8 <span class="keyword">const</span> c3 = input[len - 1];
<a name="l00705"></a>00705         xxh_u32 <span class="keyword">const</span> combined = ((xxh_u32)c1 &lt;&lt; 16) | ((xxh_u32)c2  &lt;&lt; 24)
<a name="l00706"></a>00706                                | ((xxh_u32)c3 &lt;&lt;  0) | ((xxh_u32)len &lt;&lt; 8);
<a name="l00707"></a>00707         xxh_u64 <span class="keyword">const</span> bitflip = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
<a name="l00708"></a>00708         xxh_u64 <span class="keyword">const</span> keyed = (xxh_u64)combined ^ bitflip;
<a name="l00709"></a>00709         xxh_u64 <span class="keyword">const</span> mixed = keyed * XXH_PRIME64_1;
<a name="l00710"></a>00710         <span class="keywordflow">return</span> XXH3_avalanche(mixed);
<a name="l00711"></a>00711     }
<a name="l00712"></a>00712 }
<a name="l00713"></a>00713 
<a name="l00714"></a>00714 XXH_FORCE_INLINE XXH64_hash_t
<a name="l00715"></a>00715 XXH3_len_4to8_64b(<span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> xxh_u8* secret, XXH64_hash_t seed)
<a name="l00716"></a>00716 {
<a name="l00717"></a>00717     XXH_ASSERT(input != NULL);
<a name="l00718"></a>00718     XXH_ASSERT(secret != NULL);
<a name="l00719"></a>00719     XXH_ASSERT(4 &lt;= len &amp;&amp; len &lt; 8);
<a name="l00720"></a>00720     seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) &lt;&lt; 32;
<a name="l00721"></a>00721     {   xxh_u32 <span class="keyword">const</span> input1 = XXH_readLE32(input);
<a name="l00722"></a>00722         xxh_u32 <span class="keyword">const</span> input2 = XXH_readLE32(input + len - 4);
<a name="l00723"></a>00723         xxh_u64 <span class="keyword">const</span> bitflip = (XXH_readLE64(secret+8) ^ XXH_readLE64(secret+16)) - seed;
<a name="l00724"></a>00724         xxh_u64 <span class="keyword">const</span> input64 = input2 + (((xxh_u64)input1) &lt;&lt; 32);
<a name="l00725"></a>00725         xxh_u64 x = input64 ^ bitflip;
<a name="l00726"></a>00726         <span class="comment">/* this mix is inspired by Pelle Evensen&#39;s rrmxmx */</span>
<a name="l00727"></a>00727         x ^= XXH_rotl64(x, 49) ^ XXH_rotl64(x, 24);
<a name="l00728"></a>00728         x *= 0x9FB21C651E98DF25ULL;
<a name="l00729"></a>00729         x ^= (x &gt;&gt; 35) + len ;
<a name="l00730"></a>00730         x *= 0x9FB21C651E98DF25ULL;
<a name="l00731"></a>00731         <span class="keywordflow">return</span> XXH_xorshift64(x, 28);
<a name="l00732"></a>00732     }
<a name="l00733"></a>00733 }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735 XXH_FORCE_INLINE XXH64_hash_t
<a name="l00736"></a>00736 XXH3_len_9to16_64b(<span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> xxh_u8* secret, XXH64_hash_t seed)
<a name="l00737"></a>00737 {
<a name="l00738"></a>00738     XXH_ASSERT(input != NULL);
<a name="l00739"></a>00739     XXH_ASSERT(secret != NULL);
<a name="l00740"></a>00740     XXH_ASSERT(8 &lt;= len &amp;&amp; len &lt;= 16);
<a name="l00741"></a>00741     {   xxh_u64 <span class="keyword">const</span> bitflip1 = (XXH_readLE64(secret+24) ^ XXH_readLE64(secret+32)) + seed;
<a name="l00742"></a>00742         xxh_u64 <span class="keyword">const</span> bitflip2 = (XXH_readLE64(secret+40) ^ XXH_readLE64(secret+48)) - seed;
<a name="l00743"></a>00743         xxh_u64 <span class="keyword">const</span> input_lo = XXH_readLE64(input)           ^ bitflip1;
<a name="l00744"></a>00744         xxh_u64 <span class="keyword">const</span> input_hi = XXH_readLE64(input + len - 8) ^ bitflip2;
<a name="l00745"></a>00745         xxh_u64 <span class="keyword">const</span> acc = len
<a name="l00746"></a>00746                           + XXH_swap64(input_lo) + input_hi
<a name="l00747"></a>00747                           + XXH3_mul128_fold64(input_lo, input_hi);
<a name="l00748"></a>00748         <span class="keywordflow">return</span> XXH3_avalanche(acc);
<a name="l00749"></a>00749     }
<a name="l00750"></a>00750 }
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 XXH_FORCE_INLINE XXH64_hash_t
<a name="l00753"></a>00753 XXH3_len_0to16_64b(<span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> xxh_u8* secret, XXH64_hash_t seed)
<a name="l00754"></a>00754 {
<a name="l00755"></a>00755     XXH_ASSERT(len &lt;= 16);
<a name="l00756"></a>00756     {   <span class="keywordflow">if</span> (XXH_likely(len &gt;  8)) <span class="keywordflow">return</span> XXH3_len_9to16_64b(input, len, secret, seed);
<a name="l00757"></a>00757         <span class="keywordflow">if</span> (XXH_likely(len &gt;= 4)) <span class="keywordflow">return</span> XXH3_len_4to8_64b(input, len, secret, seed);
<a name="l00758"></a>00758         <span class="keywordflow">if</span> (len) <span class="keywordflow">return</span> XXH3_len_1to3_64b(input, len, secret, seed);
<a name="l00759"></a>00759         <span class="keywordflow">return</span> XXH3_avalanche((XXH_PRIME64_1 + seed) ^ (XXH_readLE64(secret+56) ^ XXH_readLE64(secret+64)));
<a name="l00760"></a>00760     }
<a name="l00761"></a>00761 }
<a name="l00762"></a>00762 
<a name="l00763"></a>00763 <span class="comment">/*</span>
<a name="l00764"></a>00764 <span class="comment"> * DISCLAIMER: There are known *seed-dependent* multicollisions here due to</span>
<a name="l00765"></a>00765 <span class="comment"> * multiplication by zero, affecting hashes of lengths 17 to 240.</span>
<a name="l00766"></a>00766 <span class="comment"> *</span>
<a name="l00767"></a>00767 <span class="comment"> * However, they are very unlikely.</span>
<a name="l00768"></a>00768 <span class="comment"> *</span>
<a name="l00769"></a>00769 <span class="comment"> * Keep this in mind when using the unseeded XXH3_64bits() variant: As with all</span>
<a name="l00770"></a>00770 <span class="comment"> * unseeded non-cryptographic hashes, it does not attempt to defend itself</span>
<a name="l00771"></a>00771 <span class="comment"> * against specially crafted inputs, only random inputs.</span>
<a name="l00772"></a>00772 <span class="comment"> *</span>
<a name="l00773"></a>00773 <span class="comment"> * Compared to classic UMAC where a 1 in 2^31 chance of 4 consecutive bytes</span>
<a name="l00774"></a>00774 <span class="comment"> * cancelling out the secret is taken an arbitrary number of times (addressed</span>
<a name="l00775"></a>00775 <span class="comment"> * in XXH3_accumulate_512), this collision is very unlikely with random inputs</span>
<a name="l00776"></a>00776 <span class="comment"> * and/or proper seeding:</span>
<a name="l00777"></a>00777 <span class="comment"> *</span>
<a name="l00778"></a>00778 <span class="comment"> * This only has a 1 in 2^63 chance of 8 consecutive bytes cancelling out, in a</span>
<a name="l00779"></a>00779 <span class="comment"> * function that is only called up to 16 times per hash with up to 240 bytes of</span>
<a name="l00780"></a>00780 <span class="comment"> * input.</span>
<a name="l00781"></a>00781 <span class="comment"> *</span>
<a name="l00782"></a>00782 <span class="comment"> * This is not too bad for a non-cryptographic hash function, especially with</span>
<a name="l00783"></a>00783 <span class="comment"> * only 64 bit outputs.</span>
<a name="l00784"></a>00784 <span class="comment"> *</span>
<a name="l00785"></a>00785 <span class="comment"> * The 128-bit variant (which trades some speed for strength) is NOT affected</span>
<a name="l00786"></a>00786 <span class="comment"> * by this, although it is always a good idea to use a proper seed if you care</span>
<a name="l00787"></a>00787 <span class="comment"> * about strength.</span>
<a name="l00788"></a>00788 <span class="comment"> */</span>
<a name="l00789"></a>00789 XXH_FORCE_INLINE xxh_u64 XXH3_mix16B(<span class="keyword">const</span> xxh_u8* XXH_RESTRICT input,
<a name="l00790"></a>00790                                      <span class="keyword">const</span> xxh_u8* XXH_RESTRICT secret, xxh_u64 seed64)
<a name="l00791"></a>00791 {
<a name="l00792"></a>00792 <span class="preprocessor">#if defined(__GNUC__) &amp;&amp; !defined(__clang__) </span><span class="comment">/* GCC, not Clang */</span> \
<a name="l00793"></a>00793   &amp;&amp; defined(__i386__) &amp;&amp; defined(__SSE2__)  <span class="comment">/* x86 + SSE2 */</span> \
<a name="l00794"></a>00794   &amp;&amp; !defined(XXH_ENABLE_AUTOVECTORIZE)      <span class="comment">/* Define to disable like XXH32 hack */</span>
<a name="l00795"></a>00795     <span class="comment">/*</span>
<a name="l00796"></a>00796 <span class="comment">     * UGLY HACK:</span>
<a name="l00797"></a>00797 <span class="comment">     * GCC for x86 tends to autovectorize the 128-bit multiply, resulting in</span>
<a name="l00798"></a>00798 <span class="comment">     * slower code.</span>
<a name="l00799"></a>00799 <span class="comment">     *</span>
<a name="l00800"></a>00800 <span class="comment">     * By forcing seed64 into a register, we disrupt the cost model and</span>
<a name="l00801"></a>00801 <span class="comment">     * cause it to scalarize. See `XXH32_round()`</span>
<a name="l00802"></a>00802 <span class="comment">     *</span>
<a name="l00803"></a>00803 <span class="comment">     * FIXME: Clang&#39;s output is still _much_ faster -- On an AMD Ryzen 3600,</span>
<a name="l00804"></a>00804 <span class="comment">     * XXH3_64bits @ len=240 runs at 4.6 GB/s with Clang 9, but 3.3 GB/s on</span>
<a name="l00805"></a>00805 <span class="comment">     * GCC 9.2, despite both emitting scalar code.</span>
<a name="l00806"></a>00806 <span class="comment">     *</span>
<a name="l00807"></a>00807 <span class="comment">     * GCC generates much better scalar code than Clang for the rest of XXH3,</span>
<a name="l00808"></a>00808 <span class="comment">     * which is why finding a more optimal codepath is an interest.</span>
<a name="l00809"></a>00809 <span class="comment">     */</span>
<a name="l00810"></a>00810     __asm__ (<span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;+r&quot;</span> (seed64));
<a name="l00811"></a>00811 <span class="preprocessor">#endif</span>
<a name="l00812"></a>00812 <span class="preprocessor"></span>    {   xxh_u64 <span class="keyword">const</span> input_lo = XXH_readLE64(input);
<a name="l00813"></a>00813         xxh_u64 <span class="keyword">const</span> input_hi = XXH_readLE64(input+8);
<a name="l00814"></a>00814         <span class="keywordflow">return</span> XXH3_mul128_fold64(
<a name="l00815"></a>00815             input_lo ^ (XXH_readLE64(secret)   + seed64),
<a name="l00816"></a>00816             input_hi ^ (XXH_readLE64(secret+8) - seed64)
<a name="l00817"></a>00817         );
<a name="l00818"></a>00818     }
<a name="l00819"></a>00819 }
<a name="l00820"></a>00820 
<a name="l00821"></a>00821 <span class="comment">/* For mid range keys, XXH3 uses a Mum-hash variant. */</span>
<a name="l00822"></a>00822 XXH_FORCE_INLINE XXH64_hash_t
<a name="l00823"></a>00823 XXH3_len_17to128_64b(<span class="keyword">const</span> xxh_u8* XXH_RESTRICT input, <span class="keywordtype">size_t</span> len,
<a name="l00824"></a>00824                      <span class="keyword">const</span> xxh_u8* XXH_RESTRICT secret, <span class="keywordtype">size_t</span> secretSize,
<a name="l00825"></a>00825                      XXH64_hash_t seed)
<a name="l00826"></a>00826 {
<a name="l00827"></a>00827     XXH_ASSERT(secretSize &gt;= XXH3_SECRET_SIZE_MIN); (void)secretSize;
<a name="l00828"></a>00828     XXH_ASSERT(16 &lt; len &amp;&amp; len &lt;= 128);
<a name="l00829"></a>00829 
<a name="l00830"></a>00830     {   xxh_u64 acc = len * XXH_PRIME64_1;
<a name="l00831"></a>00831         <span class="keywordflow">if</span> (len &gt; 32) {
<a name="l00832"></a>00832             <span class="keywordflow">if</span> (len &gt; 64) {
<a name="l00833"></a>00833                 <span class="keywordflow">if</span> (len &gt; 96) {
<a name="l00834"></a>00834                     acc += XXH3_mix16B(input+48, secret+96, seed);
<a name="l00835"></a>00835                     acc += XXH3_mix16B(input+len-64, secret+112, seed);
<a name="l00836"></a>00836                 }
<a name="l00837"></a>00837                 acc += XXH3_mix16B(input+32, secret+64, seed);
<a name="l00838"></a>00838                 acc += XXH3_mix16B(input+len-48, secret+80, seed);
<a name="l00839"></a>00839             }
<a name="l00840"></a>00840             acc += XXH3_mix16B(input+16, secret+32, seed);
<a name="l00841"></a>00841             acc += XXH3_mix16B(input+len-32, secret+48, seed);
<a name="l00842"></a>00842         }
<a name="l00843"></a>00843         acc += XXH3_mix16B(input+0, secret+0, seed);
<a name="l00844"></a>00844         acc += XXH3_mix16B(input+len-16, secret+16, seed);
<a name="l00845"></a>00845 
<a name="l00846"></a>00846         <span class="keywordflow">return</span> XXH3_avalanche(acc);
<a name="l00847"></a>00847     }
<a name="l00848"></a>00848 }
<a name="l00849"></a>00849 
<a name="l00850"></a>00850 <span class="preprocessor">#define XXH3_MIDSIZE_MAX 240</span>
<a name="l00851"></a>00851 <span class="preprocessor"></span>
<a name="l00852"></a>00852 XXH_NO_INLINE XXH64_hash_t
<a name="l00853"></a>00853 XXH3_len_129to240_64b(<span class="keyword">const</span> xxh_u8* XXH_RESTRICT input, <span class="keywordtype">size_t</span> len,
<a name="l00854"></a>00854                       <span class="keyword">const</span> xxh_u8* XXH_RESTRICT secret, <span class="keywordtype">size_t</span> secretSize,
<a name="l00855"></a>00855                       XXH64_hash_t seed)
<a name="l00856"></a>00856 {
<a name="l00857"></a>00857     XXH_ASSERT(secretSize &gt;= XXH3_SECRET_SIZE_MIN); (void)secretSize;
<a name="l00858"></a>00858     XXH_ASSERT(128 &lt; len &amp;&amp; len &lt;= XXH3_MIDSIZE_MAX);
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 <span class="preprocessor">    #define XXH3_MIDSIZE_STARTOFFSET 3</span>
<a name="l00861"></a>00861 <span class="preprocessor"></span><span class="preprocessor">    #define XXH3_MIDSIZE_LASTOFFSET  17</span>
<a name="l00862"></a>00862 <span class="preprocessor"></span>
<a name="l00863"></a>00863     {   xxh_u64 acc = len * XXH_PRIME64_1;
<a name="l00864"></a>00864         <span class="keywordtype">int</span> <span class="keyword">const</span> nbRounds = (int)len / 16;
<a name="l00865"></a>00865         <span class="keywordtype">int</span> i;
<a name="l00866"></a>00866         <span class="keywordflow">for</span> (i=0; i&lt;8; i++) {
<a name="l00867"></a>00867             acc += XXH3_mix16B(input+(16*i), secret+(16*i), seed);
<a name="l00868"></a>00868         }
<a name="l00869"></a>00869         acc = XXH3_avalanche(acc);
<a name="l00870"></a>00870         XXH_ASSERT(nbRounds &gt;= 8);
<a name="l00871"></a>00871 <span class="preprocessor">#if defined(__clang__)                                </span><span class="comment">/* Clang */</span> \
<a name="l00872"></a>00872     &amp;&amp; (defined(__ARM_NEON) || defined(__ARM_NEON__)) <span class="comment">/* NEON */</span> \
<a name="l00873"></a>00873     &amp;&amp; !defined(XXH_ENABLE_AUTOVECTORIZE)             <span class="comment">/* Define to disable */</span>
<a name="l00874"></a>00874         <span class="comment">/*</span>
<a name="l00875"></a>00875 <span class="comment">         * UGLY HACK:</span>
<a name="l00876"></a>00876 <span class="comment">         * Clang for ARMv7-A tries to vectorize this loop, similar to GCC x86.</span>
<a name="l00877"></a>00877 <span class="comment">         * In everywhere else, it uses scalar code.</span>
<a name="l00878"></a>00878 <span class="comment">         *</span>
<a name="l00879"></a>00879 <span class="comment">         * For 64-&gt;128-bit multiplies, even if the NEON was 100% optimal, it</span>
<a name="l00880"></a>00880 <span class="comment">         * would still be slower than UMAAL (see XXH_mult64to128).</span>
<a name="l00881"></a>00881 <span class="comment">         *</span>
<a name="l00882"></a>00882 <span class="comment">         * Unfortunately, Clang doesn&#39;t handle the long multiplies properly and</span>
<a name="l00883"></a>00883 <span class="comment">         * converts them to the nonexistent &quot;vmulq_u64&quot; intrinsic, which is then</span>
<a name="l00884"></a>00884 <span class="comment">         * scalarized into an ugly mess of VMOV.32 instructions.</span>
<a name="l00885"></a>00885 <span class="comment">         *</span>
<a name="l00886"></a>00886 <span class="comment">         * This mess is difficult to avoid without turning autovectorization</span>
<a name="l00887"></a>00887 <span class="comment">         * off completely, but they are usually relatively minor and/or not</span>
<a name="l00888"></a>00888 <span class="comment">         * worth it to fix.</span>
<a name="l00889"></a>00889 <span class="comment">         *</span>
<a name="l00890"></a>00890 <span class="comment">         * This loop is the easiest to fix, as unlike XXH32, this pragma</span>
<a name="l00891"></a>00891 <span class="comment">         * _actually works_ because it is a loop vectorization instead of an</span>
<a name="l00892"></a>00892 <span class="comment">         * SLP vectorization.</span>
<a name="l00893"></a>00893 <span class="comment">         */</span>
<a name="l00894"></a>00894 <span class="preprocessor">        #pragma clang loop vectorize(disable)</span>
<a name="l00895"></a>00895 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00896"></a>00896 <span class="preprocessor"></span>        <span class="keywordflow">for</span> (i=8 ; i &lt; nbRounds; i++) {
<a name="l00897"></a>00897             acc += XXH3_mix16B(input+(16*i), secret+(16*(i-8)) + XXH3_MIDSIZE_STARTOFFSET, seed);
<a name="l00898"></a>00898         }
<a name="l00899"></a>00899         <span class="comment">/* last bytes */</span>
<a name="l00900"></a>00900         acc += XXH3_mix16B(input + len - 16, secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET, seed);
<a name="l00901"></a>00901         <span class="keywordflow">return</span> XXH3_avalanche(acc);
<a name="l00902"></a>00902     }
<a name="l00903"></a>00903 }
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 
<a name="l00906"></a>00906 <span class="comment">/* ===    Long Keys    === */</span>
<a name="l00907"></a>00907 
<a name="l00908"></a>00908 <span class="preprocessor">#define XXH_STRIPE_LEN 64</span>
<a name="l00909"></a>00909 <span class="preprocessor"></span><span class="preprocessor">#define XXH_SECRET_CONSUME_RATE 8   </span><span class="comment">/* nb of secret bytes consumed at each accumulation */</span>
<a name="l00910"></a>00910 <span class="preprocessor">#define XXH_ACC_NB (XXH_STRIPE_LEN / sizeof(xxh_u64))</span>
<a name="l00911"></a>00911 <span class="preprocessor"></span>
<a name="l00912"></a>00912 <span class="preprocessor">#ifdef XXH_OLD_NAMES</span>
<a name="l00913"></a>00913 <span class="preprocessor"></span><span class="preprocessor">#  define STRIPE_LEN XXH_STRIPE_LEN</span>
<a name="l00914"></a>00914 <span class="preprocessor"></span><span class="preprocessor">#  define ACC_NB XXH_ACC_NB</span>
<a name="l00915"></a>00915 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00916"></a>00916 <span class="preprocessor"></span>
<a name="l00917"></a>00917 <span class="keyword">typedef</span> <span class="keyword">enum</span> { XXH3_acc_64bits, XXH3_acc_128bits } XXH3_accWidth_e;
<a name="l00918"></a>00918 
<a name="l00919"></a>00919 <span class="comment">/*</span>
<a name="l00920"></a>00920 <span class="comment"> * XXH3_accumulate_512 is the tightest loop for long inputs, and it is the most optimized.</span>
<a name="l00921"></a>00921 <span class="comment"> *</span>
<a name="l00922"></a>00922 <span class="comment"> * It is a hardened version of UMAC, based off of FARSH&#39;s implementation.</span>
<a name="l00923"></a>00923 <span class="comment"> *</span>
<a name="l00924"></a>00924 <span class="comment"> * This was chosen because it adapts quite well to 32-bit, 64-bit, and SIMD</span>
<a name="l00925"></a>00925 <span class="comment"> * implementations, and it is ridiculously fast.</span>
<a name="l00926"></a>00926 <span class="comment"> *</span>
<a name="l00927"></a>00927 <span class="comment"> * We harden it by mixing the original input to the accumulators as well as the product.</span>
<a name="l00928"></a>00928 <span class="comment"> *</span>
<a name="l00929"></a>00929 <span class="comment"> * This means that in the (relatively likely) case of a multiply by zero, the</span>
<a name="l00930"></a>00930 <span class="comment"> * original input is preserved.</span>
<a name="l00931"></a>00931 <span class="comment"> *</span>
<a name="l00932"></a>00932 <span class="comment"> * On 128-bit inputs, we swap 64-bit pairs when we add the input to improve</span>
<a name="l00933"></a>00933 <span class="comment"> * cross-pollination, as otherwise the upper and lower halves would be</span>
<a name="l00934"></a>00934 <span class="comment"> * essentially independent.</span>
<a name="l00935"></a>00935 <span class="comment"> *</span>
<a name="l00936"></a>00936 <span class="comment"> * This doesn&#39;t matter on 64-bit hashes since they all get merged together in</span>
<a name="l00937"></a>00937 <span class="comment"> * the end, so we skip the extra step.</span>
<a name="l00938"></a>00938 <span class="comment"> *</span>
<a name="l00939"></a>00939 <span class="comment"> * Both XXH3_64bits and XXH3_128bits use this subroutine.</span>
<a name="l00940"></a>00940 <span class="comment"> */</span>
<a name="l00941"></a>00941 XXH_FORCE_INLINE <span class="keywordtype">void</span>
<a name="l00942"></a>00942 XXH3_accumulate_512(      <span class="keywordtype">void</span>* XXH_RESTRICT acc,
<a name="l00943"></a>00943                     <span class="keyword">const</span> <span class="keywordtype">void</span>* XXH_RESTRICT input,
<a name="l00944"></a>00944                     <span class="keyword">const</span> <span class="keywordtype">void</span>* XXH_RESTRICT secret,
<a name="l00945"></a>00945                     XXH3_accWidth_e accWidth)
<a name="l00946"></a>00946 {
<a name="l00947"></a>00947 <span class="preprocessor">#if (XXH_VECTOR == XXH_AVX512)</span>
<a name="l00948"></a>00948 <span class="preprocessor"></span>
<a name="l00949"></a>00949     XXH_ASSERT((((<span class="keywordtype">size_t</span>)acc) &amp; 63) == 0);
<a name="l00950"></a>00950     XXH_STATIC_ASSERT(XXH_STRIPE_LEN == <span class="keyword">sizeof</span>(__m512i));
<a name="l00951"></a>00951     {   XXH_ALIGN(64) __m512i* const xacc    =       (__m512i *) acc;
<a name="l00952"></a>00952 
<a name="l00953"></a>00953         <span class="comment">/* data_vec    = input[0]; */</span>
<a name="l00954"></a>00954         __m512i const data_vec    = _mm512_loadu_si512   (input);
<a name="l00955"></a>00955         <span class="comment">/* key_vec     = secret[0]; */</span>
<a name="l00956"></a>00956         __m512i const key_vec     = _mm512_loadu_si512   (secret);
<a name="l00957"></a>00957         <span class="comment">/* data_key    = data_vec ^ key_vec; */</span>
<a name="l00958"></a>00958         __m512i const data_key    = _mm512_xor_si512     (data_vec, key_vec);
<a name="l00959"></a>00959         <span class="comment">/* data_key_lo = data_key &gt;&gt; 32; */</span>
<a name="l00960"></a>00960         __m512i const data_key_lo = _mm512_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
<a name="l00961"></a>00961         <span class="comment">/* product     = (data_key &amp; 0xffffffff) * (data_key_lo &amp; 0xffffffff); */</span>
<a name="l00962"></a>00962         __m512i const product     = _mm512_mul_epu32     (data_key, data_key_lo);
<a name="l00963"></a>00963         if (accWidth == XXH3_acc_128bits) {
<a name="l00964"></a>00964             <span class="comment">/* xacc[0] += swap(data_vec); */</span>
<a name="l00965"></a>00965             __m512i <span class="keyword">const</span> data_swap = _mm512_shuffle_epi32(data_vec, _MM_SHUFFLE(1, 0, 3, 2));
<a name="l00966"></a>00966             __m512i <span class="keyword">const</span> sum       = _mm512_add_epi64(*xacc, data_swap);
<a name="l00967"></a>00967             <span class="comment">/* xacc[0] += product; */</span>
<a name="l00968"></a>00968             *xacc = _mm512_add_epi64(product, sum);
<a name="l00969"></a>00969         } <span class="keywordflow">else</span> {  <span class="comment">/* XXH3_acc_64bits */</span>
<a name="l00970"></a>00970             <span class="comment">/* xacc[0] += data_vec; */</span>
<a name="l00971"></a>00971             __m512i <span class="keyword">const</span> sum = _mm512_add_epi64(*xacc, data_vec);
<a name="l00972"></a>00972             <span class="comment">/* xacc[0] += product; */</span>
<a name="l00973"></a>00973             *xacc = _mm512_add_epi64(product, sum);
<a name="l00974"></a>00974         }
<a name="l00975"></a>00975     }
<a name="l00976"></a>00976 
<a name="l00977"></a>00977 <span class="preprocessor">#elif (XXH_VECTOR == XXH_AVX2)</span>
<a name="l00978"></a>00978 <span class="preprocessor"></span>
<a name="l00979"></a>00979     XXH_ASSERT((((<span class="keywordtype">size_t</span>)acc) &amp; 31) == 0);
<a name="l00980"></a>00980     {   XXH_ALIGN(32) __m256i* const xacc    =       (__m256i *) acc;
<a name="l00981"></a>00981         <span class="comment">/* Unaligned. This is mainly for pointer arithmetic, and because</span>
<a name="l00982"></a>00982 <span class="comment">         * _mm256_loadu_si256 requires  a const __m256i * pointer for some reason. */</span>
<a name="l00983"></a>00983         const         __m256i* const xinput  = (const __m256i *) input;
<a name="l00984"></a>00984         <span class="comment">/* Unaligned. This is mainly for pointer arithmetic, and because</span>
<a name="l00985"></a>00985 <span class="comment">         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */</span>
<a name="l00986"></a>00986         const         __m256i* const xsecret = (const __m256i *) secret;
<a name="l00987"></a>00987 
<a name="l00988"></a>00988         <span class="keywordtype">size_t</span> i;
<a name="l00989"></a>00989         for (i=0; i &lt; XXH_STRIPE_LEN/sizeof(__m256i); i++) {
<a name="l00990"></a>00990             <span class="comment">/* data_vec    = xinput[i]; */</span>
<a name="l00991"></a>00991             __m256i <span class="keyword">const</span> data_vec    = _mm256_loadu_si256    (xinput+i);
<a name="l00992"></a>00992             <span class="comment">/* key_vec     = xsecret[i]; */</span>
<a name="l00993"></a>00993             __m256i <span class="keyword">const</span> key_vec     = _mm256_loadu_si256   (xsecret+i);
<a name="l00994"></a>00994             <span class="comment">/* data_key    = data_vec ^ key_vec; */</span>
<a name="l00995"></a>00995             __m256i <span class="keyword">const</span> data_key    = _mm256_xor_si256     (data_vec, key_vec);
<a name="l00996"></a>00996             <span class="comment">/* data_key_lo = data_key &gt;&gt; 32; */</span>
<a name="l00997"></a>00997             __m256i <span class="keyword">const</span> data_key_lo = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
<a name="l00998"></a>00998             <span class="comment">/* product     = (data_key &amp; 0xffffffff) * (data_key_lo &amp; 0xffffffff); */</span>
<a name="l00999"></a>00999             __m256i <span class="keyword">const</span> product     = _mm256_mul_epu32     (data_key, data_key_lo);
<a name="l01000"></a>01000             <span class="keywordflow">if</span> (accWidth == XXH3_acc_128bits) {
<a name="l01001"></a>01001                 <span class="comment">/* xacc[i] += swap(data_vec); */</span>
<a name="l01002"></a>01002                 __m256i <span class="keyword">const</span> data_swap = _mm256_shuffle_epi32(data_vec, _MM_SHUFFLE(1, 0, 3, 2));
<a name="l01003"></a>01003                 __m256i <span class="keyword">const</span> sum       = _mm256_add_epi64(xacc[i], data_swap);
<a name="l01004"></a>01004                 <span class="comment">/* xacc[i] += product; */</span>
<a name="l01005"></a>01005                 xacc[i] = _mm256_add_epi64(product, sum);
<a name="l01006"></a>01006             } <span class="keywordflow">else</span> {  <span class="comment">/* XXH3_acc_64bits */</span>
<a name="l01007"></a>01007                 <span class="comment">/* xacc[i] += data_vec; */</span>
<a name="l01008"></a>01008                 __m256i <span class="keyword">const</span> sum = _mm256_add_epi64(xacc[i], data_vec);
<a name="l01009"></a>01009                 <span class="comment">/* xacc[i] += product; */</span>
<a name="l01010"></a>01010                 xacc[i] = _mm256_add_epi64(product, sum);
<a name="l01011"></a>01011             }
<a name="l01012"></a>01012     }   }
<a name="l01013"></a>01013 
<a name="l01014"></a>01014 <span class="preprocessor">#elif (XXH_VECTOR == XXH_SSE2)</span>
<a name="l01015"></a>01015 <span class="preprocessor"></span>
<a name="l01016"></a>01016     <span class="comment">/* SSE2 is just a half-scale version of the AVX2 version. */</span>
<a name="l01017"></a>01017     XXH_ASSERT((((<span class="keywordtype">size_t</span>)acc) &amp; 15) == 0);
<a name="l01018"></a>01018     {   XXH_ALIGN(16) __m128i* const xacc    =       (__m128i *) acc;
<a name="l01019"></a>01019         <span class="comment">/* Unaligned. This is mainly for pointer arithmetic, and because</span>
<a name="l01020"></a>01020 <span class="comment">         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */</span>
<a name="l01021"></a>01021         const         __m128i* const xinput  = (const __m128i *) input;
<a name="l01022"></a>01022         <span class="comment">/* Unaligned. This is mainly for pointer arithmetic, and because</span>
<a name="l01023"></a>01023 <span class="comment">         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */</span>
<a name="l01024"></a>01024         const         __m128i* const xsecret = (const __m128i *) secret;
<a name="l01025"></a>01025 
<a name="l01026"></a>01026         <span class="keywordtype">size_t</span> i;
<a name="l01027"></a>01027         for (i=0; i &lt; XXH_STRIPE_LEN/sizeof(__m128i); i++) {
<a name="l01028"></a>01028             <span class="comment">/* data_vec    = xinput[i]; */</span>
<a name="l01029"></a>01029             __m128i <span class="keyword">const</span> data_vec    = _mm_loadu_si128   (xinput+i);
<a name="l01030"></a>01030             <span class="comment">/* key_vec     = xsecret[i]; */</span>
<a name="l01031"></a>01031             __m128i <span class="keyword">const</span> key_vec     = _mm_loadu_si128   (xsecret+i);
<a name="l01032"></a>01032             <span class="comment">/* data_key    = data_vec ^ key_vec; */</span>
<a name="l01033"></a>01033             __m128i <span class="keyword">const</span> data_key    = _mm_xor_si128     (data_vec, key_vec);
<a name="l01034"></a>01034             <span class="comment">/* data_key_lo = data_key &gt;&gt; 32; */</span>
<a name="l01035"></a>01035             __m128i <span class="keyword">const</span> data_key_lo = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
<a name="l01036"></a>01036             <span class="comment">/* product     = (data_key &amp; 0xffffffff) * (data_key_lo &amp; 0xffffffff); */</span>
<a name="l01037"></a>01037             __m128i <span class="keyword">const</span> product     = _mm_mul_epu32     (data_key, data_key_lo);
<a name="l01038"></a>01038             <span class="keywordflow">if</span> (accWidth == XXH3_acc_128bits) {
<a name="l01039"></a>01039                 <span class="comment">/* xacc[i] += swap(data_vec); */</span>
<a name="l01040"></a>01040                 __m128i <span class="keyword">const</span> data_swap = _mm_shuffle_epi32(data_vec, _MM_SHUFFLE(1,0,3,2));
<a name="l01041"></a>01041                 __m128i <span class="keyword">const</span> sum       = _mm_add_epi64(xacc[i], data_swap);
<a name="l01042"></a>01042                 <span class="comment">/* xacc[i] += product; */</span>
<a name="l01043"></a>01043                 xacc[i] = _mm_add_epi64(product, sum);
<a name="l01044"></a>01044             } <span class="keywordflow">else</span> {  <span class="comment">/* XXH3_acc_64bits */</span>
<a name="l01045"></a>01045                 <span class="comment">/* xacc[i] += data_vec; */</span>
<a name="l01046"></a>01046                 __m128i <span class="keyword">const</span> sum = _mm_add_epi64(xacc[i], data_vec);
<a name="l01047"></a>01047                 <span class="comment">/* xacc[i] += product; */</span>
<a name="l01048"></a>01048                 xacc[i] = _mm_add_epi64(product, sum);
<a name="l01049"></a>01049             }
<a name="l01050"></a>01050     }   }
<a name="l01051"></a>01051 
<a name="l01052"></a>01052 <span class="preprocessor">#elif (XXH_VECTOR == XXH_NEON)</span>
<a name="l01053"></a>01053 <span class="preprocessor"></span>
<a name="l01054"></a>01054     XXH_ASSERT((((<span class="keywordtype">size_t</span>)acc) &amp; 15) == 0);
<a name="l01055"></a>01055     {
<a name="l01056"></a>01056         XXH_ALIGN(16) uint64x2_t* const xacc = (uint64x2_t *) acc;
<a name="l01057"></a>01057         <span class="comment">/* We don&#39;t use a uint32x4_t pointer because it causes bus errors on ARMv7. */</span>
<a name="l01058"></a>01058         uint8_t const* const xinput = (const uint8_t *) input;
<a name="l01059"></a>01059         uint8_t const* const xsecret  = (const uint8_t *) secret;
<a name="l01060"></a>01060 
<a name="l01061"></a>01061         <span class="keywordtype">size_t</span> i;
<a name="l01062"></a>01062         for (i=0; i &lt; XXH_STRIPE_LEN / sizeof(uint64x2_t); i++) {
<a name="l01063"></a>01063             <span class="comment">/* data_vec = xinput[i]; */</span>
<a name="l01064"></a>01064             uint8x16_t data_vec    = vld1q_u8(xinput  + (i * 16));
<a name="l01065"></a>01065             <span class="comment">/* key_vec  = xsecret[i];  */</span>
<a name="l01066"></a>01066             uint8x16_t key_vec     = vld1q_u8(xsecret + (i * 16));
<a name="l01067"></a>01067             uint64x2_t data_key;
<a name="l01068"></a>01068             uint32x2_t data_key_lo, data_key_hi;
<a name="l01069"></a>01069             <span class="keywordflow">if</span> (accWidth == XXH3_acc_64bits) {
<a name="l01070"></a>01070                 <span class="comment">/* xacc[i] += data_vec; */</span>
<a name="l01071"></a>01071                 xacc[i] = vaddq_u64 (xacc[i], vreinterpretq_u64_u8(data_vec));
<a name="l01072"></a>01072             } <span class="keywordflow">else</span> {  <span class="comment">/* XXH3_acc_128bits */</span>
<a name="l01073"></a>01073                 <span class="comment">/* xacc[i] += swap(data_vec); */</span>
<a name="l01074"></a>01074                 uint64x2_t <span class="keyword">const</span> data64  = vreinterpretq_u64_u8(data_vec);
<a name="l01075"></a>01075                 uint64x2_t <span class="keyword">const</span> swapped = vextq_u64(data64, data64, 1);
<a name="l01076"></a>01076                 xacc[i] = vaddq_u64 (xacc[i], swapped);
<a name="l01077"></a>01077             }
<a name="l01078"></a>01078             <span class="comment">/* data_key = data_vec ^ key_vec; */</span>
<a name="l01079"></a>01079             data_key = vreinterpretq_u64_u8(veorq_u8(data_vec, key_vec));
<a name="l01080"></a>01080             <span class="comment">/* data_key_lo = (uint32x2_t) (data_key &amp; 0xFFFFFFFF);</span>
<a name="l01081"></a>01081 <span class="comment">             * data_key_hi = (uint32x2_t) (data_key &gt;&gt; 32);</span>
<a name="l01082"></a>01082 <span class="comment">             * data_key = UNDEFINED; */</span>
<a name="l01083"></a>01083             XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
<a name="l01084"></a>01084             <span class="comment">/* xacc[i] += (uint64x2_t) data_key_lo * (uint64x2_t) data_key_hi; */</span>
<a name="l01085"></a>01085             xacc[i] = vmlal_u32 (xacc[i], data_key_lo, data_key_hi);
<a name="l01086"></a>01086 
<a name="l01087"></a>01087         }
<a name="l01088"></a>01088     }
<a name="l01089"></a>01089 
<a name="l01090"></a>01090 <span class="preprocessor">#elif (XXH_VECTOR == XXH_VSX)</span>
<a name="l01091"></a>01091 <span class="preprocessor"></span>          xxh_u64x2* <span class="keyword">const</span> xacc     =       (xxh_u64x2*) acc;    <span class="comment">/* presumed aligned */</span>
<a name="l01092"></a>01092     xxh_u64x2 <span class="keyword">const</span>* <span class="keyword">const</span> xinput   = (xxh_u64x2 <span class="keyword">const</span>*) input;   <span class="comment">/* no alignment restriction */</span>
<a name="l01093"></a>01093     xxh_u64x2 <span class="keyword">const</span>* <span class="keyword">const</span> xsecret  = (xxh_u64x2 <span class="keyword">const</span>*) secret;    <span class="comment">/* no alignment restriction */</span>
<a name="l01094"></a>01094     xxh_u64x2 <span class="keyword">const</span> v32 = { 32, 32 };
<a name="l01095"></a>01095     <span class="keywordtype">size_t</span> i;
<a name="l01096"></a>01096     <span class="keywordflow">for</span> (i = 0; i &lt; XXH_STRIPE_LEN / <span class="keyword">sizeof</span>(xxh_u64x2); i++) {
<a name="l01097"></a>01097         <span class="comment">/* data_vec = xinput[i]; */</span>
<a name="l01098"></a>01098         xxh_u64x2 <span class="keyword">const</span> data_vec = XXH_vec_loadu(xinput + i);
<a name="l01099"></a>01099         <span class="comment">/* key_vec = xsecret[i]; */</span>
<a name="l01100"></a>01100         xxh_u64x2 <span class="keyword">const</span> key_vec  = XXH_vec_loadu(xsecret + i);
<a name="l01101"></a>01101         xxh_u64x2 <span class="keyword">const</span> data_key = data_vec ^ key_vec;
<a name="l01102"></a>01102         <span class="comment">/* shuffled = (data_key &lt;&lt; 32) | (data_key &gt;&gt; 32); */</span>
<a name="l01103"></a>01103         xxh_u32x4 <span class="keyword">const</span> shuffled = (xxh_u32x4)vec_rl(data_key, v32);
<a name="l01104"></a>01104         <span class="comment">/* product = ((xxh_u64x2)data_key &amp; 0xFFFFFFFF) * ((xxh_u64x2)shuffled &amp; 0xFFFFFFFF); */</span>
<a name="l01105"></a>01105         xxh_u64x2 <span class="keyword">const</span> product  = XXH_vec_mulo((xxh_u32x4)data_key, shuffled);
<a name="l01106"></a>01106         xacc[i] += product;
<a name="l01107"></a>01107 
<a name="l01108"></a>01108         <span class="keywordflow">if</span> (accWidth == XXH3_acc_64bits) {
<a name="l01109"></a>01109             xacc[i] += data_vec;
<a name="l01110"></a>01110         } <span class="keywordflow">else</span> {  <span class="comment">/* XXH3_acc_128bits */</span>
<a name="l01111"></a>01111             <span class="comment">/* swap high and low halves */</span>
<a name="l01112"></a>01112 <span class="preprocessor">#ifdef __s390x__</span>
<a name="l01113"></a>01113 <span class="preprocessor"></span>            xxh_u64x2 <span class="keyword">const</span> data_swapped = vec_permi(data_vec, data_vec, 2);
<a name="l01114"></a>01114 <span class="preprocessor">#else</span>
<a name="l01115"></a>01115 <span class="preprocessor"></span>            xxh_u64x2 <span class="keyword">const</span> data_swapped = vec_xxpermdi(data_vec, data_vec, 2);
<a name="l01116"></a>01116 <span class="preprocessor">#endif</span>
<a name="l01117"></a>01117 <span class="preprocessor"></span>            xacc[i] += data_swapped;
<a name="l01118"></a>01118         }
<a name="l01119"></a>01119     }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121 <span class="preprocessor">#else   </span><span class="comment">/* scalar variant of Accumulator - universal */</span>
<a name="l01122"></a>01122 
<a name="l01123"></a>01123     XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc; <span class="comment">/* presumed aligned */</span>
<a name="l01124"></a>01124     const xxh_u8* const xinput  = (const xxh_u8*) input;  <span class="comment">/* no alignment restriction */</span>
<a name="l01125"></a>01125     const xxh_u8* const xsecret = (const xxh_u8*) secret;   <span class="comment">/* no alignment restriction */</span>
<a name="l01126"></a>01126     <span class="keywordtype">size_t</span> i;
<a name="l01127"></a>01127     XXH_ASSERT(((<span class="keywordtype">size_t</span>)acc &amp; (XXH_ACC_ALIGN-1)) == 0);
<a name="l01128"></a>01128     for (i=0; i &lt; XXH_ACC_NB; i++) {
<a name="l01129"></a>01129         xxh_u64 <span class="keyword">const</span> data_val = XXH_readLE64(xinput + 8*i);
<a name="l01130"></a>01130         xxh_u64 <span class="keyword">const</span> data_key = data_val ^ XXH_readLE64(xsecret + i*8);
<a name="l01131"></a>01131 
<a name="l01132"></a>01132         <span class="keywordflow">if</span> (accWidth == XXH3_acc_64bits) {
<a name="l01133"></a>01133             xacc[i] += data_val;
<a name="l01134"></a>01134         } <span class="keywordflow">else</span> {
<a name="l01135"></a>01135             xacc[i ^ 1] += data_val; <span class="comment">/* swap adjacent lanes */</span>
<a name="l01136"></a>01136         }
<a name="l01137"></a>01137         xacc[i] += XXH_mult32to64(data_key &amp; 0xFFFFFFFF, data_key &gt;&gt; 32);
<a name="l01138"></a>01138     }
<a name="l01139"></a>01139 <span class="preprocessor">#endif</span>
<a name="l01140"></a>01140 <span class="preprocessor"></span>}
<a name="l01141"></a>01141 
<a name="l01142"></a>01142 <span class="comment">/*</span>
<a name="l01143"></a>01143 <span class="comment"> * XXH3_scrambleAcc: Scrambles the accumulators to improve mixing.</span>
<a name="l01144"></a>01144 <span class="comment"> *</span>
<a name="l01145"></a>01145 <span class="comment"> * Multiplication isn&#39;t perfect, as explained by Google in HighwayHash:</span>
<a name="l01146"></a>01146 <span class="comment"> *</span>
<a name="l01147"></a>01147 <span class="comment"> *  // Multiplication mixes/scrambles bytes 0-7 of the 64-bit result to</span>
<a name="l01148"></a>01148 <span class="comment"> *  // varying degrees. In descending order of goodness, bytes</span>
<a name="l01149"></a>01149 <span class="comment"> *  // 3 4 2 5 1 6 0 7 have quality 228 224 164 160 100 96 36 32.</span>
<a name="l01150"></a>01150 <span class="comment"> *  // As expected, the upper and lower bytes are much worse.</span>
<a name="l01151"></a>01151 <span class="comment"> *</span>
<a name="l01152"></a>01152 <span class="comment"> * Source: https://github.com/google/highwayhash/blob/0aaf66b/highwayhash/hh_avx2.h#L291</span>
<a name="l01153"></a>01153 <span class="comment"> *</span>
<a name="l01154"></a>01154 <span class="comment"> * Since our algorithm uses a pseudorandom secret to add some variance into the</span>
<a name="l01155"></a>01155 <span class="comment"> * mix, we don&#39;t need to (or want to) mix as often or as much as HighwayHash does.</span>
<a name="l01156"></a>01156 <span class="comment"> *</span>
<a name="l01157"></a>01157 <span class="comment"> * This isn&#39;t as tight as XXH3_accumulate, but still written in SIMD to avoid</span>
<a name="l01158"></a>01158 <span class="comment"> * extraction.</span>
<a name="l01159"></a>01159 <span class="comment"> *</span>
<a name="l01160"></a>01160 <span class="comment"> * Both XXH3_64bits and XXH3_128bits use this subroutine.</span>
<a name="l01161"></a>01161 <span class="comment"> */</span>
<a name="l01162"></a>01162 XXH_FORCE_INLINE <span class="keywordtype">void</span>
<a name="l01163"></a>01163 XXH3_scrambleAcc(<span class="keywordtype">void</span>* XXH_RESTRICT acc, <span class="keyword">const</span> <span class="keywordtype">void</span>* XXH_RESTRICT secret)
<a name="l01164"></a>01164 {
<a name="l01165"></a>01165 <span class="preprocessor">#if (XXH_VECTOR == XXH_AVX512)</span>
<a name="l01166"></a>01166 <span class="preprocessor"></span>
<a name="l01167"></a>01167     XXH_ASSERT((((<span class="keywordtype">size_t</span>)acc) &amp; 63) == 0);
<a name="l01168"></a>01168     XXH_STATIC_ASSERT(XXH_STRIPE_LEN == <span class="keyword">sizeof</span>(__m512i));
<a name="l01169"></a>01169     {   XXH_ALIGN(64) __m512i* const xacc = (__m512i*) acc;
<a name="l01170"></a>01170         const __m512i prime32 = _mm512_set1_epi32((<span class="keywordtype">int</span>)XXH_PRIME32_1);
<a name="l01171"></a>01171 
<a name="l01172"></a>01172         <span class="comment">/* xacc[0] ^= (xacc[0] &gt;&gt; 47) */</span>
<a name="l01173"></a>01173         __m512i const acc_vec     = *xacc;
<a name="l01174"></a>01174         __m512i const shifted     = _mm512_srli_epi64    (acc_vec, 47);
<a name="l01175"></a>01175         __m512i const data_vec    = _mm512_xor_si512     (acc_vec, shifted);
<a name="l01176"></a>01176         <span class="comment">/* xacc[0] ^= secret; */</span>
<a name="l01177"></a>01177         __m512i const key_vec     = _mm512_loadu_si512   (secret);
<a name="l01178"></a>01178         __m512i const data_key    = _mm512_xor_si512     (data_vec, key_vec);
<a name="l01179"></a>01179 
<a name="l01180"></a>01180         <span class="comment">/* xacc[0] *= XXH_PRIME32_1; */</span>
<a name="l01181"></a>01181         __m512i const data_key_hi = _mm512_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
<a name="l01182"></a>01182         __m512i const prod_lo     = _mm512_mul_epu32     (data_key, prime32);
<a name="l01183"></a>01183         __m512i const prod_hi     = _mm512_mul_epu32     (data_key_hi, prime32);
<a name="l01184"></a>01184         *xacc = _mm512_add_epi64(prod_lo, _mm512_slli_epi64(prod_hi, 32));
<a name="l01185"></a>01185     }
<a name="l01186"></a>01186 
<a name="l01187"></a>01187 <span class="preprocessor">#elif (XXH_VECTOR == XXH_AVX2)</span>
<a name="l01188"></a>01188 <span class="preprocessor"></span>
<a name="l01189"></a>01189     XXH_ASSERT((((<span class="keywordtype">size_t</span>)acc) &amp; 31) == 0);
<a name="l01190"></a>01190     {   XXH_ALIGN(32) __m256i* const xacc = (__m256i*) acc;
<a name="l01191"></a>01191         <span class="comment">/* Unaligned. This is mainly for pointer arithmetic, and because</span>
<a name="l01192"></a>01192 <span class="comment">         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */</span>
<a name="l01193"></a>01193         const         __m256i* const xsecret = (const __m256i *) secret;
<a name="l01194"></a>01194         const __m256i prime32 = _mm256_set1_epi32((<span class="keywordtype">int</span>)XXH_PRIME32_1);
<a name="l01195"></a>01195 
<a name="l01196"></a>01196         <span class="keywordtype">size_t</span> i;
<a name="l01197"></a>01197         for (i=0; i &lt; XXH_STRIPE_LEN/sizeof(__m256i); i++) {
<a name="l01198"></a>01198             <span class="comment">/* xacc[i] ^= (xacc[i] &gt;&gt; 47) */</span>
<a name="l01199"></a>01199             __m256i <span class="keyword">const</span> acc_vec     = xacc[i];
<a name="l01200"></a>01200             __m256i <span class="keyword">const</span> shifted     = _mm256_srli_epi64    (acc_vec, 47);
<a name="l01201"></a>01201             __m256i <span class="keyword">const</span> data_vec    = _mm256_xor_si256     (acc_vec, shifted);
<a name="l01202"></a>01202             <span class="comment">/* xacc[i] ^= xsecret; */</span>
<a name="l01203"></a>01203             __m256i <span class="keyword">const</span> key_vec     = _mm256_loadu_si256   (xsecret+i);
<a name="l01204"></a>01204             __m256i <span class="keyword">const</span> data_key    = _mm256_xor_si256     (data_vec, key_vec);
<a name="l01205"></a>01205 
<a name="l01206"></a>01206             <span class="comment">/* xacc[i] *= XXH_PRIME32_1; */</span>
<a name="l01207"></a>01207             __m256i <span class="keyword">const</span> data_key_hi = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
<a name="l01208"></a>01208             __m256i <span class="keyword">const</span> prod_lo     = _mm256_mul_epu32     (data_key, prime32);
<a name="l01209"></a>01209             __m256i <span class="keyword">const</span> prod_hi     = _mm256_mul_epu32     (data_key_hi, prime32);
<a name="l01210"></a>01210             xacc[i] = _mm256_add_epi64(prod_lo, _mm256_slli_epi64(prod_hi, 32));
<a name="l01211"></a>01211         }
<a name="l01212"></a>01212     }
<a name="l01213"></a>01213 
<a name="l01214"></a>01214 <span class="preprocessor">#elif (XXH_VECTOR == XXH_SSE2)</span>
<a name="l01215"></a>01215 <span class="preprocessor"></span>
<a name="l01216"></a>01216     XXH_ASSERT((((<span class="keywordtype">size_t</span>)acc) &amp; 15) == 0);
<a name="l01217"></a>01217     {   XXH_ALIGN(16) __m128i* const xacc = (__m128i*) acc;
<a name="l01218"></a>01218         <span class="comment">/* Unaligned. This is mainly for pointer arithmetic, and because</span>
<a name="l01219"></a>01219 <span class="comment">         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */</span>
<a name="l01220"></a>01220         const         __m128i* const xsecret = (const __m128i *) secret;
<a name="l01221"></a>01221         const __m128i prime32 = _mm_set1_epi32((<span class="keywordtype">int</span>)XXH_PRIME32_1);
<a name="l01222"></a>01222 
<a name="l01223"></a>01223         <span class="keywordtype">size_t</span> i;
<a name="l01224"></a>01224         for (i=0; i &lt; XXH_STRIPE_LEN/sizeof(__m128i); i++) {
<a name="l01225"></a>01225             <span class="comment">/* xacc[i] ^= (xacc[i] &gt;&gt; 47) */</span>
<a name="l01226"></a>01226             __m128i <span class="keyword">const</span> acc_vec     = xacc[i];
<a name="l01227"></a>01227             __m128i <span class="keyword">const</span> shifted     = _mm_srli_epi64    (acc_vec, 47);
<a name="l01228"></a>01228             __m128i <span class="keyword">const</span> data_vec    = _mm_xor_si128     (acc_vec, shifted);
<a name="l01229"></a>01229             <span class="comment">/* xacc[i] ^= xsecret[i]; */</span>
<a name="l01230"></a>01230             __m128i <span class="keyword">const</span> key_vec     = _mm_loadu_si128   (xsecret+i);
<a name="l01231"></a>01231             __m128i <span class="keyword">const</span> data_key    = _mm_xor_si128     (data_vec, key_vec);
<a name="l01232"></a>01232 
<a name="l01233"></a>01233             <span class="comment">/* xacc[i] *= XXH_PRIME32_1; */</span>
<a name="l01234"></a>01234             __m128i <span class="keyword">const</span> data_key_hi = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
<a name="l01235"></a>01235             __m128i <span class="keyword">const</span> prod_lo     = _mm_mul_epu32     (data_key, prime32);
<a name="l01236"></a>01236             __m128i <span class="keyword">const</span> prod_hi     = _mm_mul_epu32     (data_key_hi, prime32);
<a name="l01237"></a>01237             xacc[i] = _mm_add_epi64(prod_lo, _mm_slli_epi64(prod_hi, 32));
<a name="l01238"></a>01238         }
<a name="l01239"></a>01239     }
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 <span class="preprocessor">#elif (XXH_VECTOR == XXH_NEON)</span>
<a name="l01242"></a>01242 <span class="preprocessor"></span>
<a name="l01243"></a>01243     XXH_ASSERT((((<span class="keywordtype">size_t</span>)acc) &amp; 15) == 0);
<a name="l01244"></a>01244 
<a name="l01245"></a>01245     {   uint64x2_t* xacc       = (uint64x2_t*) acc;
<a name="l01246"></a>01246         uint8_t <span class="keyword">const</span>* xsecret = (uint8_t <span class="keyword">const</span>*) secret;
<a name="l01247"></a>01247         uint32x2_t prime       = vdup_n_u32 (XXH_PRIME32_1);
<a name="l01248"></a>01248 
<a name="l01249"></a>01249         <span class="keywordtype">size_t</span> i;
<a name="l01250"></a>01250         <span class="keywordflow">for</span> (i=0; i &lt; XXH_STRIPE_LEN/<span class="keyword">sizeof</span>(uint64x2_t); i++) {
<a name="l01251"></a>01251             <span class="comment">/* xacc[i] ^= (xacc[i] &gt;&gt; 47); */</span>
<a name="l01252"></a>01252             uint64x2_t acc_vec  = xacc[i];
<a name="l01253"></a>01253             uint64x2_t shifted  = vshrq_n_u64 (acc_vec, 47);
<a name="l01254"></a>01254             uint64x2_t data_vec = veorq_u64   (acc_vec, shifted);
<a name="l01255"></a>01255 
<a name="l01256"></a>01256             <span class="comment">/* xacc[i] ^= xsecret[i]; */</span>
<a name="l01257"></a>01257             uint8x16_t key_vec  = vld1q_u8(xsecret + (i * 16));
<a name="l01258"></a>01258             uint64x2_t data_key = veorq_u64(data_vec, vreinterpretq_u64_u8(key_vec));
<a name="l01259"></a>01259 
<a name="l01260"></a>01260             <span class="comment">/* xacc[i] *= XXH_PRIME32_1 */</span>
<a name="l01261"></a>01261             uint32x2_t data_key_lo, data_key_hi;
<a name="l01262"></a>01262             <span class="comment">/* data_key_lo = (uint32x2_t) (xacc[i] &amp; 0xFFFFFFFF);</span>
<a name="l01263"></a>01263 <span class="comment">             * data_key_hi = (uint32x2_t) (xacc[i] &gt;&gt; 32);</span>
<a name="l01264"></a>01264 <span class="comment">             * xacc[i] = UNDEFINED; */</span>
<a name="l01265"></a>01265             XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
<a name="l01266"></a>01266             {   <span class="comment">/*</span>
<a name="l01267"></a>01267 <span class="comment">                 * prod_hi = (data_key &gt;&gt; 32) * XXH_PRIME32_1;</span>
<a name="l01268"></a>01268 <span class="comment">                 *</span>
<a name="l01269"></a>01269 <span class="comment">                 * Avoid vmul_u32 + vshll_n_u32 since Clang 6 and 7 will</span>
<a name="l01270"></a>01270 <span class="comment">                 * incorrectly &quot;optimize&quot; this:</span>
<a name="l01271"></a>01271 <span class="comment">                 *   tmp     = vmul_u32(vmovn_u64(a), vmovn_u64(b));</span>
<a name="l01272"></a>01272 <span class="comment">                 *   shifted = vshll_n_u32(tmp, 32);</span>
<a name="l01273"></a>01273 <span class="comment">                 * to this:</span>
<a name="l01274"></a>01274 <span class="comment">                 *   tmp     = &quot;vmulq_u64&quot;(a, b); // no such thing!</span>
<a name="l01275"></a>01275 <span class="comment">                 *   shifted = vshlq_n_u64(tmp, 32);</span>
<a name="l01276"></a>01276 <span class="comment">                 *</span>
<a name="l01277"></a>01277 <span class="comment">                 * However, unlike SSE, Clang lacks a 64-bit multiply routine</span>
<a name="l01278"></a>01278 <span class="comment">                 * for NEON, and it scalarizes two 64-bit multiplies instead.</span>
<a name="l01279"></a>01279 <span class="comment">                 *</span>
<a name="l01280"></a>01280 <span class="comment">                 * vmull_u32 has the same timing as vmul_u32, and it avoids</span>
<a name="l01281"></a>01281 <span class="comment">                 * this bug completely.</span>
<a name="l01282"></a>01282 <span class="comment">                 * See https://bugs.llvm.org/show_bug.cgi?id=39967</span>
<a name="l01283"></a>01283 <span class="comment">                 */</span>
<a name="l01284"></a>01284                 uint64x2_t prod_hi = vmull_u32 (data_key_hi, prime);
<a name="l01285"></a>01285                 <span class="comment">/* xacc[i] = prod_hi &lt;&lt; 32; */</span>
<a name="l01286"></a>01286                 xacc[i] = vshlq_n_u64(prod_hi, 32);
<a name="l01287"></a>01287                 <span class="comment">/* xacc[i] += (prod_hi &amp; 0xFFFFFFFF) * XXH_PRIME32_1; */</span>
<a name="l01288"></a>01288                 xacc[i] = vmlal_u32(xacc[i], data_key_lo, prime);
<a name="l01289"></a>01289             }
<a name="l01290"></a>01290     }   }
<a name="l01291"></a>01291 
<a name="l01292"></a>01292 <span class="preprocessor">#elif (XXH_VECTOR == XXH_VSX)</span>
<a name="l01293"></a>01293 <span class="preprocessor"></span>
<a name="l01294"></a>01294     XXH_ASSERT((((<span class="keywordtype">size_t</span>)acc) &amp; 15) == 0);
<a name="l01295"></a>01295 
<a name="l01296"></a>01296     {         xxh_u64x2* <span class="keyword">const</span> xacc    =       (xxh_u64x2*) acc;
<a name="l01297"></a>01297         <span class="keyword">const</span> xxh_u64x2* <span class="keyword">const</span> xsecret = (<span class="keyword">const</span> xxh_u64x2*) secret;
<a name="l01298"></a>01298         <span class="comment">/* constants */</span>
<a name="l01299"></a>01299         xxh_u64x2 <span class="keyword">const</span> v32  = { 32, 32 };
<a name="l01300"></a>01300         xxh_u64x2 <span class="keyword">const</span> v47 = { 47, 47 };
<a name="l01301"></a>01301         xxh_u32x4 <span class="keyword">const</span> prime = { XXH_PRIME32_1, XXH_PRIME32_1, XXH_PRIME32_1, XXH_PRIME32_1 };
<a name="l01302"></a>01302         <span class="keywordtype">size_t</span> i;
<a name="l01303"></a>01303         <span class="keywordflow">for</span> (i = 0; i &lt; XXH_STRIPE_LEN / <span class="keyword">sizeof</span>(xxh_u64x2); i++) {
<a name="l01304"></a>01304             <span class="comment">/* xacc[i] ^= (xacc[i] &gt;&gt; 47); */</span>
<a name="l01305"></a>01305             xxh_u64x2 <span class="keyword">const</span> acc_vec  = xacc[i];
<a name="l01306"></a>01306             xxh_u64x2 <span class="keyword">const</span> data_vec = acc_vec ^ (acc_vec &gt;&gt; v47);
<a name="l01307"></a>01307 
<a name="l01308"></a>01308             <span class="comment">/* xacc[i] ^= xsecret[i]; */</span>
<a name="l01309"></a>01309             xxh_u64x2 <span class="keyword">const</span> key_vec  = XXH_vec_loadu(xsecret + i);
<a name="l01310"></a>01310             xxh_u64x2 <span class="keyword">const</span> data_key = data_vec ^ key_vec;
<a name="l01311"></a>01311 
<a name="l01312"></a>01312             <span class="comment">/* xacc[i] *= XXH_PRIME32_1 */</span>
<a name="l01313"></a>01313             <span class="comment">/* prod_lo = ((xxh_u64x2)data_key &amp; 0xFFFFFFFF) * ((xxh_u64x2)prime &amp; 0xFFFFFFFF);  */</span>
<a name="l01314"></a>01314             xxh_u64x2 <span class="keyword">const</span> prod_even  = XXH_vec_mule((xxh_u32x4)data_key, prime);
<a name="l01315"></a>01315             <span class="comment">/* prod_hi = ((xxh_u64x2)data_key &gt;&gt; 32) * ((xxh_u64x2)prime &gt;&gt; 32);  */</span>
<a name="l01316"></a>01316             xxh_u64x2 <span class="keyword">const</span> prod_odd  = XXH_vec_mulo((xxh_u32x4)data_key, prime);
<a name="l01317"></a>01317             xacc[i] = prod_odd + (prod_even &lt;&lt; v32);
<a name="l01318"></a>01318     }   }
<a name="l01319"></a>01319 
<a name="l01320"></a>01320 <span class="preprocessor">#else   </span><span class="comment">/* scalar variant of Scrambler - universal */</span>
<a name="l01321"></a>01321 
<a name="l01322"></a>01322     XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc;   <span class="comment">/* presumed aligned */</span>
<a name="l01323"></a>01323     const xxh_u8* const xsecret = (const xxh_u8*) secret;   <span class="comment">/* no alignment restriction */</span>
<a name="l01324"></a>01324     <span class="keywordtype">size_t</span> i;
<a name="l01325"></a>01325     XXH_ASSERT((((<span class="keywordtype">size_t</span>)acc) &amp; (XXH_ACC_ALIGN-1)) == 0);
<a name="l01326"></a>01326     for (i=0; i &lt; XXH_ACC_NB; i++) {
<a name="l01327"></a>01327         xxh_u64 <span class="keyword">const</span> key64 = XXH_readLE64(xsecret + 8*i);
<a name="l01328"></a>01328         xxh_u64 acc64 = xacc[i];
<a name="l01329"></a>01329         acc64 = XXH_xorshift64(acc64, 47);
<a name="l01330"></a>01330         acc64 ^= key64;
<a name="l01331"></a>01331         acc64 *= XXH_PRIME32_1;
<a name="l01332"></a>01332         xacc[i] = acc64;
<a name="l01333"></a>01333     }
<a name="l01334"></a>01334 
<a name="l01335"></a>01335 <span class="preprocessor">#endif</span>
<a name="l01336"></a>01336 <span class="preprocessor"></span>}
<a name="l01337"></a>01337 
<a name="l01338"></a>01338 <span class="preprocessor">#define XXH_PREFETCH_DIST 384</span>
<a name="l01339"></a>01339 <span class="preprocessor"></span>
<a name="l01340"></a>01340 <span class="preprocessor">#ifdef __clang__ // for clang</span>
<a name="l01341"></a>01341 <span class="preprocessor"></span><span class="preprocessor">#  define XXH_PREFETCH_DIST_AVX512_64  320</span>
<a name="l01342"></a>01342 <span class="preprocessor"></span><span class="preprocessor">#  define XXH_PREFETCH_DIST_AVX512_128 320</span>
<a name="l01343"></a>01343 <span class="preprocessor"></span><span class="preprocessor">#else // for gcc</span>
<a name="l01344"></a>01344 <span class="preprocessor"></span><span class="preprocessor">#  define XXH_PREFETCH_DIST_AVX512_64  640</span>
<a name="l01345"></a>01345 <span class="preprocessor"></span><span class="preprocessor">#  define XXH_PREFETCH_DIST_AVX512_128 512</span>
<a name="l01346"></a>01346 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01347"></a>01347 <span class="preprocessor"></span>
<a name="l01348"></a>01348 <span class="comment">/*</span>
<a name="l01349"></a>01349 <span class="comment"> * XXH3_accumulate()</span>
<a name="l01350"></a>01350 <span class="comment"> * Loops over XXH3_accumulate_512().</span>
<a name="l01351"></a>01351 <span class="comment"> * Assumption: nbStripes will not overflow the secret size</span>
<a name="l01352"></a>01352 <span class="comment"> */</span>
<a name="l01353"></a>01353 XXH_FORCE_INLINE <span class="keywordtype">void</span>
<a name="l01354"></a>01354 XXH3_accumulate(     xxh_u64* XXH_RESTRICT acc,
<a name="l01355"></a>01355                 <span class="keyword">const</span> xxh_u8* XXH_RESTRICT input,
<a name="l01356"></a>01356                 <span class="keyword">const</span> xxh_u8* XXH_RESTRICT secret,
<a name="l01357"></a>01357                       <span class="keywordtype">size_t</span> nbStripes,
<a name="l01358"></a>01358                       XXH3_accWidth_e accWidth)
<a name="l01359"></a>01359 {
<a name="l01360"></a>01360     <span class="keywordtype">size_t</span> n;
<a name="l01361"></a>01361     <span class="keywordflow">for</span> (n = 0; n &lt; nbStripes; n++ ) {
<a name="l01362"></a>01362         <span class="keyword">const</span> xxh_u8* <span class="keyword">const</span> in = input + n*XXH_STRIPE_LEN;
<a name="l01363"></a>01363 <span class="preprocessor">#if (XXH_VECTOR == XXH_AVX512)</span>
<a name="l01364"></a>01364 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (accWidth == XXH3_acc_64bits) XXH_PREFETCH(in + XXH_PREFETCH_DIST_AVX512_64);
<a name="l01365"></a>01365         <span class="keywordflow">else</span>                             XXH_PREFETCH(in + XXH_PREFETCH_DIST_AVX512_128);
<a name="l01366"></a>01366 <span class="preprocessor">#else</span>
<a name="l01367"></a>01367 <span class="preprocessor"></span>        XXH_PREFETCH(in + XXH_PREFETCH_DIST);
<a name="l01368"></a>01368 <span class="preprocessor">#endif</span>
<a name="l01369"></a>01369 <span class="preprocessor"></span>        XXH3_accumulate_512(acc,
<a name="l01370"></a>01370                             in,
<a name="l01371"></a>01371                             secret + n*XXH_SECRET_CONSUME_RATE,
<a name="l01372"></a>01372                             accWidth);
<a name="l01373"></a>01373     }
<a name="l01374"></a>01374 }
<a name="l01375"></a>01375 
<a name="l01376"></a>01376 XXH_FORCE_INLINE <span class="keywordtype">void</span>
<a name="l01377"></a>01377 XXH3_hashLong_internal_loop( xxh_u64* XXH_RESTRICT acc,
<a name="l01378"></a>01378                       <span class="keyword">const</span> xxh_u8* XXH_RESTRICT input, <span class="keywordtype">size_t</span> len,
<a name="l01379"></a>01379                       <span class="keyword">const</span> xxh_u8* XXH_RESTRICT secret, <span class="keywordtype">size_t</span> secretSize,
<a name="l01380"></a>01380                             XXH3_accWidth_e accWidth)
<a name="l01381"></a>01381 {
<a name="l01382"></a>01382     <span class="keywordtype">size_t</span> <span class="keyword">const</span> nb_rounds = (secretSize - XXH_STRIPE_LEN) / XXH_SECRET_CONSUME_RATE;
<a name="l01383"></a>01383     <span class="keywordtype">size_t</span> <span class="keyword">const</span> block_len = XXH_STRIPE_LEN * nb_rounds;
<a name="l01384"></a>01384     <span class="keywordtype">size_t</span> <span class="keyword">const</span> nb_blocks = len / block_len;
<a name="l01385"></a>01385 
<a name="l01386"></a>01386     <span class="keywordtype">size_t</span> n;
<a name="l01387"></a>01387 
<a name="l01388"></a>01388     XXH_ASSERT(secretSize &gt;= XXH3_SECRET_SIZE_MIN);
<a name="l01389"></a>01389 
<a name="l01390"></a>01390     <span class="keywordflow">for</span> (n = 0; n &lt; nb_blocks; n++) {
<a name="l01391"></a>01391         XXH3_accumulate(acc, input + n*block_len, secret, nb_rounds, accWidth);
<a name="l01392"></a>01392         XXH3_scrambleAcc(acc, secret + secretSize - XXH_STRIPE_LEN);
<a name="l01393"></a>01393     }
<a name="l01394"></a>01394 
<a name="l01395"></a>01395     <span class="comment">/* last partial block */</span>
<a name="l01396"></a>01396     XXH_ASSERT(len &gt; XXH_STRIPE_LEN);
<a name="l01397"></a>01397     {   <span class="keywordtype">size_t</span> <span class="keyword">const</span> nbStripes = (len - (block_len * nb_blocks)) / XXH_STRIPE_LEN;
<a name="l01398"></a>01398         XXH_ASSERT(nbStripes &lt;= (secretSize / XXH_SECRET_CONSUME_RATE));
<a name="l01399"></a>01399         XXH3_accumulate(acc, input + nb_blocks*block_len, secret, nbStripes, accWidth);
<a name="l01400"></a>01400 
<a name="l01401"></a>01401         <span class="comment">/* last stripe */</span>
<a name="l01402"></a>01402         <span class="keywordflow">if</span> (len &amp; (XXH_STRIPE_LEN - 1)) {
<a name="l01403"></a>01403             <span class="keyword">const</span> xxh_u8* <span class="keyword">const</span> p = input + len - XXH_STRIPE_LEN;
<a name="l01404"></a>01404             <span class="comment">/* Do not align on 8, so that the secret is different from the scrambler */</span>
<a name="l01405"></a>01405 <span class="preprocessor">#define XXH_SECRET_LASTACC_START 7</span>
<a name="l01406"></a>01406 <span class="preprocessor"></span>            XXH3_accumulate_512(acc, p, secret + secretSize - XXH_STRIPE_LEN - XXH_SECRET_LASTACC_START, accWidth);
<a name="l01407"></a>01407     }   }
<a name="l01408"></a>01408 }
<a name="l01409"></a>01409 
<a name="l01410"></a>01410 XXH_FORCE_INLINE xxh_u64
<a name="l01411"></a>01411 XXH3_mix2Accs(<span class="keyword">const</span> xxh_u64* XXH_RESTRICT acc, <span class="keyword">const</span> xxh_u8* XXH_RESTRICT secret)
<a name="l01412"></a>01412 {
<a name="l01413"></a>01413     <span class="keywordflow">return</span> XXH3_mul128_fold64(
<a name="l01414"></a>01414                acc[0] ^ XXH_readLE64(secret),
<a name="l01415"></a>01415                acc[1] ^ XXH_readLE64(secret+8) );
<a name="l01416"></a>01416 }
<a name="l01417"></a>01417 
<a name="l01418"></a>01418 <span class="keyword">static</span> XXH64_hash_t
<a name="l01419"></a>01419 XXH3_mergeAccs(<span class="keyword">const</span> xxh_u64* XXH_RESTRICT acc, <span class="keyword">const</span> xxh_u8* XXH_RESTRICT secret, xxh_u64 start)
<a name="l01420"></a>01420 {
<a name="l01421"></a>01421     xxh_u64 result64 = start;
<a name="l01422"></a>01422     <span class="keywordtype">size_t</span> i = 0;
<a name="l01423"></a>01423 
<a name="l01424"></a>01424     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l01425"></a>01425         result64 += XXH3_mix2Accs(acc+2*i, secret + 16*i);
<a name="l01426"></a>01426 <span class="preprocessor">#if defined(__clang__)                                </span><span class="comment">/* Clang */</span> \
<a name="l01427"></a>01427     &amp;&amp; (defined(__arm__) || defined(__thumb__))       <span class="comment">/* ARMv7 */</span> \
<a name="l01428"></a>01428     &amp;&amp; (defined(__ARM_NEON) || defined(__ARM_NEON__)) <span class="comment">/* NEON */</span>  \
<a name="l01429"></a>01429     &amp;&amp; !defined(XXH_ENABLE_AUTOVECTORIZE)             <span class="comment">/* Define to disable */</span>
<a name="l01430"></a>01430         <span class="comment">/*</span>
<a name="l01431"></a>01431 <span class="comment">         * UGLY HACK:</span>
<a name="l01432"></a>01432 <span class="comment">         * Prevent autovectorization on Clang ARMv7-a. Exact same problem as</span>
<a name="l01433"></a>01433 <span class="comment">         * the one in XXH3_len_129to240_64b. Speeds up shorter keys &gt; 240b.</span>
<a name="l01434"></a>01434 <span class="comment">         * XXH3_64bits, len == 256, Snapdragon 835:</span>
<a name="l01435"></a>01435 <span class="comment">         *   without hack: 2063.7 MB/s</span>
<a name="l01436"></a>01436 <span class="comment">         *   with hack:    2560.7 MB/s</span>
<a name="l01437"></a>01437 <span class="comment">         */</span>
<a name="l01438"></a>01438         __asm__(<span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;+r&quot;</span> (result64));
<a name="l01439"></a>01439 <span class="preprocessor">#endif</span>
<a name="l01440"></a>01440 <span class="preprocessor"></span>    }
<a name="l01441"></a>01441 
<a name="l01442"></a>01442     <span class="keywordflow">return</span> XXH3_avalanche(result64);
<a name="l01443"></a>01443 }
<a name="l01444"></a>01444 
<a name="l01445"></a>01445 <span class="preprocessor">#define XXH3_INIT_ACC { XXH_PRIME32_3, XXH_PRIME64_1, XXH_PRIME64_2, XXH_PRIME64_3, \</span>
<a name="l01446"></a>01446 <span class="preprocessor">                        XXH_PRIME64_4, XXH_PRIME32_2, XXH_PRIME64_5, XXH_PRIME32_1 }</span>
<a name="l01447"></a>01447 <span class="preprocessor"></span>
<a name="l01448"></a>01448 XXH_FORCE_INLINE XXH64_hash_t
<a name="l01449"></a>01449 XXH3_hashLong_64b_internal(<span class="keyword">const</span> xxh_u8* XXH_RESTRICT input, <span class="keywordtype">size_t</span> len,
<a name="l01450"></a>01450                            <span class="keyword">const</span> xxh_u8* XXH_RESTRICT secret, <span class="keywordtype">size_t</span> secretSize)
<a name="l01451"></a>01451 {
<a name="l01452"></a>01452     XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[XXH_ACC_NB] = XXH3_INIT_ACC;
<a name="l01453"></a>01453 
<a name="l01454"></a>01454     XXH3_hashLong_internal_loop(acc, input, len, secret, secretSize, XXH3_acc_64bits);
<a name="l01455"></a>01455 
<a name="l01456"></a>01456     <span class="comment">/* converge into final hash */</span>
<a name="l01457"></a>01457     XXH_STATIC_ASSERT(sizeof(acc) == 64);
<a name="l01458"></a>01458     <span class="comment">/* do not align on 8, so that the secret is different from the accumulator */</span>
<a name="l01459"></a>01459 <span class="preprocessor">#define XXH_SECRET_MERGEACCS_START 11</span>
<a name="l01460"></a>01460 <span class="preprocessor"></span>    XXH_ASSERT(secretSize &gt;= <span class="keyword">sizeof</span>(acc) + XXH_SECRET_MERGEACCS_START);
<a name="l01461"></a>01461     <span class="keywordflow">return</span> XXH3_mergeAccs(acc, secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)len * XXH_PRIME64_1);
<a name="l01462"></a>01462 }
<a name="l01463"></a>01463 
<a name="l01464"></a>01464 XXH_FORCE_INLINE <span class="keywordtype">void</span> XXH_writeLE64(<span class="keywordtype">void</span>* dst, xxh_u64 v64)
<a name="l01465"></a>01465 {
<a name="l01466"></a>01466     <span class="keywordflow">if</span> (!XXH_CPU_LITTLE_ENDIAN) v64 = XXH_swap64(v64);
<a name="l01467"></a>01467     memcpy(dst, &amp;v64, <span class="keyword">sizeof</span>(v64));
<a name="l01468"></a>01468 }
<a name="l01469"></a>01469 
<a name="l01470"></a>01470 <span class="comment">/* XXH3_initCustomSecret() :</span>
<a name="l01471"></a>01471 <span class="comment"> * destination `customSecret` is presumed allocated and same size as `XXH3_kSecret`.</span>
<a name="l01472"></a>01472 <span class="comment"> */</span>
<a name="l01473"></a>01473 XXH_FORCE_INLINE <span class="keywordtype">void</span> XXH3_initCustomSecret(xxh_u8* XXH_RESTRICT customSecret, xxh_u64 seed64)
<a name="l01474"></a>01474 {
<a name="l01475"></a>01475     <span class="keywordtype">int</span> <span class="keyword">const</span> nbRounds = XXH_SECRET_DEFAULT_SIZE / 16;
<a name="l01476"></a>01476     <span class="keywordtype">int</span> i;
<a name="l01477"></a>01477     <span class="comment">/*</span>
<a name="l01478"></a>01478 <span class="comment">     * We need a separate pointer for the hack below.</span>
<a name="l01479"></a>01479 <span class="comment">     * Any decent compiler will optimize this out otherwise.</span>
<a name="l01480"></a>01480 <span class="comment">     */</span>
<a name="l01481"></a>01481     <span class="keyword">const</span> xxh_u8 *kSecretPtr = XXH3_kSecret;
<a name="l01482"></a>01482 
<a name="l01483"></a>01483     XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE &amp; 15) == 0);
<a name="l01484"></a>01484 
<a name="l01485"></a>01485 <span class="preprocessor">#if defined(__clang__) &amp;&amp; defined(__aarch64__)</span>
<a name="l01486"></a>01486 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l01487"></a>01487 <span class="comment">     * UGLY HACK:</span>
<a name="l01488"></a>01488 <span class="comment">     * Clang generates a bunch of MOV/MOVK pairs for aarch64, and they are</span>
<a name="l01489"></a>01489 <span class="comment">     * placed sequentially, in order, at the top of the unrolled loop.</span>
<a name="l01490"></a>01490 <span class="comment">     *</span>
<a name="l01491"></a>01491 <span class="comment">     * While MOVK is great for generating constants (2 cycles for a 64-bit</span>
<a name="l01492"></a>01492 <span class="comment">     * constant compared to 4 cycles for LDR), long MOVK chains stall the</span>
<a name="l01493"></a>01493 <span class="comment">     * integer pipelines:</span>
<a name="l01494"></a>01494 <span class="comment">     *   I   L   S</span>
<a name="l01495"></a>01495 <span class="comment">     * MOVK</span>
<a name="l01496"></a>01496 <span class="comment">     * MOVK</span>
<a name="l01497"></a>01497 <span class="comment">     * MOVK</span>
<a name="l01498"></a>01498 <span class="comment">     * MOVK</span>
<a name="l01499"></a>01499 <span class="comment">     * ADD</span>
<a name="l01500"></a>01500 <span class="comment">     * SUB      STR</span>
<a name="l01501"></a>01501 <span class="comment">     *          STR</span>
<a name="l01502"></a>01502 <span class="comment">     * By forcing loads from memory (as the asm line causes Clang to assume</span>
<a name="l01503"></a>01503 <span class="comment">     * that XXH3_kSecretPtr has been changed), the pipelines are used more</span>
<a name="l01504"></a>01504 <span class="comment">     * efficiently:</span>
<a name="l01505"></a>01505 <span class="comment">     *   I   L   S</span>
<a name="l01506"></a>01506 <span class="comment">     *      LDR</span>
<a name="l01507"></a>01507 <span class="comment">     *  ADD LDR</span>
<a name="l01508"></a>01508 <span class="comment">     *  SUB     STR</span>
<a name="l01509"></a>01509 <span class="comment">     *          STR</span>
<a name="l01510"></a>01510 <span class="comment">     * XXH3_64bits_withSeed, len == 256, Snapdragon 835</span>
<a name="l01511"></a>01511 <span class="comment">     *   without hack: 2654.4 MB/s</span>
<a name="l01512"></a>01512 <span class="comment">     *   with hack:    3202.9 MB/s</span>
<a name="l01513"></a>01513 <span class="comment">     */</span>
<a name="l01514"></a>01514     __asm__(<span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;+r&quot;</span> (kSecretPtr));
<a name="l01515"></a>01515 <span class="preprocessor">#endif</span>
<a name="l01516"></a>01516 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l01517"></a>01517 <span class="comment">     * Note: in debug mode, this overrides the asm optimization</span>
<a name="l01518"></a>01518 <span class="comment">     * and Clang will emit MOVK chains again.</span>
<a name="l01519"></a>01519 <span class="comment">     */</span>
<a name="l01520"></a>01520     XXH_ASSERT(kSecretPtr == XXH3_kSecret);
<a name="l01521"></a>01521 
<a name="l01522"></a>01522     <span class="keywordflow">for</span> (i=0; i &lt; nbRounds; i++) {
<a name="l01523"></a>01523         <span class="comment">/*</span>
<a name="l01524"></a>01524 <span class="comment">         * The asm hack causes Clang to assume that XXH3_kSecretPtr aliases with</span>
<a name="l01525"></a>01525 <span class="comment">         * customSecret, and on aarch64, this prevented LDP from merging two</span>
<a name="l01526"></a>01526 <span class="comment">         * loads together for free. Putting the loads together before the stores</span>
<a name="l01527"></a>01527 <span class="comment">         * properly generates LDP.</span>
<a name="l01528"></a>01528 <span class="comment">         */</span>
<a name="l01529"></a>01529         xxh_u64 lo = XXH_readLE64(kSecretPtr + 16*i)     + seed64;
<a name="l01530"></a>01530         xxh_u64 hi = XXH_readLE64(kSecretPtr + 16*i + 8) - seed64;
<a name="l01531"></a>01531         XXH_writeLE64(customSecret + 16*i,     lo);
<a name="l01532"></a>01532         XXH_writeLE64(customSecret + 16*i + 8, hi);
<a name="l01533"></a>01533     }
<a name="l01534"></a>01534 }
<a name="l01535"></a>01535 
<a name="l01536"></a>01536 
<a name="l01537"></a>01537 <span class="comment">/*</span>
<a name="l01538"></a>01538 <span class="comment"> * It&#39;s important for performance that XXH3_hashLong is not inlined. Not sure</span>
<a name="l01539"></a>01539 <span class="comment"> * why (uop cache maybe?), but the difference is large and easily measurable.</span>
<a name="l01540"></a>01540 <span class="comment"> */</span>
<a name="l01541"></a>01541 XXH_NO_INLINE XXH64_hash_t
<a name="l01542"></a>01542 XXH3_hashLong_64b_defaultSecret(<span class="keyword">const</span> xxh_u8* XXH_RESTRICT input, <span class="keywordtype">size_t</span> len)
<a name="l01543"></a>01543 {
<a name="l01544"></a>01544     <span class="keywordflow">return</span> XXH3_hashLong_64b_internal(input, len, XXH3_kSecret, <span class="keyword">sizeof</span>(XXH3_kSecret));
<a name="l01545"></a>01545 }
<a name="l01546"></a>01546 
<a name="l01547"></a>01547 <span class="comment">/*</span>
<a name="l01548"></a>01548 <span class="comment"> * It&#39;s important for performance that XXH3_hashLong is not inlined. Not sure</span>
<a name="l01549"></a>01549 <span class="comment"> * why (uop cache maybe?), but the difference is large and easily measurable.</span>
<a name="l01550"></a>01550 <span class="comment"> */</span>
<a name="l01551"></a>01551 XXH_NO_INLINE XXH64_hash_t
<a name="l01552"></a>01552 XXH3_hashLong_64b_withSecret(<span class="keyword">const</span> xxh_u8* XXH_RESTRICT input, <span class="keywordtype">size_t</span> len,
<a name="l01553"></a>01553                              <span class="keyword">const</span> xxh_u8* XXH_RESTRICT secret, <span class="keywordtype">size_t</span> secretSize)
<a name="l01554"></a>01554 {
<a name="l01555"></a>01555     <span class="keywordflow">return</span> XXH3_hashLong_64b_internal(input, len, secret, secretSize);
<a name="l01556"></a>01556 }
<a name="l01557"></a>01557 
<a name="l01558"></a>01558 <span class="comment">/*</span>
<a name="l01559"></a>01559 <span class="comment"> * XXH3_hashLong_64b_withSeed():</span>
<a name="l01560"></a>01560 <span class="comment"> * Generate a custom key based on alteration of default XXH3_kSecret with the seed,</span>
<a name="l01561"></a>01561 <span class="comment"> * and then use this key for long mode hashing.</span>
<a name="l01562"></a>01562 <span class="comment"> *</span>
<a name="l01563"></a>01563 <span class="comment"> * This operation is decently fast but nonetheless costs a little bit of time.</span>
<a name="l01564"></a>01564 <span class="comment"> * Try to avoid it whenever possible (typically when seed==0).</span>
<a name="l01565"></a>01565 <span class="comment"> *</span>
<a name="l01566"></a>01566 <span class="comment"> * It&#39;s important for performance that XXH3_hashLong is not inlined. Not sure</span>
<a name="l01567"></a>01567 <span class="comment"> * why (uop cache maybe?), but the difference is large and easily measurable.</span>
<a name="l01568"></a>01568 <span class="comment"> */</span>
<a name="l01569"></a>01569 XXH_NO_INLINE XXH64_hash_t
<a name="l01570"></a>01570 XXH3_hashLong_64b_withSeed(<span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> len, XXH64_hash_t seed)
<a name="l01571"></a>01571 {
<a name="l01572"></a>01572     XXH_ALIGN(8) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
<a name="l01573"></a>01573     if (seed==0) return XXH3_hashLong_64b_defaultSecret(input, len);
<a name="l01574"></a>01574     XXH3_initCustomSecret(secret, seed);
<a name="l01575"></a>01575     return XXH3_hashLong_64b_internal(input, len, secret, sizeof(secret));
<a name="l01576"></a>01576 }
<a name="l01577"></a>01577 
<a name="l01578"></a>01578 <span class="comment">/* ===   Public entry point   === */</span>
<a name="l01579"></a>01579 
<a name="l01580"></a>01580 XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const <span class="keywordtype">void</span>* input, <span class="keywordtype">size_t</span> len)
<a name="l01581"></a>01581 {
<a name="l01582"></a>01582     <span class="keywordflow">if</span> (len &lt;= 16)
<a name="l01583"></a>01583         <span class="keywordflow">return</span> XXH3_len_0to16_64b((<span class="keyword">const</span> xxh_u8*)input, len, XXH3_kSecret, 0);
<a name="l01584"></a>01584     <span class="keywordflow">if</span> (len &lt;= 128)
<a name="l01585"></a>01585         <span class="keywordflow">return</span> XXH3_len_17to128_64b((<span class="keyword">const</span> xxh_u8*)input, len, XXH3_kSecret, <span class="keyword">sizeof</span>(XXH3_kSecret), 0);
<a name="l01586"></a>01586     <span class="keywordflow">if</span> (len &lt;= XXH3_MIDSIZE_MAX)
<a name="l01587"></a>01587          <span class="keywordflow">return</span> XXH3_len_129to240_64b((<span class="keyword">const</span> xxh_u8*)input, len, XXH3_kSecret, <span class="keyword">sizeof</span>(XXH3_kSecret), 0);
<a name="l01588"></a>01588     <span class="keywordflow">return</span> XXH3_hashLong_64b_defaultSecret((<span class="keyword">const</span> xxh_u8*)input, len);
<a name="l01589"></a>01589 }
<a name="l01590"></a>01590 
<a name="l01591"></a>01591 XXH_PUBLIC_API XXH64_hash_t
<a name="l01592"></a>01592 XXH3_64bits_withSecret(<span class="keyword">const</span> <span class="keywordtype">void</span>* input, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> <span class="keywordtype">void</span>* secret, <span class="keywordtype">size_t</span> secretSize)
<a name="l01593"></a>01593 {
<a name="l01594"></a>01594     XXH_ASSERT(secretSize &gt;= XXH3_SECRET_SIZE_MIN);
<a name="l01595"></a>01595     <span class="comment">/*</span>
<a name="l01596"></a>01596 <span class="comment">     * If an action is to be taken if `secret` conditions are not respected,</span>
<a name="l01597"></a>01597 <span class="comment">     * it should be done here.</span>
<a name="l01598"></a>01598 <span class="comment">     * For now, it&#39;s a contract pre-condition.</span>
<a name="l01599"></a>01599 <span class="comment">     * Adding a check and a branch here would cost performance at every hash.</span>
<a name="l01600"></a>01600 <span class="comment">     */</span>
<a name="l01601"></a>01601     <span class="keywordflow">if</span> (len &lt;= 16)
<a name="l01602"></a>01602         <span class="keywordflow">return</span> XXH3_len_0to16_64b((<span class="keyword">const</span> xxh_u8*)input, len, (<span class="keyword">const</span> xxh_u8*)secret, 0);
<a name="l01603"></a>01603     <span class="keywordflow">if</span> (len &lt;= 128)
<a name="l01604"></a>01604         <span class="keywordflow">return</span> XXH3_len_17to128_64b((<span class="keyword">const</span> xxh_u8*)input, len, (<span class="keyword">const</span> xxh_u8*)secret, secretSize, 0);
<a name="l01605"></a>01605     <span class="keywordflow">if</span> (len &lt;= XXH3_MIDSIZE_MAX)
<a name="l01606"></a>01606         <span class="keywordflow">return</span> XXH3_len_129to240_64b((<span class="keyword">const</span> xxh_u8*)input, len, (<span class="keyword">const</span> xxh_u8*)secret, secretSize, 0);
<a name="l01607"></a>01607     <span class="keywordflow">return</span> XXH3_hashLong_64b_withSecret((<span class="keyword">const</span> xxh_u8*)input, len, (<span class="keyword">const</span> xxh_u8*)secret, secretSize);
<a name="l01608"></a>01608 }
<a name="l01609"></a>01609 
<a name="l01610"></a>01610 XXH_PUBLIC_API XXH64_hash_t
<a name="l01611"></a>01611 XXH3_64bits_withSeed(<span class="keyword">const</span> <span class="keywordtype">void</span>* input, <span class="keywordtype">size_t</span> len, XXH64_hash_t seed)
<a name="l01612"></a>01612 {
<a name="l01613"></a>01613     <span class="keywordflow">if</span> (len &lt;= 16)
<a name="l01614"></a>01614         <span class="keywordflow">return</span> XXH3_len_0to16_64b((<span class="keyword">const</span> xxh_u8*)input, len, XXH3_kSecret, seed);
<a name="l01615"></a>01615     <span class="keywordflow">if</span> (len &lt;= 128)
<a name="l01616"></a>01616         <span class="keywordflow">return</span> XXH3_len_17to128_64b((<span class="keyword">const</span> xxh_u8*)input, len, XXH3_kSecret, <span class="keyword">sizeof</span>(XXH3_kSecret), seed);
<a name="l01617"></a>01617     <span class="keywordflow">if</span> (len &lt;= XXH3_MIDSIZE_MAX)
<a name="l01618"></a>01618         <span class="keywordflow">return</span> XXH3_len_129to240_64b((<span class="keyword">const</span> xxh_u8*)input, len, XXH3_kSecret, <span class="keyword">sizeof</span>(XXH3_kSecret), seed);
<a name="l01619"></a>01619     <span class="keywordflow">return</span> XXH3_hashLong_64b_withSeed((<span class="keyword">const</span> xxh_u8*)input, len, seed);
<a name="l01620"></a>01620 }
<a name="l01621"></a>01621 
<a name="l01622"></a>01622 <span class="comment">/* ===   XXH3 streaming   === */</span>
<a name="l01623"></a>01623 
<a name="l01624"></a>01624 
<a name="l01625"></a>01625 <span class="comment">/*</span>
<a name="l01626"></a>01626 <span class="comment"> * Malloc&#39;s a pointer that is always aligned to align.</span>
<a name="l01627"></a>01627 <span class="comment"> *</span>
<a name="l01628"></a>01628 <span class="comment"> * This must be freed with `XXH_alignedFree()`.</span>
<a name="l01629"></a>01629 <span class="comment"> *</span>
<a name="l01630"></a>01630 <span class="comment"> * malloc typically guarantees 16 byte alignment on 64-bit systems and 8 byte</span>
<a name="l01631"></a>01631 <span class="comment"> * alignment on 32-bit. This isn&#39;t enough for the 32 byte aligned loads in AVX2</span>
<a name="l01632"></a>01632 <span class="comment"> * or on 32-bit, the 16 byte aligned loads in SSE2 and NEON.</span>
<a name="l01633"></a>01633 <span class="comment"> *</span>
<a name="l01634"></a>01634 <span class="comment"> * This underalignment previously caused a rather obvious crash which went</span>
<a name="l01635"></a>01635 <span class="comment"> * completely unnoticed due to XXH3_createState() not actually being tested.</span>
<a name="l01636"></a>01636 <span class="comment"> * Credit to RedSpah for noticing this bug.</span>
<a name="l01637"></a>01637 <span class="comment"> *</span>
<a name="l01638"></a>01638 <span class="comment"> * The alignment is done manually: Functions like posix_memalign or _mm_malloc</span>
<a name="l01639"></a>01639 <span class="comment"> * are avoided: To maintain portability, we would have to write a fallback</span>
<a name="l01640"></a>01640 <span class="comment"> * like this anyways, and besides, testing for the existence of library</span>
<a name="l01641"></a>01641 <span class="comment"> * functions without relying on external build tools is impossible.</span>
<a name="l01642"></a>01642 <span class="comment"> *</span>
<a name="l01643"></a>01643 <span class="comment"> * The method is simple: Overallocate, manually align, and store the offset</span>
<a name="l01644"></a>01644 <span class="comment"> * to the original behind the returned pointer.</span>
<a name="l01645"></a>01645 <span class="comment"> *</span>
<a name="l01646"></a>01646 <span class="comment"> * Align must be a power of 2 and 8 &lt;= align &lt;= 128.</span>
<a name="l01647"></a>01647 <span class="comment"> */</span>
<a name="l01648"></a>01648 <span class="keyword">static</span> <span class="keywordtype">void</span>* XXH_alignedMalloc(<span class="keywordtype">size_t</span> s, <span class="keywordtype">size_t</span> align)
<a name="l01649"></a>01649 {
<a name="l01650"></a>01650     XXH_ASSERT(align &lt;= 128 &amp;&amp; align &gt;= 8); <span class="comment">/* range check */</span>
<a name="l01651"></a>01651     XXH_ASSERT((align &amp; (align-1)) == 0);   <span class="comment">/* power of 2 */</span>
<a name="l01652"></a>01652     XXH_ASSERT(s != 0 &amp;&amp; s &lt; (s + align));  <span class="comment">/* empty/overflow */</span>
<a name="l01653"></a>01653     {   <span class="comment">/* Overallocate to make room for manual realignment and an offset byte */</span>
<a name="l01654"></a>01654         xxh_u8* base = (xxh_u8*)XXH_malloc(s + align);
<a name="l01655"></a>01655         <span class="keywordflow">if</span> (base != NULL) {
<a name="l01656"></a>01656             <span class="comment">/*</span>
<a name="l01657"></a>01657 <span class="comment">             * Get the offset needed to align this pointer.</span>
<a name="l01658"></a>01658 <span class="comment">             *</span>
<a name="l01659"></a>01659 <span class="comment">             * Even if the returned pointer is aligned, there will always be</span>
<a name="l01660"></a>01660 <span class="comment">             * at least one byte to store the offset to the original pointer.</span>
<a name="l01661"></a>01661 <span class="comment">             */</span>
<a name="l01662"></a>01662             <span class="keywordtype">size_t</span> offset = align - ((size_t)base &amp; (align - 1)); <span class="comment">/* base % align */</span>
<a name="l01663"></a>01663             <span class="comment">/* Add the offset for the now-aligned pointer */</span>
<a name="l01664"></a>01664             xxh_u8* ptr = base + offset;
<a name="l01665"></a>01665 
<a name="l01666"></a>01666             XXH_ASSERT((<span class="keywordtype">size_t</span>)ptr % align == 0);
<a name="l01667"></a>01667 
<a name="l01668"></a>01668             <span class="comment">/* Store the offset immediately before the returned pointer. */</span>
<a name="l01669"></a>01669             ptr[-1] = (xxh_u8)offset;
<a name="l01670"></a>01670             <span class="keywordflow">return</span> ptr;
<a name="l01671"></a>01671         }
<a name="l01672"></a>01672         <span class="keywordflow">return</span> NULL;
<a name="l01673"></a>01673     }
<a name="l01674"></a>01674 }
<a name="l01675"></a>01675 <span class="comment">/*</span>
<a name="l01676"></a>01676 <span class="comment"> * Frees an aligned pointer allocated by XXH_alignedMalloc(). Don&#39;t pass</span>
<a name="l01677"></a>01677 <span class="comment"> * normal malloc&#39;d pointers, XXH_alignedMalloc has a specific data layout.</span>
<a name="l01678"></a>01678 <span class="comment"> */</span>
<a name="l01679"></a>01679 <span class="keyword">static</span> <span class="keywordtype">void</span> XXH_alignedFree(<span class="keywordtype">void</span>* p)
<a name="l01680"></a>01680 {
<a name="l01681"></a>01681     <span class="keywordflow">if</span> (p != NULL) {
<a name="l01682"></a>01682         xxh_u8* ptr = (xxh_u8*)p;
<a name="l01683"></a>01683         <span class="comment">/* Get the offset byte we added in XXH_malloc. */</span>
<a name="l01684"></a>01684         xxh_u8 offset = ptr[-1];
<a name="l01685"></a>01685         <span class="comment">/* Free the original malloc&#39;d pointer */</span>
<a name="l01686"></a>01686         xxh_u8* base = ptr - offset;
<a name="l01687"></a>01687         XXH_free(base);
<a name="l01688"></a>01688     }
<a name="l01689"></a>01689 }
<a name="l01690"></a>01690 XXH_PUBLIC_API XXH3_state_t* XXH3_createState(<span class="keywordtype">void</span>)
<a name="l01691"></a>01691 {
<a name="l01692"></a>01692     <span class="keywordflow">return</span> (XXH3_state_t*)XXH_alignedMalloc(<span class="keyword">sizeof</span>(XXH3_state_t), 64);
<a name="l01693"></a>01693 }
<a name="l01694"></a>01694 
<a name="l01695"></a>01695 XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr)
<a name="l01696"></a>01696 {
<a name="l01697"></a>01697     XXH_alignedFree(statePtr);
<a name="l01698"></a>01698     <span class="keywordflow">return</span> XXH_OK;
<a name="l01699"></a>01699 }
<a name="l01700"></a>01700 
<a name="l01701"></a>01701 XXH_PUBLIC_API <span class="keywordtype">void</span>
<a name="l01702"></a>01702 XXH3_copyState(XXH3_state_t* dst_state, <span class="keyword">const</span> XXH3_state_t* src_state)
<a name="l01703"></a>01703 {
<a name="l01704"></a>01704     memcpy(dst_state, src_state, <span class="keyword">sizeof</span>(*dst_state));
<a name="l01705"></a>01705 }
<a name="l01706"></a>01706 
<a name="l01707"></a>01707 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01708"></a>01708 XXH3_64bits_reset_internal(XXH3_state_t* statePtr,
<a name="l01709"></a>01709                            XXH64_hash_t seed,
<a name="l01710"></a>01710                            <span class="keyword">const</span> xxh_u8* secret, <span class="keywordtype">size_t</span> secretSize)
<a name="l01711"></a>01711 {
<a name="l01712"></a>01712     XXH_ASSERT(statePtr != NULL);
<a name="l01713"></a>01713     memset(statePtr, 0, <span class="keyword">sizeof</span>(*statePtr));
<a name="l01714"></a>01714     statePtr-&gt;acc[0] = XXH_PRIME32_3;
<a name="l01715"></a>01715     statePtr-&gt;acc[1] = XXH_PRIME64_1;
<a name="l01716"></a>01716     statePtr-&gt;acc[2] = XXH_PRIME64_2;
<a name="l01717"></a>01717     statePtr-&gt;acc[3] = XXH_PRIME64_3;
<a name="l01718"></a>01718     statePtr-&gt;acc[4] = XXH_PRIME64_4;
<a name="l01719"></a>01719     statePtr-&gt;acc[5] = XXH_PRIME32_2;
<a name="l01720"></a>01720     statePtr-&gt;acc[6] = XXH_PRIME64_5;
<a name="l01721"></a>01721     statePtr-&gt;acc[7] = XXH_PRIME32_1;
<a name="l01722"></a>01722     statePtr-&gt;seed = seed;
<a name="l01723"></a>01723     XXH_ASSERT(secret != NULL);
<a name="l01724"></a>01724     statePtr-&gt;extSecret = secret;
<a name="l01725"></a>01725     XXH_ASSERT(secretSize &gt;= XXH3_SECRET_SIZE_MIN);
<a name="l01726"></a>01726     statePtr-&gt;secretLimit = secretSize - XXH_STRIPE_LEN;
<a name="l01727"></a>01727     statePtr-&gt;nbStripesPerBlock = statePtr-&gt;secretLimit / XXH_SECRET_CONSUME_RATE;
<a name="l01728"></a>01728 }
<a name="l01729"></a>01729 
<a name="l01730"></a>01730 XXH_PUBLIC_API XXH_errorcode
<a name="l01731"></a>01731 XXH3_64bits_reset(XXH3_state_t* statePtr)
<a name="l01732"></a>01732 {
<a name="l01733"></a>01733     <span class="keywordflow">if</span> (statePtr == NULL) <span class="keywordflow">return</span> XXH_ERROR;
<a name="l01734"></a>01734     XXH3_64bits_reset_internal(statePtr, 0, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
<a name="l01735"></a>01735     <span class="keywordflow">return</span> XXH_OK;
<a name="l01736"></a>01736 }
<a name="l01737"></a>01737 
<a name="l01738"></a>01738 XXH_PUBLIC_API XXH_errorcode
<a name="l01739"></a>01739 XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, <span class="keyword">const</span> <span class="keywordtype">void</span>* secret, <span class="keywordtype">size_t</span> secretSize)
<a name="l01740"></a>01740 {
<a name="l01741"></a>01741     <span class="keywordflow">if</span> (statePtr == NULL) <span class="keywordflow">return</span> XXH_ERROR;
<a name="l01742"></a>01742     XXH3_64bits_reset_internal(statePtr, 0, (<span class="keyword">const</span> xxh_u8*)secret, secretSize);
<a name="l01743"></a>01743     <span class="keywordflow">if</span> (secret == NULL) <span class="keywordflow">return</span> XXH_ERROR;
<a name="l01744"></a>01744     <span class="keywordflow">if</span> (secretSize &lt; XXH3_SECRET_SIZE_MIN) <span class="keywordflow">return</span> XXH_ERROR;
<a name="l01745"></a>01745     <span class="keywordflow">return</span> XXH_OK;
<a name="l01746"></a>01746 }
<a name="l01747"></a>01747 
<a name="l01748"></a>01748 XXH_PUBLIC_API XXH_errorcode
<a name="l01749"></a>01749 XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed)
<a name="l01750"></a>01750 {
<a name="l01751"></a>01751     <span class="keywordflow">if</span> (statePtr == NULL) <span class="keywordflow">return</span> XXH_ERROR;
<a name="l01752"></a>01752     XXH3_64bits_reset_internal(statePtr, seed, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
<a name="l01753"></a>01753     XXH3_initCustomSecret(statePtr-&gt;customSecret, seed);
<a name="l01754"></a>01754     statePtr-&gt;extSecret = NULL;
<a name="l01755"></a>01755     <span class="keywordflow">return</span> XXH_OK;
<a name="l01756"></a>01756 }
<a name="l01757"></a>01757 
<a name="l01758"></a>01758 XXH_FORCE_INLINE <span class="keywordtype">void</span>
<a name="l01759"></a>01759 XXH3_consumeStripes( xxh_u64* acc,
<a name="l01760"></a>01760                     <span class="keywordtype">size_t</span>* nbStripesSoFarPtr, <span class="keywordtype">size_t</span> nbStripesPerBlock,
<a name="l01761"></a>01761                     <span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> totalStripes,
<a name="l01762"></a>01762                     <span class="keyword">const</span> xxh_u8* secret, <span class="keywordtype">size_t</span> secretLimit,
<a name="l01763"></a>01763                     XXH3_accWidth_e accWidth)
<a name="l01764"></a>01764 {
<a name="l01765"></a>01765     XXH_ASSERT(*nbStripesSoFarPtr &lt; nbStripesPerBlock);
<a name="l01766"></a>01766     <span class="keywordflow">if</span> (nbStripesPerBlock - *nbStripesSoFarPtr &lt;= totalStripes) {
<a name="l01767"></a>01767         <span class="comment">/* need a scrambling operation */</span>
<a name="l01768"></a>01768         <span class="keywordtype">size_t</span> <span class="keyword">const</span> nbStripes = nbStripesPerBlock - *nbStripesSoFarPtr;
<a name="l01769"></a>01769         XXH3_accumulate(acc, input, secret + nbStripesSoFarPtr[0] * XXH_SECRET_CONSUME_RATE, nbStripes, accWidth);
<a name="l01770"></a>01770         XXH3_scrambleAcc(acc, secret + secretLimit);
<a name="l01771"></a>01771         XXH3_accumulate(acc, input + nbStripes * XXH_STRIPE_LEN, secret, totalStripes - nbStripes, accWidth);
<a name="l01772"></a>01772         *nbStripesSoFarPtr = (XXH32_hash_t)(totalStripes - nbStripes);
<a name="l01773"></a>01773     } <span class="keywordflow">else</span> {
<a name="l01774"></a>01774         XXH3_accumulate(acc, input, secret + nbStripesSoFarPtr[0] * XXH_SECRET_CONSUME_RATE, totalStripes, accWidth);
<a name="l01775"></a>01775         *nbStripesSoFarPtr += (XXH32_hash_t)totalStripes;
<a name="l01776"></a>01776     }
<a name="l01777"></a>01777 }
<a name="l01778"></a>01778 
<a name="l01779"></a>01779 <span class="comment">/*</span>
<a name="l01780"></a>01780 <span class="comment"> * Both XXH3_64bits_update and XXH3_128bits_update use this routine.</span>
<a name="l01781"></a>01781 <span class="comment"> */</span>
<a name="l01782"></a>01782 XXH_FORCE_INLINE XXH_errorcode
<a name="l01783"></a>01783 XXH3_update(XXH3_state_t* state, <span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> len, XXH3_accWidth_e accWidth)
<a name="l01784"></a>01784 {
<a name="l01785"></a>01785     <span class="keywordflow">if</span> (input==NULL)
<a name="l01786"></a>01786 <span class="preprocessor">#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) &amp;&amp; (XXH_ACCEPT_NULL_INPUT_POINTER&gt;=1)</span>
<a name="l01787"></a>01787 <span class="preprocessor"></span>        <span class="keywordflow">return</span> XXH_OK;
<a name="l01788"></a>01788 <span class="preprocessor">#else</span>
<a name="l01789"></a>01789 <span class="preprocessor"></span>        <span class="keywordflow">return</span> XXH_ERROR;
<a name="l01790"></a>01790 <span class="preprocessor">#endif</span>
<a name="l01791"></a>01791 <span class="preprocessor"></span>
<a name="l01792"></a>01792     {   <span class="keyword">const</span> xxh_u8* <span class="keyword">const</span> bEnd = input + len;
<a name="l01793"></a>01793         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> secret = (state-&gt;extSecret == NULL) ? state-&gt;customSecret : state-&gt;extSecret;
<a name="l01794"></a>01794 
<a name="l01795"></a>01795         state-&gt;totalLen += len;
<a name="l01796"></a>01796 
<a name="l01797"></a>01797         if (state-&gt;bufferedSize + len &lt;= XXH3_INTERNALBUFFER_SIZE) {  <span class="comment">/* fill in tmp buffer */</span>
<a name="l01798"></a>01798             XXH_memcpy(state-&gt;buffer + state-&gt;bufferedSize, input, len);
<a name="l01799"></a>01799             state-&gt;bufferedSize += (XXH32_hash_t)len;
<a name="l01800"></a>01800             <span class="keywordflow">return</span> XXH_OK;
<a name="l01801"></a>01801         }
<a name="l01802"></a>01802         <span class="comment">/* input is now &gt; XXH3_INTERNALBUFFER_SIZE */</span>
<a name="l01803"></a>01803 
<a name="l01804"></a>01804 <span class="preprocessor">        #define XXH3_INTERNALBUFFER_STRIPES (XXH3_INTERNALBUFFER_SIZE / XXH_STRIPE_LEN)</span>
<a name="l01805"></a>01805 <span class="preprocessor"></span>        XXH_STATIC_ASSERT(XXH3_INTERNALBUFFER_SIZE % XXH_STRIPE_LEN == 0);   <span class="comment">/* clean multiple */</span>
<a name="l01806"></a>01806 
<a name="l01807"></a>01807         <span class="comment">/*</span>
<a name="l01808"></a>01808 <span class="comment">         * There is some input left inside the internal buffer.</span>
<a name="l01809"></a>01809 <span class="comment">         * Fill it, then consume it.</span>
<a name="l01810"></a>01810 <span class="comment">         */</span>
<a name="l01811"></a>01811         <span class="keywordflow">if</span> (state-&gt;bufferedSize) {
<a name="l01812"></a>01812             <span class="keywordtype">size_t</span> <span class="keyword">const</span> loadSize = XXH3_INTERNALBUFFER_SIZE - state-&gt;bufferedSize;
<a name="l01813"></a>01813             XXH_memcpy(state-&gt;buffer + state-&gt;bufferedSize, input, loadSize);
<a name="l01814"></a>01814             input += loadSize;
<a name="l01815"></a>01815             XXH3_consumeStripes(state-&gt;acc,
<a name="l01816"></a>01816                                &amp;state-&gt;nbStripesSoFar, state-&gt;nbStripesPerBlock,
<a name="l01817"></a>01817                                 state-&gt;buffer, XXH3_INTERNALBUFFER_STRIPES,
<a name="l01818"></a>01818                                 secret, state-&gt;secretLimit,
<a name="l01819"></a>01819                                 accWidth);
<a name="l01820"></a>01820             state-&gt;bufferedSize = 0;
<a name="l01821"></a>01821         }
<a name="l01822"></a>01822 
<a name="l01823"></a>01823         <span class="comment">/* Consume input by full buffer quantities */</span>
<a name="l01824"></a>01824         <span class="keywordflow">if</span> (input+XXH3_INTERNALBUFFER_SIZE &lt;= bEnd) {
<a name="l01825"></a>01825             <span class="keyword">const</span> xxh_u8* <span class="keyword">const</span> limit = bEnd - XXH3_INTERNALBUFFER_SIZE;
<a name="l01826"></a>01826             <span class="keywordflow">do</span> {
<a name="l01827"></a>01827                 XXH3_consumeStripes(state-&gt;acc,
<a name="l01828"></a>01828                                    &amp;state-&gt;nbStripesSoFar, state-&gt;nbStripesPerBlock,
<a name="l01829"></a>01829                                     input, XXH3_INTERNALBUFFER_STRIPES,
<a name="l01830"></a>01830                                     secret, state-&gt;secretLimit,
<a name="l01831"></a>01831                                     accWidth);
<a name="l01832"></a>01832                 input += XXH3_INTERNALBUFFER_SIZE;
<a name="l01833"></a>01833             } <span class="keywordflow">while</span> (input&lt;=limit);
<a name="l01834"></a>01834         }
<a name="l01835"></a>01835 
<a name="l01836"></a>01836         <span class="keywordflow">if</span> (input &lt; bEnd) { <span class="comment">/* Some remaining input: buffer it */</span>
<a name="l01837"></a>01837             XXH_memcpy(state-&gt;buffer, input, (<span class="keywordtype">size_t</span>)(bEnd-input));
<a name="l01838"></a>01838             state-&gt;bufferedSize = (XXH32_hash_t)(bEnd-input);
<a name="l01839"></a>01839         }
<a name="l01840"></a>01840     }
<a name="l01841"></a>01841 
<a name="l01842"></a>01842     <span class="keywordflow">return</span> XXH_OK;
<a name="l01843"></a>01843 }
<a name="l01844"></a>01844 
<a name="l01845"></a>01845 XXH_PUBLIC_API XXH_errorcode
<a name="l01846"></a>01846 XXH3_64bits_update(XXH3_state_t* state, <span class="keyword">const</span> <span class="keywordtype">void</span>* input, <span class="keywordtype">size_t</span> len)
<a name="l01847"></a>01847 {
<a name="l01848"></a>01848     <span class="keywordflow">return</span> XXH3_update(state, (<span class="keyword">const</span> xxh_u8*)input, len, XXH3_acc_64bits);
<a name="l01849"></a>01849 }
<a name="l01850"></a>01850 
<a name="l01851"></a>01851 
<a name="l01852"></a>01852 XXH_FORCE_INLINE <span class="keywordtype">void</span>
<a name="l01853"></a>01853 XXH3_digest_long (XXH64_hash_t* acc,
<a name="l01854"></a>01854                   <span class="keyword">const</span> XXH3_state_t* state,
<a name="l01855"></a>01855                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* secret,
<a name="l01856"></a>01856                   XXH3_accWidth_e accWidth)
<a name="l01857"></a>01857 {
<a name="l01858"></a>01858     <span class="comment">/*</span>
<a name="l01859"></a>01859 <span class="comment">     * Digest on a local copy. This way, the state remains unaltered, and it can</span>
<a name="l01860"></a>01860 <span class="comment">     * continue ingesting more input afterwards.</span>
<a name="l01861"></a>01861 <span class="comment">     */</span>
<a name="l01862"></a>01862     memcpy(acc, state-&gt;acc, <span class="keyword">sizeof</span>(state-&gt;acc));
<a name="l01863"></a>01863     <span class="keywordflow">if</span> (state-&gt;bufferedSize &gt;= XXH_STRIPE_LEN) {
<a name="l01864"></a>01864         <span class="keywordtype">size_t</span> <span class="keyword">const</span> totalNbStripes = state-&gt;bufferedSize / XXH_STRIPE_LEN;
<a name="l01865"></a>01865         <span class="keywordtype">size_t</span> nbStripesSoFar = state-&gt;nbStripesSoFar;
<a name="l01866"></a>01866         XXH3_consumeStripes(acc,
<a name="l01867"></a>01867                            &amp;nbStripesSoFar, state-&gt;nbStripesPerBlock,
<a name="l01868"></a>01868                             state-&gt;buffer, totalNbStripes,
<a name="l01869"></a>01869                             secret, state-&gt;secretLimit,
<a name="l01870"></a>01870                             accWidth);
<a name="l01871"></a>01871         <span class="keywordflow">if</span> (state-&gt;bufferedSize % XXH_STRIPE_LEN) {  <span class="comment">/* one last partial stripe */</span>
<a name="l01872"></a>01872             XXH3_accumulate_512(acc,
<a name="l01873"></a>01873                                 state-&gt;buffer + state-&gt;bufferedSize - XXH_STRIPE_LEN,
<a name="l01874"></a>01874                                 secret + state-&gt;secretLimit - XXH_SECRET_LASTACC_START,
<a name="l01875"></a>01875                                 accWidth);
<a name="l01876"></a>01876         }
<a name="l01877"></a>01877     } <span class="keywordflow">else</span> {  <span class="comment">/* bufferedSize &lt; XXH_STRIPE_LEN */</span>
<a name="l01878"></a>01878         <span class="keywordflow">if</span> (state-&gt;bufferedSize) { <span class="comment">/* one last stripe */</span>
<a name="l01879"></a>01879             xxh_u8 lastStripe[XXH_STRIPE_LEN];
<a name="l01880"></a>01880             <span class="keywordtype">size_t</span> <span class="keyword">const</span> catchupSize = XXH_STRIPE_LEN - state-&gt;bufferedSize;
<a name="l01881"></a>01881             memcpy(lastStripe, state-&gt;buffer + <span class="keyword">sizeof</span>(state-&gt;buffer) - catchupSize, catchupSize);
<a name="l01882"></a>01882             memcpy(lastStripe + catchupSize, state-&gt;buffer, state-&gt;bufferedSize);
<a name="l01883"></a>01883             XXH3_accumulate_512(acc,
<a name="l01884"></a>01884                                 lastStripe,
<a name="l01885"></a>01885                                 secret + state-&gt;secretLimit - XXH_SECRET_LASTACC_START,
<a name="l01886"></a>01886                                 accWidth);
<a name="l01887"></a>01887     }   }
<a name="l01888"></a>01888 }
<a name="l01889"></a>01889 
<a name="l01890"></a>01890 XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_digest (<span class="keyword">const</span> XXH3_state_t* state)
<a name="l01891"></a>01891 {
<a name="l01892"></a>01892     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> secret = (state-&gt;extSecret == NULL) ? state-&gt;customSecret : state-&gt;extSecret;
<a name="l01893"></a>01893     if (state-&gt;totalLen &gt; XXH3_MIDSIZE_MAX) {
<a name="l01894"></a>01894         XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[XXH_ACC_NB];
<a name="l01895"></a>01895         XXH3_digest_long(acc, state, secret, XXH3_acc_64bits);
<a name="l01896"></a>01896         return XXH3_mergeAccs(acc,
<a name="l01897"></a>01897                               secret + XXH_SECRET_MERGEACCS_START,
<a name="l01898"></a>01898                               (xxh_u64)state-&gt;totalLen * XXH_PRIME64_1);
<a name="l01899"></a>01899     }
<a name="l01900"></a>01900     <span class="comment">/* totalLen &lt;= XXH3_MIDSIZE_MAX: digesting a short input */</span>
<a name="l01901"></a>01901     if (state-&gt;seed)
<a name="l01902"></a>01902         return XXH3_64bits_withSeed(state-&gt;buffer, (<span class="keywordtype">size_t</span>)state-&gt;totalLen, state-&gt;seed);
<a name="l01903"></a>01903     return XXH3_64bits_withSecret(state-&gt;buffer, (<span class="keywordtype">size_t</span>)(state-&gt;totalLen),
<a name="l01904"></a>01904                                   secret, state-&gt;secretLimit + XXH_STRIPE_LEN);
<a name="l01905"></a>01905 }
<a name="l01906"></a>01906 
<a name="l01907"></a>01907 <span class="comment">/* ==========================================</span>
<a name="l01908"></a>01908 <span class="comment"> * XXH3 128 bits (a.k.a XXH128)</span>
<a name="l01909"></a>01909 <span class="comment"> * ==========================================</span>
<a name="l01910"></a>01910 <span class="comment"> * XXH3&#39;s 128-bit variant has better mixing and strength than the 64-bit variant,</span>
<a name="l01911"></a>01911 <span class="comment"> * even without counting the significantly larger output size.</span>
<a name="l01912"></a>01912 <span class="comment"> *</span>
<a name="l01913"></a>01913 <span class="comment"> * For example, extra steps are taken to avoid the seed-dependent collisions</span>
<a name="l01914"></a>01914 <span class="comment"> * in 17-240 byte inputs (See XXH3_mix16B and XXH128_mix32B).</span>
<a name="l01915"></a>01915 <span class="comment"> *</span>
<a name="l01916"></a>01916 <span class="comment"> * This strength naturally comes at the cost of some speed, especially on short</span>
<a name="l01917"></a>01917 <span class="comment"> * lengths. Note that longer hashes are about as fast as the 64-bit version</span>
<a name="l01918"></a>01918 <span class="comment"> * due to it using only a slight modification of the 64-bit loop.</span>
<a name="l01919"></a>01919 <span class="comment"> *</span>
<a name="l01920"></a>01920 <span class="comment"> * XXH128 is also more oriented towards 64-bit machines. It is still extremely</span>
<a name="l01921"></a>01921 <span class="comment"> * fast for a _128-bit_ hash on 32-bit (it usually clears XXH64).</span>
<a name="l01922"></a>01922 <span class="comment"> */</span>
<a name="l01923"></a>01923 
<a name="l01924"></a>01924 XXH_FORCE_INLINE XXH128_hash_t
<a name="l01925"></a>01925 XXH3_len_1to3_128b(const xxh_u8* input, <span class="keywordtype">size_t</span> len, const xxh_u8* secret, XXH64_hash_t seed)
<a name="l01926"></a>01926 {
<a name="l01927"></a>01927     <span class="comment">/* A doubled version of 1to3_64b with different constants. */</span>
<a name="l01928"></a>01928     XXH_ASSERT(input != NULL);
<a name="l01929"></a>01929     XXH_ASSERT(1 &lt;= len &amp;&amp; len &lt;= 3);
<a name="l01930"></a>01930     XXH_ASSERT(secret != NULL);
<a name="l01931"></a>01931     <span class="comment">/*</span>
<a name="l01932"></a>01932 <span class="comment">     * len = 1: combinedl = { input[0], 0x01, input[0], input[0] }</span>
<a name="l01933"></a>01933 <span class="comment">     * len = 2: combinedl = { input[1], 0x02, input[0], input[1] }</span>
<a name="l01934"></a>01934 <span class="comment">     * len = 3: combinedl = { input[2], 0x03, input[0], input[1] }</span>
<a name="l01935"></a>01935 <span class="comment">     */</span>
<a name="l01936"></a>01936     {   xxh_u8 <span class="keyword">const</span> c1 = input[0];
<a name="l01937"></a>01937         xxh_u8 <span class="keyword">const</span> c2 = input[len &gt;&gt; 1];
<a name="l01938"></a>01938         xxh_u8 <span class="keyword">const</span> c3 = input[len - 1];
<a name="l01939"></a>01939         xxh_u32 <span class="keyword">const</span> combinedl = ((xxh_u32)c1 &lt;&lt;16) | ((xxh_u32)c2 &lt;&lt; 24)
<a name="l01940"></a>01940                                 | ((xxh_u32)c3 &lt;&lt; 0) | ((xxh_u32)len &lt;&lt; 8);
<a name="l01941"></a>01941         xxh_u32 <span class="keyword">const</span> combinedh = XXH_rotl32(XXH_swap32(combinedl), 13);
<a name="l01942"></a>01942         xxh_u64 <span class="keyword">const</span> bitflipl = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
<a name="l01943"></a>01943         xxh_u64 <span class="keyword">const</span> bitfliph = (XXH_readLE32(secret+8) ^ XXH_readLE32(secret+12)) - seed;
<a name="l01944"></a>01944         xxh_u64 <span class="keyword">const</span> keyed_lo = (xxh_u64)combinedl ^ bitflipl;
<a name="l01945"></a>01945         xxh_u64 <span class="keyword">const</span> keyed_hi = (xxh_u64)combinedh ^ bitfliph;
<a name="l01946"></a>01946         xxh_u64 <span class="keyword">const</span> mixedl = keyed_lo * XXH_PRIME64_1;
<a name="l01947"></a>01947         xxh_u64 <span class="keyword">const</span> mixedh = keyed_hi * XXH_PRIME64_5;
<a name="l01948"></a>01948         XXH128_hash_t h128;
<a name="l01949"></a>01949         h128.low64  = XXH3_avalanche(mixedl);
<a name="l01950"></a>01950         h128.high64 = XXH3_avalanche(mixedh);
<a name="l01951"></a>01951         <span class="keywordflow">return</span> h128;
<a name="l01952"></a>01952     }
<a name="l01953"></a>01953 }
<a name="l01954"></a>01954 
<a name="l01955"></a>01955 XXH_FORCE_INLINE XXH128_hash_t
<a name="l01956"></a>01956 XXH3_len_4to8_128b(<span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> xxh_u8* secret, XXH64_hash_t seed)
<a name="l01957"></a>01957 {
<a name="l01958"></a>01958     XXH_ASSERT(input != NULL);
<a name="l01959"></a>01959     XXH_ASSERT(secret != NULL);
<a name="l01960"></a>01960     XXH_ASSERT(4 &lt;= len &amp;&amp; len &lt;= 8);
<a name="l01961"></a>01961     seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) &lt;&lt; 32;
<a name="l01962"></a>01962     {   xxh_u32 <span class="keyword">const</span> input_lo = XXH_readLE32(input);
<a name="l01963"></a>01963         xxh_u32 <span class="keyword">const</span> input_hi = XXH_readLE32(input + len - 4);
<a name="l01964"></a>01964         xxh_u64 <span class="keyword">const</span> input_64 = input_lo + ((xxh_u64)input_hi &lt;&lt; 32);
<a name="l01965"></a>01965         xxh_u64 <span class="keyword">const</span> bitflip = (XXH_readLE64(secret+16) ^ XXH_readLE64(secret+24)) + seed;
<a name="l01966"></a>01966         xxh_u64 <span class="keyword">const</span> keyed = input_64 ^ bitflip;
<a name="l01967"></a>01967 
<a name="l01968"></a>01968         <span class="comment">/* Shift len to the left to ensure it is even, this avoids even multiplies. */</span>
<a name="l01969"></a>01969         XXH128_hash_t m128 = XXH_mult64to128(keyed, XXH_PRIME64_1 + (len &lt;&lt; 2));
<a name="l01970"></a>01970 
<a name="l01971"></a>01971         m128.high64 += (m128.low64 &lt;&lt; 1);
<a name="l01972"></a>01972         m128.low64  ^= (m128.high64 &gt;&gt; 3);
<a name="l01973"></a>01973 
<a name="l01974"></a>01974         m128.low64   = XXH_xorshift64(m128.low64, 35);
<a name="l01975"></a>01975         m128.low64  *= 0x9FB21C651E98DF25ULL;
<a name="l01976"></a>01976         m128.low64   = XXH_xorshift64(m128.low64, 28);
<a name="l01977"></a>01977         m128.high64  = XXH3_avalanche(m128.high64);
<a name="l01978"></a>01978         <span class="keywordflow">return</span> m128;
<a name="l01979"></a>01979     }
<a name="l01980"></a>01980 }
<a name="l01981"></a>01981 
<a name="l01982"></a>01982 XXH_FORCE_INLINE XXH128_hash_t
<a name="l01983"></a>01983 XXH3_len_9to16_128b(<span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> xxh_u8* secret, XXH64_hash_t seed)
<a name="l01984"></a>01984 {
<a name="l01985"></a>01985     XXH_ASSERT(input != NULL);
<a name="l01986"></a>01986     XXH_ASSERT(secret != NULL);
<a name="l01987"></a>01987     XXH_ASSERT(9 &lt;= len &amp;&amp; len &lt;= 16);
<a name="l01988"></a>01988     {   xxh_u64 <span class="keyword">const</span> bitflipl = (XXH_readLE64(secret+32) ^ XXH_readLE64(secret+40)) - seed;
<a name="l01989"></a>01989         xxh_u64 <span class="keyword">const</span> bitfliph = (XXH_readLE64(secret+48) ^ XXH_readLE64(secret+56)) + seed;
<a name="l01990"></a>01990         xxh_u64 <span class="keyword">const</span> input_lo = XXH_readLE64(input);
<a name="l01991"></a>01991         xxh_u64       input_hi = XXH_readLE64(input + len - 8);
<a name="l01992"></a>01992         XXH128_hash_t m128 = XXH_mult64to128(input_lo ^ input_hi ^ bitflipl, XXH_PRIME64_1);
<a name="l01993"></a>01993         <span class="comment">/*</span>
<a name="l01994"></a>01994 <span class="comment">         * Put len in the middle of m128 to ensure that the length gets mixed to</span>
<a name="l01995"></a>01995 <span class="comment">         * both the low and high bits in the 128x64 multiply below.</span>
<a name="l01996"></a>01996 <span class="comment">         */</span>
<a name="l01997"></a>01997         m128.low64 += (xxh_u64)(len - 1) &lt;&lt; 54;
<a name="l01998"></a>01998         input_hi   ^= bitfliph;
<a name="l01999"></a>01999         <span class="comment">/*</span>
<a name="l02000"></a>02000 <span class="comment">         * Add the high 32 bits of input_hi to the high 32 bits of m128, then</span>
<a name="l02001"></a>02001 <span class="comment">         * add the long product of the low 32 bits of input_hi and XXH_PRIME32_2 to</span>
<a name="l02002"></a>02002 <span class="comment">         * the high 64 bits of m128.</span>
<a name="l02003"></a>02003 <span class="comment">         *</span>
<a name="l02004"></a>02004 <span class="comment">         * The best approach to this operation is different on 32-bit and 64-bit.</span>
<a name="l02005"></a>02005 <span class="comment">         */</span>
<a name="l02006"></a>02006         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *) &lt; <span class="keyword">sizeof</span>(xxh_u64)) { <span class="comment">/* 32-bit */</span>
<a name="l02007"></a>02007             <span class="comment">/*</span>
<a name="l02008"></a>02008 <span class="comment">             * 32-bit optimized version, which is more readable.</span>
<a name="l02009"></a>02009 <span class="comment">             *</span>
<a name="l02010"></a>02010 <span class="comment">             * On 32-bit, it removes an ADC and delays a dependency between the two</span>
<a name="l02011"></a>02011 <span class="comment">             * halves of m128.high64, but it generates an extra mask on 64-bit.</span>
<a name="l02012"></a>02012 <span class="comment">             */</span>
<a name="l02013"></a>02013             m128.high64 += (input_hi &amp; 0xFFFFFFFF00000000) + XXH_mult32to64((xxh_u32)input_hi, XXH_PRIME32_2);
<a name="l02014"></a>02014         } <span class="keywordflow">else</span> {
<a name="l02015"></a>02015             <span class="comment">/*</span>
<a name="l02016"></a>02016 <span class="comment">             * 64-bit optimized (albeit more confusing) version.</span>
<a name="l02017"></a>02017 <span class="comment">             *</span>
<a name="l02018"></a>02018 <span class="comment">             * Uses some properties of addition and multiplication to remove the mask:</span>
<a name="l02019"></a>02019 <span class="comment">             *</span>
<a name="l02020"></a>02020 <span class="comment">             * Let:</span>
<a name="l02021"></a>02021 <span class="comment">             *    a = input_hi.lo = (input_hi &amp; 0x00000000FFFFFFFF)</span>
<a name="l02022"></a>02022 <span class="comment">             *    b = input_hi.hi = (input_hi &amp; 0xFFFFFFFF00000000)</span>
<a name="l02023"></a>02023 <span class="comment">             *    c = XXH_PRIME32_2</span>
<a name="l02024"></a>02024 <span class="comment">             *</span>
<a name="l02025"></a>02025 <span class="comment">             *    a + (b * c)</span>
<a name="l02026"></a>02026 <span class="comment">             * Inverse Property: x + y - x == y</span>
<a name="l02027"></a>02027 <span class="comment">             *    a + (b * (1 + c - 1))</span>
<a name="l02028"></a>02028 <span class="comment">             * Distributive Property: x * (y + z) == (x * y) + (x * z)</span>
<a name="l02029"></a>02029 <span class="comment">             *    a + (b * 1) + (b * (c - 1))</span>
<a name="l02030"></a>02030 <span class="comment">             * Identity Property: x * 1 == x</span>
<a name="l02031"></a>02031 <span class="comment">             *    a + b + (b * (c - 1))</span>
<a name="l02032"></a>02032 <span class="comment">             *</span>
<a name="l02033"></a>02033 <span class="comment">             * Substitute a, b, and c:</span>
<a name="l02034"></a>02034 <span class="comment">             *    input_hi.hi + input_hi.lo + ((xxh_u64)input_hi.lo * (XXH_PRIME32_2 - 1))</span>
<a name="l02035"></a>02035 <span class="comment">             *</span>
<a name="l02036"></a>02036 <span class="comment">             * Since input_hi.hi + input_hi.lo == input_hi, we get this:</span>
<a name="l02037"></a>02037 <span class="comment">             *    input_hi + ((xxh_u64)input_hi.lo * (XXH_PRIME32_2 - 1))</span>
<a name="l02038"></a>02038 <span class="comment">             */</span>
<a name="l02039"></a>02039             m128.high64 += input_hi + XXH_mult32to64((xxh_u32)input_hi, XXH_PRIME32_2 - 1);
<a name="l02040"></a>02040         }
<a name="l02041"></a>02041         <span class="comment">/* m128 ^= XXH_swap64(m128 &gt;&gt; 64); */</span>
<a name="l02042"></a>02042         m128.low64  ^= XXH_swap64(m128.high64);
<a name="l02043"></a>02043 
<a name="l02044"></a>02044         {   <span class="comment">/* 128x64 multiply: h128 = m128 * XXH_PRIME64_2; */</span>
<a name="l02045"></a>02045             XXH128_hash_t h128 = XXH_mult64to128(m128.low64, XXH_PRIME64_2);
<a name="l02046"></a>02046             h128.high64 += m128.high64 * XXH_PRIME64_2;
<a name="l02047"></a>02047 
<a name="l02048"></a>02048             h128.low64   = XXH3_avalanche(h128.low64);
<a name="l02049"></a>02049             h128.high64  = XXH3_avalanche(h128.high64);
<a name="l02050"></a>02050             <span class="keywordflow">return</span> h128;
<a name="l02051"></a>02051     }   }
<a name="l02052"></a>02052 }
<a name="l02053"></a>02053 
<a name="l02054"></a>02054 <span class="comment">/*</span>
<a name="l02055"></a>02055 <span class="comment"> * Assumption: `secret` size is &gt;= XXH3_SECRET_SIZE_MIN</span>
<a name="l02056"></a>02056 <span class="comment"> */</span>
<a name="l02057"></a>02057 XXH_FORCE_INLINE XXH128_hash_t
<a name="l02058"></a>02058 XXH3_len_0to16_128b(<span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> xxh_u8* secret, XXH64_hash_t seed)
<a name="l02059"></a>02059 {
<a name="l02060"></a>02060     XXH_ASSERT(len &lt;= 16);
<a name="l02061"></a>02061     {   <span class="keywordflow">if</span> (len &gt; 8) <span class="keywordflow">return</span> XXH3_len_9to16_128b(input, len, secret, seed);
<a name="l02062"></a>02062         <span class="keywordflow">if</span> (len &gt;= 4) <span class="keywordflow">return</span> XXH3_len_4to8_128b(input, len, secret, seed);
<a name="l02063"></a>02063         <span class="keywordflow">if</span> (len) <span class="keywordflow">return</span> XXH3_len_1to3_128b(input, len, secret, seed);
<a name="l02064"></a>02064         {   XXH128_hash_t h128;
<a name="l02065"></a>02065             xxh_u64 <span class="keyword">const</span> bitflipl = XXH_readLE64(secret+64) ^ XXH_readLE64(secret+72);
<a name="l02066"></a>02066             xxh_u64 <span class="keyword">const</span> bitfliph = XXH_readLE64(secret+80) ^ XXH_readLE64(secret+88);
<a name="l02067"></a>02067             h128.low64 = XXH3_avalanche((XXH_PRIME64_1 + seed) ^ bitflipl);
<a name="l02068"></a>02068             h128.high64 = XXH3_avalanche((XXH_PRIME64_2 - seed) ^ bitfliph);
<a name="l02069"></a>02069             <span class="keywordflow">return</span> h128;
<a name="l02070"></a>02070     }   }
<a name="l02071"></a>02071 }
<a name="l02072"></a>02072 
<a name="l02073"></a>02073 <span class="comment">/*</span>
<a name="l02074"></a>02074 <span class="comment"> * A bit slower than XXH3_mix16B, but handles multiply by zero better.</span>
<a name="l02075"></a>02075 <span class="comment"> */</span>
<a name="l02076"></a>02076 XXH_FORCE_INLINE XXH128_hash_t
<a name="l02077"></a>02077 XXH128_mix32B(XXH128_hash_t acc, <span class="keyword">const</span> xxh_u8* input_1, <span class="keyword">const</span> xxh_u8* input_2,
<a name="l02078"></a>02078               <span class="keyword">const</span> xxh_u8* secret, XXH64_hash_t seed)
<a name="l02079"></a>02079 {
<a name="l02080"></a>02080     acc.low64  += XXH3_mix16B (input_1, secret+0, seed);
<a name="l02081"></a>02081     acc.low64  ^= XXH_readLE64(input_2) + XXH_readLE64(input_2 + 8);
<a name="l02082"></a>02082     acc.high64 += XXH3_mix16B (input_2, secret+16, seed);
<a name="l02083"></a>02083     acc.high64 ^= XXH_readLE64(input_1) + XXH_readLE64(input_1 + 8);
<a name="l02084"></a>02084     <span class="keywordflow">return</span> acc;
<a name="l02085"></a>02085 }
<a name="l02086"></a>02086 
<a name="l02087"></a>02087 
<a name="l02088"></a>02088 XXH_FORCE_INLINE XXH128_hash_t
<a name="l02089"></a>02089 XXH3_len_17to128_128b(<span class="keyword">const</span> xxh_u8* XXH_RESTRICT input, <span class="keywordtype">size_t</span> len,
<a name="l02090"></a>02090                       <span class="keyword">const</span> xxh_u8* XXH_RESTRICT secret, <span class="keywordtype">size_t</span> secretSize,
<a name="l02091"></a>02091                       XXH64_hash_t seed)
<a name="l02092"></a>02092 {
<a name="l02093"></a>02093     XXH_ASSERT(secretSize &gt;= XXH3_SECRET_SIZE_MIN); (void)secretSize;
<a name="l02094"></a>02094     XXH_ASSERT(16 &lt; len &amp;&amp; len &lt;= 128);
<a name="l02095"></a>02095 
<a name="l02096"></a>02096     {   XXH128_hash_t acc;
<a name="l02097"></a>02097         acc.low64 = len * XXH_PRIME64_1;
<a name="l02098"></a>02098         acc.high64 = 0;
<a name="l02099"></a>02099         <span class="keywordflow">if</span> (len &gt; 32) {
<a name="l02100"></a>02100             <span class="keywordflow">if</span> (len &gt; 64) {
<a name="l02101"></a>02101                 <span class="keywordflow">if</span> (len &gt; 96) {
<a name="l02102"></a>02102                     acc = XXH128_mix32B(acc, input+48, input+len-64, secret+96, seed);
<a name="l02103"></a>02103                 }
<a name="l02104"></a>02104                 acc = XXH128_mix32B(acc, input+32, input+len-48, secret+64, seed);
<a name="l02105"></a>02105             }
<a name="l02106"></a>02106             acc = XXH128_mix32B(acc, input+16, input+len-32, secret+32, seed);
<a name="l02107"></a>02107         }
<a name="l02108"></a>02108         acc = XXH128_mix32B(acc, input, input+len-16, secret, seed);
<a name="l02109"></a>02109         {   XXH128_hash_t h128;
<a name="l02110"></a>02110             h128.low64  = acc.low64 + acc.high64;
<a name="l02111"></a>02111             h128.high64 = (acc.low64    * XXH_PRIME64_1)
<a name="l02112"></a>02112                         + (acc.high64   * XXH_PRIME64_4)
<a name="l02113"></a>02113                         + ((len - seed) * XXH_PRIME64_2);
<a name="l02114"></a>02114             h128.low64  = XXH3_avalanche(h128.low64);
<a name="l02115"></a>02115             h128.high64 = (XXH64_hash_t)0 - XXH3_avalanche(h128.high64);
<a name="l02116"></a>02116             <span class="keywordflow">return</span> h128;
<a name="l02117"></a>02117         }
<a name="l02118"></a>02118     }
<a name="l02119"></a>02119 }
<a name="l02120"></a>02120 
<a name="l02121"></a>02121 XXH_NO_INLINE XXH128_hash_t
<a name="l02122"></a>02122 XXH3_len_129to240_128b(<span class="keyword">const</span> xxh_u8* XXH_RESTRICT input, <span class="keywordtype">size_t</span> len,
<a name="l02123"></a>02123                        <span class="keyword">const</span> xxh_u8* XXH_RESTRICT secret, <span class="keywordtype">size_t</span> secretSize,
<a name="l02124"></a>02124                        XXH64_hash_t seed)
<a name="l02125"></a>02125 {
<a name="l02126"></a>02126     XXH_ASSERT(secretSize &gt;= XXH3_SECRET_SIZE_MIN); (void)secretSize;
<a name="l02127"></a>02127     XXH_ASSERT(128 &lt; len &amp;&amp; len &lt;= XXH3_MIDSIZE_MAX);
<a name="l02128"></a>02128 
<a name="l02129"></a>02129     {   XXH128_hash_t acc;
<a name="l02130"></a>02130         <span class="keywordtype">int</span> <span class="keyword">const</span> nbRounds = (int)len / 32;
<a name="l02131"></a>02131         <span class="keywordtype">int</span> i;
<a name="l02132"></a>02132         acc.low64 = len * XXH_PRIME64_1;
<a name="l02133"></a>02133         acc.high64 = 0;
<a name="l02134"></a>02134         <span class="keywordflow">for</span> (i=0; i&lt;4; i++) {
<a name="l02135"></a>02135             acc = XXH128_mix32B(acc,
<a name="l02136"></a>02136                                 input  + (32 * i),
<a name="l02137"></a>02137                                 input  + (32 * i) + 16,
<a name="l02138"></a>02138                                 secret + (32 * i),
<a name="l02139"></a>02139                                 seed);
<a name="l02140"></a>02140         }
<a name="l02141"></a>02141         acc.low64 = XXH3_avalanche(acc.low64);
<a name="l02142"></a>02142         acc.high64 = XXH3_avalanche(acc.high64);
<a name="l02143"></a>02143         XXH_ASSERT(nbRounds &gt;= 4);
<a name="l02144"></a>02144         <span class="keywordflow">for</span> (i=4 ; i &lt; nbRounds; i++) {
<a name="l02145"></a>02145             acc = XXH128_mix32B(acc,
<a name="l02146"></a>02146                                 input + (32 * i),
<a name="l02147"></a>02147                                 input + (32 * i) + 16,
<a name="l02148"></a>02148                                 secret + XXH3_MIDSIZE_STARTOFFSET + (32 * (i - 4)),
<a name="l02149"></a>02149                                 seed);
<a name="l02150"></a>02150         }
<a name="l02151"></a>02151         <span class="comment">/* last bytes */</span>
<a name="l02152"></a>02152         acc = XXH128_mix32B(acc,
<a name="l02153"></a>02153                             input + len - 16,
<a name="l02154"></a>02154                             input + len - 32,
<a name="l02155"></a>02155                             secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET - 16,
<a name="l02156"></a>02156                             0ULL - seed);
<a name="l02157"></a>02157 
<a name="l02158"></a>02158         {   XXH128_hash_t h128;
<a name="l02159"></a>02159             h128.low64  = acc.low64 + acc.high64;
<a name="l02160"></a>02160             h128.high64 = (acc.low64    * XXH_PRIME64_1)
<a name="l02161"></a>02161                         + (acc.high64   * XXH_PRIME64_4)
<a name="l02162"></a>02162                         + ((len - seed) * XXH_PRIME64_2);
<a name="l02163"></a>02163             h128.low64  = XXH3_avalanche(h128.low64);
<a name="l02164"></a>02164             h128.high64 = (XXH64_hash_t)0 - XXH3_avalanche(h128.high64);
<a name="l02165"></a>02165             <span class="keywordflow">return</span> h128;
<a name="l02166"></a>02166         }
<a name="l02167"></a>02167     }
<a name="l02168"></a>02168 }
<a name="l02169"></a>02169 
<a name="l02170"></a>02170 XXH_FORCE_INLINE XXH128_hash_t
<a name="l02171"></a>02171 XXH3_hashLong_128b_internal(<span class="keyword">const</span> xxh_u8* XXH_RESTRICT input, <span class="keywordtype">size_t</span> len,
<a name="l02172"></a>02172                             <span class="keyword">const</span> xxh_u8* XXH_RESTRICT secret, <span class="keywordtype">size_t</span> secretSize)
<a name="l02173"></a>02173 {
<a name="l02174"></a>02174     XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[XXH_ACC_NB] = XXH3_INIT_ACC;
<a name="l02175"></a>02175 
<a name="l02176"></a>02176     XXH3_hashLong_internal_loop(acc, input, len, secret, secretSize, XXH3_acc_128bits);
<a name="l02177"></a>02177 
<a name="l02178"></a>02178     <span class="comment">/* converge into final hash */</span>
<a name="l02179"></a>02179     XXH_STATIC_ASSERT(sizeof(acc) == 64);
<a name="l02180"></a>02180     XXH_ASSERT(secretSize &gt;= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
<a name="l02181"></a>02181     {   XXH128_hash_t h128;
<a name="l02182"></a>02182         h128.low64  = XXH3_mergeAccs(acc,
<a name="l02183"></a>02183                                      secret + XXH_SECRET_MERGEACCS_START,
<a name="l02184"></a>02184                                      (xxh_u64)len * XXH_PRIME64_1);
<a name="l02185"></a>02185         h128.high64 = XXH3_mergeAccs(acc,
<a name="l02186"></a>02186                                      secret + secretSize
<a name="l02187"></a>02187                                             - <span class="keyword">sizeof</span>(acc) - XXH_SECRET_MERGEACCS_START,
<a name="l02188"></a>02188                                      ~((xxh_u64)len * XXH_PRIME64_2));
<a name="l02189"></a>02189         <span class="keywordflow">return</span> h128;
<a name="l02190"></a>02190     }
<a name="l02191"></a>02191 }
<a name="l02192"></a>02192 
<a name="l02193"></a>02193 <span class="comment">/*</span>
<a name="l02194"></a>02194 <span class="comment"> * It&#39;s important for performance that XXH3_hashLong is not inlined. Not sure</span>
<a name="l02195"></a>02195 <span class="comment"> * why (uop cache maybe?), but the difference is large and easily measurable.</span>
<a name="l02196"></a>02196 <span class="comment"> */</span>
<a name="l02197"></a>02197 XXH_NO_INLINE XXH128_hash_t
<a name="l02198"></a>02198 XXH3_hashLong_128b_defaultSecret(<span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> len)
<a name="l02199"></a>02199 {
<a name="l02200"></a>02200     <span class="keywordflow">return</span> XXH3_hashLong_128b_internal(input, len, XXH3_kSecret, <span class="keyword">sizeof</span>(XXH3_kSecret));
<a name="l02201"></a>02201 }
<a name="l02202"></a>02202 
<a name="l02203"></a>02203 <span class="comment">/*</span>
<a name="l02204"></a>02204 <span class="comment"> * It&#39;s important for performance that XXH3_hashLong is not inlined. Not sure</span>
<a name="l02205"></a>02205 <span class="comment"> * why (uop cache maybe?), but the difference is large and easily measurable.</span>
<a name="l02206"></a>02206 <span class="comment"> */</span>
<a name="l02207"></a>02207 XXH_NO_INLINE XXH128_hash_t
<a name="l02208"></a>02208 XXH3_hashLong_128b_withSecret(<span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> len,
<a name="l02209"></a>02209                               <span class="keyword">const</span> xxh_u8* secret, <span class="keywordtype">size_t</span> secretSize)
<a name="l02210"></a>02210 {
<a name="l02211"></a>02211     <span class="keywordflow">return</span> XXH3_hashLong_128b_internal(input, len, secret, secretSize);
<a name="l02212"></a>02212 }
<a name="l02213"></a>02213 
<a name="l02214"></a>02214 <span class="comment">/*</span>
<a name="l02215"></a>02215 <span class="comment"> * It&#39;s important for performance that XXH3_hashLong is not inlined. Not sure</span>
<a name="l02216"></a>02216 <span class="comment"> * why (uop cache maybe?), but the difference is large and easily measurable.</span>
<a name="l02217"></a>02217 <span class="comment"> */</span>
<a name="l02218"></a>02218 XXH_NO_INLINE XXH128_hash_t
<a name="l02219"></a>02219 XXH3_hashLong_128b_withSeed(<span class="keyword">const</span> xxh_u8* input, <span class="keywordtype">size_t</span> len, XXH64_hash_t seed)
<a name="l02220"></a>02220 {
<a name="l02221"></a>02221     XXH_ALIGN(8) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
<a name="l02222"></a>02222     if (seed == 0) return XXH3_hashLong_128b_defaultSecret(input, len);
<a name="l02223"></a>02223     XXH3_initCustomSecret(secret, seed);
<a name="l02224"></a>02224     return XXH3_hashLong_128b_internal(input, len, secret, sizeof(secret));
<a name="l02225"></a>02225 }
<a name="l02226"></a>02226 
<a name="l02227"></a>02227 
<a name="l02228"></a>02228 XXH_PUBLIC_API XXH128_hash_t XXH3_128bits(const <span class="keywordtype">void</span>* input, <span class="keywordtype">size_t</span> len)
<a name="l02229"></a>02229 {
<a name="l02230"></a>02230     <span class="keywordflow">if</span> (len &lt;= 16)
<a name="l02231"></a>02231         <span class="keywordflow">return</span> XXH3_len_0to16_128b((<span class="keyword">const</span> xxh_u8*)input, len, XXH3_kSecret, 0);
<a name="l02232"></a>02232     <span class="keywordflow">if</span> (len &lt;= 128)
<a name="l02233"></a>02233         <span class="keywordflow">return</span> XXH3_len_17to128_128b((<span class="keyword">const</span> xxh_u8*)input, len, XXH3_kSecret, <span class="keyword">sizeof</span>(XXH3_kSecret), 0);
<a name="l02234"></a>02234     <span class="keywordflow">if</span> (len &lt;= XXH3_MIDSIZE_MAX)
<a name="l02235"></a>02235         <span class="keywordflow">return</span> XXH3_len_129to240_128b((<span class="keyword">const</span> xxh_u8*)input, len, XXH3_kSecret, <span class="keyword">sizeof</span>(XXH3_kSecret), 0);
<a name="l02236"></a>02236     <span class="keywordflow">return</span> XXH3_hashLong_128b_defaultSecret((<span class="keyword">const</span> xxh_u8*)input, len);
<a name="l02237"></a>02237 }
<a name="l02238"></a>02238 
<a name="l02239"></a>02239 XXH_PUBLIC_API XXH128_hash_t
<a name="l02240"></a>02240 XXH3_128bits_withSecret(<span class="keyword">const</span> <span class="keywordtype">void</span>* input, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> <span class="keywordtype">void</span>* secret, <span class="keywordtype">size_t</span> secretSize)
<a name="l02241"></a>02241 {
<a name="l02242"></a>02242     XXH_ASSERT(secretSize &gt;= XXH3_SECRET_SIZE_MIN);
<a name="l02243"></a>02243     <span class="comment">/*</span>
<a name="l02244"></a>02244 <span class="comment">     * If an action is to be taken if `secret` conditions are not respected,</span>
<a name="l02245"></a>02245 <span class="comment">     * it should be done here.</span>
<a name="l02246"></a>02246 <span class="comment">     * For now, it&#39;s a contract pre-condition.</span>
<a name="l02247"></a>02247 <span class="comment">     * Adding a check and a branch here would cost performance at every hash.</span>
<a name="l02248"></a>02248 <span class="comment">     */</span>
<a name="l02249"></a>02249     <span class="keywordflow">if</span> (len &lt;= 16)
<a name="l02250"></a>02250         <span class="keywordflow">return</span> XXH3_len_0to16_128b((<span class="keyword">const</span> xxh_u8*)input, len, (<span class="keyword">const</span> xxh_u8*)secret, 0);
<a name="l02251"></a>02251     <span class="keywordflow">if</span> (len &lt;= 128)
<a name="l02252"></a>02252         <span class="keywordflow">return</span> XXH3_len_17to128_128b((<span class="keyword">const</span> xxh_u8*)input, len, (<span class="keyword">const</span> xxh_u8*)secret, secretSize, 0);
<a name="l02253"></a>02253     <span class="keywordflow">if</span> (len &lt;= XXH3_MIDSIZE_MAX)
<a name="l02254"></a>02254         <span class="keywordflow">return</span> XXH3_len_129to240_128b((<span class="keyword">const</span> xxh_u8*)input, len, (<span class="keyword">const</span> xxh_u8*)secret, secretSize, 0);
<a name="l02255"></a>02255     <span class="keywordflow">return</span> XXH3_hashLong_128b_withSecret((<span class="keyword">const</span> xxh_u8*)input, len, (<span class="keyword">const</span> xxh_u8*)secret, secretSize);
<a name="l02256"></a>02256 }
<a name="l02257"></a>02257 
<a name="l02258"></a>02258 XXH_PUBLIC_API XXH128_hash_t
<a name="l02259"></a>02259 XXH3_128bits_withSeed(<span class="keyword">const</span> <span class="keywordtype">void</span>* input, <span class="keywordtype">size_t</span> len, XXH64_hash_t seed)
<a name="l02260"></a>02260 {
<a name="l02261"></a>02261     <span class="keywordflow">if</span> (len &lt;= 16)
<a name="l02262"></a>02262         <span class="keywordflow">return</span> XXH3_len_0to16_128b((<span class="keyword">const</span> xxh_u8*)input, len, XXH3_kSecret, seed);
<a name="l02263"></a>02263     <span class="keywordflow">if</span> (len &lt;= 128)
<a name="l02264"></a>02264          <span class="keywordflow">return</span> XXH3_len_17to128_128b((<span class="keyword">const</span> xxh_u8*)input, len, XXH3_kSecret, <span class="keyword">sizeof</span>(XXH3_kSecret), seed);
<a name="l02265"></a>02265     <span class="keywordflow">if</span> (len &lt;= XXH3_MIDSIZE_MAX)
<a name="l02266"></a>02266          <span class="keywordflow">return</span> XXH3_len_129to240_128b((<span class="keyword">const</span> xxh_u8*)input, len, XXH3_kSecret, <span class="keyword">sizeof</span>(XXH3_kSecret), seed);
<a name="l02267"></a>02267     <span class="keywordflow">return</span> XXH3_hashLong_128b_withSeed((<span class="keyword">const</span> xxh_u8*)input, len, seed);
<a name="l02268"></a>02268 }
<a name="l02269"></a>02269 
<a name="l02270"></a>02270 XXH_PUBLIC_API XXH128_hash_t
<a name="l02271"></a>02271 XXH128(<span class="keyword">const</span> <span class="keywordtype">void</span>* input, <span class="keywordtype">size_t</span> len, XXH64_hash_t seed)
<a name="l02272"></a>02272 {
<a name="l02273"></a>02273     <span class="keywordflow">return</span> XXH3_128bits_withSeed(input, len, seed);
<a name="l02274"></a>02274 }
<a name="l02275"></a>02275 
<a name="l02276"></a>02276 
<a name="l02277"></a>02277 <span class="comment">/* ===   XXH3 128-bit streaming   === */</span>
<a name="l02278"></a>02278 
<a name="l02279"></a>02279 <span class="comment">/*</span>
<a name="l02280"></a>02280 <span class="comment"> * All the functions are actually the same as for 64-bit streaming variant.</span>
<a name="l02281"></a>02281 <span class="comment"> * The only difference is the finalizatiom routine.</span>
<a name="l02282"></a>02282 <span class="comment"> */</span>
<a name="l02283"></a>02283 
<a name="l02284"></a>02284 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l02285"></a>02285 XXH3_128bits_reset_internal(XXH3_state_t* statePtr,
<a name="l02286"></a>02286                             XXH64_hash_t seed,
<a name="l02287"></a>02287                             <span class="keyword">const</span> xxh_u8* secret, <span class="keywordtype">size_t</span> secretSize)
<a name="l02288"></a>02288 {
<a name="l02289"></a>02289     XXH3_64bits_reset_internal(statePtr, seed, secret, secretSize);
<a name="l02290"></a>02290 }
<a name="l02291"></a>02291 
<a name="l02292"></a>02292 XXH_PUBLIC_API XXH_errorcode
<a name="l02293"></a>02293 XXH3_128bits_reset(XXH3_state_t* statePtr)
<a name="l02294"></a>02294 {
<a name="l02295"></a>02295     <span class="keywordflow">if</span> (statePtr == NULL) <span class="keywordflow">return</span> XXH_ERROR;
<a name="l02296"></a>02296     XXH3_128bits_reset_internal(statePtr, 0, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
<a name="l02297"></a>02297     <span class="keywordflow">return</span> XXH_OK;
<a name="l02298"></a>02298 }
<a name="l02299"></a>02299 
<a name="l02300"></a>02300 XXH_PUBLIC_API XXH_errorcode
<a name="l02301"></a>02301 XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, <span class="keyword">const</span> <span class="keywordtype">void</span>* secret, <span class="keywordtype">size_t</span> secretSize)
<a name="l02302"></a>02302 {
<a name="l02303"></a>02303     <span class="keywordflow">if</span> (statePtr == NULL) <span class="keywordflow">return</span> XXH_ERROR;
<a name="l02304"></a>02304     XXH3_128bits_reset_internal(statePtr, 0, (<span class="keyword">const</span> xxh_u8*)secret, secretSize);
<a name="l02305"></a>02305     <span class="keywordflow">if</span> (secret == NULL) <span class="keywordflow">return</span> XXH_ERROR;
<a name="l02306"></a>02306     <span class="keywordflow">if</span> (secretSize &lt; XXH3_SECRET_SIZE_MIN) <span class="keywordflow">return</span> XXH_ERROR;
<a name="l02307"></a>02307     <span class="keywordflow">return</span> XXH_OK;
<a name="l02308"></a>02308 }
<a name="l02309"></a>02309 
<a name="l02310"></a>02310 XXH_PUBLIC_API XXH_errorcode
<a name="l02311"></a>02311 XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed)
<a name="l02312"></a>02312 {
<a name="l02313"></a>02313     <span class="keywordflow">if</span> (statePtr == NULL) <span class="keywordflow">return</span> XXH_ERROR;
<a name="l02314"></a>02314     XXH3_128bits_reset_internal(statePtr, seed, XXH3_kSecret, XXH_SECRET_DEFAULT_SIZE);
<a name="l02315"></a>02315     XXH3_initCustomSecret(statePtr-&gt;customSecret, seed);
<a name="l02316"></a>02316     statePtr-&gt;extSecret = NULL;
<a name="l02317"></a>02317     <span class="keywordflow">return</span> XXH_OK;
<a name="l02318"></a>02318 }
<a name="l02319"></a>02319 
<a name="l02320"></a>02320 XXH_PUBLIC_API XXH_errorcode
<a name="l02321"></a>02321 XXH3_128bits_update(XXH3_state_t* state, <span class="keyword">const</span> <span class="keywordtype">void</span>* input, <span class="keywordtype">size_t</span> len)
<a name="l02322"></a>02322 {
<a name="l02323"></a>02323     <span class="keywordflow">return</span> XXH3_update(state, (<span class="keyword">const</span> xxh_u8*)input, len, XXH3_acc_128bits);
<a name="l02324"></a>02324 }
<a name="l02325"></a>02325 
<a name="l02326"></a>02326 XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (<span class="keyword">const</span> XXH3_state_t* state)
<a name="l02327"></a>02327 {
<a name="l02328"></a>02328     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> secret = (state-&gt;extSecret == NULL) ? state-&gt;customSecret : state-&gt;extSecret;
<a name="l02329"></a>02329     if (state-&gt;totalLen &gt; XXH3_MIDSIZE_MAX) {
<a name="l02330"></a>02330         XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[XXH_ACC_NB];
<a name="l02331"></a>02331         XXH3_digest_long(acc, state, secret, XXH3_acc_128bits);
<a name="l02332"></a>02332         XXH_ASSERT(state-&gt;secretLimit + XXH_STRIPE_LEN &gt;= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
<a name="l02333"></a>02333         {   XXH128_hash_t h128;
<a name="l02334"></a>02334             h128.low64  = XXH3_mergeAccs(acc,
<a name="l02335"></a>02335                                          secret + XXH_SECRET_MERGEACCS_START,
<a name="l02336"></a>02336                                          (xxh_u64)state-&gt;totalLen * XXH_PRIME64_1);
<a name="l02337"></a>02337             h128.high64 = XXH3_mergeAccs(acc,
<a name="l02338"></a>02338                                          secret + state-&gt;secretLimit + XXH_STRIPE_LEN
<a name="l02339"></a>02339                                                 - <span class="keyword">sizeof</span>(acc) - XXH_SECRET_MERGEACCS_START,
<a name="l02340"></a>02340                                          ~((xxh_u64)state-&gt;totalLen * XXH_PRIME64_2));
<a name="l02341"></a>02341             <span class="keywordflow">return</span> h128;
<a name="l02342"></a>02342         }
<a name="l02343"></a>02343     }
<a name="l02344"></a>02344     <span class="comment">/* len &lt;= XXH3_MIDSIZE_MAX : short code */</span>
<a name="l02345"></a>02345     <span class="keywordflow">if</span> (state-&gt;seed)
<a name="l02346"></a>02346         <span class="keywordflow">return</span> XXH3_128bits_withSeed(state-&gt;buffer, (<span class="keywordtype">size_t</span>)state-&gt;totalLen, state-&gt;seed);
<a name="l02347"></a>02347     <span class="keywordflow">return</span> XXH3_128bits_withSecret(state-&gt;buffer, (<span class="keywordtype">size_t</span>)(state-&gt;totalLen),
<a name="l02348"></a>02348                                    secret, state-&gt;secretLimit + XXH_STRIPE_LEN);
<a name="l02349"></a>02349 }
<a name="l02350"></a>02350 
<a name="l02351"></a>02351 <span class="comment">/* 128-bit utility functions */</span>
<a name="l02352"></a>02352 
<a name="l02353"></a>02353 <span class="preprocessor">#include &lt;string.h&gt;</span>   <span class="comment">/* memcmp, memcpy */</span>
<a name="l02354"></a>02354 
<a name="l02355"></a>02355 <span class="comment">/* return : 1 is equal, 0 if different */</span>
<a name="l02356"></a>02356 XXH_PUBLIC_API <span class="keywordtype">int</span> XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2)
<a name="l02357"></a>02357 {
<a name="l02358"></a>02358     <span class="comment">/* note : XXH128_hash_t is compact, it has no padding byte */</span>
<a name="l02359"></a>02359     <span class="keywordflow">return</span> !(memcmp(&amp;h1, &amp;h2, <span class="keyword">sizeof</span>(h1)));
<a name="l02360"></a>02360 }
<a name="l02361"></a>02361 
<a name="l02362"></a>02362 <span class="comment">/* This prototype is compatible with stdlib&#39;s qsort().</span>
<a name="l02363"></a>02363 <span class="comment"> * return : &gt;0 if *h128_1  &gt; *h128_2</span>
<a name="l02364"></a>02364 <span class="comment"> *          &lt;0 if *h128_1  &lt; *h128_2</span>
<a name="l02365"></a>02365 <span class="comment"> *          =0 if *h128_1 == *h128_2  */</span>
<a name="l02366"></a>02366 XXH_PUBLIC_API <span class="keywordtype">int</span> XXH128_cmp(<span class="keyword">const</span> <span class="keywordtype">void</span>* h128_1, <span class="keyword">const</span> <span class="keywordtype">void</span>* h128_2)
<a name="l02367"></a>02367 {
<a name="l02368"></a>02368     XXH128_hash_t <span class="keyword">const</span> h1 = *(<span class="keyword">const</span> XXH128_hash_t*)h128_1;
<a name="l02369"></a>02369     XXH128_hash_t <span class="keyword">const</span> h2 = *(<span class="keyword">const</span> XXH128_hash_t*)h128_2;
<a name="l02370"></a>02370     <span class="keywordtype">int</span> <span class="keyword">const</span> hcmp = (h1.high64 &gt; h2.high64) - (h2.high64 &gt; h1.high64);
<a name="l02371"></a>02371     <span class="comment">/* note : bets that, in most cases, hash values are different */</span>
<a name="l02372"></a>02372     <span class="keywordflow">if</span> (hcmp) <span class="keywordflow">return</span> hcmp;
<a name="l02373"></a>02373     <span class="keywordflow">return</span> (h1.low64 &gt; h2.low64) - (h2.low64 &gt; h1.low64);
<a name="l02374"></a>02374 }
<a name="l02375"></a>02375 
<a name="l02376"></a>02376 
<a name="l02377"></a>02377 <span class="comment">/*======   Canonical representation   ======*/</span>
<a name="l02378"></a>02378 XXH_PUBLIC_API <span class="keywordtype">void</span>
<a name="l02379"></a>02379 XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash)
<a name="l02380"></a>02380 {
<a name="l02381"></a>02381     XXH_STATIC_ASSERT(<span class="keyword">sizeof</span>(XXH128_canonical_t) == <span class="keyword">sizeof</span>(XXH128_hash_t));
<a name="l02382"></a>02382     <span class="keywordflow">if</span> (XXH_CPU_LITTLE_ENDIAN) {
<a name="l02383"></a>02383         hash.high64 = XXH_swap64(hash.high64);
<a name="l02384"></a>02384         hash.low64  = XXH_swap64(hash.low64);
<a name="l02385"></a>02385     }
<a name="l02386"></a>02386     memcpy(dst, &amp;hash.high64, <span class="keyword">sizeof</span>(hash.high64));
<a name="l02387"></a>02387     memcpy((<span class="keywordtype">char</span>*)dst + <span class="keyword">sizeof</span>(hash.high64), &amp;hash.low64, <span class="keyword">sizeof</span>(hash.low64));
<a name="l02388"></a>02388 }
<a name="l02389"></a>02389 
<a name="l02390"></a>02390 XXH_PUBLIC_API XXH128_hash_t
<a name="l02391"></a>02391 XXH128_hashFromCanonical(<span class="keyword">const</span> XXH128_canonical_t* src)
<a name="l02392"></a>02392 {
<a name="l02393"></a>02393     XXH128_hash_t h;
<a name="l02394"></a>02394     h.high64 = XXH_readBE64(src);
<a name="l02395"></a>02395     h.low64  = XXH_readBE64(src-&gt;digest + 8);
<a name="l02396"></a>02396     <span class="keywordflow">return</span> h;
<a name="l02397"></a>02397 }
<a name="l02398"></a>02398 
<a name="l02399"></a>02399 <span class="comment">/* Pop our optimization override from above */</span>
<a name="l02400"></a>02400 <span class="preprocessor">#if XXH_VECTOR == XXH_AVX2 </span><span class="comment">/* AVX2 */</span> \
<a name="l02401"></a>02401   &amp;&amp; defined(__GNUC__) &amp;&amp; !defined(__clang__) <span class="comment">/* GCC, not Clang */</span> \
<a name="l02402"></a>02402   &amp;&amp; defined(__OPTIMIZE__) &amp;&amp; !defined(__OPTIMIZE_SIZE__) <span class="comment">/* respect -O0 and -Os */</span>
<a name="l02403"></a>02403 <span class="preprocessor">#  pragma GCC pop_options</span>
<a name="l02404"></a>02404 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02405"></a>02405 <span class="preprocessor"></span>
<a name="l02406"></a>02406 <span class="preprocessor">#endif  </span><span class="comment">/* XXH3_H_1397135465 */</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 5 2020 13:11:39 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
