<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/hardware/timer.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/hardware/timer.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  Copyright (C) 2002-2015  The DOSBox Team</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  This program is free software; you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment"> *  (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *  This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment"> *  GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment"> *  along with this program; if not, write to the Free Software</span>
<a name="l00016"></a>00016 <span class="comment"> *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;dosbox.h&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;inout.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;pic.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;mem.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;mixer.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;timer.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;setup.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;control.h&quot;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> BIN2BCD(Bit16u&amp; val) {
<a name="l00032"></a>00032         Bit16u temp=val%10 + (((val/10)%10)&lt;&lt;4)+ (((val/100)%10)&lt;&lt;8) + (((val/1000)%10)&lt;&lt;12);
<a name="l00033"></a>00033         val=temp;
<a name="l00034"></a>00034 }
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="keyword">static</span> INLINE <span class="keywordtype">void</span> BCD2BIN(Bit16u&amp; val) {
<a name="l00037"></a>00037         Bit16u temp= (val&amp;0x0f) +((val&gt;&gt;4)&amp;0x0f) *10 +((val&gt;&gt;8)&amp;0x0f) *100 +((val&gt;&gt;12)&amp;0x0f) *1000;
<a name="l00038"></a>00038         val=temp;
<a name="l00039"></a>00039 }
<a name="l00040"></a>00040 
<a name="l00041"></a><a class="code" href="structPIT__Block.html">00041</a> <span class="keyword">struct </span><a class="code" href="structPIT__Block.html">PIT_Block</a> {
<a name="l00042"></a>00042         Bitu cntr;
<a name="l00043"></a>00043         <span class="keywordtype">float</span> delay;
<a name="l00044"></a>00044         <span class="keywordtype">double</span> start;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046         Bit16u read_latch;
<a name="l00047"></a>00047         Bit16u write_latch;
<a name="l00048"></a>00048 
<a name="l00049"></a>00049         Bit8u mode;
<a name="l00050"></a>00050         Bit8u latch_mode;
<a name="l00051"></a>00051         Bit8u read_state;
<a name="l00052"></a>00052         Bit8u write_state;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054         <span class="keywordtype">bool</span> bcd;
<a name="l00055"></a>00055         <span class="keywordtype">bool</span> go_read_latch;
<a name="l00056"></a>00056         <span class="keywordtype">bool</span> new_mode;
<a name="l00057"></a>00057         <span class="keywordtype">bool</span> counterstatus_set;
<a name="l00058"></a>00058         <span class="keywordtype">bool</span> counting;
<a name="l00059"></a>00059         <span class="keywordtype">bool</span> update_count;
<a name="l00060"></a>00060 };
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="keyword">static</span> <a class="code" href="structPIT__Block.html">PIT_Block</a> pit[3];
<a name="l00063"></a>00063 <span class="keyword">static</span> <span class="keywordtype">bool</span> gate2;
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="keyword">static</span> Bit8u latched_timerstatus;
<a name="l00066"></a>00066 <span class="comment">// the timer status can not be overwritten until it is read or the timer was </span>
<a name="l00067"></a>00067 <span class="comment">// reprogrammed.</span>
<a name="l00068"></a>00068 <span class="keyword">static</span> <span class="keywordtype">bool</span> latched_timerstatus_locked;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> PIT_TICK_RATE = PIT_TICK_RATE_IBM;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="keyword">static</span> <span class="keywordtype">void</span> PIT0_Event(Bitu <span class="comment">/*val*/</span>) {
<a name="l00073"></a>00073         PIC_ActivateIRQ(0);
<a name="l00074"></a>00074         <span class="keywordflow">if</span> (pit[0].mode != 0) {
<a name="l00075"></a>00075                 pit[0].start += pit[0].delay;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077                 <span class="keywordflow">if</span> (GCC_UNLIKELY(pit[0].update_count)) {
<a name="l00078"></a>00078                         pit[0].delay=(1000.0f/((float)PIT_TICK_RATE/(<span class="keywordtype">float</span>)pit[0].cntr));
<a name="l00079"></a>00079                         pit[0].update_count=<span class="keyword">false</span>;
<a name="l00080"></a>00080                 }
<a name="l00081"></a>00081                 <span class="comment">// regression to r3533 fixes flight simulator 5.0</span>
<a name="l00082"></a>00082                 <span class="keywordtype">double</span> error =  pit[0].start - PIC_FullIndex();
<a name="l00083"></a>00083                 PIC_AddEvent(PIT0_Event,(<span class="keywordtype">float</span>)(pit[0].delay + error));                 
<a name="l00084"></a>00084 <span class="comment">//              PIC_AddEvent(PIT0_Event,pit[0].delay); // r3534</span>
<a name="l00085"></a>00085         }
<a name="l00086"></a>00086 }
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="keyword">static</span> <span class="keywordtype">bool</span> counter_output(Bitu counter) {
<a name="l00089"></a>00089         <a class="code" href="structPIT__Block.html">PIT_Block</a> * p=&amp;pit[counter];
<a name="l00090"></a>00090         <span class="keywordtype">double</span> index=PIC_FullIndex()-p-&gt;start;
<a name="l00091"></a>00091         <span class="keywordflow">switch</span> (p-&gt;mode) {
<a name="l00092"></a>00092         <span class="keywordflow">case</span> 0:
<a name="l00093"></a>00093                 <span class="keywordflow">if</span> (p-&gt;new_mode) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00094"></a>00094                 <span class="keywordflow">if</span> (index&gt;p-&gt;delay) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00095"></a>00095                 <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00096"></a>00096                 <span class="keywordflow">break</span>;
<a name="l00097"></a>00097         <span class="keywordflow">case</span> 2:
<a name="l00098"></a>00098                 <span class="keywordflow">if</span> (p-&gt;new_mode) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00099"></a>00099                 index=fmod(index,(<span class="keywordtype">double</span>)p-&gt;delay);
<a name="l00100"></a>00100                 <span class="keywordflow">return</span> index&gt;0;
<a name="l00101"></a>00101         <span class="keywordflow">case</span> 3:
<a name="l00102"></a>00102                 <span class="keywordflow">if</span> (p-&gt;new_mode) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00103"></a>00103                 index=fmod(index,(<span class="keywordtype">double</span>)p-&gt;delay);
<a name="l00104"></a>00104                 <span class="keywordflow">return</span> index*2&lt;p-&gt;delay;
<a name="l00105"></a>00105         <span class="keywordflow">case</span> 4:
<a name="l00106"></a>00106                 <span class="comment">//Only low on terminal count</span>
<a name="l00107"></a>00107                 <span class="comment">// if(fmod(index,(double)p-&gt;delay) == 0) return false; //Maybe take one rate tick in consideration</span>
<a name="l00108"></a>00108                 <span class="comment">//Easiest solution is to report always high (Space marines uses this mode)</span>
<a name="l00109"></a>00109                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00110"></a>00110         <span class="keywordflow">default</span>:
<a name="l00111"></a>00111                 <a class="code" href="classLOG.html">LOG</a>(LOG_PIT,LOG_ERROR)(<span class="stringliteral">&quot;Illegal Mode %d for reading output&quot;</span>,p-&gt;mode);
<a name="l00112"></a>00112                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00113"></a>00113         }
<a name="l00114"></a>00114 }
<a name="l00115"></a>00115 <span class="keyword">static</span> <span class="keywordtype">void</span> status_latch(Bitu counter) {
<a name="l00116"></a>00116         <span class="comment">// the timer status can not be overwritten until it is read or the timer was </span>
<a name="l00117"></a>00117         <span class="comment">// reprogrammed.</span>
<a name="l00118"></a>00118         <span class="keywordflow">if</span>(!latched_timerstatus_locked) {
<a name="l00119"></a>00119                 <a class="code" href="structPIT__Block.html">PIT_Block</a> * p=&amp;pit[counter];
<a name="l00120"></a>00120                 latched_timerstatus=0;
<a name="l00121"></a>00121                 <span class="comment">// Timer Status Word</span>
<a name="l00122"></a>00122                 <span class="comment">// 0: BCD </span>
<a name="l00123"></a>00123                 <span class="comment">// 1-3: Timer mode</span>
<a name="l00124"></a>00124                 <span class="comment">// 4-5: read/load mode</span>
<a name="l00125"></a>00125                 <span class="comment">// 6: &quot;NULL&quot; - this is 0 if &quot;the counter value is in the counter&quot; ;)</span>
<a name="l00126"></a>00126                 <span class="comment">// should rarely be 1 (i.e. on exotic modes)</span>
<a name="l00127"></a>00127                 <span class="comment">// 7: OUT - the logic level on the Timer output pin</span>
<a name="l00128"></a>00128                 <span class="keywordflow">if</span>(p-&gt;bcd)latched_timerstatus|=0x1;
<a name="l00129"></a>00129                 latched_timerstatus|=((p-&gt;mode&amp;7)&lt;&lt;1);
<a name="l00130"></a>00130                 <span class="keywordflow">if</span>((p-&gt;read_state==0)||(p-&gt;read_state==3)) latched_timerstatus|=0x30;
<a name="l00131"></a>00131                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(p-&gt;read_state==1) latched_timerstatus|=0x10;
<a name="l00132"></a>00132                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(p-&gt;read_state==2) latched_timerstatus|=0x20;
<a name="l00133"></a>00133                 <span class="keywordflow">if</span>(counter_output(counter)) latched_timerstatus|=0x80;
<a name="l00134"></a>00134                 <span class="keywordflow">if</span>(p-&gt;new_mode) latched_timerstatus|=0x40;
<a name="l00135"></a>00135                 <span class="comment">// The first thing that is being read from this counter now is the</span>
<a name="l00136"></a>00136                 <span class="comment">// counter status.</span>
<a name="l00137"></a>00137                 p-&gt;counterstatus_set=<span class="keyword">true</span>;
<a name="l00138"></a>00138                 latched_timerstatus_locked=<span class="keyword">true</span>;
<a name="l00139"></a>00139         }
<a name="l00140"></a>00140 }
<a name="l00141"></a>00141 <span class="keyword">static</span> <span class="keywordtype">void</span> counter_latch(Bitu counter) {
<a name="l00142"></a>00142         <span class="comment">/* Fill the read_latch of the selected counter with current count */</span>
<a name="l00143"></a>00143         <a class="code" href="structPIT__Block.html">PIT_Block</a> * p=&amp;pit[counter];
<a name="l00144"></a>00144         p-&gt;go_read_latch=<span class="keyword">false</span>;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146         <span class="comment">//If gate2 is disabled don&#39;t update the read_latch</span>
<a name="l00147"></a>00147         <span class="keywordflow">if</span> (counter == (IS_PC98_ARCH ? 1 : 2) &amp;&amp; !gate2 &amp;&amp; p-&gt;mode !=1) <span class="keywordflow">return</span>;
<a name="l00148"></a>00148 
<a name="l00149"></a>00149         <span class="keywordflow">if</span> (GCC_UNLIKELY(p-&gt;new_mode)) {
<a name="l00150"></a>00150                 <span class="keywordtype">double</span> passed_time = PIC_FullIndex() - p-&gt;start;
<a name="l00151"></a>00151                 Bitu ticks_since_then = (Bitu)(passed_time / (1000.0/PIT_TICK_RATE));
<a name="l00152"></a>00152                 <span class="comment">//if (p-&gt;mode==3) ticks_since_then /= 2; // TODO figure this out on real hardware</span>
<a name="l00153"></a>00153                 p-&gt;read_latch -= ticks_since_then;
<a name="l00154"></a>00154                 <span class="keywordflow">return</span>;
<a name="l00155"></a>00155         }
<a name="l00156"></a>00156         <span class="keywordtype">double</span> index=PIC_FullIndex()-p-&gt;start;
<a name="l00157"></a>00157         <span class="keywordflow">switch</span> (p-&gt;mode) {
<a name="l00158"></a>00158         <span class="keywordflow">case</span> 4:         <span class="comment">/* Software Triggered Strobe */</span>
<a name="l00159"></a>00159         <span class="keywordflow">case</span> 0:         <span class="comment">/* Interrupt on Terminal Count */</span>
<a name="l00160"></a>00160                 {
<a name="l00161"></a>00161                         <span class="comment">/* Counter keeps on counting after passing terminal count */</span>
<a name="l00162"></a>00162                         <span class="keywordflow">if</span>(p-&gt;bcd) {
<a name="l00163"></a>00163                                 index = fmod(index,(1000.0/PIT_TICK_RATE)*10000.0);
<a name="l00164"></a>00164                                 p-&gt;read_latch = (Bit16u)(((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(p-&gt;cntr-index*(PIT_TICK_RATE/1000.0))) % 10000UL);
<a name="l00165"></a>00165                         } <span class="keywordflow">else</span> {
<a name="l00166"></a>00166                                 index = fmod(index,(1000.0/PIT_TICK_RATE)*(<span class="keywordtype">double</span>)0x10000);
<a name="l00167"></a>00167                                 p-&gt;read_latch = (Bit16u)(p-&gt;cntr-index*(PIT_TICK_RATE/1000.0));
<a name="l00168"></a>00168                         }
<a name="l00169"></a>00169                 }
<a name="l00170"></a>00170                 <span class="keywordflow">break</span>;
<a name="l00171"></a>00171         <span class="keywordflow">case</span> 1: <span class="comment">// countdown</span>
<a name="l00172"></a>00172                 <span class="keywordflow">if</span>(p-&gt;counting) {
<a name="l00173"></a>00173                         <span class="keywordflow">if</span> (index&gt;p-&gt;delay) { <span class="comment">// has timed out</span>
<a name="l00174"></a>00174                                 p-&gt;read_latch = 0xffff; <span class="comment">//unconfirmed</span>
<a name="l00175"></a>00175                         } <span class="keywordflow">else</span> {
<a name="l00176"></a>00176                                 p-&gt;read_latch=(Bit16u)(p-&gt;cntr-index*(PIT_TICK_RATE/1000.0));
<a name="l00177"></a>00177                         }
<a name="l00178"></a>00178                 }
<a name="l00179"></a>00179                 <span class="keywordflow">break</span>;
<a name="l00180"></a>00180         <span class="keywordflow">case</span> 2:         <span class="comment">/* Rate Generator */</span>
<a name="l00181"></a>00181                 index=fmod(index,(<span class="keywordtype">double</span>)p-&gt;delay);
<a name="l00182"></a>00182                 p-&gt;read_latch=(Bit16u)(p-&gt;cntr - (index/p-&gt;delay)*p-&gt;cntr);
<a name="l00183"></a>00183                 <span class="keywordflow">break</span>;
<a name="l00184"></a>00184         <span class="keywordflow">case</span> 3:         <span class="comment">/* Square Wave Rate Generator */</span>
<a name="l00185"></a>00185                 index=fmod(index,(<span class="keywordtype">double</span>)p-&gt;delay);
<a name="l00186"></a>00186                 index*=2;
<a name="l00187"></a>00187                 <span class="keywordflow">if</span> (index&gt;p-&gt;delay) index-=p-&gt;delay;
<a name="l00188"></a>00188                 p-&gt;read_latch=(Bit16u)(p-&gt;cntr - (index/p-&gt;delay)*p-&gt;cntr);
<a name="l00189"></a>00189                 <span class="comment">// In mode 3 it never returns odd numbers LSB (if odd number is written 1 will be</span>
<a name="l00190"></a>00190                 <span class="comment">// subtracted on first clock and then always 2)</span>
<a name="l00191"></a>00191                 <span class="comment">// fixes &quot;Corncob 3D&quot;</span>
<a name="l00192"></a>00192                 p-&gt;read_latch&amp;=0xfffe;
<a name="l00193"></a>00193                 <span class="keywordflow">break</span>;
<a name="l00194"></a>00194         <span class="keywordflow">default</span>:
<a name="l00195"></a>00195                 <a class="code" href="classLOG.html">LOG</a>(LOG_PIT,LOG_ERROR)(<span class="stringliteral">&quot;Illegal Mode %d for reading counter %d&quot;</span>,(int)p-&gt;mode,(<span class="keywordtype">int</span>)counter);
<a name="l00196"></a>00196                 p-&gt;read_latch=0xffff;
<a name="l00197"></a>00197                 <span class="keywordflow">break</span>;
<a name="l00198"></a>00198         }
<a name="l00199"></a>00199 }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="keyword">static</span> <span class="keywordtype">void</span> write_latch(Bitu port,Bitu val,Bitu <span class="comment">/*iolen*/</span>) {
<a name="l00203"></a>00203 <span class="comment">//LOG(LOG_PIT,LOG_ERROR)(&quot;port %X write:%X state:%X&quot;,port,val,pit[port-0x40].write_state);</span>
<a name="l00204"></a>00204 
<a name="l00205"></a>00205     <span class="comment">// HACK: Port translation for this code PC-98 mode.</span>
<a name="l00206"></a>00206     <span class="comment">//       0x71,0x73,0x75,0x77 =&gt; 0x40-0x43</span>
<a name="l00207"></a>00207     <span class="keywordflow">if</span> (IS_PC98_ARCH) {
<a name="l00208"></a>00208         <span class="keywordflow">if</span> (port &gt;= 0x3FD9)
<a name="l00209"></a>00209             port = ((port - 0x3FD9) &gt;&gt; 1) + 0x40;
<a name="l00210"></a>00210         <span class="keywordflow">else</span>
<a name="l00211"></a>00211             port = ((port - 0x71) &gt;&gt; 1) + 0x40;
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         Bitu counter=port-0x40;
<a name="l00215"></a>00215         <a class="code" href="structPIT__Block.html">PIT_Block</a> * p=&amp;pit[counter];
<a name="l00216"></a>00216         <span class="keywordflow">if</span>(p-&gt;bcd == <span class="keyword">true</span>) BIN2BCD(p-&gt;write_latch);
<a name="l00217"></a>00217    
<a name="l00218"></a>00218         <span class="keywordflow">switch</span> (p-&gt;write_state) {
<a name="l00219"></a>00219                 <span class="keywordflow">case</span> 0:
<a name="l00220"></a>00220                         p-&gt;write_latch = p-&gt;write_latch | ((val &amp; 0xff) &lt;&lt; 8);
<a name="l00221"></a>00221                         p-&gt;write_state = 3;
<a name="l00222"></a>00222                         <span class="keywordflow">break</span>;
<a name="l00223"></a>00223                 <span class="keywordflow">case</span> 3:
<a name="l00224"></a>00224                         p-&gt;write_latch = val &amp; 0xff;
<a name="l00225"></a>00225                         p-&gt;write_state = 0;
<a name="l00226"></a>00226                         <span class="keywordflow">break</span>;
<a name="l00227"></a>00227                 <span class="keywordflow">case</span> 1:
<a name="l00228"></a>00228                         p-&gt;write_latch = val &amp; 0xff;
<a name="l00229"></a>00229                         <span class="keywordflow">break</span>;
<a name="l00230"></a>00230                 <span class="keywordflow">case</span> 2:
<a name="l00231"></a>00231                         p-&gt;write_latch = (val &amp; 0xff) &lt;&lt; 8;
<a name="l00232"></a>00232                 <span class="keywordflow">break</span>;
<a name="l00233"></a>00233         }
<a name="l00234"></a>00234         <span class="keywordflow">if</span> (p-&gt;bcd==<span class="keyword">true</span>) BCD2BIN(p-&gt;write_latch);
<a name="l00235"></a>00235         <span class="keywordflow">if</span> (p-&gt;write_state != 0) {
<a name="l00236"></a>00236                 <span class="keywordflow">if</span> (p-&gt;write_latch == 0) {
<a name="l00237"></a>00237                         <span class="keywordflow">if</span> (p-&gt;bcd == <span class="keyword">false</span>) p-&gt;cntr = 0x10000;
<a name="l00238"></a>00238                         <span class="keywordflow">else</span> p-&gt;cntr=9999;
<a name="l00239"></a>00239                 } <span class="keywordflow">else</span> p-&gt;cntr = p-&gt;write_latch;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241                 <span class="keywordflow">if</span> ((!p-&gt;new_mode) &amp;&amp; (p-&gt;mode == 2) &amp;&amp; (counter == 0)) {
<a name="l00242"></a>00242                         <span class="comment">// In mode 2 writing another value has no direct effect on the count</span>
<a name="l00243"></a>00243                         <span class="comment">// until the old one has run out. This might apply to other modes too.</span>
<a name="l00244"></a>00244                         <span class="comment">// This is not fixed for PIT2 yet!!</span>
<a name="l00245"></a>00245                         p-&gt;update_count=<span class="keyword">true</span>;
<a name="l00246"></a>00246                         <span class="keywordflow">return</span>;
<a name="l00247"></a>00247                 }
<a name="l00248"></a>00248                 p-&gt;start=PIC_FullIndex();
<a name="l00249"></a>00249                 p-&gt;delay=(1000.0f/((float)PIT_TICK_RATE/(<span class="keywordtype">float</span>)p-&gt;cntr));
<a name="l00250"></a>00250 
<a name="l00251"></a>00251                 <span class="keywordflow">switch</span> (counter) {
<a name="l00252"></a>00252                 <span class="keywordflow">case</span> 0x00:                      <span class="comment">/* Timer hooked to IRQ 0 */</span>
<a name="l00253"></a>00253                         <span class="keywordflow">if</span> (p-&gt;new_mode || p-&gt;mode == 0 ) {
<a name="l00254"></a>00254                                 <span class="keywordflow">if</span>(p-&gt;mode==0) PIC_RemoveEvents(PIT0_Event); <span class="comment">// DoWhackaDo demo</span>
<a name="l00255"></a>00255                                 PIC_AddEvent(PIT0_Event,p-&gt;delay);
<a name="l00256"></a>00256                         } <span class="keywordflow">else</span> <a class="code" href="classLOG.html">LOG</a>(LOG_PIT,LOG_NORMAL)(<span class="stringliteral">&quot;PIT 0 Timer set without new control word&quot;</span>);
<a name="l00257"></a>00257                         <a class="code" href="classLOG.html">LOG</a>(LOG_PIT,LOG_NORMAL)(<span class="stringliteral">&quot;PIT 0 Timer at %.4f Hz mode %d&quot;</span>,1000.0/p-&gt;delay,p-&gt;mode);
<a name="l00258"></a>00258                         <span class="keywordflow">break</span>;
<a name="l00259"></a>00259         <span class="keywordflow">case</span> 0x01:          <span class="comment">/* Timer hooked to PC-Speaker (NEC-PC98) */</span>
<a name="l00260"></a>00260             <span class="keywordflow">if</span> (IS_PC98_ARCH)
<a name="l00261"></a>00261                 PCSPEAKER_SetCounter(p-&gt;cntr,p-&gt;mode);
<a name="l00262"></a>00262             <span class="keywordflow">break</span>;
<a name="l00263"></a>00263         <span class="keywordflow">case</span> 0x02:                      <span class="comment">/* Timer hooked to PC-Speaker (IBM PC) */</span>
<a name="l00264"></a>00264             <span class="keywordflow">if</span> (!IS_PC98_ARCH)
<a name="l00265"></a>00265                 PCSPEAKER_SetCounter(p-&gt;cntr,p-&gt;mode);
<a name="l00266"></a>00266             <span class="keywordflow">break</span>;
<a name="l00267"></a>00267         <span class="keywordflow">default</span>:
<a name="l00268"></a>00268                         <a class="code" href="classLOG.html">LOG</a>(LOG_PIT,LOG_ERROR)(<span class="stringliteral">&quot;PIT:Illegal timer selected for writing&quot;</span>);
<a name="l00269"></a>00269                 }
<a name="l00270"></a>00270                 p-&gt;new_mode=<span class="keyword">false</span>;
<a name="l00271"></a>00271     }
<a name="l00272"></a>00272 }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 <span class="keyword">static</span> Bitu read_latch(Bitu port,Bitu <span class="comment">/*iolen*/</span>) {
<a name="l00275"></a>00275 <span class="comment">//LOG(LOG_PIT,LOG_ERROR)(&quot;port read %X&quot;,port);</span>
<a name="l00276"></a>00276 
<a name="l00277"></a>00277     <span class="comment">// HACK: Port translation for this code PC-98 mode.</span>
<a name="l00278"></a>00278     <span class="comment">//       0x71,0x73,0x75,0x77 =&gt; 0x40-0x43</span>
<a name="l00279"></a>00279     <span class="keywordflow">if</span> (IS_PC98_ARCH) {
<a name="l00280"></a>00280         <span class="keywordflow">if</span> (port &gt;= 0x3FD9)
<a name="l00281"></a>00281             port = ((port - 0x3FD9) &gt;&gt; 1) + 0x40;
<a name="l00282"></a>00282         <span class="keywordflow">else</span>
<a name="l00283"></a>00283             port = ((port - 0x71) &gt;&gt; 1) + 0x40;
<a name="l00284"></a>00284     }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286         Bit32u counter=port-0x40;
<a name="l00287"></a>00287         Bit8u ret=0;
<a name="l00288"></a>00288         <span class="keywordflow">if</span>(GCC_UNLIKELY(pit[counter].counterstatus_set)){
<a name="l00289"></a>00289                 pit[counter].counterstatus_set = <span class="keyword">false</span>;
<a name="l00290"></a>00290                 latched_timerstatus_locked = <span class="keyword">false</span>;
<a name="l00291"></a>00291                 ret = latched_timerstatus;
<a name="l00292"></a>00292         } <span class="keywordflow">else</span> {
<a name="l00293"></a>00293                 <span class="keywordflow">if</span> (pit[counter].go_read_latch == <span class="keyword">true</span>) 
<a name="l00294"></a>00294                         counter_latch(counter);
<a name="l00295"></a>00295 
<a name="l00296"></a>00296                 <span class="keywordflow">if</span>( pit[counter].bcd == <span class="keyword">true</span>) BIN2BCD(pit[counter].read_latch);
<a name="l00297"></a>00297 
<a name="l00298"></a>00298                 <span class="keywordflow">switch</span> (pit[counter].read_state) {
<a name="l00299"></a>00299                 <span class="keywordflow">case</span> 0: <span class="comment">/* read MSB &amp; return to state 3 */</span>
<a name="l00300"></a>00300                         ret=(pit[counter].read_latch &gt;&gt; 8) &amp; 0xff;
<a name="l00301"></a>00301                         pit[counter].read_state = 3;
<a name="l00302"></a>00302                         pit[counter].go_read_latch = <span class="keyword">true</span>;
<a name="l00303"></a>00303                         <span class="keywordflow">break</span>;
<a name="l00304"></a>00304                 <span class="keywordflow">case</span> 3: <span class="comment">/* read LSB followed by MSB */</span>
<a name="l00305"></a>00305                         ret = pit[counter].read_latch &amp; 0xff;
<a name="l00306"></a>00306                         pit[counter].read_state = 0;
<a name="l00307"></a>00307                         <span class="keywordflow">break</span>;
<a name="l00308"></a>00308                 <span class="keywordflow">case</span> 1: <span class="comment">/* read LSB */</span>
<a name="l00309"></a>00309                         ret = pit[counter].read_latch &amp; 0xff;
<a name="l00310"></a>00310                         pit[counter].go_read_latch = <span class="keyword">true</span>;
<a name="l00311"></a>00311                         <span class="keywordflow">break</span>;
<a name="l00312"></a>00312                 <span class="keywordflow">case</span> 2: <span class="comment">/* read MSB */</span>
<a name="l00313"></a>00313                         ret = (pit[counter].read_latch &gt;&gt; 8) &amp; 0xff;
<a name="l00314"></a>00314                         pit[counter].go_read_latch = <span class="keyword">true</span>;
<a name="l00315"></a>00315                         <span class="keywordflow">break</span>;
<a name="l00316"></a>00316                 <span class="keywordflow">default</span>:
<a name="l00317"></a>00317                         E_Exit(<span class="stringliteral">&quot;Timer.cpp: error in readlatch&quot;</span>);
<a name="l00318"></a>00318                         <span class="keywordflow">break</span>;
<a name="l00319"></a>00319                 }
<a name="l00320"></a>00320                 <span class="keywordflow">if</span>( pit[counter].bcd == <span class="keyword">true</span>) BCD2BIN(pit[counter].read_latch);
<a name="l00321"></a>00321         }
<a name="l00322"></a>00322         <span class="keywordflow">return</span> ret;
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="keyword">static</span> <span class="keywordtype">void</span> write_p43(Bitu <span class="comment">/*port*/</span>,Bitu val,Bitu <span class="comment">/*iolen*/</span>) {
<a name="l00326"></a>00326 <span class="comment">//LOG(LOG_PIT,LOG_ERROR)(&quot;port 43 %X&quot;,val);</span>
<a name="l00327"></a>00327         Bitu latch=(val &gt;&gt; 6) &amp; 0x03;
<a name="l00328"></a>00328         <span class="keywordflow">switch</span> (latch) {
<a name="l00329"></a>00329         <span class="keywordflow">case</span> 0:
<a name="l00330"></a>00330         <span class="keywordflow">case</span> 1:
<a name="l00331"></a>00331         <span class="keywordflow">case</span> 2:
<a name="l00332"></a>00332                 <span class="keywordflow">if</span> ((val &amp; 0x30) == 0) {
<a name="l00333"></a>00333                         <span class="comment">/* Counter latch command */</span>
<a name="l00334"></a>00334                         counter_latch(latch);
<a name="l00335"></a>00335                 } <span class="keywordflow">else</span> {
<a name="l00336"></a>00336                         <span class="comment">// save output status to be used with timer 0 irq</span>
<a name="l00337"></a>00337                         <span class="keywordtype">bool</span> old_output = counter_output(0);
<a name="l00338"></a>00338                         <span class="comment">// save the current count value to be re-used in undocumented newmode</span>
<a name="l00339"></a>00339                         counter_latch(latch);
<a name="l00340"></a>00340                         pit[latch].bcd = (val&amp;1)&gt;0;   
<a name="l00341"></a>00341                         <span class="keywordflow">if</span> (val &amp; 1) {
<a name="l00342"></a>00342                                 <span class="keywordflow">if</span>(pit[latch].cntr&gt;=9999) pit[latch].cntr=9999;
<a name="l00343"></a>00343                         }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345                         <span class="comment">// Timer is being reprogrammed, unlock the status</span>
<a name="l00346"></a>00346                         <span class="keywordflow">if</span>(pit[latch].counterstatus_set) {
<a name="l00347"></a>00347                                 pit[latch].counterstatus_set=<span class="keyword">false</span>;
<a name="l00348"></a>00348                                 latched_timerstatus_locked=<span class="keyword">false</span>;
<a name="l00349"></a>00349                         }
<a name="l00350"></a>00350                         pit[latch].start = PIC_FullIndex(); <span class="comment">// for undocumented newmode</span>
<a name="l00351"></a>00351                         pit[latch].go_read_latch = <span class="keyword">true</span>;
<a name="l00352"></a>00352                         pit[latch].update_count = <span class="keyword">false</span>;
<a name="l00353"></a>00353                         pit[latch].counting = <span class="keyword">false</span>;
<a name="l00354"></a>00354                         pit[latch].read_state  = (val &gt;&gt; 4) &amp; 0x03;
<a name="l00355"></a>00355                         pit[latch].write_state = (val &gt;&gt; 4) &amp; 0x03;
<a name="l00356"></a>00356                         Bit8u mode             = (val &gt;&gt; 1) &amp; 0x07;
<a name="l00357"></a>00357                         <span class="keywordflow">if</span> (mode &gt; 5)
<a name="l00358"></a>00358                                 mode -= 4; <span class="comment">//6,7 become 2 and 3</span>
<a name="l00359"></a>00359 
<a name="l00360"></a>00360                         pit[latch].mode = mode;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362                         <span class="comment">/* If the line goes from low to up =&gt; generate irq. </span>
<a name="l00363"></a>00363 <span class="comment">                         *      ( BUT needs to stay up until acknowlegded by the cpu!!! therefore: )</span>
<a name="l00364"></a>00364 <span class="comment">                         * If the line goes to low =&gt; disable irq.</span>
<a name="l00365"></a>00365 <span class="comment">                         * Mode 0 starts with a low line. (so always disable irq)</span>
<a name="l00366"></a>00366 <span class="comment">                         * Mode 2,3 start with a high line.</span>
<a name="l00367"></a>00367 <span class="comment">                         * counter_output tells if the current counter is high or low </span>
<a name="l00368"></a>00368 <span class="comment">                         * So actually a mode 3 timer enables and disables irq al the time. (not handled) */</span>
<a name="l00369"></a>00369 
<a name="l00370"></a>00370                         <span class="keywordflow">if</span> (latch == 0) {
<a name="l00371"></a>00371                                 PIC_RemoveEvents(PIT0_Event);
<a name="l00372"></a>00372                                 <span class="keywordflow">if</span>((mode != 0)&amp;&amp; !old_output) {
<a name="l00373"></a>00373                                         PIC_ActivateIRQ(0);
<a name="l00374"></a>00374                                 } <span class="keywordflow">else</span> {
<a name="l00375"></a>00375                                         PIC_DeActivateIRQ(0);
<a name="l00376"></a>00376                                 }
<a name="l00377"></a>00377                         }
<a name="l00378"></a>00378                         pit[latch].new_mode = <span class="keyword">true</span>;
<a name="l00379"></a>00379                         <span class="keywordflow">if</span> (latch == (IS_PC98_ARCH ? 1 : 2)) {
<a name="l00380"></a>00380                                 <span class="comment">// notify pc speaker code that the control word was written</span>
<a name="l00381"></a>00381                                 PCSPEAKER_SetPITControl(mode);
<a name="l00382"></a>00382                         }
<a name="l00383"></a>00383                 }
<a name="l00384"></a>00384                 <span class="keywordflow">break</span>;
<a name="l00385"></a>00385     <span class="keywordflow">case</span> 3:
<a name="l00386"></a>00386                 <span class="keywordflow">if</span> ((val &amp; 0x20)==0) {  <span class="comment">/* Latch multiple pit counters */</span>
<a name="l00387"></a>00387                         <span class="keywordflow">if</span> (val &amp; 0x02) counter_latch(0);
<a name="l00388"></a>00388                         <span class="keywordflow">if</span> (val &amp; 0x04) counter_latch(1);
<a name="l00389"></a>00389                         <span class="keywordflow">if</span> (val &amp; 0x08) counter_latch(2);
<a name="l00390"></a>00390                 }
<a name="l00391"></a>00391                 <span class="comment">// status and values can be latched simultaneously</span>
<a name="l00392"></a>00392                 <span class="keywordflow">if</span> ((val &amp; 0x10)==0) {  <span class="comment">/* Latch status words */</span>
<a name="l00393"></a>00393                         <span class="comment">// but only 1 status can be latched simultaneously</span>
<a name="l00394"></a>00394                         <span class="keywordflow">if</span> (val &amp; 0x02) status_latch(0);
<a name="l00395"></a>00395                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val &amp; 0x04) status_latch(1);
<a name="l00396"></a>00396                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val &amp; 0x08) status_latch(2);
<a name="l00397"></a>00397                 }
<a name="l00398"></a>00398                 <span class="keywordflow">break</span>;
<a name="l00399"></a>00399         }
<a name="l00400"></a>00400 }
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 <span class="keywordtype">void</span> TIMER_SetGate2(<span class="keywordtype">bool</span> in) {
<a name="l00403"></a>00403         <span class="comment">//No changes if gate doesn&#39;t change</span>
<a name="l00404"></a>00404         <span class="keywordflow">if</span>(gate2 == in) <span class="keywordflow">return</span>;
<a name="l00405"></a>00405         Bit8u &amp; mode=pit[2].mode;
<a name="l00406"></a>00406         <span class="keywordflow">switch</span>(mode) {
<a name="l00407"></a>00407         <span class="keywordflow">case</span> 0:
<a name="l00408"></a>00408                 <span class="keywordflow">if</span>(in) pit[2].start = PIC_FullIndex();
<a name="l00409"></a>00409                 <span class="keywordflow">else</span> {
<a name="l00410"></a>00410                         <span class="comment">//Fill readlatch and store it.</span>
<a name="l00411"></a>00411                         counter_latch(2);
<a name="l00412"></a>00412                         pit[2].cntr = pit[2].read_latch;
<a name="l00413"></a>00413                 }
<a name="l00414"></a>00414                 <span class="keywordflow">break</span>;
<a name="l00415"></a>00415         <span class="keywordflow">case</span> 1:
<a name="l00416"></a>00416                 <span class="comment">// gate 1 on: reload counter; off: nothing</span>
<a name="l00417"></a>00417                 <span class="keywordflow">if</span>(in) {
<a name="l00418"></a>00418                         pit[2].counting = <span class="keyword">true</span>;
<a name="l00419"></a>00419                         pit[2].start = PIC_FullIndex();
<a name="l00420"></a>00420                 }
<a name="l00421"></a>00421                 <span class="keywordflow">break</span>;
<a name="l00422"></a>00422         <span class="keywordflow">case</span> 2:
<a name="l00423"></a>00423         <span class="keywordflow">case</span> 3:
<a name="l00424"></a>00424                 <span class="comment">//If gate is enabled restart counting. If disable store the current read_latch</span>
<a name="l00425"></a>00425                 <span class="keywordflow">if</span>(in) pit[2].start = PIC_FullIndex();
<a name="l00426"></a>00426                 <span class="keywordflow">else</span> counter_latch(2);
<a name="l00427"></a>00427                 <span class="keywordflow">break</span>;
<a name="l00428"></a>00428         <span class="keywordflow">case</span> 4:
<a name="l00429"></a>00429         <span class="keywordflow">case</span> 5:
<a name="l00430"></a>00430                 <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_WARN)(<span class="stringliteral">&quot;unsupported gate 2 mode %x&quot;</span>,mode);
<a name="l00431"></a>00431                 <span class="keywordflow">break</span>;
<a name="l00432"></a>00432         }
<a name="l00433"></a>00433         gate2 = in; <span class="comment">//Set it here so the counter_latch above works</span>
<a name="l00434"></a>00434 }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 <span class="keywordtype">bool</span> TIMER_GetOutput2() {
<a name="l00437"></a>00437         <span class="keywordflow">return</span> counter_output(2);
<a name="l00438"></a>00438 }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="preprocessor">#include &quot;programs.h&quot;</span>
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="keyword">static</span> <a class="code" href="classIO__ReadHandleObject.html">IO_ReadHandleObject</a> ReadHandler[4];
<a name="l00443"></a>00443 <span class="keyword">static</span> <a class="code" href="classIO__WriteHandleObject.html">IO_WriteHandleObject</a> WriteHandler[4];
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 <span class="comment">/* PC-98 alias */</span>
<a name="l00446"></a>00446 <span class="keyword">static</span> <a class="code" href="classIO__ReadHandleObject.html">IO_ReadHandleObject</a> ReadHandler2[4];
<a name="l00447"></a>00447 <span class="keyword">static</span> <a class="code" href="classIO__WriteHandleObject.html">IO_WriteHandleObject</a> WriteHandler2[4];
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 <span class="keywordtype">void</span> TIMER_BIOS_INIT_Configure() {
<a name="l00450"></a>00450         PIC_RemoveEvents(PIT0_Event);
<a name="l00451"></a>00451         PIC_DeActivateIRQ(0);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453         <span class="comment">/* Setup Timer 0 */</span>
<a name="l00454"></a>00454         pit[0].cntr = 0x10000;
<a name="l00455"></a>00455         pit[0].write_state = 3;
<a name="l00456"></a>00456         pit[0].read_state = 3;
<a name="l00457"></a>00457         pit[0].read_latch = 0;
<a name="l00458"></a>00458         pit[0].write_latch = 0;
<a name="l00459"></a>00459         pit[0].mode = 3;
<a name="l00460"></a>00460         pit[0].bcd = <span class="keyword">false</span>;
<a name="l00461"></a>00461         pit[0].go_read_latch = <span class="keyword">true</span>;
<a name="l00462"></a>00462         pit[0].counterstatus_set = <span class="keyword">false</span>;
<a name="l00463"></a>00463         pit[0].update_count = <span class="keyword">false</span>;
<a name="l00464"></a>00464         pit[0].start = PIC_FullIndex();
<a name="l00465"></a>00465 
<a name="l00466"></a>00466         pit[1].bcd = <span class="keyword">false</span>;
<a name="l00467"></a>00467         pit[1].write_state = 1;
<a name="l00468"></a>00468         pit[1].read_state = 1;
<a name="l00469"></a>00469         pit[1].go_read_latch = <span class="keyword">true</span>;
<a name="l00470"></a>00470         pit[1].cntr = 18;
<a name="l00471"></a>00471         pit[1].mode = 2;
<a name="l00472"></a>00472         pit[1].write_state = 3;
<a name="l00473"></a>00473         pit[1].counterstatus_set = <span class="keyword">false</span>;
<a name="l00474"></a>00474         pit[1].start = PIC_FullIndex();
<a name="l00475"></a>00475 
<a name="l00476"></a>00476         pit[2].bcd = <span class="keyword">false</span>;
<a name="l00477"></a>00477         pit[2].write_state = 1;
<a name="l00478"></a>00478         pit[2].read_state = 1;
<a name="l00479"></a>00479         pit[2].go_read_latch = <span class="keyword">true</span>;
<a name="l00480"></a>00480         pit[2].cntr = 18;
<a name="l00481"></a>00481         pit[2].mode = 2;
<a name="l00482"></a>00482         pit[2].write_state = 3;
<a name="l00483"></a>00483         pit[2].counterstatus_set = <span class="keyword">false</span>;
<a name="l00484"></a>00484         pit[2].start = PIC_FullIndex();
<a name="l00485"></a>00485 
<a name="l00486"></a>00486     <span class="comment">/* TODO: I have observed that on real PC-98 hardware:</span>
<a name="l00487"></a>00487 <span class="comment">     * </span>
<a name="l00488"></a>00488 <span class="comment">     *   Output 1 (speaker) does not cycle if inhibited by port 35h</span>
<a name="l00489"></a>00489 <span class="comment">     *</span>
<a name="l00490"></a>00490 <span class="comment">     *   Output 2 (RS232C) does not cycle until programmed to cycle</span>
<a name="l00491"></a>00491 <span class="comment">     *   to operate the 8251 for data transfer. It is configured by</span>
<a name="l00492"></a>00492 <span class="comment">     *   the BIOS to countdown and stop, thus the UART is not cycling</span>
<a name="l00493"></a>00493 <span class="comment">     *   until put into active use. */</span>
<a name="l00494"></a>00494 
<a name="l00495"></a>00495     <span class="keywordtype">int</span> pcspeaker_pit = IS_PC98_ARCH ? 1 : 2; <span class="comment">/* IBM: PC speaker on output 2   PC-98: PC speaker on output 1 */</span>
<a name="l00496"></a>00496 
<a name="l00497"></a>00497         {
<a name="l00498"></a>00498                 <a class="code" href="classSection__prop.html">Section_prop</a> *pcsec = <span class="keyword">static_cast&lt;</span><a class="code" href="classSection__prop.html">Section_prop</a> *<span class="keyword">&gt;</span>(control-&gt;GetSection(<span class="stringliteral">&quot;speaker&quot;</span>));
<a name="l00499"></a>00499                 <span class="keywordtype">int</span> freq = pcsec-&gt;Get_int(<span class="stringliteral">&quot;initial frequency&quot;</span>); <span class="comment">/* original code: 1320 */</span>
<a name="l00500"></a>00500                 <span class="keywordtype">int</span> div;
<a name="l00501"></a>00501 
<a name="l00502"></a>00502         <span class="comment">/* IBM PC defaults to 903Hz.</span>
<a name="l00503"></a>00503 <span class="comment">         * NEC PC-98 defaults to 2KHz */</span>
<a name="l00504"></a>00504         <span class="keywordflow">if</span> (freq &lt; 0)
<a name="l00505"></a>00505             freq = IS_PC98_ARCH ? 2000 : 903;
<a name="l00506"></a>00506 
<a name="l00507"></a>00507                 <span class="keywordflow">if</span> (freq &lt; 19) {
<a name="l00508"></a>00508                         div = 1;
<a name="l00509"></a>00509                 }
<a name="l00510"></a>00510                 <span class="keywordflow">else</span> {
<a name="l00511"></a>00511                         div = PIT_TICK_RATE / freq;
<a name="l00512"></a>00512                         <span class="keywordflow">if</span> (div &gt; 65535) div = 65535;
<a name="l00513"></a>00513                 }
<a name="l00514"></a>00514 
<a name="l00515"></a>00515                 pit[pcspeaker_pit].cntr = div;
<a name="l00516"></a>00516                 pit[pcspeaker_pit].read_latch = div;
<a name="l00517"></a>00517                 pit[pcspeaker_pit].write_state = 3; <span class="comment">/* Chuck Yeager */</span>
<a name="l00518"></a>00518                 pit[pcspeaker_pit].read_state = 3;
<a name="l00519"></a>00519                 pit[pcspeaker_pit].mode = 3;
<a name="l00520"></a>00520                 pit[pcspeaker_pit].bcd = <span class="keyword">false</span>;
<a name="l00521"></a>00521                 pit[pcspeaker_pit].go_read_latch = <span class="keyword">true</span>;
<a name="l00522"></a>00522                 pit[pcspeaker_pit].counterstatus_set = <span class="keyword">false</span>;
<a name="l00523"></a>00523                 pit[pcspeaker_pit].counting = <span class="keyword">false</span>;
<a name="l00524"></a>00524             pit[pcspeaker_pit].start = PIC_FullIndex();
<a name="l00525"></a>00525         }
<a name="l00526"></a>00526 
<a name="l00527"></a>00527         pit[0].delay=(1000.0f/((float)PIT_TICK_RATE/(<span class="keywordtype">float</span>)pit[0].cntr));
<a name="l00528"></a>00528         pit[1].delay=(1000.0f/((float)PIT_TICK_RATE/(<span class="keywordtype">float</span>)pit[1].cntr));
<a name="l00529"></a>00529         pit[2].delay=(1000.0f/((float)PIT_TICK_RATE/(<span class="keywordtype">float</span>)pit[2].cntr));
<a name="l00530"></a>00530 
<a name="l00531"></a>00531         PCSPEAKER_SetCounter(pit[pcspeaker_pit].cntr,pit[pcspeaker_pit].mode);
<a name="l00532"></a>00532         PIC_AddEvent(PIT0_Event,pit[0].delay);
<a name="l00533"></a>00533 
<a name="l00534"></a>00534     <span class="keywordflow">if</span> (IS_PC98_ARCH) {
<a name="l00535"></a>00535     <span class="comment">/* BIOS data area at 0x501 tells the DOS application which clock rate to use */</span>
<a name="l00536"></a>00536         phys_writeb(0x501,
<a name="l00537"></a>00537             (phys_readb(0x501) &amp; 0x7F) |
<a name="l00538"></a>00538             ((PIT_TICK_RATE == PIT_TICK_RATE_PC98_8MHZ) ? 0x80 : 0x00)      <span class="comment">/* bit 7: 1=8MHz  0=5MHz/10MHz */</span>
<a name="l00539"></a>00539             );
<a name="l00540"></a>00540     }
<a name="l00541"></a>00541 }
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 <span class="keywordtype">void</span> TIMER_OnPowerOn(<a class="code" href="classSection.html">Section</a>*) {
<a name="l00544"></a>00544         <a class="code" href="classSection__prop.html">Section_prop</a> * section=<span class="keyword">static_cast&lt;</span><a class="code" href="classSection__prop.html">Section_prop</a> *<span class="keyword">&gt;</span>(control-&gt;GetSection(<span class="stringliteral">&quot;dosbox&quot;</span>));
<a name="l00545"></a>00545         assert(section != NULL);
<a name="l00546"></a>00546 
<a name="l00547"></a>00547         <span class="comment">// log</span>
<a name="l00548"></a>00548         <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;TIMER_OnPowerOn(): Reinitializing PIT timer emulation&quot;</span>);
<a name="l00549"></a>00549 
<a name="l00550"></a>00550         PIC_RemoveEvents(PIT0_Event);
<a name="l00551"></a>00551 
<a name="l00552"></a>00552         WriteHandler[0].Uninstall();
<a name="l00553"></a>00553         WriteHandler[1].Uninstall();
<a name="l00554"></a>00554         WriteHandler[2].Uninstall();
<a name="l00555"></a>00555         WriteHandler[3].Uninstall();
<a name="l00556"></a>00556         ReadHandler[0].Uninstall();
<a name="l00557"></a>00557         ReadHandler[1].Uninstall();
<a name="l00558"></a>00558         ReadHandler[2].Uninstall();
<a name="l00559"></a>00559         ReadHandler[3].Uninstall();
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         WriteHandler2[0].Uninstall();
<a name="l00562"></a>00562         WriteHandler2[1].Uninstall();
<a name="l00563"></a>00563         WriteHandler2[2].Uninstall();
<a name="l00564"></a>00564         WriteHandler2[3].Uninstall();
<a name="l00565"></a>00565         ReadHandler2[0].Uninstall();
<a name="l00566"></a>00566         ReadHandler2[1].Uninstall();
<a name="l00567"></a>00567         ReadHandler2[2].Uninstall();
<a name="l00568"></a>00568         ReadHandler2[3].Uninstall();
<a name="l00569"></a>00569 
<a name="l00570"></a>00570         WriteHandler[0].Install(0x40,write_latch,IO_MB);
<a name="l00571"></a>00571 <span class="comment">//      WriteHandler[1].Install(0x41,write_latch,IO_MB);</span>
<a name="l00572"></a>00572         WriteHandler[2].Install(0x42,write_latch,IO_MB);
<a name="l00573"></a>00573         WriteHandler[3].Install(0x43,write_p43,IO_MB);
<a name="l00574"></a>00574         ReadHandler[0].Install(0x40,read_latch,IO_MB);
<a name="l00575"></a>00575         ReadHandler[1].Install(0x41,read_latch,IO_MB);
<a name="l00576"></a>00576         ReadHandler[2].Install(0x42,read_latch,IO_MB);
<a name="l00577"></a>00577 
<a name="l00578"></a>00578         latched_timerstatus_locked=<span class="keyword">false</span>;
<a name="l00579"></a>00579         gate2 = <span class="keyword">false</span>;
<a name="l00580"></a>00580 
<a name="l00581"></a>00581     <span class="keywordflow">if</span> (IS_PC98_ARCH) {
<a name="l00582"></a>00582         <span class="keywordtype">void</span> TIMER_OnEnterPC98_Phase2(<a class="code" href="classSection.html">Section</a>*);
<a name="l00583"></a>00583         TIMER_OnEnterPC98_Phase2(NULL);
<a name="l00584"></a>00584     }
<a name="l00585"></a>00585 }
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 <span class="keywordtype">void</span> TIMER_OnEnterPC98_Phase2_UpdateBDA(<span class="keywordtype">void</span>) {
<a name="l00588"></a>00588         <span class="keywordflow">if</span> (!cpu.pmode) {
<a name="l00589"></a>00589                 <span class="comment">/* BIOS data area at 0x501 tells the DOS application which clock rate to use */</span>
<a name="l00590"></a>00590                 phys_writeb(0x501,
<a name="l00591"></a>00591             (phys_readb(0x501) &amp; 0x7F) |
<a name="l00592"></a>00592                         ((PIT_TICK_RATE == PIT_TICK_RATE_PC98_8MHZ) ? 0x80 : 0x00)      <span class="comment">/* bit 7: 1=8MHz  0=5MHz/10MHz */</span>
<a name="l00593"></a>00593                 );
<a name="l00594"></a>00594         }
<a name="l00595"></a>00595         <span class="keywordflow">else</span> {
<a name="l00596"></a>00596                 LOG_MSG(<span class="stringliteral">&quot;PC-98 warning: PIT timer change cannot be reflected to BIOS data area in protected/vm86 mode&quot;</span>);
<a name="l00597"></a>00597         }
<a name="l00598"></a>00598 }
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 <span class="comment">/* NTS: This comes in two phases because we&#39;re taking ports 0x71-0x77 which overlap</span>
<a name="l00601"></a>00601 <span class="comment"> *      with ports 0x70-0x71 from CMOS emulation.</span>
<a name="l00602"></a>00602 <span class="comment"> *</span>
<a name="l00603"></a>00603 <span class="comment"> *      Phase 1 is where we unregister our I/O ports. CMOS emulation will do so as</span>
<a name="l00604"></a>00604 <span class="comment"> *      well either before or after our callback procedure.</span>
<a name="l00605"></a>00605 <span class="comment"> *</span>
<a name="l00606"></a>00606 <span class="comment"> *      Phase 2 is where we can then claim the I/O ports without our claim getting</span>
<a name="l00607"></a>00607 <span class="comment"> *      overwritten by CMOS emulation unregistering the I/O port. */</span>
<a name="l00608"></a>00608 
<a name="l00609"></a>00609 <span class="keywordtype">void</span> TIMER_OnEnterPC98_Phase2(<a class="code" href="classSection.html">Section</a>*) {
<a name="l00610"></a>00610         <a class="code" href="classSection__prop.html">Section_prop</a> * section=<span class="keyword">static_cast&lt;</span><a class="code" href="classSection__prop.html">Section_prop</a> *<span class="keyword">&gt;</span>(control-&gt;GetSection(<span class="stringliteral">&quot;dosbox&quot;</span>));
<a name="l00611"></a>00611         assert(section != NULL);
<a name="l00612"></a>00612     <span class="keywordtype">int</span> pc98rate;
<a name="l00613"></a>00613 
<a name="l00614"></a>00614         PIC_RemoveEvents(PIT0_Event);
<a name="l00615"></a>00615 
<a name="l00616"></a>00616         WriteHandler[0].Uninstall();
<a name="l00617"></a>00617         WriteHandler[1].Uninstall();
<a name="l00618"></a>00618         WriteHandler[2].Uninstall();
<a name="l00619"></a>00619         WriteHandler[3].Uninstall();
<a name="l00620"></a>00620         ReadHandler[0].Uninstall();
<a name="l00621"></a>00621         ReadHandler[1].Uninstall();
<a name="l00622"></a>00622         ReadHandler[2].Uninstall();
<a name="l00623"></a>00623         ReadHandler[3].Uninstall();
<a name="l00624"></a>00624 
<a name="l00625"></a>00625         WriteHandler2[0].Uninstall();
<a name="l00626"></a>00626         WriteHandler2[1].Uninstall();
<a name="l00627"></a>00627         WriteHandler2[2].Uninstall();
<a name="l00628"></a>00628         WriteHandler2[3].Uninstall();
<a name="l00629"></a>00629         ReadHandler2[0].Uninstall();
<a name="l00630"></a>00630         ReadHandler2[1].Uninstall();
<a name="l00631"></a>00631         ReadHandler2[2].Uninstall();
<a name="l00632"></a>00632         ReadHandler2[3].Uninstall();
<a name="l00633"></a>00633 
<a name="l00634"></a>00634     <span class="comment">/* PC-98 has two different rates: 5/10MHz base or 8MHz base. Let the user choose via dosbox.conf */</span>
<a name="l00635"></a>00635     pc98rate = section-&gt;Get_int(<span class="stringliteral">&quot;pc-98 timer master frequency&quot;</span>);
<a name="l00636"></a>00636         <span class="keywordflow">if</span> (pc98rate &gt; 6) pc98rate /= 2;
<a name="l00637"></a>00637     <span class="keywordflow">if</span> (pc98rate == 0) pc98rate = 5; <span class="comment">/* Pick the most likely to work with DOS games (FIXME: This is a GUESS!! Is this correct?) */</span>
<a name="l00638"></a>00638     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pc98rate &lt; 5) pc98rate = 4;
<a name="l00639"></a>00639     <span class="keywordflow">else</span> pc98rate = 5;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641     <span class="keywordflow">if</span> (pc98rate &gt;= 5)
<a name="l00642"></a>00642         PIT_TICK_RATE = PIT_TICK_RATE_PC98_10MHZ;
<a name="l00643"></a>00643     <span class="keywordflow">else</span>
<a name="l00644"></a>00644         PIT_TICK_RATE = PIT_TICK_RATE_PC98_8MHZ;
<a name="l00645"></a>00645 
<a name="l00646"></a>00646     LOG_MSG(<span class="stringliteral">&quot;PC-98 PIT master clock rate %luHz&quot;</span>,PIT_TICK_RATE);
<a name="l00647"></a>00647 
<a name="l00648"></a>00648     <span class="comment">/* I/O port map (8254)</span>
<a name="l00649"></a>00649 <span class="comment">     *</span>
<a name="l00650"></a>00650 <span class="comment">     * IBM PC/XT/AT      NEC-PC98     A1-A0</span>
<a name="l00651"></a>00651 <span class="comment">     * -----------------------------------</span>
<a name="l00652"></a>00652 <span class="comment">     *  0x40              0x71        0</span>
<a name="l00653"></a>00653 <span class="comment">     *  0x41              0x73        1</span>
<a name="l00654"></a>00654 <span class="comment">     *  0x42              0x75        2</span>
<a name="l00655"></a>00655 <span class="comment">     *  0x43              0x77        3</span>
<a name="l00656"></a>00656 <span class="comment">     */</span>
<a name="l00657"></a>00657     <span class="comment">/* Timer output connection</span>
<a name="l00658"></a>00658 <span class="comment">     * </span>
<a name="l00659"></a>00659 <span class="comment">     * IBM PC/XT/AT      NEC-PC98     Timer</span>
<a name="l00660"></a>00660 <span class="comment">     * ------------------------------------</span>
<a name="l00661"></a>00661 <span class="comment">     * Timer int.        Timer int.   0</span>
<a name="l00662"></a>00662 <span class="comment">     * DRAM refresh      Speaker      1</span>
<a name="l00663"></a>00663 <span class="comment">     * Speaker           RS-232C clk  2</span>
<a name="l00664"></a>00664 <span class="comment">     *</span>
<a name="l00665"></a>00665 <span class="comment">     * If I read documentation correctly, PC-98 wires timer output 2</span>
<a name="l00666"></a>00666 <span class="comment">     * to the clock pin of the 8251 UART for COM1 as a way to set the</span>
<a name="l00667"></a>00667 <span class="comment">     * baud rate. */</span>
<a name="l00668"></a>00668 
<a name="l00669"></a>00669     <span class="comment">/* This code is written to eventually copy-paste out in general */</span>
<a name="l00670"></a>00670         WriteHandler[0].Install(IS_PC98_ARCH ? 0x71 : 0x40,write_latch,IO_MB);
<a name="l00671"></a>00671         WriteHandler[1].Install(IS_PC98_ARCH ? 0x73 : 0x41,write_latch,IO_MB);
<a name="l00672"></a>00672         WriteHandler[2].Install(IS_PC98_ARCH ? 0x75 : 0x42,write_latch,IO_MB);
<a name="l00673"></a>00673         WriteHandler[3].Install(IS_PC98_ARCH ? 0x77 : 0x43,write_p43,IO_MB);
<a name="l00674"></a>00674         ReadHandler[0].Install(IS_PC98_ARCH ? 0x71 : 0x40,read_latch,IO_MB);
<a name="l00675"></a>00675         ReadHandler[1].Install(IS_PC98_ARCH ? 0x73 : 0x41,read_latch,IO_MB);
<a name="l00676"></a>00676         ReadHandler[2].Install(IS_PC98_ARCH ? 0x75 : 0x42,read_latch,IO_MB);
<a name="l00677"></a>00677 
<a name="l00678"></a>00678     <span class="comment">/* Apparently all but the first PC-9801 systems have an alias of these</span>
<a name="l00679"></a>00679 <span class="comment">     * ports at 0x3FD9-0x3FDF odd. This alias is required for games that</span>
<a name="l00680"></a>00680 <span class="comment">     * rely on this alias. */</span>
<a name="l00681"></a>00681     <span class="keywordflow">if</span> (IS_PC98_ARCH) {
<a name="l00682"></a>00682         WriteHandler2[0].Install(0x3FD9,write_latch,IO_MB);
<a name="l00683"></a>00683         WriteHandler2[1].Install(0x3FDB,write_latch,IO_MB);
<a name="l00684"></a>00684         WriteHandler2[2].Install(0x3FDD,write_latch,IO_MB);
<a name="l00685"></a>00685         WriteHandler2[3].Install(0x3FDF,write_p43,IO_MB);
<a name="l00686"></a>00686         ReadHandler2[0].Install(0x3FD9,read_latch,IO_MB);
<a name="l00687"></a>00687         ReadHandler2[1].Install(0x3FDB,read_latch,IO_MB);
<a name="l00688"></a>00688         ReadHandler2[2].Install(0x3FDD,read_latch,IO_MB);
<a name="l00689"></a>00689     }
<a name="l00690"></a>00690 
<a name="l00691"></a>00691         latched_timerstatus_locked=<span class="keyword">false</span>;
<a name="l00692"></a>00692         gate2 = <span class="keyword">false</span>;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694     TIMER_BIOS_INIT_Configure();
<a name="l00695"></a>00695 }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 <span class="keywordtype">void</span> TIMER_Destroy(<a class="code" href="classSection.html">Section</a>*) {
<a name="l00698"></a>00698         PIC_RemoveEvents(PIT0_Event);
<a name="l00699"></a>00699 }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701 <span class="keywordtype">void</span> TIMER_Init() {
<a name="l00702"></a>00702         Bitu i;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704         <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;TIMER_Init()&quot;</span>);
<a name="l00705"></a>00705 
<a name="l00706"></a>00706     PIT_TICK_RATE = PIT_TICK_RATE_IBM;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708         <span class="keywordflow">for</span> (i=0;i &lt; 3;i++) {
<a name="l00709"></a>00709                 pit[i].cntr = 0x10000;
<a name="l00710"></a>00710                 pit[i].write_state = 0;
<a name="l00711"></a>00711                 pit[i].read_state = 0;
<a name="l00712"></a>00712                 pit[i].read_latch = 0;
<a name="l00713"></a>00713                 pit[i].write_latch = 0;
<a name="l00714"></a>00714                 pit[i].mode = 0;
<a name="l00715"></a>00715                 pit[i].bcd = <span class="keyword">false</span>;
<a name="l00716"></a>00716                 pit[i].go_read_latch = <span class="keyword">false</span>;
<a name="l00717"></a>00717                 pit[i].counterstatus_set = <span class="keyword">false</span>;
<a name="l00718"></a>00718                 pit[i].update_count = <span class="keyword">false</span>;
<a name="l00719"></a>00719                 pit[i].delay = (1000.0f/((float)PIT_TICK_RATE/(<span class="keywordtype">float</span>)pit[i].cntr));
<a name="l00720"></a>00720         }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722         AddExitFunction(AddExitFunctionFuncPair(TIMER_Destroy));
<a name="l00723"></a>00723         AddVMEventFunction(VM_EVENT_POWERON, AddVMEventFunctionFuncPair(TIMER_OnPowerOn));
<a name="l00724"></a>00724 
<a name="l00725"></a>00725     <span class="keywordflow">if</span> (IS_PC98_ARCH) <span class="comment">/* HACK! Clean this up! */</span>
<a name="l00726"></a>00726         AddVMEventFunction(VM_EVENT_RESET, AddVMEventFunctionFuncPair(TIMER_OnEnterPC98_Phase2));
<a name="l00727"></a>00727 }
<a name="l00728"></a>00728 
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 20 2018 21:51:34 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
