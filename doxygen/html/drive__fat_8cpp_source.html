<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/dos/drive_fat.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/dos/drive_fat.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  Copyright (C) 2002-2020  The DOSBox Team</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  This program is free software; you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment"> *  (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *  This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment"> *  GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  You should have received a copy of the GNU General Public License along</span>
<a name="l00015"></a>00015 <span class="comment"> *  with this program; if not, write to the Free Software Foundation, Inc.,</span>
<a name="l00016"></a>00016 <span class="comment"> *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;time.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;dosbox.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;dos_inc.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;drives.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;support.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;cross.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;bios.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;bios_disk.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;qcow2_disk.h&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;bitop.h&quot;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#define IMGTYPE_FLOPPY 0</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#define IMGTYPE_ISO    1</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#define IMGTYPE_HDD        2</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="preprocessor">#define FAT12              0</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#define FAT16              1</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#define FAT32              2</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="keyword">static</span> Bit16u dpos[256];
<a name="l00045"></a>00045 <span class="keyword">static</span> Bit32u dnum[256];
<a name="l00046"></a>00046 <span class="keyword">extern</span> <span class="keywordtype">bool</span> wpcolon, force_sfn;
<a name="l00047"></a>00047 <span class="keyword">extern</span> <span class="keywordtype">int</span> lfn_filefind_handle;
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="keywordtype">bool</span> filename_not_8x3(<span class="keyword">const</span> <span class="keywordtype">char</span> *n) {
<a name="l00050"></a>00050         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052         i = 0;
<a name="l00053"></a>00053         <span class="keywordflow">while</span> (*n != 0) {
<a name="l00054"></a>00054                 <span class="keywordflow">if</span> (*n == <span class="charliteral">&#39;.&#39;</span>) <span class="keywordflow">break</span>;
<a name="l00055"></a>00055                 <span class="keywordflow">if</span> (*n&lt;=32||*n==127||*n==<span class="charliteral">&#39;&quot;&#39;</span>||*n==<span class="charliteral">&#39;+&#39;</span>||*n==<span class="charliteral">&#39;=&#39;</span>||*n==<span class="charliteral">&#39;,&#39;</span>||*n==<span class="charliteral">&#39;;&#39;</span>||*n==<span class="charliteral">&#39;:&#39;</span>||*n==<span class="charliteral">&#39;&lt;&#39;</span>||*n==<span class="charliteral">&#39;&gt;&#39;</span>||*n==<span class="charliteral">&#39;[&#39;</span>||*n==<span class="charliteral">&#39;]&#39;</span>||*n==<span class="charliteral">&#39;|&#39;</span>||*n==<span class="charliteral">&#39;?&#39;</span>||*n==<span class="charliteral">&#39;*&#39;</span>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00056"></a>00056                 i++;
<a name="l00057"></a>00057                 n++;
<a name="l00058"></a>00058         }
<a name="l00059"></a>00059         <span class="keywordflow">if</span> (i &gt; 8) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00060"></a>00060         <span class="keywordflow">if</span> (*n == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">/* made it past 8 or less normal chars and end of string: normal */</span>
<a name="l00061"></a>00061 
<a name="l00062"></a>00062         <span class="comment">/* skip dot */</span>
<a name="l00063"></a>00063         assert(*n == <span class="charliteral">&#39;.&#39;</span>);
<a name="l00064"></a>00064         n++;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066         i = 0;
<a name="l00067"></a>00067         <span class="keywordflow">while</span> (*n != 0) {
<a name="l00068"></a>00068                 <span class="keywordflow">if</span> (*n == <span class="charliteral">&#39;.&#39;</span>) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">/* another &#39;.&#39; means LFN */</span>
<a name="l00069"></a>00069                 <span class="keywordflow">if</span> (*n&lt;=32||*n==127||*n==<span class="charliteral">&#39;&quot;&#39;</span>||*n==<span class="charliteral">&#39;+&#39;</span>||*n==<span class="charliteral">&#39;=&#39;</span>||*n==<span class="charliteral">&#39;,&#39;</span>||*n==<span class="charliteral">&#39;;&#39;</span>||*n==<span class="charliteral">&#39;:&#39;</span>||*n==<span class="charliteral">&#39;&lt;&#39;</span>||*n==<span class="charliteral">&#39;&gt;&#39;</span>||*n==<span class="charliteral">&#39;[&#39;</span>||*n==<span class="charliteral">&#39;]&#39;</span>||*n==<span class="charliteral">&#39;|&#39;</span>||*n==<span class="charliteral">&#39;?&#39;</span>||*n==<span class="charliteral">&#39;*&#39;</span>) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00070"></a>00070                 i++;
<a name="l00071"></a>00071                 n++;
<a name="l00072"></a>00072         }
<a name="l00073"></a>00073         <span class="keywordflow">if</span> (i &gt; 3) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075         <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">/* it is 8.3 case */</span>
<a name="l00076"></a>00076 }
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="comment">/* Assuming an LFN call, if the name is not strict 8.3 uppercase, return true.</span>
<a name="l00079"></a>00079 <span class="comment"> * If the name is strict 8.3 uppercase like &quot;FILENAME.TXT&quot; there is no point making an LFN because it is a waste of space */</span>
<a name="l00080"></a>00080 <span class="keywordtype">bool</span> filename_not_strict_8x3(<span class="keyword">const</span> <span class="keywordtype">char</span> *n) {
<a name="l00081"></a>00081         <span class="keywordflow">if</span> (filename_not_8x3(n)) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00082"></a>00082         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;strlen(n); i++)
<a name="l00083"></a>00083                 <span class="keywordflow">if</span> (n[i]&gt;=<span class="charliteral">&#39;a&#39;</span> &amp;&amp; n[i]&lt;=<span class="charliteral">&#39;z&#39;</span>)
<a name="l00084"></a>00084                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00085"></a>00085         <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">/* it is strict 8.3 upper case */</span>
<a name="l00086"></a>00086 }
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="keywordtype">char</span> sfn[DOS_NAMELENGTH_ASCII];
<a name="l00089"></a>00089 <span class="comment">/* Generate 8.3 names from LFNs, with tilde usage (from ~1 to ~9999). */</span>
<a name="l00090"></a>00090 <span class="keywordtype">char</span>* fatDrive::Generate_SFN(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l00091"></a>00091         <span class="keywordflow">if</span> (!filename_not_8x3(name)) {
<a name="l00092"></a>00092                 strcpy(sfn, name);
<a name="l00093"></a>00093                 upcase(sfn);
<a name="l00094"></a>00094                 <span class="keywordflow">return</span> sfn;
<a name="l00095"></a>00095         }
<a name="l00096"></a>00096         <span class="keywordtype">char</span> lfn[LFN_NAMELENGTH+1], fullname[DOS_PATHLENGTH+DOS_NAMELENGTH_ASCII], *n;
<a name="l00097"></a>00097         <span class="keywordflow">if</span> (name==NULL||!*name) <span class="keywordflow">return</span> NULL;
<a name="l00098"></a>00098         <span class="keywordflow">if</span> (strlen(name)&gt;LFN_NAMELENGTH) {
<a name="l00099"></a>00099                 strncpy(lfn, name, LFN_NAMELENGTH);
<a name="l00100"></a>00100                 lfn[LFN_NAMELENGTH]=0;
<a name="l00101"></a>00101         } <span class="keywordflow">else</span>
<a name="l00102"></a>00102                 strcpy(lfn, name);
<a name="l00103"></a>00103         <span class="keywordflow">if</span> (!strlen(lfn)) <span class="keywordflow">return</span> NULL;
<a name="l00104"></a>00104         <a class="code" href="structdirentry.html">direntry</a> fileEntry = {};
<a name="l00105"></a>00105         Bit32u dirClust, subEntry;
<a name="l00106"></a>00106         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=1, i, t=10000;
<a name="l00107"></a>00107         <span class="keywordflow">while</span> (k&lt;10000) {
<a name="l00108"></a>00108                 n=lfn;
<a name="l00109"></a>00109                 <span class="keywordflow">if</span> (t&gt;strlen(n)||k==1||k==10||k==100||k==1000) {
<a name="l00110"></a>00110                         i=0;
<a name="l00111"></a>00111                         *sfn=0;
<a name="l00112"></a>00112                         <span class="keywordflow">while</span> (*n == <span class="charliteral">&#39;.&#39;</span>||*n == <span class="charliteral">&#39; &#39;</span>) n++;
<a name="l00113"></a>00113                         <span class="keywordflow">while</span> (strlen(n)&amp;&amp;(*(n+strlen(n)-1)==<span class="charliteral">&#39;.&#39;</span>||*(n+strlen(n)-1)==<span class="charliteral">&#39; &#39;</span>)) *(n+strlen(n)-1)=0;
<a name="l00114"></a>00114                         <span class="keywordflow">while</span> (*n != 0 &amp;&amp; *n != <span class="charliteral">&#39;.&#39;</span> &amp;&amp; i&lt;(k&lt;10?6u:(k&lt;100?5u:(k&lt;1000?4:3u)))) {
<a name="l00115"></a>00115                                 <span class="keywordflow">if</span> (*n == <span class="charliteral">&#39; &#39;</span>) {
<a name="l00116"></a>00116                                         n++;
<a name="l00117"></a>00117                                         <span class="keywordflow">continue</span>;
<a name="l00118"></a>00118                                 }
<a name="l00119"></a>00119                                 <span class="keywordflow">if</span> (*n==<span class="charliteral">&#39;&quot;&#39;</span>||*n==<span class="charliteral">&#39;+&#39;</span>||*n==<span class="charliteral">&#39;=&#39;</span>||*n==<span class="charliteral">&#39;,&#39;</span>||*n==<span class="charliteral">&#39;;&#39;</span>||*n==<span class="charliteral">&#39;:&#39;</span>||*n==<span class="charliteral">&#39;&lt;&#39;</span>||*n==<span class="charliteral">&#39;&gt;&#39;</span>||*n==<span class="charliteral">&#39;[&#39;</span>||*n==<span class="charliteral">&#39;]&#39;</span>||*n==<span class="charliteral">&#39;|&#39;</span>||*n==<span class="charliteral">&#39;?&#39;</span>||*n==<span class="charliteral">&#39;*&#39;</span>) {
<a name="l00120"></a>00120                                         sfn[i++]=<span class="charliteral">&#39;_&#39;</span>;
<a name="l00121"></a>00121                                         n++;
<a name="l00122"></a>00122                                 } <span class="keywordflow">else</span>
<a name="l00123"></a>00123                                         sfn[i++]=toupper(*(n++));
<a name="l00124"></a>00124                         }
<a name="l00125"></a>00125                         sfn[i++]=<span class="charliteral">&#39;~&#39;</span>;
<a name="l00126"></a>00126                         t=i;
<a name="l00127"></a>00127                 } <span class="keywordflow">else</span>
<a name="l00128"></a>00128                         i=t;
<a name="l00129"></a>00129                 <span class="keywordflow">if</span> (k&lt;10)
<a name="l00130"></a>00130                         sfn[i++]=<span class="charliteral">&#39;0&#39;</span>+k;
<a name="l00131"></a>00131                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k&lt;100) {
<a name="l00132"></a>00132                         sfn[i++]=<span class="charliteral">&#39;0&#39;</span>+(k/10);
<a name="l00133"></a>00133                         sfn[i++]=<span class="charliteral">&#39;0&#39;</span>+(k%10);
<a name="l00134"></a>00134                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k&lt;1000) {
<a name="l00135"></a>00135                         sfn[i++]=<span class="charliteral">&#39;0&#39;</span>+(k/100);
<a name="l00136"></a>00136                         sfn[i++]=<span class="charliteral">&#39;0&#39;</span>+((k%100)/10);
<a name="l00137"></a>00137                         sfn[i++]=<span class="charliteral">&#39;0&#39;</span>+(k%10);
<a name="l00138"></a>00138                 } <span class="keywordflow">else</span> {
<a name="l00139"></a>00139                         sfn[i++]=<span class="charliteral">&#39;0&#39;</span>+(k/1000);
<a name="l00140"></a>00140                         sfn[i++]=<span class="charliteral">&#39;0&#39;</span>+((k%1000)/100);
<a name="l00141"></a>00141                         sfn[i++]=<span class="charliteral">&#39;0&#39;</span>+((k%100)/10);
<a name="l00142"></a>00142                         sfn[i++]=<span class="charliteral">&#39;0&#39;</span>+(k%10);
<a name="l00143"></a>00143                 }
<a name="l00144"></a>00144                 <span class="keywordflow">if</span> (t&gt;strlen(n)||k==1||k==10||k==100||k==1000) {
<a name="l00145"></a>00145                         <span class="keywordtype">char</span> *p=strrchr(n, <span class="charliteral">&#39;.&#39;</span>);
<a name="l00146"></a>00146                         <span class="keywordflow">if</span> (p!=NULL) {
<a name="l00147"></a>00147                                 sfn[i++]=<span class="charliteral">&#39;.&#39;</span>;
<a name="l00148"></a>00148                                 n=p+1;
<a name="l00149"></a>00149                                 <span class="keywordflow">while</span> (*n == <span class="charliteral">&#39;.&#39;</span>) n++;
<a name="l00150"></a>00150                                 <span class="keywordtype">int</span> j=0;
<a name="l00151"></a>00151                                 <span class="keywordflow">while</span> (*n != 0 &amp;&amp; j++&lt;3) {
<a name="l00152"></a>00152                                         <span class="keywordflow">if</span> (*n == <span class="charliteral">&#39; &#39;</span>) {
<a name="l00153"></a>00153                                                 n++;
<a name="l00154"></a>00154                                                 <span class="keywordflow">continue</span>;
<a name="l00155"></a>00155                                         }
<a name="l00156"></a>00156                                         <span class="keywordflow">if</span> (*n==<span class="charliteral">&#39;&quot;&#39;</span>||*n==<span class="charliteral">&#39;+&#39;</span>||*n==<span class="charliteral">&#39;=&#39;</span>||*n==<span class="charliteral">&#39;,&#39;</span>||*n==<span class="charliteral">&#39;;&#39;</span>||*n==<span class="charliteral">&#39;:&#39;</span>||*n==<span class="charliteral">&#39;&lt;&#39;</span>||*n==<span class="charliteral">&#39;&gt;&#39;</span>||*n==<span class="charliteral">&#39;[&#39;</span>||*n==<span class="charliteral">&#39;]&#39;</span>||*n==<span class="charliteral">&#39;|&#39;</span>||*n==<span class="charliteral">&#39;?&#39;</span>||*n==<span class="charliteral">&#39;*&#39;</span>) {
<a name="l00157"></a>00157                                                 sfn[i++]=<span class="charliteral">&#39;_&#39;</span>;
<a name="l00158"></a>00158                                                 n++;
<a name="l00159"></a>00159                                         } <span class="keywordflow">else</span>
<a name="l00160"></a>00160                                                 sfn[i++]=toupper(*(n++));
<a name="l00161"></a>00161                                 }
<a name="l00162"></a>00162                         }
<a name="l00163"></a>00163                         sfn[i++]=0;
<a name="l00164"></a>00164                 }
<a name="l00165"></a>00165                 strcpy(fullname, path);
<a name="l00166"></a>00166                 strcat(fullname, sfn);
<a name="l00167"></a>00167                 <span class="keywordflow">if</span>(!getFileDirEntry(fullname, &amp;fileEntry, &amp;dirClust, &amp;subEntry,<span class="comment">/*dirOk*/</span><span class="keyword">true</span>)) <span class="keywordflow">return</span> sfn;
<a name="l00168"></a>00168                 k++;
<a name="l00169"></a>00169         }
<a name="l00170"></a>00170         <span class="keywordflow">return</span> NULL;
<a name="l00171"></a>00171 }
<a name="l00172"></a>00172 
<a name="l00173"></a><a class="code" href="classfatFile.html">00173</a> <span class="keyword">class </span><a class="code" href="classfatFile.html">fatFile</a> : <span class="keyword">public</span> <a class="code" href="classDOS__File.html">DOS_File</a> {
<a name="l00174"></a>00174 <span class="keyword">public</span>:
<a name="l00175"></a>00175         <a class="code" href="classfatFile.html">fatFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* name, Bit32u startCluster, Bit32u fileLen, <a class="code" href="classfatDrive.html">fatDrive</a> *useDrive);
<a name="l00176"></a>00176         <span class="keywordtype">bool</span> Read(Bit8u * data,Bit16u * size);
<a name="l00177"></a>00177         <span class="keywordtype">bool</span> Write(<span class="keyword">const</span> Bit8u * data,Bit16u * size);
<a name="l00178"></a>00178         <span class="keywordtype">bool</span> Seek(Bit32u * pos,Bit32u type);
<a name="l00179"></a>00179         <span class="keywordtype">bool</span> Close();
<a name="l00180"></a>00180         Bit16u GetInformation(<span class="keywordtype">void</span>);
<a name="l00181"></a>00181     <span class="keywordtype">void</span> Flush(<span class="keywordtype">void</span>);
<a name="l00182"></a>00182         <span class="keywordtype">bool</span> UpdateDateTimeFromHost(<span class="keywordtype">void</span>);   
<a name="l00183"></a>00183         Bit32u GetSeekPos(<span class="keywordtype">void</span>);
<a name="l00184"></a>00184         Bit32u firstCluster;
<a name="l00185"></a>00185         Bit32u seekpos = 0;
<a name="l00186"></a>00186         Bit32u filelength;
<a name="l00187"></a>00187         Bit32u currentSector = 0;
<a name="l00188"></a>00188         Bit32u curSectOff = 0;
<a name="l00189"></a>00189         Bit8u sectorBuffer[SECTOR_SIZE_MAX];
<a name="l00190"></a>00190         <span class="comment">/* Record of where in the directory structure this file is located */</span>
<a name="l00191"></a>00191         Bit32u dirCluster = 0;
<a name="l00192"></a>00192         Bit32u dirIndex = 0;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194     <span class="keywordtype">bool</span> modified = <span class="keyword">false</span>;
<a name="l00195"></a>00195         <span class="keywordtype">bool</span> loadedSector = <span class="keyword">false</span>;
<a name="l00196"></a>00196         <a class="code" href="classfatDrive.html">fatDrive</a> *myDrive;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 <span class="preprocessor">#if 0</span><span class="comment">/*unused*/</span>
<a name="l00199"></a>00199 <span class="keyword">private</span>:
<a name="l00200"></a>00200     <span class="keyword">enum</span> { NONE,READ,WRITE } last_action;
<a name="l00201"></a>00201         Bit16u info;
<a name="l00202"></a>00202 <span class="preprocessor">#endif</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span>};
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="keywordtype">void</span> time_t_to_DOS_DateTime(Bit16u &amp;t,Bit16u &amp;d,time_t unix_time) {
<a name="l00206"></a>00206     <span class="keyword">const</span> <span class="keyword">struct </span>tm *tm = localtime(&amp;unix_time);
<a name="l00207"></a>00207     <span class="keywordflow">if</span> (tm == NULL) <span class="keywordflow">return</span>;
<a name="l00208"></a>00208 
<a name="l00209"></a>00209     <span class="comment">/* NTS: tm-&gt;tm_year = years since 1900,</span>
<a name="l00210"></a>00210 <span class="comment">     *      tm-&gt;tm_mon = months since January therefore January == 0</span>
<a name="l00211"></a>00211 <span class="comment">     *      tm-&gt;tm_mday = day of the month, starting with 1 */</span>
<a name="l00212"></a>00212 
<a name="l00213"></a>00213     t = ((<span class="keywordtype">unsigned</span> int)tm-&gt;tm_hour &lt;&lt; 11u) + ((<span class="keywordtype">unsigned</span> int)tm-&gt;tm_min &lt;&lt; 5u) + ((<span class="keywordtype">unsigned</span> int)tm-&gt;tm_sec &gt;&gt; 1u);
<a name="l00214"></a>00214     d = (((<span class="keywordtype">unsigned</span> int)tm-&gt;tm_year - 80u) &lt;&lt; 9u) + (((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)tm-&gt;tm_mon + 1u) &lt;&lt; 5u) + (<span class="keywordtype">unsigned</span> int)tm-&gt;tm_mday;
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="comment">/* IN - char * filename: Name in regular filename format, e.g. bob.txt */</span>
<a name="l00218"></a>00218 <span class="comment">/* OUT - char * filearray: Name in DOS directory format, eleven char, e.g. bob     txt */</span>
<a name="l00219"></a>00219 <span class="keyword">static</span> <span class="keywordtype">void</span> convToDirFile(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keywordtype">char</span> *filearray) {
<a name="l00220"></a>00220         Bit32u charidx = 0;
<a name="l00221"></a>00221         Bit32u flen,i;
<a name="l00222"></a>00222         flen = (Bit32u)strlen(filename);
<a name="l00223"></a>00223         memset(filearray, 32, 11);
<a name="l00224"></a>00224         <span class="keywordflow">for</span>(i=0;i&lt;flen;i++) {
<a name="l00225"></a>00225                 <span class="keywordflow">if</span>(charidx &gt;= 11) <span class="keywordflow">break</span>;
<a name="l00226"></a>00226                 <span class="keywordflow">if</span>(filename[i] != <span class="charliteral">&#39;.&#39;</span>) {
<a name="l00227"></a>00227                         filearray[charidx] = filename[i];
<a name="l00228"></a>00228                         charidx++;
<a name="l00229"></a>00229                 } <span class="keywordflow">else</span> {
<a name="l00230"></a>00230                         charidx = 8;
<a name="l00231"></a>00231                 }
<a name="l00232"></a>00232         }
<a name="l00233"></a>00233 }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 fatFile::fatFile(<span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="comment">/*name*/</span>, Bit32u startCluster, Bit32u fileLen, <a class="code" href="classfatDrive.html">fatDrive</a> *useDrive) : firstCluster(startCluster), filelength(fileLen), myDrive(useDrive) {
<a name="l00236"></a>00236         Bit32u seekto = 0;
<a name="l00237"></a>00237         open = <span class="keyword">true</span>;
<a name="l00238"></a>00238         memset(&amp;sectorBuffer[0], 0, <span class="keyword">sizeof</span>(sectorBuffer));
<a name="l00239"></a>00239         
<a name="l00240"></a>00240         <span class="keywordflow">if</span>(filelength &gt; 0) {
<a name="l00241"></a>00241                 Seek(&amp;seekto, DOS_SEEK_SET);
<a name="l00242"></a>00242         }
<a name="l00243"></a>00243 }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="keywordtype">void</span> fatFile::Flush(<span class="keywordtype">void</span>) {
<a name="l00246"></a>00246         <span class="keywordflow">if</span> (loadedSector) {
<a name="l00247"></a>00247                 myDrive-&gt;writeSector(currentSector, sectorBuffer);
<a name="l00248"></a>00248                 loadedSector = <span class="keyword">false</span>;
<a name="l00249"></a>00249         }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     <span class="keywordflow">if</span> (modified || newtime) {
<a name="l00252"></a>00252         <a class="code" href="structdirentry.html">direntry</a> tmpentry = {};
<a name="l00253"></a>00253 
<a name="l00254"></a>00254         myDrive-&gt;directoryBrowse(dirCluster, &amp;tmpentry, (Bit32s)dirIndex);
<a name="l00255"></a>00255 
<a name="l00256"></a>00256         <span class="keywordflow">if</span> (newtime) {
<a name="l00257"></a>00257             tmpentry.modTime = time;
<a name="l00258"></a>00258             tmpentry.modDate = date;
<a name="l00259"></a>00259         }
<a name="l00260"></a>00260         <span class="keywordflow">else</span> {
<a name="l00261"></a>00261             Bit16u ct,cd;
<a name="l00262"></a>00262 
<a name="l00263"></a>00263             time_t_to_DOS_DateTime(<span class="comment">/*&amp;*/</span>ct,<span class="comment">/*&amp;*/</span>cd,::time(NULL));
<a name="l00264"></a>00264 
<a name="l00265"></a>00265             tmpentry.modTime = ct;
<a name="l00266"></a>00266             tmpentry.modDate = cd;
<a name="l00267"></a>00267         }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269         myDrive-&gt;directoryChange(dirCluster, &amp;tmpentry, (Bit32s)dirIndex);
<a name="l00270"></a>00270         modified = <span class="keyword">false</span>;
<a name="l00271"></a>00271         newtime = <span class="keyword">false</span>;
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="keywordtype">bool</span> fatFile::Read(Bit8u * data, Bit16u *size) {
<a name="l00276"></a>00276         <span class="keywordflow">if</span> ((this-&gt;flags &amp; 0xf) == OPEN_WRITE) {        <span class="comment">// check if file opened in write-only mode</span>
<a name="l00277"></a>00277                 DOS_SetError(DOSERR_ACCESS_DENIED);
<a name="l00278"></a>00278                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00279"></a>00279         }
<a name="l00280"></a>00280         Bit16u sizedec, sizecount;
<a name="l00281"></a>00281         <span class="keywordflow">if</span>(seekpos &gt;= filelength) {
<a name="l00282"></a>00282                 *size = 0;
<a name="l00283"></a>00283                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00284"></a>00284         }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286         <span class="keywordflow">if</span> (!loadedSector) {
<a name="l00287"></a>00287                 currentSector = myDrive-&gt;getAbsoluteSectFromBytePos(firstCluster, seekpos);
<a name="l00288"></a>00288                 <span class="keywordflow">if</span>(currentSector == 0) {
<a name="l00289"></a>00289                         <span class="comment">/* EOC reached before EOF */</span>
<a name="l00290"></a>00290                         *size = 0;
<a name="l00291"></a>00291                         loadedSector = <span class="keyword">false</span>;
<a name="l00292"></a>00292                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00293"></a>00293                 }
<a name="l00294"></a>00294                 curSectOff = seekpos % myDrive-&gt;getSectorSize();
<a name="l00295"></a>00295                 myDrive-&gt;readSector(currentSector, sectorBuffer);
<a name="l00296"></a>00296                 loadedSector = <span class="keyword">true</span>;
<a name="l00297"></a>00297         }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299         sizedec = *size;
<a name="l00300"></a>00300         sizecount = 0;
<a name="l00301"></a>00301         <span class="keywordflow">while</span>(sizedec != 0) {
<a name="l00302"></a>00302                 <span class="keywordflow">if</span>(seekpos &gt;= filelength) {
<a name="l00303"></a>00303                         *size = sizecount;
<a name="l00304"></a>00304                         <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l00305"></a>00305                 }
<a name="l00306"></a>00306                 data[sizecount++] = sectorBuffer[curSectOff++];
<a name="l00307"></a>00307                 seekpos++;
<a name="l00308"></a>00308                 <span class="keywordflow">if</span>(curSectOff &gt;= myDrive-&gt;getSectorSize()) {
<a name="l00309"></a>00309                         currentSector = myDrive-&gt;getAbsoluteSectFromBytePos(firstCluster, seekpos);
<a name="l00310"></a>00310                         <span class="keywordflow">if</span>(currentSector == 0) {
<a name="l00311"></a>00311                                 <span class="comment">/* EOC reached before EOF */</span>
<a name="l00312"></a>00312                                 <span class="comment">//LOG_MSG(&quot;EOC reached before EOF, seekpos %d, filelen %d&quot;, seekpos, filelength);</span>
<a name="l00313"></a>00313                                 *size = sizecount;
<a name="l00314"></a>00314                                 loadedSector = <span class="keyword">false</span>;
<a name="l00315"></a>00315                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00316"></a>00316                         }
<a name="l00317"></a>00317                         curSectOff = 0;
<a name="l00318"></a>00318                         myDrive-&gt;readSector(currentSector, sectorBuffer);
<a name="l00319"></a>00319                         loadedSector = <span class="keyword">true</span>;
<a name="l00320"></a>00320                         <span class="comment">//LOG_MSG(&quot;Reading absolute sector at %d for seekpos %d&quot;, currentSector, seekpos);</span>
<a name="l00321"></a>00321                 }
<a name="l00322"></a>00322                 --sizedec;
<a name="l00323"></a>00323         }
<a name="l00324"></a>00324         *size =sizecount;
<a name="l00325"></a>00325         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00326"></a>00326 }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="keywordtype">bool</span> fatFile::Write(<span class="keyword">const</span> Bit8u * data, Bit16u *size) {
<a name="l00329"></a>00329         <span class="keywordflow">if</span> ((this-&gt;flags &amp; 0xf) == OPEN_READ) { <span class="comment">// check if file opened in read-only mode</span>
<a name="l00330"></a>00330                 DOS_SetError(DOSERR_ACCESS_DENIED);
<a name="l00331"></a>00331                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334     <a class="code" href="structdirentry.html">direntry</a> tmpentry = {};
<a name="l00335"></a>00335         Bit16u sizedec, sizecount;
<a name="l00336"></a>00336         sizedec = *size;
<a name="l00337"></a>00337         sizecount = 0;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339         <span class="keywordflow">if</span>(seekpos &lt; filelength &amp;&amp; *size == 0) {
<a name="l00340"></a>00340                 <span class="comment">/* Truncate file to current position */</span>
<a name="l00341"></a>00341                 myDrive-&gt;deleteClustChain(firstCluster, seekpos);
<a name="l00342"></a>00342                 filelength = seekpos;
<a name="l00343"></a>00343                 <span class="keywordflow">if</span> (filelength == 0) firstCluster = 0; <span class="comment">/* A file of length zero has a starting cluster of zero as well */</span>
<a name="l00344"></a>00344                 modified = <span class="keyword">true</span>;
<a name="l00345"></a>00345                 <span class="keywordflow">goto</span> finalizeWrite;
<a name="l00346"></a>00346         }
<a name="l00347"></a>00347 
<a name="l00348"></a>00348         <span class="keywordflow">if</span>(seekpos &gt; filelength) {
<a name="l00349"></a>00349                 <span class="comment">/* Extend file to current position */</span>
<a name="l00350"></a>00350                 Bit32u clustSize = myDrive-&gt;getClusterSize();
<a name="l00351"></a>00351                 <span class="keywordflow">if</span>(filelength == 0) {
<a name="l00352"></a>00352                         firstCluster = myDrive-&gt;getFirstFreeClust();
<a name="l00353"></a>00353                         <span class="keywordflow">if</span>(firstCluster == 0) <span class="keywordflow">goto</span> finalizeWrite; <span class="comment">// out of space</span>
<a name="l00354"></a>00354                         myDrive-&gt;allocateCluster(firstCluster, 0);
<a name="l00355"></a>00355                         filelength = clustSize;
<a name="l00356"></a>00356                 }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358                 <span class="comment">/* round up */</span>
<a name="l00359"></a>00359                 filelength += clustSize - 1;
<a name="l00360"></a>00360                 filelength -= filelength % clustSize;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362                 <span class="comment">/* add clusters until the file length is correct */</span>
<a name="l00363"></a>00363                 <span class="keywordflow">while</span>(filelength &lt; seekpos) {
<a name="l00364"></a>00364                         <span class="keywordflow">if</span>(myDrive-&gt;appendCluster(firstCluster) == 0) <span class="keywordflow">goto</span> finalizeWrite; <span class="comment">// out of space</span>
<a name="l00365"></a>00365                         filelength += clustSize;
<a name="l00366"></a>00366                 }
<a name="l00367"></a>00367                 assert(filelength &lt; (seekpos+clustSize));
<a name="l00368"></a>00368 
<a name="l00369"></a>00369                 <span class="comment">/* limit file length to seekpos, then bail out if write count is zero */</span>
<a name="l00370"></a>00370                 modified = <span class="keyword">true</span>;
<a name="l00371"></a>00371                 <span class="keywordflow">if</span>(filelength &gt; seekpos) filelength = seekpos;
<a name="l00372"></a>00372                 <span class="keywordflow">if</span>(*size == 0) <span class="keywordflow">goto</span> finalizeWrite;
<a name="l00373"></a>00373         }
<a name="l00374"></a>00374 
<a name="l00375"></a>00375         <span class="keywordflow">while</span>(sizedec != 0) {
<a name="l00376"></a>00376                 <span class="comment">/* Increase filesize if necessary */</span>
<a name="l00377"></a>00377                 <span class="keywordflow">if</span>(seekpos &gt;= filelength) {
<a name="l00378"></a>00378                         <span class="keywordflow">if</span>(filelength == 0) {
<a name="l00379"></a>00379                                 firstCluster = myDrive-&gt;getFirstFreeClust();
<a name="l00380"></a>00380                                 <span class="keywordflow">if</span>(firstCluster == 0) <span class="keywordflow">goto</span> finalizeWrite; <span class="comment">// out of space</span>
<a name="l00381"></a>00381                                 myDrive-&gt;allocateCluster(firstCluster, 0);
<a name="l00382"></a>00382                                 currentSector = myDrive-&gt;getAbsoluteSectFromBytePos(firstCluster, seekpos);
<a name="l00383"></a>00383                                 <span class="keywordflow">if</span> (currentSector == 0) {
<a name="l00384"></a>00384                                         <span class="comment">/* I guess allocateCluster() didn&#39;t work after all. This check is necessary to prevent</span>
<a name="l00385"></a>00385 <span class="comment">                                         * this conditon from treating the BOOT SECTOR as a file. */</span>
<a name="l00386"></a>00386                                         <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_WARN)(<span class="stringliteral">&quot;FAT file write: unable to allocate first cluster, erroring out&quot;</span>);
<a name="l00387"></a>00387                                         <span class="keywordflow">goto</span> finalizeWrite;
<a name="l00388"></a>00388                                 }
<a name="l00389"></a>00389                                 myDrive-&gt;readSector(currentSector, sectorBuffer);
<a name="l00390"></a>00390                                 loadedSector = <span class="keyword">true</span>;
<a name="l00391"></a>00391                         }
<a name="l00392"></a>00392                         <span class="keywordflow">if</span> (!loadedSector) {
<a name="l00393"></a>00393                                 currentSector = myDrive-&gt;getAbsoluteSectFromBytePos(firstCluster, seekpos);
<a name="l00394"></a>00394                                 <span class="keywordflow">if</span>(currentSector == 0) {
<a name="l00395"></a>00395                                         <span class="comment">/* EOC reached before EOF - try to increase file allocation */</span>
<a name="l00396"></a>00396                                         myDrive-&gt;appendCluster(firstCluster);
<a name="l00397"></a>00397                                         <span class="comment">/* Try getting sector again */</span>
<a name="l00398"></a>00398                                         currentSector = myDrive-&gt;getAbsoluteSectFromBytePos(firstCluster, seekpos);
<a name="l00399"></a>00399                                         <span class="keywordflow">if</span>(currentSector == 0) {
<a name="l00400"></a>00400                                                 <span class="comment">/* No can do. lets give up and go home.  We must be out of room */</span>
<a name="l00401"></a>00401                                                 <span class="keywordflow">goto</span> finalizeWrite;
<a name="l00402"></a>00402                                         }
<a name="l00403"></a>00403                                 }
<a name="l00404"></a>00404                                 curSectOff = seekpos % myDrive-&gt;getSectorSize();
<a name="l00405"></a>00405                                 myDrive-&gt;readSector(currentSector, sectorBuffer);
<a name="l00406"></a>00406                                 loadedSector = <span class="keyword">true</span>;
<a name="l00407"></a>00407                         }
<a name="l00408"></a>00408                         filelength = seekpos+1;
<a name="l00409"></a>00409                 }
<a name="l00410"></a>00410                 --sizedec;
<a name="l00411"></a>00411                 modified = <span class="keyword">true</span>;
<a name="l00412"></a>00412                 sectorBuffer[curSectOff++] = data[sizecount++];
<a name="l00413"></a>00413                 seekpos++;
<a name="l00414"></a>00414                 <span class="keywordflow">if</span>(curSectOff &gt;= myDrive-&gt;getSectorSize()) {
<a name="l00415"></a>00415                         <span class="keywordflow">if</span>(loadedSector) myDrive-&gt;writeSector(currentSector, sectorBuffer);
<a name="l00416"></a>00416                         loadedSector = <span class="keyword">false</span>;
<a name="l00417"></a>00417 
<a name="l00418"></a>00418                         <span class="keywordflow">if</span> (sizedec == 0) <span class="keywordflow">goto</span> finalizeWrite;
<a name="l00419"></a>00419 
<a name="l00420"></a>00420                         currentSector = myDrive-&gt;getAbsoluteSectFromBytePos(firstCluster, seekpos);
<a name="l00421"></a>00421                         <span class="keywordflow">if</span>(currentSector == 0) {
<a name="l00422"></a>00422                                 <span class="comment">/* EOC reached before EOF - try to increase file allocation */</span>
<a name="l00423"></a>00423                                 myDrive-&gt;appendCluster(firstCluster);
<a name="l00424"></a>00424                                 <span class="comment">/* Try getting sector again */</span>
<a name="l00425"></a>00425                                 currentSector = myDrive-&gt;getAbsoluteSectFromBytePos(firstCluster, seekpos);
<a name="l00426"></a>00426                                 <span class="keywordflow">if</span>(currentSector == 0) {
<a name="l00427"></a>00427                                         <span class="comment">/* No can do. lets give up and go home.  We must be out of room */</span>
<a name="l00428"></a>00428                                         <span class="keywordflow">goto</span> finalizeWrite;
<a name="l00429"></a>00429                                 }
<a name="l00430"></a>00430                         }
<a name="l00431"></a>00431                         curSectOff = 0;
<a name="l00432"></a>00432                         myDrive-&gt;readSector(currentSector, sectorBuffer);
<a name="l00433"></a>00433                         loadedSector = <span class="keyword">true</span>;
<a name="l00434"></a>00434                 }
<a name="l00435"></a>00435         }
<a name="l00436"></a>00436         <span class="keywordflow">if</span>(curSectOff&gt;0 &amp;&amp; loadedSector) myDrive-&gt;writeSector(currentSector, sectorBuffer);
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 finalizeWrite:
<a name="l00439"></a>00439         myDrive-&gt;directoryBrowse(dirCluster, &amp;tmpentry, (Bit32s)dirIndex);
<a name="l00440"></a>00440         tmpentry.entrysize = filelength;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442         <span class="keywordflow">if</span> (myDrive-&gt;GetBPB().is_fat32())
<a name="l00443"></a>00443                 tmpentry.SetCluster32(firstCluster);
<a name="l00444"></a>00444         <span class="keywordflow">else</span>
<a name="l00445"></a>00445                 tmpentry.loFirstClust = (Bit16u)firstCluster;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447         myDrive-&gt;directoryChange(dirCluster, &amp;tmpentry, (Bit32s)dirIndex);
<a name="l00448"></a>00448 
<a name="l00449"></a>00449         *size =sizecount;
<a name="l00450"></a>00450         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00451"></a>00451 }
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 <span class="keywordtype">bool</span> fatFile::Seek(Bit32u *pos, Bit32u type) {
<a name="l00454"></a>00454         Bit32s seekto=0;
<a name="l00455"></a>00455         
<a name="l00456"></a>00456         <span class="keywordflow">switch</span>(type) {
<a name="l00457"></a>00457                 <span class="keywordflow">case</span> DOS_SEEK_SET:
<a name="l00458"></a>00458                         seekto = (Bit32s)*pos;
<a name="l00459"></a>00459                         <span class="keywordflow">break</span>;
<a name="l00460"></a>00460                 <span class="keywordflow">case</span> DOS_SEEK_CUR:
<a name="l00461"></a>00461                         <span class="comment">/* Is this relative seek signed? */</span>
<a name="l00462"></a>00462                         seekto = (Bit32s)*pos + (Bit32s)seekpos;
<a name="l00463"></a>00463                         <span class="keywordflow">break</span>;
<a name="l00464"></a>00464                 <span class="keywordflow">case</span> DOS_SEEK_END:
<a name="l00465"></a>00465                         seekto = (Bit32s)filelength + (Bit32s)*pos;
<a name="l00466"></a>00466                         <span class="keywordflow">break</span>;
<a name="l00467"></a>00467         }
<a name="l00468"></a>00468 <span class="comment">//      LOG_MSG(&quot;Seek to %d with type %d (absolute value %d)&quot;, *pos, type, seekto);</span>
<a name="l00469"></a>00469 
<a name="l00470"></a>00470         <span class="keywordflow">if</span>(seekto&lt;0) seekto = 0;
<a name="l00471"></a>00471         seekpos = (Bit32u)seekto;
<a name="l00472"></a>00472         currentSector = myDrive-&gt;getAbsoluteSectFromBytePos(firstCluster, seekpos);
<a name="l00473"></a>00473         <span class="keywordflow">if</span> (currentSector == 0) {
<a name="l00474"></a>00474                 <span class="comment">/* not within file size, thus no sector is available */</span>
<a name="l00475"></a>00475                 loadedSector = <span class="keyword">false</span>;
<a name="l00476"></a>00476         } <span class="keywordflow">else</span> {
<a name="l00477"></a>00477                 curSectOff = seekpos % myDrive-&gt;getSectorSize();
<a name="l00478"></a>00478                 myDrive-&gt;readSector(currentSector, sectorBuffer);
<a name="l00479"></a>00479                 loadedSector = <span class="keyword">true</span>;
<a name="l00480"></a>00480         }
<a name="l00481"></a>00481         *pos = seekpos;
<a name="l00482"></a>00482         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00483"></a>00483 }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 <span class="keywordtype">bool</span> fatFile::Close() {
<a name="l00486"></a>00486         <span class="comment">/* Flush buffer */</span>
<a name="l00487"></a>00487         <span class="keywordflow">if</span> (loadedSector) myDrive-&gt;writeSector(currentSector, sectorBuffer);
<a name="l00488"></a>00488 
<a name="l00489"></a>00489     <span class="keywordflow">if</span> (modified || newtime) {
<a name="l00490"></a>00490         <a class="code" href="structdirentry.html">direntry</a> tmpentry = {};
<a name="l00491"></a>00491 
<a name="l00492"></a>00492         myDrive-&gt;directoryBrowse(dirCluster, &amp;tmpentry, (Bit32s)dirIndex);
<a name="l00493"></a>00493 
<a name="l00494"></a>00494         <span class="keywordflow">if</span> (newtime) {
<a name="l00495"></a>00495             tmpentry.modTime = time;
<a name="l00496"></a>00496             tmpentry.modDate = date;
<a name="l00497"></a>00497         }
<a name="l00498"></a>00498         <span class="keywordflow">else</span> {
<a name="l00499"></a>00499             Bit16u ct,cd;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501             time_t_to_DOS_DateTime(<span class="comment">/*&amp;*/</span>ct,<span class="comment">/*&amp;*/</span>cd,::time(NULL));
<a name="l00502"></a>00502 
<a name="l00503"></a>00503             tmpentry.modTime = ct;
<a name="l00504"></a>00504             tmpentry.modDate = cd;
<a name="l00505"></a>00505         }
<a name="l00506"></a>00506 
<a name="l00507"></a>00507         myDrive-&gt;directoryChange(dirCluster, &amp;tmpentry, (Bit32s)dirIndex);
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00511"></a>00511 }
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 Bit16u fatFile::GetInformation(<span class="keywordtype">void</span>) {
<a name="l00514"></a>00514         <span class="keywordflow">return</span> 0;
<a name="l00515"></a>00515 }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="keywordtype">bool</span> fatFile::UpdateDateTimeFromHost(<span class="keywordtype">void</span>) {
<a name="l00518"></a>00518         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00519"></a>00519 }
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 Bit32u fatFile::GetSeekPos() {
<a name="l00522"></a>00522         <span class="keywordflow">return</span> seekpos;
<a name="l00523"></a>00523 }
<a name="l00524"></a>00524 
<a name="l00525"></a>00525 Bit32u fatDrive::getClustFirstSect(Bit32u clustNum) {
<a name="l00526"></a>00526         <span class="keywordflow">return</span> ((clustNum - 2) * BPB.v.BPB_SecPerClus) + firstDataSector;
<a name="l00527"></a>00527 }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 Bit32u fatDrive::getClusterValue(Bit32u clustNum) {
<a name="l00530"></a>00530         Bit32u fatoffset=0;
<a name="l00531"></a>00531         Bit32u fatsectnum;
<a name="l00532"></a>00532         Bit32u fatentoff;
<a name="l00533"></a>00533         Bit32u clustValue=0;
<a name="l00534"></a>00534 
<a name="l00535"></a>00535         <span class="keywordflow">switch</span>(fattype) {
<a name="l00536"></a>00536                 <span class="keywordflow">case</span> FAT12:
<a name="l00537"></a>00537                         fatoffset = clustNum + (clustNum / 2);
<a name="l00538"></a>00538                         <span class="keywordflow">break</span>;
<a name="l00539"></a>00539                 <span class="keywordflow">case</span> FAT16:
<a name="l00540"></a>00540                         fatoffset = clustNum * 2;
<a name="l00541"></a>00541                         <span class="keywordflow">break</span>;
<a name="l00542"></a>00542                 <span class="keywordflow">case</span> FAT32:
<a name="l00543"></a>00543                         fatoffset = clustNum * 4;
<a name="l00544"></a>00544                         <span class="keywordflow">break</span>;
<a name="l00545"></a>00545         }
<a name="l00546"></a>00546         fatsectnum = BPB.v.BPB_RsvdSecCnt + (fatoffset / BPB.v.BPB_BytsPerSec) + partSectOff;
<a name="l00547"></a>00547         fatentoff = fatoffset % BPB.v.BPB_BytsPerSec;
<a name="l00548"></a>00548 
<a name="l00549"></a>00549     <span class="keywordflow">if</span> (BPB.is_fat32()) {
<a name="l00550"></a>00550         <span class="keywordflow">if</span> (fatsectnum &gt;= (BPB.v.BPB_RsvdSecCnt + BPB.v32.BPB_FATSz32 + partSectOff)) {
<a name="l00551"></a>00551             <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_ERROR)(<span class="stringliteral">&quot;Attempt to read cluster entry from FAT that out of range (outside the FAT table) cluster %u&quot;</span>,(<span class="keywordtype">unsigned</span> int)clustNum);
<a name="l00552"></a>00552             <span class="keywordflow">return</span> 0;
<a name="l00553"></a>00553         }
<a name="l00554"></a>00554     }
<a name="l00555"></a>00555     <span class="keywordflow">else</span> {
<a name="l00556"></a>00556         <span class="keywordflow">if</span> (fatsectnum &gt;= (BPB.v.BPB_RsvdSecCnt + BPB.v.BPB_FATSz16 + partSectOff)) {
<a name="l00557"></a>00557             <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_ERROR)(<span class="stringliteral">&quot;Attempt to read cluster entry from FAT that out of range (outside the FAT table) cluster %u&quot;</span>,(<span class="keywordtype">unsigned</span> int)clustNum);
<a name="l00558"></a>00558             <span class="keywordflow">return</span> 0;
<a name="l00559"></a>00559         }
<a name="l00560"></a>00560     }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562     assert((BPB.v.BPB_BytsPerSec * (Bitu)2) &lt;= <span class="keyword">sizeof</span>(fatSectBuffer));
<a name="l00563"></a>00563 
<a name="l00564"></a>00564         <span class="keywordflow">if</span>(curFatSect != fatsectnum) {
<a name="l00565"></a>00565                 <span class="comment">/* Load two sectors at once for FAT12 */</span>
<a name="l00566"></a>00566                 readSector(fatsectnum, &amp;fatSectBuffer[0]);
<a name="l00567"></a>00567                 <span class="keywordflow">if</span> (fattype==FAT12)
<a name="l00568"></a>00568                         readSector(fatsectnum+1, &amp;fatSectBuffer[BPB.v.BPB_BytsPerSec]);
<a name="l00569"></a>00569                 curFatSect = fatsectnum;
<a name="l00570"></a>00570         }
<a name="l00571"></a>00571 
<a name="l00572"></a>00572         <span class="keywordflow">switch</span>(fattype) {
<a name="l00573"></a>00573                 <span class="keywordflow">case</span> FAT12:
<a name="l00574"></a>00574                         clustValue = *((Bit16u *)&amp;fatSectBuffer[fatentoff]);
<a name="l00575"></a>00575                         <span class="keywordflow">if</span>(clustNum &amp; 0x1) {
<a name="l00576"></a>00576                                 clustValue &gt;&gt;= 4;
<a name="l00577"></a>00577                         } <span class="keywordflow">else</span> {
<a name="l00578"></a>00578                                 clustValue &amp;= 0xfff;
<a name="l00579"></a>00579                         }
<a name="l00580"></a>00580                         <span class="keywordflow">break</span>;
<a name="l00581"></a>00581                 <span class="keywordflow">case</span> FAT16:
<a name="l00582"></a>00582                         clustValue = *((Bit16u *)&amp;fatSectBuffer[fatentoff]);
<a name="l00583"></a>00583                         <span class="keywordflow">break</span>;
<a name="l00584"></a>00584                 <span class="keywordflow">case</span> FAT32:
<a name="l00585"></a>00585                         clustValue = *((Bit32u *)&amp;fatSectBuffer[fatentoff]) &amp; 0x0FFFFFFFul; <span class="comment">/* Well, actually it&#39;s FAT28. Upper 4 bits are &quot;reserved&quot;. */</span>
<a name="l00586"></a>00586                         <span class="keywordflow">break</span>;
<a name="l00587"></a>00587         }
<a name="l00588"></a>00588 
<a name="l00589"></a>00589         <span class="keywordflow">return</span> clustValue;
<a name="l00590"></a>00590 }
<a name="l00591"></a>00591 
<a name="l00592"></a>00592 <span class="keywordtype">void</span> fatDrive::setClusterValue(Bit32u clustNum, Bit32u clustValue) {
<a name="l00593"></a>00593         Bit32u fatoffset=0;
<a name="l00594"></a>00594         Bit32u fatsectnum;
<a name="l00595"></a>00595         Bit32u fatentoff;
<a name="l00596"></a>00596 
<a name="l00597"></a>00597         <span class="keywordflow">switch</span>(fattype) {
<a name="l00598"></a>00598                 <span class="keywordflow">case</span> FAT12:
<a name="l00599"></a>00599                         fatoffset = clustNum + (clustNum / 2);
<a name="l00600"></a>00600                         <span class="keywordflow">break</span>;
<a name="l00601"></a>00601                 <span class="keywordflow">case</span> FAT16:
<a name="l00602"></a>00602                         fatoffset = clustNum * 2;
<a name="l00603"></a>00603                         <span class="keywordflow">break</span>;
<a name="l00604"></a>00604                 <span class="keywordflow">case</span> FAT32:
<a name="l00605"></a>00605                         fatoffset = clustNum * 4;
<a name="l00606"></a>00606                         <span class="keywordflow">break</span>;
<a name="l00607"></a>00607         }
<a name="l00608"></a>00608         fatsectnum = BPB.v.BPB_RsvdSecCnt + (fatoffset / BPB.v.BPB_BytsPerSec) + partSectOff;
<a name="l00609"></a>00609         fatentoff = fatoffset % BPB.v.BPB_BytsPerSec;
<a name="l00610"></a>00610 
<a name="l00611"></a>00611     <span class="keywordflow">if</span> (BPB.is_fat32()) {
<a name="l00612"></a>00612         <span class="keywordflow">if</span> (fatsectnum &gt;= (BPB.v.BPB_RsvdSecCnt + BPB.v32.BPB_FATSz32 + partSectOff)) {
<a name="l00613"></a>00613             <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_ERROR)(<span class="stringliteral">&quot;Attempt to write cluster entry from FAT that out of range (outside the FAT table) cluster %u&quot;</span>,(<span class="keywordtype">unsigned</span> int)clustNum);
<a name="l00614"></a>00614             <span class="keywordflow">return</span>;
<a name="l00615"></a>00615         }
<a name="l00616"></a>00616     }
<a name="l00617"></a>00617     <span class="keywordflow">else</span> {
<a name="l00618"></a>00618         <span class="keywordflow">if</span> (fatsectnum &gt;= (BPB.v.BPB_RsvdSecCnt + BPB.v.BPB_FATSz16 + partSectOff)) {
<a name="l00619"></a>00619             <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_ERROR)(<span class="stringliteral">&quot;Attempt to write cluster entry from FAT that out of range (outside the FAT table) cluster %u&quot;</span>,(<span class="keywordtype">unsigned</span> int)clustNum);
<a name="l00620"></a>00620             <span class="keywordflow">return</span>;
<a name="l00621"></a>00621         }
<a name="l00622"></a>00622     }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624     assert((BPB.v.BPB_BytsPerSec * (Bitu)2) &lt;= <span class="keyword">sizeof</span>(fatSectBuffer));
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="keywordflow">if</span>(curFatSect != fatsectnum) {
<a name="l00627"></a>00627                 <span class="comment">/* Load two sectors at once for FAT12 */</span>
<a name="l00628"></a>00628                 readSector(fatsectnum, &amp;fatSectBuffer[0]);
<a name="l00629"></a>00629                 <span class="keywordflow">if</span> (fattype==FAT12)
<a name="l00630"></a>00630                         readSector(fatsectnum+1, &amp;fatSectBuffer[BPB.v.BPB_BytsPerSec]);
<a name="l00631"></a>00631                 curFatSect = fatsectnum;
<a name="l00632"></a>00632         }
<a name="l00633"></a>00633 
<a name="l00634"></a>00634         <span class="keywordflow">switch</span>(fattype) {
<a name="l00635"></a>00635                 <span class="keywordflow">case</span> FAT12: {
<a name="l00636"></a>00636                         Bit16u tmpValue = *((Bit16u *)&amp;fatSectBuffer[fatentoff]);
<a name="l00637"></a>00637                         <span class="keywordflow">if</span>(clustNum &amp; 0x1) {
<a name="l00638"></a>00638                                 clustValue &amp;= 0xfff;
<a name="l00639"></a>00639                                 clustValue &lt;&lt;= 4;
<a name="l00640"></a>00640                                 tmpValue &amp;= 0xf;
<a name="l00641"></a>00641                                 tmpValue |= (Bit16u)clustValue;
<a name="l00642"></a>00642 
<a name="l00643"></a>00643                         } <span class="keywordflow">else</span> {
<a name="l00644"></a>00644                                 clustValue &amp;= 0xfff;
<a name="l00645"></a>00645                                 tmpValue &amp;= 0xf000;
<a name="l00646"></a>00646                                 tmpValue |= (Bit16u)clustValue;
<a name="l00647"></a>00647                         }
<a name="l00648"></a>00648                         *((Bit16u *)&amp;fatSectBuffer[fatentoff]) = tmpValue;
<a name="l00649"></a>00649                         <span class="keywordflow">break</span>;
<a name="l00650"></a>00650                         }
<a name="l00651"></a>00651                 <span class="keywordflow">case</span> FAT16:
<a name="l00652"></a>00652                         *((Bit16u *)&amp;fatSectBuffer[fatentoff]) = (Bit16u)clustValue;
<a name="l00653"></a>00653                         <span class="keywordflow">break</span>;
<a name="l00654"></a>00654                 <span class="keywordflow">case</span> FAT32:
<a name="l00655"></a>00655                         *((Bit32u *)&amp;fatSectBuffer[fatentoff]) = clustValue;
<a name="l00656"></a>00656                         <span class="keywordflow">break</span>;
<a name="l00657"></a>00657         }
<a name="l00658"></a>00658         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fc=0;fc&lt;BPB.v.BPB_NumFATs;fc++) {
<a name="l00659"></a>00659                 writeSector(fatsectnum + (fc * (BPB.is_fat32() ? BPB.v32.BPB_FATSz32 : BPB.v.BPB_FATSz16)), &amp;fatSectBuffer[0]);
<a name="l00660"></a>00660                 <span class="keywordflow">if</span> (fattype==FAT12) {
<a name="l00661"></a>00661                         <span class="keywordflow">if</span> (fatentoff &gt;= (BPB.v.BPB_BytsPerSec-1U))
<a name="l00662"></a>00662                                 writeSector(fatsectnum+1u+(fc * (BPB.is_fat32() ? BPB.v32.BPB_FATSz32 : BPB.v.BPB_FATSz16)), &amp;fatSectBuffer[BPB.v.BPB_BytsPerSec]);
<a name="l00663"></a>00663                 }
<a name="l00664"></a>00664         }
<a name="l00665"></a>00665 }
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 <span class="keywordtype">bool</span> fatDrive::getEntryName(<span class="keyword">const</span> <span class="keywordtype">char</span> *fullname, <span class="keywordtype">char</span> *entname) {
<a name="l00668"></a>00668         <span class="keywordtype">char</span> dirtoken[DOS_PATHLENGTH];
<a name="l00669"></a>00669 
<a name="l00670"></a>00670         <span class="keywordtype">char</span> * findDir;
<a name="l00671"></a>00671         <span class="keywordtype">char</span> * findFile;
<a name="l00672"></a>00672         strcpy(dirtoken,fullname);
<a name="l00673"></a>00673 
<a name="l00674"></a>00674         <span class="comment">//LOG_MSG(&quot;Testing for filename %s&quot;, fullname);</span>
<a name="l00675"></a>00675         findDir = strtok(dirtoken,<span class="stringliteral">&quot;\\&quot;</span>);
<a name="l00676"></a>00676         <span class="keywordflow">if</span> (findDir==NULL) {
<a name="l00677"></a>00677                 <span class="keywordflow">return</span> <span class="keyword">true</span>;    <span class="comment">// root always exists</span>
<a name="l00678"></a>00678         }
<a name="l00679"></a>00679         findFile = findDir;
<a name="l00680"></a>00680         <span class="keywordflow">while</span>(findDir != NULL) {
<a name="l00681"></a>00681                 findFile = findDir;
<a name="l00682"></a>00682                 findDir = strtok(NULL,<span class="stringliteral">&quot;\\&quot;</span>);
<a name="l00683"></a>00683         }
<a name="l00684"></a>00684         <span class="keywordtype">int</span> j=0;
<a name="l00685"></a>00685         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;(int)strlen(findFile); i++)
<a name="l00686"></a>00686                 <span class="keywordflow">if</span> (findFile[i]!=<span class="charliteral">&#39; &#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;&quot;&#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;+&#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;=&#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;,&#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;;&#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;:&#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;&lt;&#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;&gt;&#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;[&#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;]&#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;|&#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;?&#39;</span>&amp;&amp;findFile[i]!=<span class="charliteral">&#39;*&#39;</span>) findFile[j++]=findFile[i];
<a name="l00687"></a>00687         findFile[j]=0;
<a name="l00688"></a>00688         <span class="keywordflow">if</span> (strlen(findFile)&gt;12)
<a name="l00689"></a>00689                 strncpy(entname, findFile, 12);
<a name="l00690"></a>00690         <span class="keywordflow">else</span>
<a name="l00691"></a>00691                 strcpy(entname, findFile);
<a name="l00692"></a>00692         upcase(entname);
<a name="l00693"></a>00693         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00694"></a>00694 }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696 <span class="keywordtype">void</span> fatDrive::UpdateBootVolumeLabel(<span class="keyword">const</span> <span class="keywordtype">char</span> *label) {
<a name="l00697"></a>00697     <a class="code" href="structFAT__BootSector.html">FAT_BootSector</a> bootbuffer = {};
<a name="l00698"></a>00698 
<a name="l00699"></a>00699     <span class="keywordflow">if</span> (BPB.v.BPB_BootSig == 0x28 || BPB.v.BPB_BootSig == 0x29) {
<a name="l00700"></a>00700         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
<a name="l00701"></a>00701 
<a name="l00702"></a>00702         loadedDisk-&gt;Read_AbsoluteSector(0+partSectOff,&amp;bootbuffer);
<a name="l00703"></a>00703 
<a name="l00704"></a>00704         <span class="keywordflow">while</span> (i &lt; 11 &amp;&amp; *label != 0) bootbuffer.bpb.v.BPB_VolLab[i++] = toupper(*label++);
<a name="l00705"></a>00705         <span class="keywordflow">while</span> (i &lt; 11)                bootbuffer.bpb.v.BPB_VolLab[i++] = <span class="charliteral">&#39; &#39;</span>;
<a name="l00706"></a>00706 
<a name="l00707"></a>00707         loadedDisk-&gt;Write_AbsoluteSector(0+partSectOff,&amp;bootbuffer);
<a name="l00708"></a>00708     }
<a name="l00709"></a>00709 }
<a name="l00710"></a>00710 
<a name="l00711"></a>00711 <span class="keywordtype">void</span> fatDrive::SetLabel(<span class="keyword">const</span> <span class="keywordtype">char</span> *label, <span class="keywordtype">bool</span> <span class="comment">/*iscdrom*/</span>, <span class="keywordtype">bool</span> <span class="comment">/*updatable*/</span>) {
<a name="l00712"></a>00712         <a class="code" href="structdirentry.html">direntry</a> sectbuf[MAX_DIRENTS_PER_SECTOR]; <span class="comment">/* 16 directory entries per 512 byte sector */</span>
<a name="l00713"></a>00713         Bit32u dirClustNumber;
<a name="l00714"></a>00714         Bit32u logentsector; <span class="comment">/* Logical entry sector */</span>
<a name="l00715"></a>00715         Bit32u entryoffset;  <span class="comment">/* Index offset within sector */</span>
<a name="l00716"></a>00716         Bit32u tmpsector;
<a name="l00717"></a>00717         Bit16u dirPos = 0;
<a name="l00718"></a>00718 
<a name="l00719"></a>00719         <span class="keywordtype">size_t</span> dirent_per_sector = getSectSize() / <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>);
<a name="l00720"></a>00720         assert(dirent_per_sector &lt;= MAX_DIRENTS_PER_SECTOR);
<a name="l00721"></a>00721         assert((dirent_per_sector * <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>)) &lt;= SECTOR_SIZE_MAX);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723         <span class="keywordflow">if</span>(!getDirClustNum(<span class="stringliteral">&quot;\\&quot;</span>, &amp;dirClustNumber, <span class="keyword">false</span>))
<a name="l00724"></a>00724                 <span class="keywordflow">return</span>;
<a name="l00725"></a>00725 
<a name="l00726"></a>00726 nextfile:
<a name="l00727"></a>00727         logentsector = (Bit32u)((<span class="keywordtype">size_t</span>)dirPos / dirent_per_sector);
<a name="l00728"></a>00728         entryoffset = (Bit32u)((<span class="keywordtype">size_t</span>)dirPos % dirent_per_sector);
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         <span class="keywordflow">if</span>(dirClustNumber==0) {
<a name="l00731"></a>00731                 assert(!BPB.is_fat32());
<a name="l00732"></a>00732                 <span class="keywordflow">if</span>(dirPos &gt;= BPB.v.BPB_RootEntCnt) <span class="keywordflow">return</span>;
<a name="l00733"></a>00733                 tmpsector = firstRootDirSect+logentsector;
<a name="l00734"></a>00734         } <span class="keywordflow">else</span> {
<a name="l00735"></a>00735                 <span class="comment">/* A zero sector number can&#39;t happen */</span>
<a name="l00736"></a>00736                 tmpsector = getAbsoluteSectFromChain(dirClustNumber, logentsector);
<a name="l00737"></a>00737                 <span class="comment">/* A zero sector number can&#39;t happen - we need to allocate more room for this directory*/</span>
<a name="l00738"></a>00738                 <span class="keywordflow">if</span>(tmpsector == 0) {
<a name="l00739"></a>00739                         <span class="keywordflow">if</span> (*label == 0) <span class="keywordflow">return</span>; <span class="comment">// removing volume label, so stop now</span>
<a name="l00740"></a>00740                         Bit32u newClust;
<a name="l00741"></a>00741                         newClust = appendCluster(dirClustNumber);
<a name="l00742"></a>00742                         <span class="keywordflow">if</span>(newClust == 0) <span class="keywordflow">return</span>;
<a name="l00743"></a>00743                         zeroOutCluster(newClust);
<a name="l00744"></a>00744                         <span class="comment">/* Try again to get tmpsector */</span>
<a name="l00745"></a>00745                         tmpsector = getAbsoluteSectFromChain(dirClustNumber, logentsector);
<a name="l00746"></a>00746                         <span class="keywordflow">if</span>(tmpsector == 0) <span class="keywordflow">return</span>; <span class="comment">/* Give up if still can&#39;t get more room for directory */</span>
<a name="l00747"></a>00747                 }
<a name="l00748"></a>00748                 readSector(tmpsector,sectbuf);
<a name="l00749"></a>00749         }
<a name="l00750"></a>00750         readSector(tmpsector,sectbuf);
<a name="l00751"></a>00751         dirPos++;
<a name="l00752"></a>00752 
<a name="l00753"></a>00753         <span class="keywordflow">if</span> (dos.version.major &gt;= 7 || uselfn) {
<a name="l00754"></a>00754                 <span class="comment">/* skip LFN entries */</span>
<a name="l00755"></a>00755                 <span class="keywordflow">if</span> ((sectbuf[entryoffset].attrib &amp; 0x3F) == 0x0F)
<a name="l00756"></a>00756                         <span class="keywordflow">goto</span> nextfile;
<a name="l00757"></a>00757         }
<a name="l00758"></a>00758 
<a name="l00759"></a>00759         <span class="keywordflow">if</span> (*label != 0) {
<a name="l00760"></a>00760                 <span class="comment">/* adding a volume label */</span>
<a name="l00761"></a>00761                 <span class="keywordflow">if</span> (sectbuf[entryoffset].entryname[0] == 0x00 ||
<a name="l00762"></a>00762                         sectbuf[entryoffset].entryname[0] == 0xE5) {
<a name="l00763"></a>00763                         memset(&amp;sectbuf[entryoffset],0,<span class="keyword">sizeof</span>(sectbuf[entryoffset]));
<a name="l00764"></a>00764                         sectbuf[entryoffset].attrib = DOS_ATTR_VOLUME;
<a name="l00765"></a>00765                         {
<a name="l00766"></a>00766                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0;
<a name="l00767"></a>00767                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *s = label;
<a name="l00768"></a>00768                                 <span class="keywordflow">while</span> (j &lt; 11 &amp;&amp; *s != 0) sectbuf[entryoffset].entryname[j++] = toupper(*s++);
<a name="l00769"></a>00769                                 <span class="keywordflow">while</span> (j &lt; 11)            sectbuf[entryoffset].entryname[j++] = <span class="charliteral">&#39; &#39;</span>;
<a name="l00770"></a>00770                         }
<a name="l00771"></a>00771                         writeSector(tmpsector,sectbuf);
<a name="l00772"></a>00772                         labelCache.SetLabel(label, <span class="keyword">false</span>, <span class="keyword">true</span>);
<a name="l00773"></a>00773                         UpdateBootVolumeLabel(label);
<a name="l00774"></a>00774                         <span class="keywordflow">return</span>;
<a name="l00775"></a>00775                 }
<a name="l00776"></a>00776         }
<a name="l00777"></a>00777         <span class="keywordflow">else</span> {
<a name="l00778"></a>00778                 <span class="keywordflow">if</span> (sectbuf[entryoffset].entryname[0] == 0x00)
<a name="l00779"></a>00779                         <span class="keywordflow">return</span>;
<a name="l00780"></a>00780                 <span class="keywordflow">if</span> (sectbuf[entryoffset].entryname[0] == 0xe5)
<a name="l00781"></a>00781                         <span class="keywordflow">goto</span> nextfile;
<a name="l00782"></a>00782 
<a name="l00783"></a>00783                 <span class="keywordflow">if</span> (sectbuf[entryoffset].attrib &amp; DOS_ATTR_VOLUME) {
<a name="l00784"></a>00784                         <span class="comment">/* TODO: There needs to be a way for FCB delete to erase the volume label by name instead</span>
<a name="l00785"></a>00785 <span class="comment">                         *       of just picking the first one */</span>
<a name="l00786"></a>00786                         <span class="comment">/* found one */</span>
<a name="l00787"></a>00787                         sectbuf[entryoffset].entryname[0] = 0xe5;
<a name="l00788"></a>00788                         writeSector(tmpsector,sectbuf);
<a name="l00789"></a>00789                         labelCache.SetLabel(<span class="stringliteral">&quot;&quot;</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);
<a name="l00790"></a>00790                         UpdateBootVolumeLabel(<span class="stringliteral">&quot;NO NAME&quot;</span>);
<a name="l00791"></a>00791                         <span class="keywordflow">return</span>;
<a name="l00792"></a>00792                 }
<a name="l00793"></a>00793         }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795         <span class="keywordflow">goto</span> nextfile;
<a name="l00796"></a>00796 }
<a name="l00797"></a>00797 
<a name="l00798"></a>00798 <span class="comment">/* NTS: This function normally will only return files. Every element of the path that is a directory is entered into.</span>
<a name="l00799"></a>00799 <span class="comment"> *      If every element is a directory, then this code will fail to locate anything.</span>
<a name="l00800"></a>00800 <span class="comment"> *</span>
<a name="l00801"></a>00801 <span class="comment"> *      If dirOk is set, and all path elements are directories, it will stop at the last one and look it up as if a file.</span>
<a name="l00802"></a>00802 <span class="comment"> *      The purpose is to clean up this FAT driver by eliminating all the ridiculous &quot;look up getFileDirEntry but if it fails</span>
<a name="l00803"></a>00803 <span class="comment"> *      do a whole different code path that looks it up as if directory&quot; copy-pasta in this code that complicates some functions</span>
<a name="l00804"></a>00804 <span class="comment"> *      like the Rename() method.</span>
<a name="l00805"></a>00805 <span class="comment"> *</span>
<a name="l00806"></a>00806 <span class="comment"> *      useEntry is filled with the SFN direntry of the first search result. dirClust is filled in with the starting cluster of</span>
<a name="l00807"></a>00807 <span class="comment"> *      the parent directory. Note that even if dirOk is set and the result is a directory, dirClust is the parent directory of</span>
<a name="l00808"></a>00808 <span class="comment"> *      that directory. subEntry is the dirent index into the directory.</span>
<a name="l00809"></a>00809 <span class="comment"> *</span>
<a name="l00810"></a>00810 <span class="comment"> *      As a side effect of using FindNextInternal, variable lfnRange will be either cleared or filled in with the subEntry range</span>
<a name="l00811"></a>00811 <span class="comment"> *      of dirents that contain the LFN entries (needed for deletion, renaming, rmdir, etc). Not all paths set or clear it, so</span>
<a name="l00812"></a>00812 <span class="comment"> *      first call the clear() method before calling. After the call, copy off the value because the next call to FindNextInternal</span>
<a name="l00813"></a>00813 <span class="comment"> *      by any part of this code will obliterate the result with a new result. */</span>
<a name="l00814"></a>00814 <span class="keywordtype">bool</span> fatDrive::getFileDirEntry(<span class="keywordtype">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> filename, <a class="code" href="structdirentry.html">direntry</a> * useEntry, Bit32u * dirClust, Bit32u * subEntry,<span class="keywordtype">bool</span> dirOk) {
<a name="l00815"></a>00815         <span class="keywordtype">size_t</span> len = strlen(filename);
<a name="l00816"></a>00816         <span class="keywordtype">char</span> dirtoken[DOS_PATHLENGTH];
<a name="l00817"></a>00817         Bit32u currentClust = 0; <span class="comment">/* FAT12/FAT16 root directory */</span>
<a name="l00818"></a>00818 
<a name="l00819"></a>00819         <a class="code" href="structdirentry.html">direntry</a> foundEntry;
<a name="l00820"></a>00820         <span class="keywordtype">char</span> * findDir;
<a name="l00821"></a>00821         <span class="keywordtype">char</span> * findFile;
<a name="l00822"></a>00822         strcpy(dirtoken,filename);
<a name="l00823"></a>00823         findFile=dirtoken;
<a name="l00824"></a>00824 
<a name="l00825"></a>00825         <span class="keywordflow">if</span> (BPB.is_fat32()) {
<a name="l00826"></a>00826                 <span class="comment">/* Set to FAT32 root directory */</span>
<a name="l00827"></a>00827                 currentClust = BPB.v32.BPB_RootClus;
<a name="l00828"></a>00828         }
<a name="l00829"></a>00829 
<a name="l00830"></a>00830         <span class="keywordtype">int</span> fbak=lfn_filefind_handle;
<a name="l00831"></a>00831         lfn_filefind_handle=uselfn?LFN_FILEFIND_IMG:LFN_FILEFIND_NONE;
<a name="l00832"></a>00832         <span class="comment">/* Skip if testing in root directory */</span>
<a name="l00833"></a>00833         <span class="keywordflow">if</span> ((len&gt;0) &amp;&amp; (filename[len-1]!=<span class="charliteral">&#39;\\&#39;</span>)) {
<a name="l00834"></a>00834                 <span class="comment">//LOG_MSG(&quot;Testing for filename %s&quot;, filename);</span>
<a name="l00835"></a>00835                 findDir = strtok(dirtoken,<span class="stringliteral">&quot;\\&quot;</span>);
<a name="l00836"></a>00836                 findFile = findDir;
<a name="l00837"></a>00837                 <span class="keywordflow">while</span>(findDir != NULL) {
<a name="l00838"></a>00838                         imgDTA-&gt;SetupSearch(0,DOS_ATTR_DIRECTORY,findDir);
<a name="l00839"></a>00839                         imgDTA-&gt;SetDirID(0);
<a name="l00840"></a>00840                         
<a name="l00841"></a>00841                         findFile = findDir;
<a name="l00842"></a>00842                         <span class="keywordflow">if</span>(!FindNextInternal(currentClust, *imgDTA, &amp;foundEntry)) <span class="keywordflow">break</span>;
<a name="l00843"></a>00843                         <span class="keywordflow">else</span> {
<a name="l00844"></a>00844                                 <span class="comment">//Found something. See if it&#39;s a directory (findfirst always finds regular files)</span>
<a name="l00845"></a>00845                 <span class="keywordtype">char</span> find_name[DOS_NAMELENGTH_ASCII],lfind_name[LFN_NAMELENGTH];
<a name="l00846"></a>00846                 Bit16u find_date,find_time;Bit32u find_size;Bit8u find_attr;
<a name="l00847"></a>00847                 imgDTA-&gt;GetResult(find_name,lfind_name,find_size,find_date,find_time,find_attr);
<a name="l00848"></a>00848                                 <span class="keywordflow">if</span>(!(find_attr &amp; DOS_ATTR_DIRECTORY)) <span class="keywordflow">break</span>;
<a name="l00849"></a>00849 
<a name="l00850"></a>00850                                 <span class="keywordtype">char</span> * findNext;
<a name="l00851"></a>00851                                 findNext = strtok(NULL,<span class="stringliteral">&quot;\\&quot;</span>);
<a name="l00852"></a>00852                                 <span class="keywordflow">if</span> (findNext == NULL &amp;&amp; dirOk) <span class="keywordflow">break</span>; <span class="comment">/* dirOk means that if the last element is a directory, then refer to the directory itself */</span>
<a name="l00853"></a>00853                                 findDir = findNext;
<a name="l00854"></a>00854                         }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856                         <span class="keywordflow">if</span> (BPB.is_fat32())
<a name="l00857"></a>00857                                 currentClust = foundEntry.Cluster32();
<a name="l00858"></a>00858                         <span class="keywordflow">else</span>
<a name="l00859"></a>00859                                 currentClust = foundEntry.loFirstClust;
<a name="l00860"></a>00860                 }
<a name="l00861"></a>00861         } <span class="keywordflow">else</span> {
<a name="l00862"></a>00862                 <span class="comment">/* Set to root directory */</span>
<a name="l00863"></a>00863         }
<a name="l00864"></a>00864 
<a name="l00865"></a>00865         <span class="comment">/* Search found directory for our file */</span>
<a name="l00866"></a>00866         imgDTA-&gt;SetupSearch(0,0x7 | (dirOk ? DOS_ATTR_DIRECTORY : 0),findFile);
<a name="l00867"></a>00867         imgDTA-&gt;SetDirID(0);
<a name="l00868"></a>00868         <span class="keywordflow">if</span>(!FindNextInternal(currentClust, *imgDTA, &amp;foundEntry)) {lfn_filefind_handle=fbak;<span class="keywordflow">return</span> <span class="keyword">false</span>;}
<a name="l00869"></a>00869         lfn_filefind_handle=fbak;
<a name="l00870"></a>00870 
<a name="l00871"></a>00871         memcpy(useEntry, &amp;foundEntry, <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>));
<a name="l00872"></a>00872         *dirClust = (Bit32u)currentClust;
<a name="l00873"></a>00873         *subEntry = ((Bit32u)imgDTA-&gt;GetDirID()-1);
<a name="l00874"></a>00874         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00875"></a>00875 }
<a name="l00876"></a>00876 
<a name="l00877"></a>00877 <span class="keywordtype">bool</span> fatDrive::getDirClustNum(<span class="keyword">const</span> <span class="keywordtype">char</span> *dir, Bit32u *clustNum, <span class="keywordtype">bool</span> parDir) {
<a name="l00878"></a>00878         Bit32u len = (Bit32u)strlen(dir);
<a name="l00879"></a>00879         <span class="keywordtype">char</span> dirtoken[DOS_PATHLENGTH];
<a name="l00880"></a>00880         <a class="code" href="structdirentry.html">direntry</a> foundEntry;
<a name="l00881"></a>00881         strcpy(dirtoken,dir);
<a name="l00882"></a>00882 
<a name="l00883"></a>00883         <span class="keywordtype">int</span> fbak=lfn_filefind_handle;
<a name="l00884"></a>00884         <span class="comment">/* Skip if testing for root directory */</span>
<a name="l00885"></a>00885         <span class="keywordflow">if</span> ((len&gt;0) &amp;&amp; (dir[len-1]!=<span class="charliteral">&#39;\\&#39;</span>)) {
<a name="l00886"></a>00886                 Bit32u currentClust = 0;
<a name="l00887"></a>00887 
<a name="l00888"></a>00888         <span class="keywordflow">if</span> (BPB.is_fat32()) {
<a name="l00889"></a>00889             <span class="comment">/* Set to FAT32 root directory */</span>
<a name="l00890"></a>00890             currentClust = BPB.v32.BPB_RootClus;
<a name="l00891"></a>00891         }
<a name="l00892"></a>00892 
<a name="l00893"></a>00893                 <span class="comment">//LOG_MSG(&quot;Testing for dir %s&quot;, dir);</span>
<a name="l00894"></a>00894                 <span class="keywordtype">char</span> * findDir = strtok(dirtoken,<span class="stringliteral">&quot;\\&quot;</span>);
<a name="l00895"></a>00895                 <span class="keywordflow">while</span>(findDir != NULL) {
<a name="l00896"></a>00896                         lfn_filefind_handle=uselfn?LFN_FILEFIND_IMG:LFN_FILEFIND_NONE;
<a name="l00897"></a>00897                         imgDTA-&gt;SetupSearch(0,DOS_ATTR_DIRECTORY,findDir);
<a name="l00898"></a>00898                         imgDTA-&gt;SetDirID(0);
<a name="l00899"></a>00899                         findDir = strtok(NULL,<span class="stringliteral">&quot;\\&quot;</span>);
<a name="l00900"></a>00900                         <span class="keywordflow">if</span>(parDir &amp;&amp; (findDir == NULL)) {lfn_filefind_handle=fbak;<span class="keywordflow">break</span>;}
<a name="l00901"></a>00901 
<a name="l00902"></a>00902                         <span class="keywordflow">if</span>(!FindNextInternal(currentClust, *imgDTA, &amp;foundEntry)) {
<a name="l00903"></a>00903                                 lfn_filefind_handle=fbak;
<a name="l00904"></a>00904                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00905"></a>00905                         } <span class="keywordflow">else</span> {
<a name="l00906"></a>00906                 <span class="keywordtype">char</span> find_name[DOS_NAMELENGTH_ASCII],lfind_name[LFN_NAMELENGTH];
<a name="l00907"></a>00907                 Bit16u find_date,find_time;Bit32u find_size;Bit8u find_attr;
<a name="l00908"></a>00908                                 imgDTA-&gt;GetResult(find_name,lfind_name,find_size,find_date,find_time,find_attr);
<a name="l00909"></a>00909                                 lfn_filefind_handle=fbak;
<a name="l00910"></a>00910                                 <span class="keywordflow">if</span>(!(find_attr &amp;DOS_ATTR_DIRECTORY)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00911"></a>00911                         }
<a name="l00912"></a>00912                         <span class="keywordflow">if</span> (BPB.is_fat32())
<a name="l00913"></a>00913                                 currentClust = foundEntry.Cluster32();
<a name="l00914"></a>00914                         <span class="keywordflow">else</span>
<a name="l00915"></a>00915                                 currentClust = foundEntry.loFirstClust;
<a name="l00916"></a>00916                 }
<a name="l00917"></a>00917                 *clustNum = currentClust;
<a name="l00918"></a>00918         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BPB.is_fat32()) {
<a name="l00919"></a>00919                 <span class="comment">/* Set to FAT32 root directory */</span>
<a name="l00920"></a>00920                 *clustNum = BPB.v32.BPB_RootClus;
<a name="l00921"></a>00921         } <span class="keywordflow">else</span> {
<a name="l00922"></a>00922                 <span class="comment">/* Set to root directory */</span>
<a name="l00923"></a>00923                 *clustNum = 0;
<a name="l00924"></a>00924         }
<a name="l00925"></a>00925         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00926"></a>00926 }
<a name="l00927"></a>00927 
<a name="l00928"></a>00928 Bit8u fatDrive::readSector(Bit32u sectnum, <span class="keywordtype">void</span> * data) {
<a name="l00929"></a>00929         <span class="keywordflow">if</span> (absolute) <span class="keywordflow">return</span> Read_AbsoluteSector(sectnum, data);
<a name="l00930"></a>00930     assert(!IS_PC98_ARCH);
<a name="l00931"></a>00931         Bit32u cylindersize = (<span class="keywordtype">unsigned</span> int)BPB.v.BPB_NumHeads * (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)BPB.v.BPB_SecPerTrk;
<a name="l00932"></a>00932         Bit32u cylinder = sectnum / cylindersize;
<a name="l00933"></a>00933         sectnum %= cylindersize;
<a name="l00934"></a>00934         Bit32u head = sectnum / BPB.v.BPB_SecPerTrk;
<a name="l00935"></a>00935         Bit32u sector = sectnum % BPB.v.BPB_SecPerTrk + 1L;
<a name="l00936"></a>00936         <span class="keywordflow">return</span> loadedDisk-&gt;Read_Sector(head, cylinder, sector, data);
<a name="l00937"></a>00937 }       
<a name="l00938"></a>00938 
<a name="l00939"></a>00939 Bit8u fatDrive::writeSector(Bit32u sectnum, <span class="keywordtype">void</span> * data) {
<a name="l00940"></a>00940         <span class="keywordflow">if</span> (absolute) <span class="keywordflow">return</span> Write_AbsoluteSector(sectnum, data);
<a name="l00941"></a>00941     assert(!IS_PC98_ARCH);
<a name="l00942"></a>00942         Bit32u cylindersize = (<span class="keywordtype">unsigned</span> int)BPB.v.BPB_NumHeads * (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)BPB.v.BPB_SecPerTrk;
<a name="l00943"></a>00943         Bit32u cylinder = sectnum / cylindersize;
<a name="l00944"></a>00944         sectnum %= cylindersize;
<a name="l00945"></a>00945         Bit32u head = sectnum / BPB.v.BPB_SecPerTrk;
<a name="l00946"></a>00946         Bit32u sector = sectnum % BPB.v.BPB_SecPerTrk + 1L;
<a name="l00947"></a>00947         <span class="keywordflow">return</span> loadedDisk-&gt;Write_Sector(head, cylinder, sector, data);
<a name="l00948"></a>00948 }
<a name="l00949"></a>00949 
<a name="l00950"></a>00950 Bit32u fatDrive::getSectorSize(<span class="keywordtype">void</span>) {
<a name="l00951"></a>00951         <span class="keywordflow">return</span> BPB.v.BPB_BytsPerSec;
<a name="l00952"></a>00952 }
<a name="l00953"></a>00953 
<a name="l00954"></a>00954 Bit32u fatDrive::getClusterSize(<span class="keywordtype">void</span>) {
<a name="l00955"></a>00955         <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)BPB.v.BPB_SecPerClus * (<span class="keywordtype">unsigned</span> int)BPB.v.BPB_BytsPerSec;
<a name="l00956"></a>00956 }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 Bit32u fatDrive::getAbsoluteSectFromBytePos(Bit32u startClustNum, Bit32u bytePos) {
<a name="l00959"></a>00959         <span class="keywordflow">return</span>  getAbsoluteSectFromChain(startClustNum, bytePos / BPB.v.BPB_BytsPerSec);
<a name="l00960"></a>00960 }
<a name="l00961"></a>00961 
<a name="l00962"></a>00962 Bit32u fatDrive::getAbsoluteSectFromChain(Bit32u startClustNum, Bit32u logicalSector) {
<a name="l00963"></a>00963         Bit32s skipClust = (Bit32s)(logicalSector / BPB.v.BPB_SecPerClus);
<a name="l00964"></a>00964         Bit32u sectClust = (Bit32u)(logicalSector % BPB.v.BPB_SecPerClus);
<a name="l00965"></a>00965 
<a name="l00966"></a>00966         <span class="comment">/* startClustNum == 0 means the file is (likely) zero length and has no allocation chain yet.</span>
<a name="l00967"></a>00967 <span class="comment">         * Nothing to map. Without this check, this code would permit the FAT file reader/writer to</span>
<a name="l00968"></a>00968 <span class="comment">         * treat the ROOT DIRECTORY as a file (with disasterous results)</span>
<a name="l00969"></a>00969 <span class="comment">         *</span>
<a name="l00970"></a>00970 <span class="comment">         * [https://github.com/joncampbell123/dosbox-x/issues/1517] */</span>
<a name="l00971"></a>00971         <span class="keywordflow">if</span> (startClustNum == 0) <span class="keywordflow">return</span> 0;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973         Bit32u currentClust = startClustNum;
<a name="l00974"></a>00974 
<a name="l00975"></a>00975         <span class="keywordflow">while</span>(skipClust!=0) {
<a name="l00976"></a>00976                 <span class="keywordtype">bool</span> isEOF = <span class="keyword">false</span>;
<a name="l00977"></a>00977                 Bit32u testvalue = getClusterValue(currentClust);
<a name="l00978"></a>00978                 <span class="keywordflow">if</span>(testvalue == 0) {
<a name="l00979"></a>00979                         <span class="comment">/* What the crap?  Cluster is already empty - BAIL! */</span>
<a name="l00980"></a>00980                         <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_ERROR)(<span class="stringliteral">&quot;End of cluster chain and cluster value at the end is zero.&quot;</span>);
<a name="l00981"></a>00981                         <span class="keywordflow">return</span> 0;
<a name="l00982"></a>00982                 }
<a name="l00983"></a>00983                 <span class="keywordflow">switch</span>(fattype) {
<a name="l00984"></a>00984                         <span class="keywordflow">case</span> FAT12:
<a name="l00985"></a>00985                                 <span class="keywordflow">if</span>(testvalue &gt;= 0xff8) isEOF = <span class="keyword">true</span>;
<a name="l00986"></a>00986                                 <span class="keywordflow">break</span>;
<a name="l00987"></a>00987                         <span class="keywordflow">case</span> FAT16:
<a name="l00988"></a>00988                                 <span class="keywordflow">if</span>(testvalue &gt;= 0xfff8) isEOF = <span class="keyword">true</span>;
<a name="l00989"></a>00989                                 <span class="keywordflow">break</span>;
<a name="l00990"></a>00990                         <span class="keywordflow">case</span> FAT32:
<a name="l00991"></a>00991                                 <span class="keywordflow">if</span>(testvalue &gt;= 0x0ffffff8) isEOF = <span class="keyword">true</span>; <span class="comment">/* FAT32 is really FAT28 with 4 reserved bits */</span>
<a name="l00992"></a>00992                                 <span class="keywordflow">break</span>;
<a name="l00993"></a>00993                 }
<a name="l00994"></a>00994                 <span class="keywordflow">if</span>((isEOF) &amp;&amp; (skipClust&gt;=1)) {
<a name="l00995"></a>00995                         <span class="comment">//LOG_MSG(&quot;End of cluster chain reached before end of logical sector seek!&quot;);</span>
<a name="l00996"></a>00996                         <span class="keywordflow">if</span> (skipClust == 1 &amp;&amp; fattype == FAT12) {
<a name="l00997"></a>00997                                 <span class="comment">//break;</span>
<a name="l00998"></a>00998                                 <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_ERROR)(<span class="stringliteral">&quot;End of cluster chain reached, but maybe good afterall ?&quot;</span>);
<a name="l00999"></a>00999                         }
<a name="l01000"></a>01000                         <span class="keywordflow">return</span> 0;
<a name="l01001"></a>01001                 }
<a name="l01002"></a>01002                 currentClust = testvalue;
<a name="l01003"></a>01003                 --skipClust;
<a name="l01004"></a>01004         }
<a name="l01005"></a>01005 
<a name="l01006"></a>01006         <span class="comment">/* this should not happen! */</span>
<a name="l01007"></a>01007         assert(currentClust != 0);
<a name="l01008"></a>01008 
<a name="l01009"></a>01009         <span class="keywordflow">return</span> (getClustFirstSect(currentClust) + sectClust);
<a name="l01010"></a>01010 }
<a name="l01011"></a>01011 
<a name="l01012"></a>01012 <span class="keywordtype">void</span> fatDrive::deleteClustChain(Bit32u startCluster, Bit32u bytePos) {
<a name="l01013"></a>01013         <span class="keywordflow">if</span> (startCluster &lt; 2) <span class="keywordflow">return</span>; <span class="comment">/* do not corrupt the FAT media ID. The file has no chain. Do nothing. */</span>
<a name="l01014"></a>01014 
<a name="l01015"></a>01015         Bit32u clustSize = getClusterSize();
<a name="l01016"></a>01016         Bit32u endClust = (bytePos + clustSize - 1) / clustSize;
<a name="l01017"></a>01017         Bit32u countClust = 1;
<a name="l01018"></a>01018 
<a name="l01019"></a>01019         Bit32u currentClust = startCluster;
<a name="l01020"></a>01020         Bit32u eofClust = 0;
<a name="l01021"></a>01021 
<a name="l01022"></a>01022         <span class="keywordflow">switch</span>(fattype) {
<a name="l01023"></a>01023                 <span class="keywordflow">case</span> FAT12:
<a name="l01024"></a>01024                         eofClust = 0xff8;
<a name="l01025"></a>01025                         <span class="keywordflow">break</span>;
<a name="l01026"></a>01026                 <span class="keywordflow">case</span> FAT16:
<a name="l01027"></a>01027                         eofClust = 0xfff8;
<a name="l01028"></a>01028                         <span class="keywordflow">break</span>;
<a name="l01029"></a>01029                 <span class="keywordflow">case</span> FAT32:
<a name="l01030"></a>01030                         eofClust = 0x0ffffff8;
<a name="l01031"></a>01031                         <span class="keywordflow">break</span>;
<a name="l01032"></a>01032                 <span class="keywordflow">default</span>:
<a name="l01033"></a>01033                         abort();
<a name="l01034"></a>01034                         <span class="keywordflow">break</span>;
<a name="l01035"></a>01035         }
<a name="l01036"></a>01036 
<a name="l01037"></a>01037         <span class="comment">/* chain preservation */</span>
<a name="l01038"></a>01038         <span class="keywordflow">while</span> (countClust &lt; endClust) {
<a name="l01039"></a>01039                 Bit32u testvalue = getClusterValue(currentClust);
<a name="l01040"></a>01040                 <span class="keywordflow">if</span> (testvalue == 0) {
<a name="l01041"></a>01041                         <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_WARN)(<span class="stringliteral">&quot;deleteClusterChain startCluster=%u countClust=%u endClust=%u currentClust=%u testvalue=%u eof=%u unexpected zero cluster value in FAT table&quot;</span>,
<a name="l01042"></a>01042                                         (<span class="keywordtype">unsigned</span> int)startCluster,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)countClust,(<span class="keywordtype">unsigned</span> int)endClust,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)currentClust,(<span class="keywordtype">unsigned</span> int)testvalue,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)eofClust);
<a name="l01043"></a>01043                         <span class="keywordflow">return</span>;
<a name="l01044"></a>01044                 }
<a name="l01045"></a>01045                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (testvalue &gt;= eofClust)
<a name="l01046"></a>01046                         <span class="keywordflow">return</span>; <span class="comment">/* Allocation chain is already shorter than intended */</span>
<a name="l01047"></a>01047 
<a name="l01048"></a>01048                 currentClust = testvalue;
<a name="l01049"></a>01049                 countClust++;
<a name="l01050"></a>01050         }
<a name="l01051"></a>01051 
<a name="l01052"></a>01052         <span class="comment">/* cut the chain here, write EOF.</span>
<a name="l01053"></a>01053 <span class="comment">         * This condition will NOT occur if bytePos == 0 (i.e. complete file truncation)</span>
<a name="l01054"></a>01054 <span class="comment">         * because countClust == 1 and endClust == 0 */</span>
<a name="l01055"></a>01055         <span class="keywordflow">if</span> (countClust == endClust) {
<a name="l01056"></a>01056                 Bit32u testvalue = getClusterValue(currentClust);
<a name="l01057"></a>01057                 <span class="keywordflow">if</span> (testvalue == 0) {
<a name="l01058"></a>01058                         <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_WARN)(<span class="stringliteral">&quot;deleteClusterChain startCluster=%u countClust=%u endClust=%u currentClust=%u testvalue=%u eof=%u unexpected zero cluster value in FAT table&quot;</span>,
<a name="l01059"></a>01059                                         (<span class="keywordtype">unsigned</span> int)startCluster,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)countClust,(<span class="keywordtype">unsigned</span> int)endClust,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)currentClust,(<span class="keywordtype">unsigned</span> int)testvalue,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)eofClust);
<a name="l01060"></a>01060                         <span class="keywordflow">return</span>;
<a name="l01061"></a>01061                 }
<a name="l01062"></a>01062                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (testvalue &gt;= eofClust)
<a name="l01063"></a>01063                         <span class="keywordflow">return</span>; <span class="comment">/* No need to write EOF because EOF is already there */</span>
<a name="l01064"></a>01064 
<a name="l01065"></a>01065                 setClusterValue(currentClust,eofClust);
<a name="l01066"></a>01066                 currentClust = testvalue;
<a name="l01067"></a>01067                 countClust++;
<a name="l01068"></a>01068         }
<a name="l01069"></a>01069 
<a name="l01070"></a>01070         <span class="comment">/* then run the rest of the chain and zero it out */</span>
<a name="l01071"></a>01071         <span class="keywordflow">while</span> (1) {
<a name="l01072"></a>01072                 Bit32u testvalue = getClusterValue(currentClust);
<a name="l01073"></a>01073                 <span class="keywordflow">if</span> (testvalue == 0) {
<a name="l01074"></a>01074                         <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_WARN)(<span class="stringliteral">&quot;deleteClusterChain startCluster=%u countClust=%u endClust=%u currentClust=%u testvalue=%u eof=%u unexpected zero cluster value in FAT table&quot;</span>,
<a name="l01075"></a>01075                                         (<span class="keywordtype">unsigned</span> int)startCluster,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)countClust,(<span class="keywordtype">unsigned</span> int)endClust,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)currentClust,(<span class="keywordtype">unsigned</span> int)testvalue,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)eofClust);
<a name="l01076"></a>01076                         <span class="keywordflow">return</span>;
<a name="l01077"></a>01077                 }
<a name="l01078"></a>01078 
<a name="l01079"></a>01079                 setClusterValue(currentClust,0);
<a name="l01080"></a>01080                 currentClust = testvalue;
<a name="l01081"></a>01081                 countClust++;
<a name="l01082"></a>01082 
<a name="l01083"></a>01083                 <span class="comment">/* this follows setClusterValue() to make sure the end of the chain is zeroed too */</span>
<a name="l01084"></a>01084                 <span class="keywordflow">if</span> (testvalue &gt;= eofClust)
<a name="l01085"></a>01085                         <span class="keywordflow">return</span>;
<a name="l01086"></a>01086         }
<a name="l01087"></a>01087 }
<a name="l01088"></a>01088 
<a name="l01089"></a>01089 Bit32u fatDrive::appendCluster(Bit32u startCluster) {
<a name="l01090"></a>01090         <span class="keywordflow">if</span> (startCluster &lt; 2) <span class="keywordflow">return</span> 0; <span class="comment">/* do not corrupt the FAT media ID. The file has no chain. Do nothing. */</span>
<a name="l01091"></a>01091 
<a name="l01092"></a>01092         Bit32u currentClust = startCluster;
<a name="l01093"></a>01093         Bit32u eofClust = 0;
<a name="l01094"></a>01094 
<a name="l01095"></a>01095         <span class="keywordflow">switch</span>(fattype) {
<a name="l01096"></a>01096                 <span class="keywordflow">case</span> FAT12:
<a name="l01097"></a>01097                         eofClust = 0xff8;
<a name="l01098"></a>01098                         <span class="keywordflow">break</span>;
<a name="l01099"></a>01099                 <span class="keywordflow">case</span> FAT16:
<a name="l01100"></a>01100                         eofClust = 0xfff8;
<a name="l01101"></a>01101                         <span class="keywordflow">break</span>;
<a name="l01102"></a>01102                 <span class="keywordflow">case</span> FAT32:
<a name="l01103"></a>01103                         eofClust = 0x0ffffff8;
<a name="l01104"></a>01104                         <span class="keywordflow">break</span>;
<a name="l01105"></a>01105                 <span class="keywordflow">default</span>:
<a name="l01106"></a>01106                         abort();
<a name="l01107"></a>01107                         <span class="keywordflow">break</span>;
<a name="l01108"></a>01108         }
<a name="l01109"></a>01109 
<a name="l01110"></a>01110         <span class="keywordflow">while</span> (1) {
<a name="l01111"></a>01111                 Bit32u testvalue = getClusterValue(currentClust);
<a name="l01112"></a>01112                 <span class="keywordflow">if</span> (testvalue == 0) {
<a name="l01113"></a>01113                         <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_WARN)(<span class="stringliteral">&quot;appendCluster currentClust=%u testvalue=%u eof=%u unexpected zero cluster value in FAT table&quot;</span>,
<a name="l01114"></a>01114                                         (<span class="keywordtype">unsigned</span> int)currentClust,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)testvalue,(<span class="keywordtype">unsigned</span> int)eofClust);
<a name="l01115"></a>01115                         <span class="keywordflow">return</span> 0;
<a name="l01116"></a>01116                 }
<a name="l01117"></a>01117                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (testvalue &gt;= eofClust) {
<a name="l01118"></a>01118                         <span class="keywordflow">break</span>; <span class="comment">/* found it! */</span>
<a name="l01119"></a>01119                 }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121                 currentClust = testvalue;
<a name="l01122"></a>01122         }
<a name="l01123"></a>01123 
<a name="l01124"></a>01124         Bit32u newClust = getFirstFreeClust();
<a name="l01125"></a>01125         <span class="keywordflow">if</span>(newClust == 0) <span class="keywordflow">return</span> 0; <span class="comment">/* Drive is full */</span>
<a name="l01126"></a>01126 
<a name="l01127"></a>01127         <span class="keywordflow">if</span>(!allocateCluster(newClust, currentClust)) <span class="keywordflow">return</span> 0;
<a name="l01128"></a>01128 
<a name="l01129"></a>01129         zeroOutCluster(newClust);
<a name="l01130"></a>01130 
<a name="l01131"></a>01131         <span class="keywordflow">return</span> newClust;
<a name="l01132"></a>01132 }
<a name="l01133"></a>01133 
<a name="l01134"></a>01134 <span class="keywordtype">bool</span> fatDrive::allocateCluster(Bit32u useCluster, Bit32u prevCluster) {
<a name="l01135"></a>01135 
<a name="l01136"></a>01136         <span class="comment">/* Can&#39;t allocate cluster #0 */</span>
<a name="l01137"></a>01137         <span class="keywordflow">if</span>(useCluster == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01138"></a>01138 
<a name="l01139"></a>01139         <span class="keywordflow">if</span>(prevCluster != 0) {
<a name="l01140"></a>01140                 <span class="comment">/* Refuse to allocate cluster if previous cluster value is zero (unallocated) */</span>
<a name="l01141"></a>01141                 <span class="keywordflow">if</span>(!getClusterValue(prevCluster)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01142"></a>01142 
<a name="l01143"></a>01143                 <span class="comment">/* Point cluster to new cluster in chain */</span>
<a name="l01144"></a>01144                 setClusterValue(prevCluster, useCluster);
<a name="l01145"></a>01145                 <span class="comment">//LOG_MSG(&quot;Chaining cluser %d to %d&quot;, prevCluster, useCluster);</span>
<a name="l01146"></a>01146         } 
<a name="l01147"></a>01147 
<a name="l01148"></a>01148         <span class="keywordflow">switch</span>(fattype) {
<a name="l01149"></a>01149                 <span class="keywordflow">case</span> FAT12:
<a name="l01150"></a>01150                         setClusterValue(useCluster, 0xfff);
<a name="l01151"></a>01151                         <span class="keywordflow">break</span>;
<a name="l01152"></a>01152                 <span class="keywordflow">case</span> FAT16:
<a name="l01153"></a>01153                         setClusterValue(useCluster, 0xffff);
<a name="l01154"></a>01154                         <span class="keywordflow">break</span>;
<a name="l01155"></a>01155                 <span class="keywordflow">case</span> FAT32:
<a name="l01156"></a>01156                         setClusterValue(useCluster, 0x0fffffff);
<a name="l01157"></a>01157                         <span class="keywordflow">break</span>;
<a name="l01158"></a>01158         }
<a name="l01159"></a>01159         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01160"></a>01160 }
<a name="l01161"></a>01161 
<a name="l01162"></a>01162 fatDrive::~fatDrive() {
<a name="l01163"></a>01163         <span class="keywordflow">if</span> (loadedDisk) {
<a name="l01164"></a>01164                 loadedDisk-&gt;Release();
<a name="l01165"></a>01165                 loadedDisk = NULL;
<a name="l01166"></a>01166         }
<a name="l01167"></a>01167 }
<a name="l01168"></a>01168 
<a name="l01169"></a>01169 <span class="comment">/* PC-98 IPL1 partition table entry.</span>
<a name="l01170"></a>01170 <span class="comment"> * Taken from GNU Parted source code.</span>
<a name="l01171"></a>01171 <span class="comment"> * Maximum 16 entries. */</span>
<a name="l01172"></a>01172 <span class="preprocessor">#pragma pack(push,1)</span>
<a name="l01173"></a><a class="code" href="struct__PC98RawPartition.html">01173</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="struct__PC98RawPartition.html">_PC98RawPartition</a> {
<a name="l01174"></a>01174         uint8_t         mid;            <span class="comment">/* 0x80 - boot */</span>
<a name="l01175"></a>01175         uint8_t         sid;            <span class="comment">/* 0x80 - active */</span>
<a name="l01176"></a>01176         uint8_t         dum1;           <span class="comment">/* dummy for padding */</span>
<a name="l01177"></a>01177         uint8_t         dum2;           <span class="comment">/* dummy for padding */</span>
<a name="l01178"></a>01178         uint8_t         ipl_sect;       <span class="comment">/* IPL sector */</span>
<a name="l01179"></a>01179         uint8_t         ipl_head;       <span class="comment">/* IPL head */</span>
<a name="l01180"></a>01180         uint16_t        ipl_cyl;        <span class="comment">/* IPL cylinder */</span>
<a name="l01181"></a>01181         uint8_t         sector;         <span class="comment">/* starting sector */</span>
<a name="l01182"></a>01182         uint8_t         head;           <span class="comment">/* starting head */</span>
<a name="l01183"></a>01183         uint16_t        cyl;            <span class="comment">/* starting cylinder */</span>
<a name="l01184"></a>01184         uint8_t         end_sector;     <span class="comment">/* end sector */</span>
<a name="l01185"></a>01185         uint8_t         end_head;       <span class="comment">/* end head */</span>
<a name="l01186"></a>01186         uint16_t        end_cyl;        <span class="comment">/* end cylinder */</span>
<a name="l01187"></a>01187         <span class="keywordtype">char</span>            name[16];
<a name="l01188"></a>01188 };
<a name="l01189"></a>01189 <span class="preprocessor">#pragma pack(pop)</span>
<a name="l01190"></a>01190 <span class="preprocessor"></span>
<a name="l01191"></a>01191 fatDrive::fatDrive(<span class="keyword">const</span> <span class="keywordtype">char</span>* sysFilename, Bit32u bytesector, Bit32u cylsector, Bit32u headscyl, Bit32u cylinders, std::vector&lt;std::string&gt;&amp; options) {
<a name="l01192"></a>01192         FILE *diskfile;
<a name="l01193"></a>01193         Bit32u filesize;
<a name="l01194"></a>01194         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bootcode[256];
<a name="l01195"></a>01195 
<a name="l01196"></a>01196         <span class="keywordflow">if</span>(imgDTASeg == 0) {
<a name="l01197"></a>01197                 imgDTASeg = DOS_GetMemory(4,<span class="stringliteral">&quot;imgDTASeg&quot;</span>);
<a name="l01198"></a>01198                 imgDTAPtr = RealMake(imgDTASeg, 0);
<a name="l01199"></a>01199                 imgDTA    = <span class="keyword">new</span> <a class="code" href="classDOS__DTA.html">DOS_DTA</a>(imgDTAPtr);
<a name="l01200"></a>01200         }
<a name="l01201"></a>01201 
<a name="l01202"></a>01202         readonly = wpcolon&amp;&amp;strlen(sysFilename)&gt;1&amp;&amp;sysFilename[0]==<span class="charliteral">&#39;:&#39;</span>;
<a name="l01203"></a>01203         diskfile = fopen64(readonly?sysFilename+1:sysFilename, readonly?<span class="stringliteral">&quot;rb&quot;</span>:<span class="stringliteral">&quot;rb+&quot;</span>);
<a name="l01204"></a>01204         <span class="keywordflow">if</span>(!diskfile) {created_successfully = <span class="keyword">false</span>;<span class="keywordflow">return</span>;}
<a name="l01205"></a>01205 
<a name="l01206"></a>01206     <span class="comment">// all disk I/O is in sector-sized blocks.</span>
<a name="l01207"></a>01207     <span class="comment">// modern OSes have good caching.</span>
<a name="l01208"></a>01208     <span class="comment">// there are plenty of cases where this code aborts, exits, or re-execs itself (such as reboot)</span>
<a name="l01209"></a>01209     <span class="comment">// where stdio buffering can cause loss of data.</span>
<a name="l01210"></a>01210     setbuf(diskfile,NULL);
<a name="l01211"></a>01211 
<a name="l01212"></a>01212         <a class="code" href="structQCow2Image_1_1QCow2Header.html">QCow2Image::QCow2Header</a> qcow2_header = QCow2Image::read_header(diskfile);
<a name="l01213"></a>01213 
<a name="l01214"></a>01214         <span class="keywordflow">if</span> (qcow2_header.magic == QCow2Image::magic &amp;&amp; (qcow2_header.version == 2 || qcow2_header.version == 3)){
<a name="l01215"></a>01215                 Bit32u cluster_size = 1u &lt;&lt; qcow2_header.cluster_bits;
<a name="l01216"></a>01216                 <span class="keywordflow">if</span> ((bytesector &lt; 512) || ((cluster_size % bytesector) != 0)){
<a name="l01217"></a>01217                         created_successfully = <span class="keyword">false</span>;
<a name="l01218"></a>01218                         <span class="keywordflow">return</span>;
<a name="l01219"></a>01219                 }
<a name="l01220"></a>01220                 filesize = (Bit32u)(qcow2_header.size / 1024L);
<a name="l01221"></a>01221                 loadedDisk = <span class="keyword">new</span> <a class="code" href="classQCow2Disk.html">QCow2Disk</a>(qcow2_header, diskfile, (Bit8u *)sysFilename, filesize, bytesector, (filesize &gt; 2880));
<a name="l01222"></a>01222         }
<a name="l01223"></a>01223         <span class="keywordflow">else</span>{
<a name="l01224"></a>01224                 fseeko64(diskfile, 0L, SEEK_SET);
<a name="l01225"></a>01225         assert(<span class="keyword">sizeof</span>(bootcode) &gt;= 256);
<a name="l01226"></a>01226         <span class="keywordtype">size_t</span> readResult = fread(bootcode,256,1,diskfile); <span class="comment">// look for magic signatures</span>
<a name="l01227"></a>01227         <span class="keywordflow">if</span> (readResult != 1) {
<a name="l01228"></a>01228             <a class="code" href="classLOG.html">LOG</a>(LOG_IO, LOG_ERROR) (<span class="stringliteral">&quot;Reading error in fatDrive constructor\n&quot;</span>);
<a name="l01229"></a>01229             <span class="keywordflow">return</span>;
<a name="l01230"></a>01230         }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232         <span class="keyword">const</span> <span class="keywordtype">char</span> *ext = strrchr(sysFilename,<span class="charliteral">&#39;.&#39;</span>), *fname=readonly?sysFilename+1:sysFilename;
<a name="l01233"></a>01233 
<a name="l01234"></a>01234         <span class="keywordflow">if</span> (ext != NULL &amp;&amp; !strcasecmp(ext, <span class="stringliteral">&quot;.d88&quot;</span>)) {
<a name="l01235"></a>01235             fseeko64(diskfile, 0L, SEEK_END);
<a name="l01236"></a>01236             filesize = (Bit32u)(ftello64(diskfile) / 1024L);
<a name="l01237"></a>01237             loadedDisk = <span class="keyword">new</span> <a class="code" href="classimageDiskD88.html">imageDiskD88</a>(diskfile, (Bit8u *)fname, filesize, (filesize &gt; 2880));
<a name="l01238"></a>01238         }
<a name="l01239"></a>01239         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!memcmp(bootcode,<span class="stringliteral">&quot;VFD1.&quot;</span>,5)) { <span class="comment">/* FDD files */</span>
<a name="l01240"></a>01240             fseeko64(diskfile, 0L, SEEK_END);
<a name="l01241"></a>01241             filesize = (Bit32u)(ftello64(diskfile) / 1024L);
<a name="l01242"></a>01242             loadedDisk = <span class="keyword">new</span> <a class="code" href="classimageDiskVFD.html">imageDiskVFD</a>(diskfile, (Bit8u *)fname, filesize, (filesize &gt; 2880));
<a name="l01243"></a>01243         }
<a name="l01244"></a>01244         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!memcmp(bootcode,<span class="stringliteral">&quot;T98FDDIMAGE.R0\0\0&quot;</span>,16)) {
<a name="l01245"></a>01245             fseeko64(diskfile, 0L, SEEK_END);
<a name="l01246"></a>01246             filesize = (Bit32u)(ftello64(diskfile) / 1024L);
<a name="l01247"></a>01247             loadedDisk = <span class="keyword">new</span> <a class="code" href="classimageDiskNFD.html">imageDiskNFD</a>(diskfile, (Bit8u *)fname, filesize, (filesize &gt; 2880), 0);
<a name="l01248"></a>01248         }
<a name="l01249"></a>01249         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!memcmp(bootcode,<span class="stringliteral">&quot;T98FDDIMAGE.R1\0\0&quot;</span>,16)) {
<a name="l01250"></a>01250             fseeko64(diskfile, 0L, SEEK_END);
<a name="l01251"></a>01251             filesize = (Bit32u)(ftello64(diskfile) / 1024L);
<a name="l01252"></a>01252             loadedDisk = <span class="keyword">new</span> <a class="code" href="classimageDiskNFD.html">imageDiskNFD</a>(diskfile, (Bit8u *)fname, filesize, (filesize &gt; 2880), 1);
<a name="l01253"></a>01253         }
<a name="l01254"></a>01254         <span class="keywordflow">else</span> {
<a name="l01255"></a>01255             fseeko64(diskfile, 0L, SEEK_END);
<a name="l01256"></a>01256             filesize = (Bit32u)(ftello64(diskfile) / 1024L);
<a name="l01257"></a>01257             loadedDisk = <span class="keyword">new</span> <a class="code" href="classimageDisk.html">imageDisk</a>(diskfile, (Bit8u *)fname, filesize, (filesize &gt; 2880));
<a name="l01258"></a>01258         }
<a name="l01259"></a>01259         }
<a name="l01260"></a>01260 
<a name="l01261"></a>01261     fatDriveInit(sysFilename, bytesector, cylsector, headscyl, cylinders, filesize, options);
<a name="l01262"></a>01262 }
<a name="l01263"></a>01263 
<a name="l01264"></a>01264 fatDrive::fatDrive(<a class="code" href="classimageDisk.html">imageDisk</a> *sourceLoadedDisk, std::vector&lt;std::string&gt; &amp;options) {
<a name="l01265"></a>01265         <span class="keywordflow">if</span> (sourceLoadedDisk == 0) {
<a name="l01266"></a>01266                 created_successfully = <span class="keyword">false</span>;
<a name="l01267"></a>01267                 <span class="keywordflow">return</span>;
<a name="l01268"></a>01268         }
<a name="l01269"></a>01269         created_successfully = <span class="keyword">true</span>;
<a name="l01270"></a>01270         
<a name="l01271"></a>01271         <span class="keywordflow">if</span>(imgDTASeg == 0) {
<a name="l01272"></a>01272                 imgDTASeg = DOS_GetMemory(4,<span class="stringliteral">&quot;imgDTASeg&quot;</span>);
<a name="l01273"></a>01273                 imgDTAPtr = RealMake(imgDTASeg, 0);
<a name="l01274"></a>01274                 imgDTA    = <span class="keyword">new</span> <a class="code" href="classDOS__DTA.html">DOS_DTA</a>(imgDTAPtr);
<a name="l01275"></a>01275         }
<a name="l01276"></a>01276 
<a name="l01277"></a>01277     loadedDisk = sourceLoadedDisk;
<a name="l01278"></a>01278 
<a name="l01279"></a>01279     fatDriveInit(<span class="stringliteral">&quot;&quot;</span>, loadedDisk-&gt;sector_size, loadedDisk-&gt;sectors, loadedDisk-&gt;heads, loadedDisk-&gt;cylinders, loadedDisk-&gt;diskSizeK, options);
<a name="l01280"></a>01280 }
<a name="l01281"></a>01281 
<a name="l01282"></a>01282 Bit8u fatDrive::Read_AbsoluteSector(Bit32u sectnum, <span class="keywordtype">void</span> * data) {
<a name="l01283"></a>01283     <span class="keywordflow">if</span> (loadedDisk != NULL) {
<a name="l01284"></a>01284         <span class="comment">/* this will only work if the logical sector size is larger than the disk sector size */</span>
<a name="l01285"></a>01285         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lsz = loadedDisk-&gt;getSectSize();
<a name="l01286"></a>01286         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = sector_size / lsz;
<a name="l01287"></a>01287 
<a name="l01288"></a>01288         <span class="keywordflow">if</span> (c != 0 &amp;&amp; (sector_size % lsz) == 0) {
<a name="l01289"></a>01289             Bit32u ssect = sectnum * c;
<a name="l01290"></a>01290 
<a name="l01291"></a>01291             <span class="keywordflow">while</span> (c-- != 0) {
<a name="l01292"></a>01292                 <span class="keywordflow">if</span> (loadedDisk-&gt;Read_AbsoluteSector(ssect++,data) != 0)
<a name="l01293"></a>01293                     <span class="keywordflow">return</span> 0x05;
<a name="l01294"></a>01294 
<a name="l01295"></a>01295                 data = (<span class="keywordtype">void</span>*)((<span class="keywordtype">char</span>*)data + lsz);
<a name="l01296"></a>01296             }
<a name="l01297"></a>01297 
<a name="l01298"></a>01298             <span class="keywordflow">return</span> 0;
<a name="l01299"></a>01299         }
<a name="l01300"></a>01300     }
<a name="l01301"></a>01301 
<a name="l01302"></a>01302     <span class="keywordflow">return</span> 0x05;
<a name="l01303"></a>01303 }
<a name="l01304"></a>01304 
<a name="l01305"></a>01305 Bit8u fatDrive::Write_AbsoluteSector(Bit32u sectnum, <span class="keywordtype">void</span> * data) {
<a name="l01306"></a>01306     <span class="keywordflow">if</span> (loadedDisk != NULL) {
<a name="l01307"></a>01307         <span class="comment">/* this will only work if the logical sector size is larger than the disk sector size */</span>
<a name="l01308"></a>01308         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lsz = loadedDisk-&gt;getSectSize();
<a name="l01309"></a>01309         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = sector_size / lsz;
<a name="l01310"></a>01310 
<a name="l01311"></a>01311         <span class="keywordflow">if</span> (c != 0 &amp;&amp; (sector_size % lsz) == 0) {
<a name="l01312"></a>01312             Bit32u ssect = sectnum * c;
<a name="l01313"></a>01313 
<a name="l01314"></a>01314             <span class="keywordflow">while</span> (c-- != 0) {
<a name="l01315"></a>01315                 <span class="keywordflow">if</span> (loadedDisk-&gt;Write_AbsoluteSector(ssect++,data) != 0)
<a name="l01316"></a>01316                     <span class="keywordflow">return</span> 0x05;
<a name="l01317"></a>01317 
<a name="l01318"></a>01318                 data = (<span class="keywordtype">void</span>*)((<span class="keywordtype">char</span>*)data + lsz);
<a name="l01319"></a>01319             }
<a name="l01320"></a>01320 
<a name="l01321"></a>01321             <span class="keywordflow">return</span> 0;
<a name="l01322"></a>01322         }
<a name="l01323"></a>01323     }
<a name="l01324"></a>01324 
<a name="l01325"></a>01325     <span class="keywordflow">return</span> 0x05;
<a name="l01326"></a>01326 }
<a name="l01327"></a>01327 
<a name="l01328"></a>01328 Bit32u fatDrive::getSectSize(<span class="keywordtype">void</span>) {
<a name="l01329"></a>01329     <span class="keywordflow">return</span> sector_size;
<a name="l01330"></a>01330 }
<a name="l01331"></a>01331 
<a name="l01332"></a>01332 <span class="keywordtype">void</span> fatDrive::UpdateDPB(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> dos_drive) {
<a name="l01333"></a>01333     PhysPt ptr = DOS_Get_DPB(dos_drive);
<a name="l01334"></a>01334     <span class="keywordflow">if</span> (ptr != PhysPt(0)) {
<a name="l01335"></a>01335         mem_writew(ptr+0x02,BPB.v.BPB_BytsPerSec);                  <span class="comment">// +2 = bytes per sector</span>
<a name="l01336"></a>01336         mem_writeb(ptr+0x04,BPB.v.BPB_SecPerClus - 1);              <span class="comment">// +4 = highest sector within a cluster</span>
<a name="l01337"></a>01337         mem_writeb(ptr+0x05,bitop::log2(BPB.v.BPB_SecPerClus));     <span class="comment">// +5 = shift count to convert clusters to sectors</span>
<a name="l01338"></a>01338         mem_writew(ptr+0x06,BPB.v.BPB_RsvdSecCnt);                  <span class="comment">// +6 = number of reserved sectors at start of partition</span>
<a name="l01339"></a>01339         mem_writeb(ptr+0x08,BPB.v.BPB_NumFATs);                     <span class="comment">// +8 = number of FATs (file allocation tables)</span>
<a name="l01340"></a>01340         mem_writew(ptr+0x09,BPB.v.BPB_RootEntCnt);                  <span class="comment">// +9 = number of root directory entries</span>
<a name="l01341"></a>01341         mem_writew(ptr+0x0B,(uint16_t)(firstDataSector-partSectOff));<span class="comment">// +11 = number of first sector containing user data</span>
<a name="l01342"></a>01342 
<a name="l01343"></a>01343         <span class="keywordflow">if</span> (BPB.is_fat32())
<a name="l01344"></a>01344             mem_writew(ptr+0x0D,0);                                 <span class="comment">// Windows 98 behavior</span>
<a name="l01345"></a>01345         <span class="keywordflow">else</span>
<a name="l01346"></a>01346             mem_writew(ptr+0x0D,(uint16_t)CountOfClusters + 1);     <span class="comment">// +13 = highest cluster number</span>
<a name="l01347"></a>01347 
<a name="l01348"></a>01348         mem_writew(ptr+0x0F,(uint16_t)BPB.v.BPB_FATSz16);           <span class="comment">// +15 = sectors per FAT</span>
<a name="l01349"></a>01349 
<a name="l01350"></a>01350         <span class="keywordflow">if</span> (BPB.is_fat32())
<a name="l01351"></a>01351             mem_writew(ptr+0x11,0xFFFF);                            <span class="comment">// Windows 98 behavior</span>
<a name="l01352"></a>01352         <span class="keywordflow">else</span>
<a name="l01353"></a>01353             mem_writew(ptr+0x11,(uint16_t)(firstRootDirSect-partSectOff));<span class="comment">// +17 = sector number of first directory sector</span>
<a name="l01354"></a>01354 
<a name="l01355"></a>01355         mem_writed(ptr+0x13,0xFFFFFFFF);                            <span class="comment">// +19 = address of device driver header (NOT IMPLEMENTED) Windows 98 behavior</span>
<a name="l01356"></a>01356         mem_writeb(ptr+0x17,GetMediaByte());                        <span class="comment">// +23 = media ID byte</span>
<a name="l01357"></a>01357         mem_writeb(ptr+0x18,0x00);                                  <span class="comment">// +24 = disk accessed</span>
<a name="l01358"></a>01358         mem_writew(ptr+0x1F,0xFFFF);                                <span class="comment">// +31 = number of free clusters or 0xFFFF if unknown</span>
<a name="l01359"></a>01359         <span class="comment">// other fields, not implemented</span>
<a name="l01360"></a>01360     }
<a name="l01361"></a>01361 }
<a name="l01362"></a>01362 
<a name="l01363"></a>01363 <span class="keywordtype">void</span> fatDrive::fatDriveInit(<span class="keyword">const</span> <span class="keywordtype">char</span> *sysFilename, Bit32u bytesector, Bit32u cylsector, Bit32u headscyl, Bit32u cylinders, Bit64u filesize, <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;options) {
<a name="l01364"></a>01364         Bit32u startSector = 0,countSector = 0;
<a name="l01365"></a>01365         <span class="keywordtype">bool</span> pc98_512_to_1024_allow = <span class="keyword">false</span>;
<a name="l01366"></a>01366     <span class="keywordtype">int</span> opt_partition_index = -1;
<a name="l01367"></a>01367         <span class="keywordtype">bool</span> is_hdd = (filesize &gt; 2880);
<a name="l01368"></a>01368         <span class="keyword">struct </span><a class="code" href="structpartTable.html">partTable</a> mbrData;
<a name="l01369"></a>01369 
<a name="l01370"></a>01370         req_ver_major = req_ver_minor = 0;
<a name="l01371"></a>01371 
<a name="l01372"></a>01372         <span class="keywordflow">if</span>(!loadedDisk) {
<a name="l01373"></a>01373                 created_successfully = <span class="keyword">false</span>;
<a name="l01374"></a>01374                 <span class="keywordflow">return</span>;
<a name="l01375"></a>01375         }
<a name="l01376"></a>01376 
<a name="l01377"></a>01377     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;opt : options) {
<a name="l01378"></a>01378         <span class="keywordtype">size_t</span> equ = opt.find_first_of(<span class="charliteral">&#39;=&#39;</span>);
<a name="l01379"></a>01379         std::string name,value;
<a name="l01380"></a>01380 
<a name="l01381"></a>01381         <span class="keywordflow">if</span> (equ != std::string::npos) {
<a name="l01382"></a>01382             name = opt.substr(0,equ);
<a name="l01383"></a>01383             value = opt.substr(equ+1);
<a name="l01384"></a>01384         }
<a name="l01385"></a>01385         <span class="keywordflow">else</span> {
<a name="l01386"></a>01386             name = opt;
<a name="l01387"></a>01387             value.clear();
<a name="l01388"></a>01388         }
<a name="l01389"></a>01389 
<a name="l01390"></a>01390         <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;partidx&quot;</span>) {
<a name="l01391"></a>01391             <span class="keywordflow">if</span> (!value.empty())
<a name="l01392"></a>01392                 opt_partition_index = (<span class="keywordtype">int</span>)atol(value.c_str());
<a name="l01393"></a>01393         }
<a name="l01394"></a>01394         <span class="keywordflow">else</span> {
<a name="l01395"></a>01395             <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;FAT: option &#39;%s&#39; = &#39;%s&#39; ignored, unknown&quot;</span>,name.c_str(),value.c_str());
<a name="l01396"></a>01396         }
<a name="l01397"></a>01397 
<a name="l01398"></a>01398 <span class="comment">//        LOG_MSG(&quot;&#39;%s&#39; = &#39;%s&#39;&quot;,name.c_str(),value.c_str());</span>
<a name="l01399"></a>01399     }
<a name="l01400"></a>01400 
<a name="l01401"></a>01401         loadedDisk-&gt;Addref();
<a name="l01402"></a>01402 
<a name="l01403"></a>01403     {
<a name="l01404"></a>01404         <a class="code" href="structFAT__BootSector.html">FAT_BootSector</a> bootbuffer = {};
<a name="l01405"></a>01405 
<a name="l01406"></a>01406         <span class="keywordflow">if</span> (loadedDisk-&gt;getSectSize() &gt; <span class="keyword">sizeof</span>(bootbuffer)) {
<a name="l01407"></a>01407             LOG_MSG(<span class="stringliteral">&quot;Disk sector/bytes (%u) is too large, not attempting FAT filesystem access&quot;</span>,loadedDisk-&gt;getSectSize());
<a name="l01408"></a>01408             created_successfully = <span class="keyword">false</span>;
<a name="l01409"></a>01409             <span class="keywordflow">return</span>;
<a name="l01410"></a>01410         }
<a name="l01411"></a>01411 
<a name="l01412"></a>01412         <span class="keywordflow">if</span>(is_hdd) {
<a name="l01413"></a>01413             <span class="comment">/* Set user specified harddrive parameters */</span>
<a name="l01414"></a>01414             <span class="keywordflow">if</span> (headscyl &gt; 0 &amp;&amp; cylinders &gt; 0 &amp;&amp; cylsector &gt; 0 &amp;&amp; bytesector &gt; 0)
<a name="l01415"></a>01415                 loadedDisk-&gt;Set_Geometry(headscyl, cylinders,cylsector, bytesector);
<a name="l01416"></a>01416 
<a name="l01417"></a>01417             <span class="keywordflow">if</span> (loadedDisk-&gt;heads == 0 || loadedDisk-&gt;sectors == 0 || loadedDisk-&gt;cylinders == 0) {
<a name="l01418"></a>01418                 created_successfully = <span class="keyword">false</span>;
<a name="l01419"></a>01419                 LOG_MSG(<span class="stringliteral">&quot;No geometry&quot;</span>);
<a name="l01420"></a>01420                 <span class="keywordflow">return</span>;
<a name="l01421"></a>01421             }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423             loadedDisk-&gt;Read_Sector(0,0,1,&amp;mbrData);
<a name="l01424"></a>01424 
<a name="l01425"></a>01425             <span class="keywordflow">if</span>(mbrData.magic1!= 0x55 || mbrData.magic2!= 0xaa) LOG_MSG(<span class="stringliteral">&quot;Possibly invalid partition table in disk image.&quot;</span>);
<a name="l01426"></a>01426 
<a name="l01427"></a>01427             startSector = 0;
<a name="l01428"></a>01428 
<a name="l01429"></a>01429             <span class="comment">/* PC-98 bootloader support.</span>
<a name="l01430"></a>01430 <span class="comment">             * These can be identified by the &quot;IPL1&quot; in the boot sector.</span>
<a name="l01431"></a>01431 <span class="comment">             * These boot sectors do not have a valid partition table though the code below might</span>
<a name="l01432"></a>01432 <span class="comment">             * pick up a false partition #3 with a zero offset. Partition table is in sector 1 */</span>
<a name="l01433"></a>01433             <span class="keywordflow">if</span> (!memcmp(mbrData.booter+4,<span class="stringliteral">&quot;IPL1&quot;</span>,4)) {
<a name="l01434"></a>01434                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ipltable[SECTOR_SIZE_MAX];
<a name="l01435"></a>01435                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_entries = (std::min)(16UL,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(loadedDisk-&gt;getSectSize() / <span class="keyword">sizeof</span>(<a class="code" href="struct__PC98RawPartition.html">_PC98RawPartition</a>)));
<a name="l01436"></a>01436                 Bitu i;
<a name="l01437"></a>01437 
<a name="l01438"></a>01438                 LOG_MSG(<span class="stringliteral">&quot;PC-98 IPL1 signature detected&quot;</span>);
<a name="l01439"></a>01439 
<a name="l01440"></a>01440                 assert(<span class="keyword">sizeof</span>(<a class="code" href="struct__PC98RawPartition.html">_PC98RawPartition</a>) == 32);
<a name="l01441"></a>01441 
<a name="l01442"></a>01442                 memset(ipltable,0,<span class="keyword">sizeof</span>(ipltable));
<a name="l01443"></a>01443                 loadedDisk-&gt;Read_Sector(0,0,2,ipltable);
<a name="l01444"></a>01444 
<a name="l01445"></a>01445                 <span class="keywordflow">if</span> (opt_partition_index &gt;= 0) {
<a name="l01446"></a>01446                     <span class="comment">/* user knows best! */</span>
<a name="l01447"></a>01447                     <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)opt_partition_index &gt;= max_entries) {
<a name="l01448"></a>01448                         LOG_MSG(<span class="stringliteral">&quot;Partition index out of range&quot;</span>);
<a name="l01449"></a>01449                         created_successfully = <span class="keyword">false</span>;
<a name="l01450"></a>01450                         <span class="keywordflow">return</span>;
<a name="l01451"></a>01451                     }
<a name="l01452"></a>01452 
<a name="l01453"></a>01453                     i = (<span class="keywordtype">unsigned</span> int)opt_partition_index;
<a name="l01454"></a>01454                     <span class="keyword">const</span> <a class="code" href="struct__PC98RawPartition.html">_PC98RawPartition</a> *pe = (<a class="code" href="struct__PC98RawPartition.html">_PC98RawPartition</a>*)(ipltable+(i * 32));
<a name="l01455"></a>01455 
<a name="l01456"></a>01456                     <span class="comment">/* unfortunately start and end are in C/H/S geometry, so we have to translate.</span>
<a name="l01457"></a>01457 <span class="comment">                     * this is why it matters so much to read the geometry from the HDI header.</span>
<a name="l01458"></a>01458 <span class="comment">                     *</span>
<a name="l01459"></a>01459 <span class="comment">                     * NOTE: C/H/S values in the IPL1 table are similar to IBM PC except that sectors are counted from 0, not 1 */</span>
<a name="l01460"></a>01460                     startSector =
<a name="l01461"></a>01461                         (pe-&gt;cyl * loadedDisk-&gt;sectors * loadedDisk-&gt;heads) +
<a name="l01462"></a>01462                         (pe-&gt;head * loadedDisk-&gt;sectors) +
<a name="l01463"></a>01463                         pe-&gt;sector;
<a name="l01464"></a>01464 
<a name="l01465"></a>01465                     <span class="comment">/* Many HDI images I&#39;ve encountered so far indicate 512 bytes/sector,</span>
<a name="l01466"></a>01466 <span class="comment">                     * but then the FAT filesystem itself indicates 1024 bytes per sector. */</span>
<a name="l01467"></a>01467                     pc98_512_to_1024_allow = <span class="keyword">true</span>;
<a name="l01468"></a>01468 
<a name="l01469"></a>01469                     {
<a name="l01470"></a>01470                         <span class="comment">/* FIXME: What if the label contains SHIFT-JIS? */</span>
<a name="l01471"></a>01471                         std::string name = std::string(pe-&gt;name,<span class="keyword">sizeof</span>(pe-&gt;name));
<a name="l01472"></a>01472 
<a name="l01473"></a>01473                         LOG_MSG(<span class="stringliteral">&quot;Using IPL1 entry %lu name &#39;%s&#39; which starts at sector %lu&quot;</span>,
<a name="l01474"></a>01474                                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)i,name.c_str(),(<span class="keywordtype">unsigned</span> long)startSector);
<a name="l01475"></a>01475                     }
<a name="l01476"></a>01476                 }
<a name="l01477"></a>01477                 <span class="keywordflow">else</span> {
<a name="l01478"></a>01478                     <span class="keywordflow">for</span> (i=0;i &lt; max_entries;i++) {
<a name="l01479"></a>01479                         <span class="keyword">const</span> <a class="code" href="struct__PC98RawPartition.html">_PC98RawPartition</a> *pe = (<a class="code" href="struct__PC98RawPartition.html">_PC98RawPartition</a>*)(ipltable+(i * 32));
<a name="l01480"></a>01480 
<a name="l01481"></a>01481                         <span class="keywordflow">if</span> (pe-&gt;mid == 0 &amp;&amp; pe-&gt;sid == 0 &amp;&amp;
<a name="l01482"></a>01482                                 pe-&gt;ipl_sect == 0 &amp;&amp; pe-&gt;ipl_head == 0 &amp;&amp; pe-&gt;ipl_cyl == 0 &amp;&amp;
<a name="l01483"></a>01483                                 pe-&gt;sector == 0 &amp;&amp; pe-&gt;head == 0 &amp;&amp; pe-&gt;cyl == 0 &amp;&amp;
<a name="l01484"></a>01484                                 pe-&gt;end_sector == 0 &amp;&amp; pe-&gt;end_head == 0 &amp;&amp; pe-&gt;end_cyl == 0)
<a name="l01485"></a>01485                             <span class="keywordflow">continue</span>; <span class="comment">/* unused */</span>
<a name="l01486"></a>01486 
<a name="l01487"></a>01487                         <span class="comment">/* We&#39;re looking for MS-DOS partitions.</span>
<a name="l01488"></a>01488 <span class="comment">                         * I&#39;ve heard that some other OSes were once ported to PC-98, including Windows NT and OS/2,</span>
<a name="l01489"></a>01489 <span class="comment">                         * so I would rather not mistake NTFS or HPFS as FAT and cause damage. --J.C.</span>
<a name="l01490"></a>01490 <span class="comment">                         * FIXME: Is there a better way? */</span>
<a name="l01491"></a>01491                         <span class="keywordflow">if</span> (!strncasecmp(pe-&gt;name,<span class="stringliteral">&quot;MS-DOS&quot;</span>,6) ||
<a name="l01492"></a>01492                                 !strncasecmp(pe-&gt;name,<span class="stringliteral">&quot;MSDOS&quot;</span>,5) ||
<a name="l01493"></a>01493                                 !strncasecmp(pe-&gt;name,<span class="stringliteral">&quot;Windows&quot;</span>,7)) {
<a name="l01494"></a>01494                             <span class="comment">/* unfortunately start and end are in C/H/S geometry, so we have to translate.</span>
<a name="l01495"></a>01495 <span class="comment">                             * this is why it matters so much to read the geometry from the HDI header.</span>
<a name="l01496"></a>01496 <span class="comment">                             *</span>
<a name="l01497"></a>01497 <span class="comment">                             * NOTE: C/H/S values in the IPL1 table are similar to IBM PC except that sectors are counted from 0, not 1 */</span>
<a name="l01498"></a>01498                             startSector =
<a name="l01499"></a>01499                                 (pe-&gt;cyl * loadedDisk-&gt;sectors * loadedDisk-&gt;heads) +
<a name="l01500"></a>01500                                 (pe-&gt;head * loadedDisk-&gt;sectors) +
<a name="l01501"></a>01501                                 pe-&gt;sector;
<a name="l01502"></a>01502 
<a name="l01503"></a>01503                             <span class="comment">/* Many HDI images I&#39;ve encountered so far indicate 512 bytes/sector,</span>
<a name="l01504"></a>01504 <span class="comment">                             * but then the FAT filesystem itself indicates 1024 bytes per sector. */</span>
<a name="l01505"></a>01505                             pc98_512_to_1024_allow = <span class="keyword">true</span>;
<a name="l01506"></a>01506 
<a name="l01507"></a>01507                             {
<a name="l01508"></a>01508                                 <span class="comment">/* FIXME: What if the label contains SHIFT-JIS? */</span>
<a name="l01509"></a>01509                                 std::string name = std::string(pe-&gt;name,<span class="keyword">sizeof</span>(pe-&gt;name));
<a name="l01510"></a>01510 
<a name="l01511"></a>01511                                 LOG_MSG(<span class="stringliteral">&quot;Using IPL1 entry %lu name &#39;%s&#39; which starts at sector %lu&quot;</span>,
<a name="l01512"></a>01512                                         (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)i,name.c_str(),(<span class="keywordtype">unsigned</span> long)startSector);
<a name="l01513"></a>01513                                 <span class="keywordflow">break</span>;
<a name="l01514"></a>01514                             }
<a name="l01515"></a>01515                         }
<a name="l01516"></a>01516                     }
<a name="l01517"></a>01517                 }
<a name="l01518"></a>01518 
<a name="l01519"></a>01519                 <span class="keywordflow">if</span> (i == max_entries)
<a name="l01520"></a>01520                     LOG_MSG(<span class="stringliteral">&quot;No partitions found in the IPL1 table&quot;</span>);
<a name="l01521"></a>01521             }
<a name="l01522"></a>01522             <span class="keywordflow">else</span> {
<a name="l01523"></a>01523                 <span class="comment">/* IBM PC master boot record search */</span>
<a name="l01524"></a>01524                 <span class="keywordtype">int</span> m=4;
<a name="l01525"></a>01525 
<a name="l01526"></a>01526                 <span class="keywordflow">if</span> (opt_partition_index &gt;= 0) {
<a name="l01527"></a>01527                     <span class="comment">/* user knows best! */</span>
<a name="l01528"></a>01528                     <span class="keywordflow">if</span> (opt_partition_index &gt;= 4) {
<a name="l01529"></a>01529                         LOG_MSG(<span class="stringliteral">&quot;Partition index out of range&quot;</span>);
<a name="l01530"></a>01530                         created_successfully = <span class="keyword">false</span>;
<a name="l01531"></a>01531                         <span class="keywordflow">return</span>;
<a name="l01532"></a>01532                     }
<a name="l01533"></a>01533 
<a name="l01534"></a>01534                     startSector = mbrData.pentry[m=opt_partition_index].absSectStart;
<a name="l01535"></a>01535                     countSector = mbrData.pentry[m=opt_partition_index].partSize;
<a name="l01536"></a>01536                 }
<a name="l01537"></a>01537                 <span class="keywordflow">else</span> {
<a name="l01538"></a>01538                     <span class="keywordflow">for</span>(m=0;m&lt;4;m++) {
<a name="l01539"></a>01539                         <span class="comment">/* Pick the first available partition */</span>
<a name="l01540"></a>01540                         <span class="keywordflow">if</span> (mbrData.pentry[m].parttype == 0x01 || mbrData.pentry[m].parttype == 0x04 || mbrData.pentry[m].parttype == 0x06) {
<a name="l01541"></a>01541                             LOG_MSG(<span class="stringliteral">&quot;Using partition %d on drive (type 0x%02x); skipping %d sectors&quot;</span>, m, mbrData.pentry[m].parttype, mbrData.pentry[m].absSectStart);
<a name="l01542"></a>01542                             startSector = mbrData.pentry[m].absSectStart;
<a name="l01543"></a>01543                             countSector = mbrData.pentry[m].partSize;
<a name="l01544"></a>01544                             <span class="keywordflow">break</span>;
<a name="l01545"></a>01545                         }
<a name="l01546"></a>01546                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mbrData.pentry[m].parttype == 0x0E<span class="comment">/*FAT16B LBA*/</span>) {
<a name="l01547"></a>01547                                                         <span class="keywordflow">if</span> (dos.version.major &gt;= 7) { <span class="comment">/* MS-DOS 7.0 or higher */</span>
<a name="l01548"></a>01548                                                                 LOG_MSG(<span class="stringliteral">&quot;Using partition %d on drive (type 0x%02x); skipping %d sectors&quot;</span>, m, mbrData.pentry[m].parttype, mbrData.pentry[m].absSectStart);
<a name="l01549"></a>01549                                                                 startSector = mbrData.pentry[m].absSectStart;
<a name="l01550"></a>01550                                                                 countSector = mbrData.pentry[m].partSize;
<a name="l01551"></a>01551                                                         } <span class="keywordflow">else</span> {
<a name="l01552"></a>01552                                                                 req_ver_major = 7; req_ver_minor = 0;
<a name="l01553"></a>01553                             }
<a name="l01554"></a>01554                             <span class="keywordflow">break</span>;
<a name="l01555"></a>01555                         }
<a name="l01556"></a>01556                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mbrData.pentry[m].parttype == 0x0B || mbrData.pentry[m].parttype == 0x0C) { <span class="comment">/* FAT32 types */</span>
<a name="l01557"></a>01557                                                         <span class="keywordflow">if</span> (dos.version.major &gt; 7 || (dos.version.major == 7 &amp;&amp; dos.version.minor &gt;= 10)) { <span class="comment">/* MS-DOS 7.10 or higher */</span>
<a name="l01558"></a>01558                                                                 LOG_MSG(<span class="stringliteral">&quot;Using partition %d on drive (type 0x%02x); skipping %d sectors&quot;</span>, m, mbrData.pentry[m].parttype, mbrData.pentry[m].absSectStart);
<a name="l01559"></a>01559                                                                 startSector = mbrData.pentry[m].absSectStart;
<a name="l01560"></a>01560                                                                 countSector = mbrData.pentry[m].partSize;
<a name="l01561"></a>01561                                                         } <span class="keywordflow">else</span> {
<a name="l01562"></a>01562                                                                 req_ver_major = 7; req_ver_minor = 10;
<a name="l01563"></a>01563                             }
<a name="l01564"></a>01564                             <span class="keywordflow">break</span>;
<a name="l01565"></a>01565                         }
<a name="l01566"></a>01566                     }
<a name="l01567"></a>01567                 }
<a name="l01568"></a>01568 
<a name="l01569"></a>01569                 <span class="keywordflow">if</span>(m==4) LOG_MSG(<span class="stringliteral">&quot;No good partition found in image.&quot;</span>);
<a name="l01570"></a>01570             }
<a name="l01571"></a>01571 
<a name="l01572"></a>01572             partSectOff = startSector;
<a name="l01573"></a>01573             partSectSize = countSector;
<a name="l01574"></a>01574         } <span class="keywordflow">else</span> {
<a name="l01575"></a>01575             <span class="comment">/* Get floppy disk parameters based on image size */</span>
<a name="l01576"></a>01576             loadedDisk-&gt;Get_Geometry(&amp;headscyl, &amp;cylinders, &amp;cylsector, &amp;bytesector);
<a name="l01577"></a>01577             <span class="comment">/* Floppy disks don&#39;t have partitions */</span>
<a name="l01578"></a>01578             partSectOff = 0;
<a name="l01579"></a>01579 
<a name="l01580"></a>01580             <span class="keywordflow">if</span> (loadedDisk-&gt;heads == 0 || loadedDisk-&gt;sectors == 0 || loadedDisk-&gt;cylinders == 0) {
<a name="l01581"></a>01581                 created_successfully = <span class="keyword">false</span>;
<a name="l01582"></a>01582                 LOG_MSG(<span class="stringliteral">&quot;No geometry&quot;</span>);
<a name="l01583"></a>01583                 <span class="keywordflow">return</span>;
<a name="l01584"></a>01584             }
<a name="l01585"></a>01585         }
<a name="l01586"></a>01586 
<a name="l01587"></a>01587         BPB = {};
<a name="l01588"></a>01588         loadedDisk-&gt;Read_AbsoluteSector(0+partSectOff,&amp;bootbuffer);
<a name="l01589"></a>01589 
<a name="l01590"></a>01590         <span class="comment">/* If the sector is full of 0xF6, the partition is brand new and was just created with Microsoft FDISK.EXE (Windows 98 behavior)</span>
<a name="l01591"></a>01591 <span class="comment">         * and therefore there is NO FAT filesystem here. We&#39;ll go farther and check if all bytes are just the same. */</span>
<a name="l01592"></a>01592         {
<a name="l01593"></a>01593             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1;
<a name="l01594"></a>01594 
<a name="l01595"></a>01595             <span class="keywordflow">while</span> (i &lt; 128 &amp;&amp; ((Bit8u*)(&amp;bootbuffer))[0] == ((Bit8u*)(&amp;bootbuffer))[i]) i++;
<a name="l01596"></a>01596 
<a name="l01597"></a>01597             <span class="keywordflow">if</span> (i == 128) {
<a name="l01598"></a>01598                 LOG_MSG(<span class="stringliteral">&quot;Boot sector appears to have been created by FDISK.EXE but not formatted&quot;</span>);
<a name="l01599"></a>01599                 created_successfully = <span class="keyword">false</span>;
<a name="l01600"></a>01600                 <span class="keywordflow">return</span>;
<a name="l01601"></a>01601             }
<a name="l01602"></a>01602         }
<a name="l01603"></a>01603 
<a name="l01604"></a>01604         <span class="keywordflow">if</span> (!is_hdd) {
<a name="l01605"></a>01605             <span class="comment">/* Identify floppy format */</span>
<a name="l01606"></a>01606             <span class="keywordflow">if</span> ((bootbuffer.BS_jmpBoot[0] == 0x69 || bootbuffer.BS_jmpBoot[0] == 0xe9 ||
<a name="l01607"></a>01607                         (bootbuffer.BS_jmpBoot[0] == 0xeb &amp;&amp; bootbuffer.BS_jmpBoot[2] == 0x90)) &amp;&amp;
<a name="l01608"></a>01608                     (bootbuffer.bpb.v.BPB_Media &amp; 0xf0) == 0xf0) {
<a name="l01609"></a>01609                 <span class="comment">/* DOS 2.x or later format, BPB assumed valid */</span>
<a name="l01610"></a>01610 
<a name="l01611"></a>01611                 <span class="keywordflow">if</span> ((bootbuffer.bpb.v.BPB_Media != 0xf0 &amp;&amp; !(bootbuffer.bpb.v.BPB_Media &amp; 0x1)) &amp;&amp;
<a name="l01612"></a>01612                         (bootbuffer.BS_OEMName[5] != <span class="charliteral">&#39;3&#39;</span> || bootbuffer.BS_OEMName[6] != <span class="charliteral">&#39;.&#39;</span> || bootbuffer.BS_OEMName[7] &lt; <span class="charliteral">&#39;2&#39;</span>)) {
<a name="l01613"></a>01613                     <span class="comment">/* Fix pre-DOS 3.2 single-sided floppy */</span>
<a name="l01614"></a>01614                     bootbuffer.bpb.v.BPB_SecPerClus = 1;
<a name="l01615"></a>01615                 }
<a name="l01616"></a>01616             } <span class="keywordflow">else</span> {
<a name="l01617"></a>01617                 <span class="comment">/* Read media descriptor in FAT */</span>
<a name="l01618"></a>01618                 Bit8u sectorBuffer[512];
<a name="l01619"></a>01619                 loadedDisk-&gt;Read_AbsoluteSector(1,&amp;sectorBuffer);
<a name="l01620"></a>01620                 Bit8u mdesc = sectorBuffer[0];
<a name="l01621"></a>01621 
<a name="l01622"></a>01622                 <span class="keywordflow">if</span> (mdesc &gt;= 0xf8) {
<a name="l01623"></a>01623                     <span class="comment">/* DOS 1.x format, create BPB for 160kB floppy */</span>
<a name="l01624"></a>01624                     bootbuffer.bpb.v.BPB_BytsPerSec = 512;
<a name="l01625"></a>01625                     bootbuffer.bpb.v.BPB_SecPerClus = 1;
<a name="l01626"></a>01626                     bootbuffer.bpb.v.BPB_RsvdSecCnt = 1;
<a name="l01627"></a>01627                     bootbuffer.bpb.v.BPB_NumFATs = 2;
<a name="l01628"></a>01628                     bootbuffer.bpb.v.BPB_RootEntCnt = 64;
<a name="l01629"></a>01629                     bootbuffer.bpb.v.BPB_TotSec16 = 320;
<a name="l01630"></a>01630                     bootbuffer.bpb.v.BPB_Media = mdesc;
<a name="l01631"></a>01631                     bootbuffer.bpb.v.BPB_FATSz16 = 1;
<a name="l01632"></a>01632                     bootbuffer.bpb.v.BPB_SecPerTrk = 8;
<a name="l01633"></a>01633                     bootbuffer.bpb.v.BPB_NumHeads = 1;
<a name="l01634"></a>01634                     bootbuffer.magic1 = 0x55;   <span class="comment">// to silence warning</span>
<a name="l01635"></a>01635                     bootbuffer.magic2 = 0xaa;
<a name="l01636"></a>01636                     <span class="keywordflow">if</span> (!(mdesc &amp; 0x2)) {
<a name="l01637"></a>01637                         <span class="comment">/* Adjust for 9 sectors per track */</span>
<a name="l01638"></a>01638                         bootbuffer.bpb.v.BPB_TotSec16 = 360;
<a name="l01639"></a>01639                         bootbuffer.bpb.v.BPB_FATSz16 = 2;
<a name="l01640"></a>01640                         bootbuffer.bpb.v.BPB_SecPerTrk = 9;
<a name="l01641"></a>01641                     }
<a name="l01642"></a>01642                     <span class="keywordflow">if</span> (mdesc &amp; 0x1) {
<a name="l01643"></a>01643                         <span class="comment">/* Adjust for 2 sides */</span>
<a name="l01644"></a>01644                         bootbuffer.bpb.v.BPB_SecPerClus = 2;
<a name="l01645"></a>01645                         bootbuffer.bpb.v.BPB_RootEntCnt = 112;
<a name="l01646"></a>01646                         bootbuffer.bpb.v.BPB_TotSec16 *= 2;
<a name="l01647"></a>01647                         bootbuffer.bpb.v.BPB_NumHeads = 2;
<a name="l01648"></a>01648                     }
<a name="l01649"></a>01649                 } <span class="keywordflow">else</span> {
<a name="l01650"></a>01650                     <span class="comment">/* Unknown format */</span>
<a name="l01651"></a>01651                     created_successfully = <span class="keyword">false</span>;
<a name="l01652"></a>01652                     <span class="keywordflow">return</span>;
<a name="l01653"></a>01653                 }
<a name="l01654"></a>01654             }
<a name="l01655"></a>01655         }
<a name="l01656"></a>01656 
<a name="l01657"></a>01657         <span class="comment">/* accept BPB.. so far */</span>
<a name="l01658"></a>01658         BPB = bootbuffer.bpb;
<a name="l01659"></a>01659 
<a name="l01660"></a>01660         <span class="comment">/* DEBUG */</span>
<a name="l01661"></a>01661         <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_DEBUG)(<span class="stringliteral">&quot;FAT: BPB says %u sectors/track %u heads %u bytes/sector&quot;</span>,
<a name="l01662"></a>01662                 BPB.v.BPB_SecPerTrk,
<a name="l01663"></a>01663                 BPB.v.BPB_NumHeads,
<a name="l01664"></a>01664                 BPB.v.BPB_BytsPerSec);
<a name="l01665"></a>01665 
<a name="l01666"></a>01666         <span class="comment">/* NTS: PC-98 floppies (the 1024 byte/sector format) do not have magic bytes */</span>
<a name="l01667"></a>01667         <span class="keywordflow">if</span> (fatDrive::getSectSize() == 512 &amp;&amp; !IS_PC98_ARCH) {
<a name="l01668"></a>01668             <span class="keywordflow">if</span> ((bootbuffer.magic1 != 0x55) || (bootbuffer.magic2 != 0xaa)) {
<a name="l01669"></a>01669                 <span class="comment">/* Not a FAT filesystem */</span>
<a name="l01670"></a>01670                 LOG_MSG(<span class="stringliteral">&quot;Loaded image has no valid magicnumbers at the end!&quot;</span>);
<a name="l01671"></a>01671                 created_successfully = <span class="keyword">false</span>;
<a name="l01672"></a>01672                 <span class="keywordflow">return</span>;
<a name="l01673"></a>01673             }
<a name="l01674"></a>01674         }
<a name="l01675"></a>01675     }
<a name="l01676"></a>01676 
<a name="l01677"></a>01677     <span class="comment">/* NTS: Some HDI images of PC-98 games do in fact have BPB_NumHeads == 0. Some like &quot;Amaranth 5&quot; have BPB_SecPerTrk == 0 too! */</span>
<a name="l01678"></a>01678     <span class="keywordflow">if</span> (!IS_PC98_ARCH) {
<a name="l01679"></a>01679         <span class="comment">/* a clue that we&#39;re not really looking at FAT is invalid or weird values in the boot sector */</span>
<a name="l01680"></a>01680         <span class="keywordflow">if</span> (BPB.v.BPB_SecPerTrk == 0 || (BPB.v.BPB_SecPerTrk &gt; ((filesize &lt;= 3000) ? 40 : 255)) ||
<a name="l01681"></a>01681             (BPB.v.BPB_NumHeads &gt; ((filesize &lt;= 3000) ? 64 : 255))) {
<a name="l01682"></a>01682             LOG_MSG(<span class="stringliteral">&quot;Rejecting image, boot sector has weird values not consistent with FAT filesystem&quot;</span>);
<a name="l01683"></a>01683             created_successfully = <span class="keyword">false</span>;
<a name="l01684"></a>01684             <span class="keywordflow">return</span>;
<a name="l01685"></a>01685         }
<a name="l01686"></a>01686     }
<a name="l01687"></a>01687 
<a name="l01688"></a>01688     <span class="comment">/* work at this point in logical sectors */</span>
<a name="l01689"></a>01689         sector_size = loadedDisk-&gt;getSectSize();
<a name="l01690"></a>01690 
<a name="l01691"></a>01691     <span class="comment">/* Many HDI images indicate a disk format of 256 or 512 bytes per sector combined with a FAT filesystem</span>
<a name="l01692"></a>01692 <span class="comment">     * that indicates 1024 bytes per sector. */</span>
<a name="l01693"></a>01693     <span class="keywordflow">if</span> (pc98_512_to_1024_allow &amp;&amp;
<a name="l01694"></a>01694          BPB.v.BPB_BytsPerSec != fatDrive::getSectSize() &amp;&amp;
<a name="l01695"></a>01695          BPB.v.BPB_BytsPerSec &gt;  fatDrive::getSectSize() &amp;&amp;
<a name="l01696"></a>01696         (BPB.v.BPB_BytsPerSec %  fatDrive::getSectSize()) == 0) {
<a name="l01697"></a>01697         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ratioshift = 1;
<a name="l01698"></a>01698 
<a name="l01699"></a>01699         <span class="keywordflow">while</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(BPB.v.BPB_BytsPerSec &gt;&gt; ratioshift) &gt; fatDrive::getSectSize())
<a name="l01700"></a>01700             ratioshift++;
<a name="l01701"></a>01701 
<a name="l01702"></a>01702         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ratio = 1u &lt;&lt; ratioshift;
<a name="l01703"></a>01703 
<a name="l01704"></a>01704         LOG_MSG(<span class="stringliteral">&quot;Disk indicates %u bytes/sector, FAT filesystem indicates %u bytes/sector. Ratio=%u:1 shift=%u&quot;</span>,
<a name="l01705"></a>01705                 fatDrive::getSectSize(),BPB.v.BPB_BytsPerSec,ratio,ratioshift);
<a name="l01706"></a>01706 
<a name="l01707"></a>01707         <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(BPB.v.BPB_BytsPerSec &gt;&gt; ratioshift) == fatDrive::getSectSize()) {
<a name="l01708"></a>01708             assert(ratio &gt;= 2);
<a name="l01709"></a>01709 
<a name="l01710"></a>01710             <span class="comment">/* we can hack things in place IF the starting sector is an even number */</span>
<a name="l01711"></a>01711             <span class="keywordflow">if</span> ((partSectOff &amp; (ratio - 1)) == 0) {
<a name="l01712"></a>01712                 partSectOff &gt;&gt;= ratioshift;
<a name="l01713"></a>01713                 startSector &gt;&gt;= ratioshift;
<a name="l01714"></a>01714                 sector_size = BPB.v.BPB_BytsPerSec;
<a name="l01715"></a>01715                 LOG_MSG(<span class="stringliteral">&quot;Using logical sector size %u&quot;</span>,sector_size);
<a name="l01716"></a>01716             }
<a name="l01717"></a>01717             <span class="keywordflow">else</span> {
<a name="l01718"></a>01718                 LOG_MSG(<span class="stringliteral">&quot;However there&#39;s nothing I can do, because the partition starts on an odd sector&quot;</span>);
<a name="l01719"></a>01719             }
<a name="l01720"></a>01720         }
<a name="l01721"></a>01721     }
<a name="l01722"></a>01722 
<a name="l01723"></a>01723         <span class="comment">/* Sanity checks */</span>
<a name="l01724"></a>01724     <span class="comment">/* NTS: DOSBox-X *does* support non-standard sector sizes, though not in IBM PC mode and not through INT 13h.</span>
<a name="l01725"></a>01725 <span class="comment">     *      In DOSBox-X INT 13h emulation will enforce the standard (512 byte) sector size.</span>
<a name="l01726"></a>01726 <span class="comment">     *      In PC-98 mode mounting disk images requires &quot;non-standard&quot; sector sizes because PC-98 floppies (other</span>
<a name="l01727"></a>01727 <span class="comment">     *      than ones formatted 1.44MB) generally use 1024 bytes/sector and MAY use 128 or 256 bytes per sector. */</span>
<a name="l01728"></a>01728     <span class="comment">/* NTS: Loosen geometry checks for PC-98 mode, for two reasons. One, is that the geometry check will fail</span>
<a name="l01729"></a>01729 <span class="comment">     *      when logical vs physical sector translation is involved, since it is apparently common for PC-98 HDI</span>
<a name="l01730"></a>01730 <span class="comment">     *      images to be formatted with 256, 512, 1024, or in rare cases even 2048 bytes per sector, yet the FAT</span>
<a name="l01731"></a>01731 <span class="comment">     *      file format will report a sector size that is a power of 2 multiple of the disk sector size. The</span>
<a name="l01732"></a>01732 <span class="comment">     *      most common appears to be 512 byte/sector HDI images formatted with 1024 byte/sector FAT filesystems.</span>
<a name="l01733"></a>01733 <span class="comment">     *</span>
<a name="l01734"></a>01734 <span class="comment">     *      Second, there are some HDI images that are valid yet the FAT filesystem reports a head count of 0</span>
<a name="l01735"></a>01735 <span class="comment">     *      for some reason (Touhou Project) */</span>
<a name="l01736"></a>01736         <span class="keywordflow">if</span> ((BPB.v.BPB_SecPerClus == 0) ||
<a name="l01737"></a>01737                 (BPB.v.BPB_NumFATs == 0) ||
<a name="l01738"></a>01738                 (BPB.v.BPB_NumHeads == 0 &amp;&amp; !IS_PC98_ARCH) ||
<a name="l01739"></a>01739                 (BPB.v.BPB_NumHeads &gt; headscyl &amp;&amp; !IS_PC98_ARCH) ||
<a name="l01740"></a>01740                 (BPB.v.BPB_SecPerTrk == 0 &amp;&amp; !IS_PC98_ARCH) ||
<a name="l01741"></a>01741                 (BPB.v.BPB_SecPerTrk &gt; cylsector &amp;&amp; !IS_PC98_ARCH)) {
<a name="l01742"></a>01742                 LOG_MSG(<span class="stringliteral">&quot;Sanity checks failed&quot;</span>);
<a name="l01743"></a>01743                 created_successfully = <span class="keyword">false</span>;
<a name="l01744"></a>01744                 <span class="keywordflow">return</span>;
<a name="l01745"></a>01745         }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747     <span class="comment">/* Sanity check: Root directory count is nonzero if FAT16/FAT12, or is zero if FAT32 */</span>
<a name="l01748"></a>01748     <span class="keywordflow">if</span> (BPB.is_fat32()) {
<a name="l01749"></a>01749         <span class="keywordflow">if</span> (BPB.v.BPB_RootEntCnt != 0) {
<a name="l01750"></a>01750             LOG_MSG(<span class="stringliteral">&quot;Sanity check fail: Root directory count != 0 and not FAT32&quot;</span>);
<a name="l01751"></a>01751             created_successfully = <span class="keyword">false</span>;
<a name="l01752"></a>01752             <span class="keywordflow">return</span>;
<a name="l01753"></a>01753         }
<a name="l01754"></a>01754     }
<a name="l01755"></a>01755     <span class="keywordflow">else</span> {
<a name="l01756"></a>01756         <span class="keywordflow">if</span> (BPB.v.BPB_RootEntCnt == 0) {
<a name="l01757"></a>01757             LOG_MSG(<span class="stringliteral">&quot;Sanity check fail: Root directory count == 0 and not FAT32&quot;</span>);
<a name="l01758"></a>01758             created_successfully = <span class="keyword">false</span>;
<a name="l01759"></a>01759             <span class="keywordflow">return</span>;
<a name="l01760"></a>01760         }
<a name="l01761"></a>01761     }
<a name="l01762"></a>01762 
<a name="l01763"></a>01763     <span class="comment">/* too much of this code assumes 512 bytes per sector or more.</span>
<a name="l01764"></a>01764 <span class="comment">     * MS-DOS itself as I understand it relies on bytes per sector being a power of 2.</span>
<a name="l01765"></a>01765 <span class="comment">     * this is to protect against errant FAT structures and to help prep this code</span>
<a name="l01766"></a>01766 <span class="comment">     * later to work with the 1024 bytes/sector used by PC-98 floppy formats.</span>
<a name="l01767"></a>01767 <span class="comment">     * When done, this code should be able to then handle the FDI/FDD images</span>
<a name="l01768"></a>01768 <span class="comment">     * PC-98 games are normally distributed in on the internet.</span>
<a name="l01769"></a>01769 <span class="comment">     *</span>
<a name="l01770"></a>01770 <span class="comment">     * The value &quot;128&quot; comes from the smallest sector size possible on the floppy</span>
<a name="l01771"></a>01771 <span class="comment">     * controller of MS-DOS based systems. */</span>
<a name="l01772"></a>01772     <span class="comment">/* NTS: Power of 2 test: A number is a power of 2 if (x &amp; (x - 1)) == 0</span>
<a name="l01773"></a>01773 <span class="comment">     *</span>
<a name="l01774"></a>01774 <span class="comment">     * 15        15 &amp; 14       01111 AND 01110     RESULT: 01110 (15)</span>
<a name="l01775"></a>01775 <span class="comment">     * 16        16 &amp; 15       10000 AND 01111     RESULT: 00000 (0)</span>
<a name="l01776"></a>01776 <span class="comment">     * 17        17 &amp; 16       10001 AND 10000     RESULT: 10000 (16) */</span>
<a name="l01777"></a>01777     <span class="keywordflow">if</span> (BPB.v.BPB_BytsPerSec &lt; 128 || BPB.v.BPB_BytsPerSec &gt; SECTOR_SIZE_MAX ||
<a name="l01778"></a>01778         (BPB.v.BPB_BytsPerSec &amp; (BPB.v.BPB_BytsPerSec - 1)) != 0<span class="comment">/*not a power of 2*/</span>) {
<a name="l01779"></a>01779         LOG_MSG(<span class="stringliteral">&quot;FAT bytes/sector value %u not supported&quot;</span>,BPB.v.BPB_BytsPerSec);
<a name="l01780"></a>01780                 created_successfully = <span class="keyword">false</span>;
<a name="l01781"></a>01781         <span class="keywordflow">return</span>;
<a name="l01782"></a>01782     }
<a name="l01783"></a>01783 
<a name="l01784"></a>01784     <span class="comment">/* another fault of this code is that it assumes the sector size of the medium matches</span>
<a name="l01785"></a>01785 <span class="comment">     * the BPB_BytsPerSec value of the MS-DOS filesystem. if they don&#39;t match, problems</span>
<a name="l01786"></a>01786 <span class="comment">     * will result. */</span>
<a name="l01787"></a>01787     <span class="keywordflow">if</span> (BPB.v.BPB_BytsPerSec != fatDrive::getSectSize()) {
<a name="l01788"></a>01788         LOG_MSG(<span class="stringliteral">&quot;FAT bytes/sector %u does not match disk image bytes/sector %u&quot;</span>,
<a name="l01789"></a>01789             (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)BPB.v.BPB_BytsPerSec,
<a name="l01790"></a>01790             (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)fatDrive::getSectSize());
<a name="l01791"></a>01791                 created_successfully = <span class="keyword">false</span>;
<a name="l01792"></a>01792         <span class="keywordflow">return</span>;
<a name="l01793"></a>01793     }
<a name="l01794"></a>01794 
<a name="l01795"></a>01795         <span class="comment">/* Filesystem must be contiguous to use absolute sectors, otherwise CHS will be used */</span>
<a name="l01796"></a>01796         absolute = IS_PC98_ARCH || ((BPB.v.BPB_NumHeads == headscyl) &amp;&amp; (BPB.v.BPB_SecPerTrk == cylsector));
<a name="l01797"></a>01797         <a class="code" href="classLOG.html">LOG</a>(LOG_DOSMISC,LOG_DEBUG)(<span class="stringliteral">&quot;FAT driver: Using %s sector access&quot;</span>,absolute ? <span class="stringliteral">&quot;absolute&quot;</span> : <span class="stringliteral">&quot;C/H/S&quot;</span>);
<a name="l01798"></a>01798 
<a name="l01799"></a>01799         <span class="comment">/* Determine FAT format, 12, 16 or 32 */</span>
<a name="l01800"></a>01800 
<a name="l01801"></a>01801         <span class="comment">/* Get size of root dir in sectors */</span>
<a name="l01802"></a>01802         Bit32u RootDirSectors;
<a name="l01803"></a>01803         Bit32u DataSectors;
<a name="l01804"></a>01804 
<a name="l01805"></a>01805     <span class="keywordflow">if</span> (BPB.is_fat32()) {
<a name="l01806"></a>01806         <span class="comment">/* FAT32 requires use of TotSec32, TotSec16 must be zero. */</span>
<a name="l01807"></a>01807         <span class="keywordflow">if</span> (BPB.v.BPB_TotSec32 == 0) {
<a name="l01808"></a>01808             LOG_MSG(<span class="stringliteral">&quot;BPB_TotSec32 == 0 and FAT32 BPB, not valid&quot;</span>);
<a name="l01809"></a>01809             created_successfully = <span class="keyword">false</span>;
<a name="l01810"></a>01810             <span class="keywordflow">return</span>;
<a name="l01811"></a>01811         }
<a name="l01812"></a>01812         <span class="keywordflow">if</span> (BPB.v32.BPB_RootClus &lt; 2) {
<a name="l01813"></a>01813             LOG_MSG(<span class="stringliteral">&quot;BPB_RootClus == 0 and FAT32 BPB, not valid&quot;</span>);
<a name="l01814"></a>01814             created_successfully = <span class="keyword">false</span>;
<a name="l01815"></a>01815             <span class="keywordflow">return</span>;
<a name="l01816"></a>01816         }
<a name="l01817"></a>01817         <span class="keywordflow">if</span> (BPB.v.BPB_FATSz16 != 0) {
<a name="l01818"></a>01818             LOG_MSG(<span class="stringliteral">&quot;BPB_FATSz16 != 0 and FAT32 BPB, not valid&quot;</span>);
<a name="l01819"></a>01819             created_successfully = <span class="keyword">false</span>;
<a name="l01820"></a>01820             <span class="keywordflow">return</span>;
<a name="l01821"></a>01821         }
<a name="l01822"></a>01822         <span class="keywordflow">if</span> (BPB.v32.BPB_FATSz32 == 0) {
<a name="l01823"></a>01823             LOG_MSG(<span class="stringliteral">&quot;BPB_FATSz32 == 0 and FAT32 BPB, not valid&quot;</span>);
<a name="l01824"></a>01824             created_successfully = <span class="keyword">false</span>;
<a name="l01825"></a>01825             <span class="keywordflow">return</span>;
<a name="l01826"></a>01826         }
<a name="l01827"></a>01827 
<a name="l01828"></a>01828         RootDirSectors = 0; <span class="comment">/* FAT32 root directory has it&#39;s own allocation chain, instead of a fixed location */</span>
<a name="l01829"></a>01829         DataSectors = (Bitu)BPB.v.BPB_TotSec32 - ((Bitu)BPB.v.BPB_RsvdSecCnt + ((Bitu)BPB.v.BPB_NumFATs * (Bitu)BPB.v32.BPB_FATSz32) + (Bitu)RootDirSectors);
<a name="l01830"></a>01830         CountOfClusters = DataSectors / BPB.v.BPB_SecPerClus;
<a name="l01831"></a>01831         firstDataSector = ((Bitu)BPB.v.BPB_RsvdSecCnt + ((Bitu)BPB.v.BPB_NumFATs * (Bitu)BPB.v32.BPB_FATSz32) + (Bitu)RootDirSectors) + (Bitu)partSectOff;
<a name="l01832"></a>01832         firstRootDirSect = 0;
<a name="l01833"></a>01833     }
<a name="l01834"></a>01834     <span class="keywordflow">else</span> {
<a name="l01835"></a>01835         <span class="keywordflow">if</span> (BPB.v.BPB_FATSz16 == 0) {
<a name="l01836"></a>01836             LOG_MSG(<span class="stringliteral">&quot;BPB_FATSz16 == 0 and not FAT32 BPB, not valid&quot;</span>);
<a name="l01837"></a>01837             created_successfully = <span class="keyword">false</span>;
<a name="l01838"></a>01838             <span class="keywordflow">return</span>;
<a name="l01839"></a>01839         }
<a name="l01840"></a>01840 
<a name="l01841"></a>01841         RootDirSectors = ((BPB.v.BPB_RootEntCnt * 32u) + (BPB.v.BPB_BytsPerSec - 1u)) / BPB.v.BPB_BytsPerSec;
<a name="l01842"></a>01842 
<a name="l01843"></a>01843         if (BPB.v.BPB_TotSec16 != 0)
<a name="l01844"></a>01844             DataSectors = (Bitu)BPB.v.BPB_TotSec16 - ((Bitu)BPB.v.BPB_RsvdSecCnt + ((Bitu)BPB.v.BPB_NumFATs * (Bitu)BPB.v.BPB_FATSz16) + (Bitu)RootDirSectors);
<a name="l01845"></a>01845         <span class="keywordflow">else</span>
<a name="l01846"></a>01846             DataSectors = (Bitu)BPB.v.BPB_TotSec32 - ((Bitu)BPB.v.BPB_RsvdSecCnt + ((Bitu)BPB.v.BPB_NumFATs * (Bitu)BPB.v.BPB_FATSz16) + (Bitu)RootDirSectors);
<a name="l01847"></a>01847 
<a name="l01848"></a>01848         CountOfClusters = DataSectors / BPB.v.BPB_SecPerClus;
<a name="l01849"></a>01849         firstDataSector = ((Bitu)BPB.v.BPB_RsvdSecCnt + ((Bitu)BPB.v.BPB_NumFATs * (Bitu)BPB.v.BPB_FATSz16) + (Bitu)RootDirSectors) + (Bitu)partSectOff;
<a name="l01850"></a>01850         firstRootDirSect = (Bitu)BPB.v.BPB_RsvdSecCnt + ((Bitu)BPB.v.BPB_NumFATs * (Bitu)BPB.v.BPB_FATSz16) + (Bitu)partSectOff;
<a name="l01851"></a>01851     }
<a name="l01852"></a>01852 
<a name="l01853"></a>01853         <span class="keywordflow">if</span>(CountOfClusters &lt; 4085) {
<a name="l01854"></a>01854                 <span class="comment">/* Volume is FAT12 */</span>
<a name="l01855"></a>01855                 LOG_MSG(<span class="stringliteral">&quot;Mounted FAT volume is FAT12 with %d clusters&quot;</span>, CountOfClusters);
<a name="l01856"></a>01856                 fattype = FAT12;
<a name="l01857"></a>01857         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CountOfClusters &lt; 65525) {
<a name="l01858"></a>01858                 LOG_MSG(<span class="stringliteral">&quot;Mounted FAT volume is FAT16 with %d clusters&quot;</span>, CountOfClusters);
<a name="l01859"></a>01859                 fattype = FAT16;
<a name="l01860"></a>01860         } <span class="keywordflow">else</span> {
<a name="l01861"></a>01861                 LOG_MSG(<span class="stringliteral">&quot;Mounted FAT volume is FAT32 with %d clusters&quot;</span>, CountOfClusters);
<a name="l01862"></a>01862                 fattype = FAT32;
<a name="l01863"></a>01863         }
<a name="l01864"></a>01864 
<a name="l01865"></a>01865         <span class="comment">/* just so you know....! */</span>
<a name="l01866"></a>01866         <span class="keywordflow">if</span> (fattype == FAT32 &amp;&amp; (dos.version.major &lt; 7 || (dos.version.major == 7 &amp;&amp; dos.version.minor &lt; 10))) {
<a name="l01867"></a>01867                 LOG_MSG(<span class="stringliteral">&quot;CAUTION: Mounting FAT32 partition when reported DOS version is less than 7.10. Disk formatting/repair utilities may mis-identify the partition.&quot;</span>);
<a name="l01868"></a>01868         }
<a name="l01869"></a>01869 
<a name="l01870"></a>01870         <span class="comment">/* There is no cluster 0, this means we are in the root directory */</span>
<a name="l01871"></a>01871         cwdDirCluster = 0;
<a name="l01872"></a>01872 
<a name="l01873"></a>01873         memset(fatSectBuffer,0,1024);
<a name="l01874"></a>01874         curFatSect = 0xffffffff;
<a name="l01875"></a>01875 
<a name="l01876"></a>01876         strcpy(info, <span class="stringliteral">&quot;fatDrive &quot;</span>);
<a name="l01877"></a>01877         strcat(info, wpcolon&amp;&amp;strlen(sysFilename)&gt;1&amp;&amp;sysFilename[0]==<span class="charliteral">&#39;:&#39;</span>?sysFilename+1:sysFilename);
<a name="l01878"></a>01878 }
<a name="l01879"></a>01879 
<a name="l01880"></a>01880 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l01881"></a>01881 <span class="preprocessor"></span><span class="preprocessor"># define MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span>
<a name="l01882"></a>01882 <span class="preprocessor"></span><span class="preprocessor"># define MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span>
<a name="l01883"></a>01883 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01884"></a>01884 <span class="preprocessor"></span><span class="preprocessor"># define MIN(a,b) std::min(a,b)</span>
<a name="l01885"></a>01885 <span class="preprocessor"></span><span class="preprocessor"># define MAX(a,b) std::max(a,b)</span>
<a name="l01886"></a>01886 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01887"></a>01887 <span class="preprocessor"></span>
<a name="l01888"></a>01888 <span class="keywordtype">bool</span> fatDrive::AllocationInfo32(Bit32u * _bytes_sector,Bit32u * _sectors_cluster,Bit32u * _total_clusters,Bit32u * _free_clusters) {
<a name="l01889"></a>01889         Bit32u countFree = 0;
<a name="l01890"></a>01890         Bit32u i;
<a name="l01891"></a>01891 
<a name="l01892"></a>01892         <span class="keywordflow">for</span>(i=0;i&lt;CountOfClusters;i++) {
<a name="l01893"></a>01893                 <span class="keywordflow">if</span>(!getClusterValue(i+2))
<a name="l01894"></a>01894                         countFree++;
<a name="l01895"></a>01895         }
<a name="l01896"></a>01896 
<a name="l01897"></a>01897         *_bytes_sector = getSectSize();
<a name="l01898"></a>01898         *_sectors_cluster = BPB.v.BPB_SecPerClus;
<a name="l01899"></a>01899         *_total_clusters = CountOfClusters;
<a name="l01900"></a>01900         *_free_clusters = countFree;
<a name="l01901"></a>01901 
<a name="l01902"></a>01902         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01903"></a>01903 }
<a name="l01904"></a>01904 
<a name="l01905"></a>01905 <span class="keywordtype">bool</span> fatDrive::AllocationInfo(Bit16u *_bytes_sector, Bit8u *_sectors_cluster, Bit16u *_total_clusters, Bit16u *_free_clusters) {
<a name="l01906"></a>01906         <span class="keywordflow">if</span> (BPB.is_fat32()) {
<a name="l01907"></a>01907                 Bit32u bytes32,sectors32,clusters32,free32;
<a name="l01908"></a>01908                 <span class="keywordflow">if</span> (AllocationInfo32(&amp;bytes32,&amp;sectors32,&amp;clusters32,&amp;free32) &amp;&amp;
<a name="l01909"></a>01909                         DOS_CommonFAT32FAT16DiskSpaceConv(_bytes_sector,_sectors_cluster,_total_clusters,_free_clusters,bytes32,sectors32,clusters32,free32))
<a name="l01910"></a>01910                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01911"></a>01911 
<a name="l01912"></a>01912                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01913"></a>01913         }
<a name="l01914"></a>01914         <span class="keywordflow">else</span> {
<a name="l01915"></a>01915                 Bit32u countFree = 0;
<a name="l01916"></a>01916                 Bit32u i;
<a name="l01917"></a>01917 
<a name="l01918"></a>01918                 <span class="keywordflow">for</span>(i=0;i&lt;CountOfClusters;i++) {
<a name="l01919"></a>01919                         <span class="keywordflow">if</span>(!getClusterValue(i+2))
<a name="l01920"></a>01920                                 countFree++;
<a name="l01921"></a>01921                 }
<a name="l01922"></a>01922 
<a name="l01923"></a>01923                 <span class="comment">/* FAT12/FAT16 should never allow more than 0xFFF6 clusters and partitions larger than 2GB */</span>
<a name="l01924"></a>01924                 *_bytes_sector = (Bit16u)getSectSize();
<a name="l01925"></a>01925                 *_sectors_cluster = BPB.v.BPB_SecPerClus;
<a name="l01926"></a>01926                 *_total_clusters = (Bit16u)MIN(CountOfClusters,0xFFFFu);
<a name="l01927"></a>01927                 *_free_clusters = (Bit16u)MIN(countFree,0xFFFFu);
<a name="l01928"></a>01928         }
<a name="l01929"></a>01929 
<a name="l01930"></a>01930         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01931"></a>01931 }
<a name="l01932"></a>01932 
<a name="l01933"></a>01933 Bit32u fatDrive::getFirstFreeClust(<span class="keywordtype">void</span>) {
<a name="l01934"></a>01934         Bit32u i;
<a name="l01935"></a>01935         <span class="keywordflow">for</span>(i=0;i&lt;CountOfClusters;i++) {
<a name="l01936"></a>01936                 <span class="keywordflow">if</span>(!getClusterValue(i+2)) <span class="keywordflow">return</span> (i+2);
<a name="l01937"></a>01937         }
<a name="l01938"></a>01938 
<a name="l01939"></a>01939         <span class="comment">/* No free cluster found */</span>
<a name="l01940"></a>01940         <span class="keywordflow">return</span> 0;
<a name="l01941"></a>01941 }
<a name="l01942"></a>01942 
<a name="l01943"></a>01943 <span class="keywordtype">bool</span> fatDrive::isRemote(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l01944"></a>01944 <span class="keywordtype">bool</span> fatDrive::isRemovable(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l01945"></a>01945 
<a name="l01946"></a>01946 Bits fatDrive::UnMount(<span class="keywordtype">void</span>) {
<a name="l01947"></a>01947         <span class="keyword">delete</span> <span class="keyword">this</span>;
<a name="l01948"></a>01948         <span class="keywordflow">return</span> 0;
<a name="l01949"></a>01949 }
<a name="l01950"></a>01950 
<a name="l01951"></a>01951 Bit8u fatDrive::GetMediaByte(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> BPB.v.BPB_Media; }
<a name="l01952"></a>01952 <span class="keyword">const</span> <a class="code" href="unionFAT__BootSector_1_1bpb__union__t.html">FAT_BootSector::bpb_union_t</a> &amp;fatDrive::GetBPB(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> BPB; }
<a name="l01953"></a>01953 
<a name="l01954"></a>01954 <span class="keywordtype">void</span> fatDrive::SetBPB(<span class="keyword">const</span> <a class="code" href="unionFAT__BootSector_1_1bpb__union__t.html">FAT_BootSector::bpb_union_t</a> &amp;bpb) {
<a name="l01955"></a>01955         <span class="keywordflow">if</span> (readonly) <span class="keywordflow">return</span>;
<a name="l01956"></a>01956         BPB.v.BPB_BytsPerSec = bpb.v.BPB_BytsPerSec;
<a name="l01957"></a>01957         BPB.v.BPB_SecPerClus = bpb.v.BPB_SecPerClus;
<a name="l01958"></a>01958         BPB.v.BPB_RsvdSecCnt = bpb.v.BPB_RsvdSecCnt;
<a name="l01959"></a>01959         BPB.v.BPB_NumFATs = bpb.v.BPB_NumFATs;
<a name="l01960"></a>01960         BPB.v.BPB_RootEntCnt = bpb.v.BPB_RootEntCnt;
<a name="l01961"></a>01961         BPB.v.BPB_TotSec16 = bpb.v.BPB_TotSec16;
<a name="l01962"></a>01962         BPB.v.BPB_Media = bpb.v.BPB_Media;
<a name="l01963"></a>01963         BPB.v.BPB_FATSz16 = bpb.v.BPB_FATSz16;
<a name="l01964"></a>01964         BPB.v.BPB_SecPerTrk = bpb.v.BPB_SecPerTrk;
<a name="l01965"></a>01965         BPB.v.BPB_NumHeads = bpb.v.BPB_NumHeads;
<a name="l01966"></a>01966         BPB.v.BPB_HiddSec = bpb.v.BPB_HiddSec;
<a name="l01967"></a>01967         BPB.v.BPB_TotSec32 = bpb.v.BPB_TotSec32;
<a name="l01968"></a>01968         <span class="keywordflow">if</span> (!bpb.is_fat32() &amp;&amp; (bpb.v.BPB_BootSig == 0x28 || bpb.v.BPB_BootSig == 0x29))
<a name="l01969"></a>01969                 BPB.v.BPB_VolID = bpb.v.BPB_VolID;
<a name="l01970"></a>01970         <span class="keywordflow">if</span> (bpb.is_fat32() &amp;&amp; (bpb.v32.BS_BootSig == 0x28 || bpb.v32.BS_BootSig == 0x29))
<a name="l01971"></a>01971                 BPB.v32.BS_VolID = bpb.v32.BS_VolID;
<a name="l01972"></a>01972         <span class="keywordflow">if</span> (bpb.is_fat32()) {
<a name="l01973"></a>01973                 BPB.v32.BPB_BytsPerSec = bpb.v32.BPB_BytsPerSec;
<a name="l01974"></a>01974                 BPB.v32.BPB_SecPerClus = bpb.v32.BPB_SecPerClus;
<a name="l01975"></a>01975                 BPB.v32.BPB_RsvdSecCnt = bpb.v32.BPB_RsvdSecCnt;
<a name="l01976"></a>01976                 BPB.v32.BPB_NumFATs = bpb.v32.BPB_NumFATs;
<a name="l01977"></a>01977                 BPB.v32.BPB_RootEntCnt = bpb.v32.BPB_RootEntCnt;
<a name="l01978"></a>01978                 BPB.v32.BPB_TotSec16 = bpb.v32.BPB_TotSec16;
<a name="l01979"></a>01979                 BPB.v32.BPB_Media = bpb.v32.BPB_Media;
<a name="l01980"></a>01980                 BPB.v32.BPB_FATSz32 = bpb.v32.BPB_FATSz32;
<a name="l01981"></a>01981                 BPB.v32.BPB_SecPerTrk = bpb.v32.BPB_SecPerTrk;
<a name="l01982"></a>01982                 BPB.v32.BPB_NumHeads = bpb.v32.BPB_NumHeads;
<a name="l01983"></a>01983                 BPB.v32.BPB_HiddSec = bpb.v32.BPB_HiddSec;
<a name="l01984"></a>01984                 BPB.v32.BPB_TotSec32 = bpb.v32.BPB_TotSec32;
<a name="l01985"></a>01985                 BPB.v32.BPB_FATSz32 = bpb.v32.BPB_FATSz32;
<a name="l01986"></a>01986                 BPB.v32.BPB_ExtFlags = bpb.v32.BPB_ExtFlags;
<a name="l01987"></a>01987                 BPB.v32.BPB_FSVer = bpb.v32.BPB_FSVer;
<a name="l01988"></a>01988                 BPB.v32.BPB_RootClus = bpb.v32.BPB_RootClus;
<a name="l01989"></a>01989                 BPB.v32.BPB_FSInfo = bpb.v32.BPB_FSInfo;
<a name="l01990"></a>01990                 BPB.v32.BPB_BkBootSec = bpb.v32.BPB_BkBootSec;
<a name="l01991"></a>01991         }
<a name="l01992"></a>01992 
<a name="l01993"></a>01993     <a class="code" href="structFAT__BootSector.html">FAT_BootSector</a> bootbuffer = {};
<a name="l01994"></a>01994     loadedDisk-&gt;Read_AbsoluteSector(0+partSectOff,&amp;bootbuffer);
<a name="l01995"></a>01995         <span class="keywordflow">if</span> (BPB.is_fat32()) bootbuffer.bpb.v32=BPB.v32;
<a name="l01996"></a>01996         bootbuffer.bpb.v=BPB.v;
<a name="l01997"></a>01997     loadedDisk-&gt;Write_AbsoluteSector(0+partSectOff,&amp;bootbuffer);
<a name="l01998"></a>01998 }
<a name="l01999"></a>01999 
<a name="l02000"></a>02000 <span class="keywordtype">bool</span> fatDrive::FileCreate(<a class="code" href="classDOS__File.html">DOS_File</a> **file, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, Bit16u attributes) {
<a name="l02001"></a>02001         <span class="keyword">const</span> <span class="keywordtype">char</span> *lfn = NULL;
<a name="l02002"></a>02002 
<a name="l02003"></a>02003     <span class="keywordflow">if</span> (readonly) {
<a name="l02004"></a>02004                 DOS_SetError(DOSERR_WRITE_PROTECTED);
<a name="l02005"></a>02005         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02006"></a>02006     }
<a name="l02007"></a>02007     <a class="code" href="structdirentry.html">direntry</a> fileEntry = {};
<a name="l02008"></a>02008         Bit32u dirClust, subEntry;
<a name="l02009"></a>02009         <span class="keywordtype">char</span> dirName[DOS_NAMELENGTH_ASCII];
<a name="l02010"></a>02010         <span class="keywordtype">char</span> pathName[11], path[DOS_PATHLENGTH];
<a name="l02011"></a>02011 
<a name="l02012"></a>02012         Bit16u save_errorcode=dos.errorcode;
<a name="l02013"></a>02013 
<a name="l02014"></a>02014         <span class="keywordflow">if</span> (attributes &amp; DOS_ATTR_VOLUME) {
<a name="l02015"></a>02015                 SetLabel(name,<span class="keyword">false</span>,<span class="keyword">true</span>);
<a name="l02016"></a>02016                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02017"></a>02017         }
<a name="l02018"></a>02018         <span class="keywordflow">if</span> (attributes &amp; DOS_ATTR_DIRECTORY) {
<a name="l02019"></a>02019                 DOS_SetError(DOSERR_ACCESS_DENIED);
<a name="l02020"></a>02020                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02021"></a>02021         }
<a name="l02022"></a>02022 
<a name="l02023"></a>02023         <span class="comment">/* you cannot create root directory */</span>
<a name="l02024"></a>02024         <span class="keywordflow">if</span> (*name == 0) {
<a name="l02025"></a>02025                 DOS_SetError(DOSERR_ACCESS_DENIED);
<a name="l02026"></a>02026                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02027"></a>02027         }
<a name="l02028"></a>02028 
<a name="l02029"></a>02029         <span class="comment">/* Check if file already exists */</span>
<a name="l02030"></a>02030         <span class="keywordflow">if</span>(getFileDirEntry(name, &amp;fileEntry, &amp;dirClust, &amp;subEntry, <span class="keyword">true</span><span class="comment">/*dirOk*/</span>)) {
<a name="l02031"></a>02031                 <span class="comment">/* You can&#39;t create/truncate a directory! */</span>
<a name="l02032"></a>02032                 <span class="keywordflow">if</span> (fileEntry.attrib &amp; DOS_ATTR_DIRECTORY) {
<a name="l02033"></a>02033                         DOS_SetError(DOSERR_ACCESS_DENIED);
<a name="l02034"></a>02034                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02035"></a>02035                 }
<a name="l02036"></a>02036 
<a name="l02037"></a>02037                 <span class="comment">/* Truncate file allocation chain */</span>
<a name="l02038"></a>02038                 {
<a name="l02039"></a>02039                         <span class="keyword">const</span> Bit32u chk = BPB.is_fat32() ? fileEntry.Cluster32() : fileEntry.loFirstClust;
<a name="l02040"></a>02040                         <span class="keywordflow">if</span>(chk != 0) deleteClustChain(chk, 0);
<a name="l02041"></a>02041                 }
<a name="l02042"></a>02042                 <span class="comment">/* Update directory entry */</span>
<a name="l02043"></a>02043                 fileEntry.entrysize=0;
<a name="l02044"></a>02044                 fileEntry.SetCluster32(0);
<a name="l02045"></a>02045                 directoryChange(dirClust, &amp;fileEntry, (Bit32s)subEntry);
<a name="l02046"></a>02046         } <span class="keywordflow">else</span> {
<a name="l02047"></a>02047                 <span class="comment">/* Can we even get the name of the file itself? */</span>
<a name="l02048"></a>02048                 <span class="keywordflow">if</span>(!getEntryName(name, &amp;dirName[0])||!strlen(trim(dirName))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02049"></a>02049                 convToDirFile(&amp;dirName[0], &amp;pathName[0]);
<a name="l02050"></a>02050 
<a name="l02051"></a>02051                 <span class="comment">/* Can we find the base directory? */</span>
<a name="l02052"></a>02052                 <span class="keywordflow">if</span>(!getDirClustNum(name, &amp;dirClust, <span class="keyword">true</span>)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02053"></a>02053 
<a name="l02054"></a>02054                 <span class="comment">/* NTS: &quot;name&quot; is the full relative path. For LFN creation to work we need only the final element of the path */</span>
<a name="l02055"></a>02055                 <span class="keywordflow">if</span> (uselfn &amp;&amp; !force_sfn) {
<a name="l02056"></a>02056                         lfn = strrchr(name,<span class="charliteral">&#39;\\&#39;</span>);
<a name="l02057"></a>02057 
<a name="l02058"></a>02058                         <span class="keywordflow">if</span> (lfn != NULL) {
<a name="l02059"></a>02059                                 lfn++; <span class="comment">/* step past &#39;\&#39; */</span>
<a name="l02060"></a>02060                                 strcpy(path, name);
<a name="l02061"></a>02061                                 *(strrchr(path,<span class="charliteral">&#39;\\&#39;</span>)+1)=0;
<a name="l02062"></a>02062                         } <span class="keywordflow">else</span> {
<a name="l02063"></a>02063                                 lfn = name; <span class="comment">/* no path elements */</span>
<a name="l02064"></a>02064                                 *path=0;
<a name="l02065"></a>02065                         }
<a name="l02066"></a>02066 
<a name="l02067"></a>02067                         <span class="keywordflow">if</span> (filename_not_strict_8x3(lfn)) {
<a name="l02068"></a>02068                                 <span class="keywordtype">char</span> *sfn=Generate_SFN(path, lfn);
<a name="l02069"></a>02069                                 <span class="keywordflow">if</span> (sfn!=NULL) convToDirFile(sfn, &amp;pathName[0]);
<a name="l02070"></a>02070                         } <span class="keywordflow">else</span>
<a name="l02071"></a>02071                                 lfn = NULL;
<a name="l02072"></a>02072                 }
<a name="l02073"></a>02073 
<a name="l02074"></a>02074                 memset(&amp;fileEntry, 0, <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>));
<a name="l02075"></a>02075                 memcpy(&amp;fileEntry.entryname, &amp;pathName[0], 11);
<a name="l02076"></a>02076         {
<a name="l02077"></a>02077             Bit16u ct,cd;
<a name="l02078"></a>02078             time_t_to_DOS_DateTime(<span class="comment">/*&amp;*/</span>ct,<span class="comment">/*&amp;*/</span>cd,time(NULL));
<a name="l02079"></a>02079             fileEntry.modTime = ct;
<a name="l02080"></a>02080             fileEntry.modDate = cd;
<a name="l02081"></a>02081         }
<a name="l02082"></a>02082         fileEntry.attrib = (Bit8u)(attributes &amp; 0xff);
<a name="l02083"></a>02083                 addDirectoryEntry(dirClust, fileEntry, lfn);
<a name="l02084"></a>02084 
<a name="l02085"></a>02085                 <span class="comment">/* Check if file exists now */</span>
<a name="l02086"></a>02086                 <span class="keywordflow">if</span>(!getFileDirEntry(name, &amp;fileEntry, &amp;dirClust, &amp;subEntry)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02087"></a>02087         }
<a name="l02088"></a>02088 
<a name="l02089"></a>02089         <span class="comment">/* Empty file created, now lets open it */</span>
<a name="l02090"></a>02090         <span class="comment">/* TODO: check for read-only flag and requested write access */</span>
<a name="l02091"></a>02091         *file = <span class="keyword">new</span> <a class="code" href="classfatFile.html">fatFile</a>(name, BPB.is_fat32() ? fileEntry.Cluster32() : fileEntry.loFirstClust, fileEntry.entrysize, <span class="keyword">this</span>);
<a name="l02092"></a>02092         (*file)-&gt;flags=OPEN_READWRITE;
<a name="l02093"></a>02093         ((<a class="code" href="classfatFile.html">fatFile</a> *)(*file))-&gt;dirCluster = dirClust;
<a name="l02094"></a>02094         ((<a class="code" href="classfatFile.html">fatFile</a> *)(*file))-&gt;dirIndex = subEntry;
<a name="l02095"></a>02095         <span class="comment">/* Maybe modTime and date should be used ? (crt matches findnext) */</span>
<a name="l02096"></a>02096         ((<a class="code" href="classfatFile.html">fatFile</a> *)(*file))-&gt;time = fileEntry.modTime;
<a name="l02097"></a>02097         ((<a class="code" href="classfatFile.html">fatFile</a> *)(*file))-&gt;date = fileEntry.modDate;
<a name="l02098"></a>02098 
<a name="l02099"></a>02099         dos.errorcode=save_errorcode;
<a name="l02100"></a>02100         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02101"></a>02101 }
<a name="l02102"></a>02102 
<a name="l02103"></a>02103 <span class="keywordtype">bool</span> fatDrive::FileExists(<span class="keyword">const</span> <span class="keywordtype">char</span> *name) {
<a name="l02104"></a>02104     <a class="code" href="structdirentry.html">direntry</a> fileEntry = {};
<a name="l02105"></a>02105         Bit32u dummy1, dummy2;
<a name="l02106"></a>02106         <span class="keywordflow">if</span>(!getFileDirEntry(name, &amp;fileEntry, &amp;dummy1, &amp;dummy2)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02107"></a>02107         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02108"></a>02108 }
<a name="l02109"></a>02109 
<a name="l02110"></a>02110 <span class="keywordtype">bool</span> fatDrive::FileOpen(<a class="code" href="classDOS__File.html">DOS_File</a> **file, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, Bit32u flags) {
<a name="l02111"></a>02111     <a class="code" href="structdirentry.html">direntry</a> fileEntry = {};
<a name="l02112"></a>02112         Bit32u dirClust, subEntry;
<a name="l02113"></a>02113 
<a name="l02114"></a>02114         <span class="comment">/* you cannot open root directory */</span>
<a name="l02115"></a>02115         <span class="keywordflow">if</span> (*name == 0) {
<a name="l02116"></a>02116                 DOS_SetError(DOSERR_ACCESS_DENIED);
<a name="l02117"></a>02117                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02118"></a>02118         }
<a name="l02119"></a>02119 
<a name="l02120"></a>02120         <span class="keywordflow">if</span>(!getFileDirEntry(name, &amp;fileEntry, &amp;dirClust, &amp;subEntry)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02121"></a>02121         <span class="comment">/* TODO: check for read-only flag and requested write access */</span>
<a name="l02122"></a>02122         *file = <span class="keyword">new</span> <a class="code" href="classfatFile.html">fatFile</a>(name, BPB.is_fat32() ? fileEntry.Cluster32() : fileEntry.loFirstClust, fileEntry.entrysize, <span class="keyword">this</span>);
<a name="l02123"></a>02123         (*file)-&gt;flags = flags;
<a name="l02124"></a>02124         ((<a class="code" href="classfatFile.html">fatFile</a> *)(*file))-&gt;dirCluster = dirClust;
<a name="l02125"></a>02125         ((<a class="code" href="classfatFile.html">fatFile</a> *)(*file))-&gt;dirIndex = subEntry;
<a name="l02126"></a>02126         <span class="comment">/* Maybe modTime and date should be used ? (crt matches findnext) */</span>
<a name="l02127"></a>02127         ((<a class="code" href="classfatFile.html">fatFile</a> *)(*file))-&gt;time = fileEntry.modTime;
<a name="l02128"></a>02128         ((<a class="code" href="classfatFile.html">fatFile</a> *)(*file))-&gt;date = fileEntry.modDate;
<a name="l02129"></a>02129         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02130"></a>02130 }
<a name="l02131"></a>02131 
<a name="l02132"></a>02132 <span class="keywordtype">bool</span> fatDrive::FileStat(<span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="comment">/*name*/</span>, <a class="code" href="structFileStat__Block.html">FileStat_Block</a> *<span class="keyword">const</span> <span class="comment">/*stat_block*/</span>) {
<a name="l02133"></a>02133         <span class="comment">/* TODO: Stub */</span>
<a name="l02134"></a>02134         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02135"></a>02135 }
<a name="l02136"></a>02136 
<a name="l02137"></a>02137 <span class="keywordtype">bool</span> fatDrive::FileUnlink(<span class="keyword">const</span> <span class="keywordtype">char</span> * name) {
<a name="l02138"></a>02138     <span class="keywordflow">if</span> (readonly) {
<a name="l02139"></a>02139                 DOS_SetError(DOSERR_WRITE_PROTECTED);
<a name="l02140"></a>02140         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02141"></a>02141     }
<a name="l02142"></a>02142     <a class="code" href="structdirentry.html">direntry</a> tmpentry = {};
<a name="l02143"></a>02143     <a class="code" href="structdirentry.html">direntry</a> fileEntry = {};
<a name="l02144"></a>02144         Bit32u dirClust, subEntry;
<a name="l02145"></a>02145 
<a name="l02146"></a>02146         <span class="comment">/* you cannot delete root directory */</span>
<a name="l02147"></a>02147         <span class="keywordflow">if</span> (*name == 0) {
<a name="l02148"></a>02148                 DOS_SetError(DOSERR_ACCESS_DENIED);
<a name="l02149"></a>02149                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02150"></a>02150         }
<a name="l02151"></a>02151 
<a name="l02152"></a>02152         lfnRange.clear();
<a name="l02153"></a>02153         <span class="keywordflow">if</span>(!getFileDirEntry(name, &amp;fileEntry, &amp;dirClust, &amp;subEntry)) <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">/* Do not use dirOk, DOS should never call this unless a file */</span>
<a name="l02154"></a>02154         lfnRange_t dir_lfn_range = lfnRange; <span class="comment">/* copy down LFN results before they are obliterated by the next call to FindNextInternal. */</span>
<a name="l02155"></a>02155 
<a name="l02156"></a>02156         <span class="comment">/* delete LFNs */</span>
<a name="l02157"></a>02157         <span class="keywordflow">if</span> (!dir_lfn_range.empty() &amp;&amp; (dos.version.major &gt;= 7 || uselfn)) {
<a name="l02158"></a>02158                 <span class="comment">/* last LFN entry should be fileidx */</span>
<a name="l02159"></a>02159                 assert(dir_lfn_range.dirPos_start &lt; dir_lfn_range.dirPos_end);
<a name="l02160"></a>02160                 <span class="keywordflow">if</span> (dir_lfn_range.dirPos_end != subEntry) LOG_MSG(<span class="stringliteral">&quot;FAT warning: LFN dirPos_end=%u fileidx=%u (mismatch)&quot;</span>,dir_lfn_range.dirPos_end,subEntry);
<a name="l02161"></a>02161                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> didx=dir_lfn_range.dirPos_start;didx &lt; dir_lfn_range.dirPos_end;didx++) {
<a name="l02162"></a>02162                         <span class="keywordflow">if</span> (directoryBrowse(dirClust,&amp;tmpentry,didx)) {
<a name="l02163"></a>02163                                 tmpentry.entryname[0] = 0xe5;
<a name="l02164"></a>02164                                 directoryChange(dirClust,&amp;tmpentry,didx);
<a name="l02165"></a>02165                         }
<a name="l02166"></a>02166                 }
<a name="l02167"></a>02167         }
<a name="l02168"></a>02168 
<a name="l02169"></a>02169         <span class="comment">/* remove primary 8.3 SFN */</span>
<a name="l02170"></a>02170         fileEntry.entryname[0] = 0xe5;
<a name="l02171"></a>02171         directoryChange(dirClust, &amp;fileEntry, (Bit32s)subEntry);
<a name="l02172"></a>02172 
<a name="l02173"></a>02173         <span class="comment">/* delete allocation chain */</span>
<a name="l02174"></a>02174         {
<a name="l02175"></a>02175                 <span class="keyword">const</span> Bit32u chk = BPB.is_fat32() ? fileEntry.Cluster32() : fileEntry.loFirstClust;
<a name="l02176"></a>02176                 <span class="keywordflow">if</span>(chk != 0) deleteClustChain(chk, 0);
<a name="l02177"></a>02177         }
<a name="l02178"></a>02178 
<a name="l02179"></a>02179         <span class="keywordflow">if</span>(getFileDirEntry(name, &amp;fileEntry, &amp;dirClust, &amp;subEntry)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02180"></a>02180 
<a name="l02181"></a>02181         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02182"></a>02182 }
<a name="l02183"></a>02183 
<a name="l02184"></a>02184 <span class="keywordtype">bool</span> fatDrive::FindFirst(<span class="keyword">const</span> <span class="keywordtype">char</span> *_dir, <a class="code" href="classDOS__DTA.html">DOS_DTA</a> &amp;dta,<span class="keywordtype">bool</span> <span class="comment">/*fcb_findfirst*/</span>) {
<a name="l02185"></a>02185     <a class="code" href="structdirentry.html">direntry</a> dummyClust = {};
<a name="l02186"></a>02186 
<a name="l02187"></a>02187     <span class="comment">// volume label searches always affect root directory, no matter the current directory, at least with FCBs</span>
<a name="l02188"></a>02188     <span class="keywordflow">if</span> (dta.GetAttr() &amp; DOS_ATTR_VOLUME) {
<a name="l02189"></a>02189         <span class="keywordflow">if</span>(!getDirClustNum(<span class="stringliteral">&quot;\\&quot;</span>, &amp;cwdDirCluster, <span class="keyword">false</span>)) {
<a name="l02190"></a>02190             DOS_SetError(DOSERR_PATH_NOT_FOUND);
<a name="l02191"></a>02191             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02192"></a>02192         }
<a name="l02193"></a>02193     }
<a name="l02194"></a>02194     <span class="keywordflow">else</span> {
<a name="l02195"></a>02195         <span class="keywordflow">if</span>(!getDirClustNum(_dir, &amp;cwdDirCluster, <span class="keyword">false</span>)) {
<a name="l02196"></a>02196             DOS_SetError(DOSERR_PATH_NOT_FOUND);
<a name="l02197"></a>02197             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02198"></a>02198         }
<a name="l02199"></a>02199     }
<a name="l02200"></a>02200 
<a name="l02201"></a>02201         <span class="keywordflow">if</span> (lfn_filefind_handle&gt;=LFN_FILEFIND_MAX) {
<a name="l02202"></a>02202                 dta.SetDirID(0);
<a name="l02203"></a>02203                 dta.SetDirIDCluster(cwdDirCluster);
<a name="l02204"></a>02204         } <span class="keywordflow">else</span> {
<a name="l02205"></a>02205                 dpos[lfn_filefind_handle]=0;
<a name="l02206"></a>02206                 dnum[lfn_filefind_handle]=cwdDirCluster;
<a name="l02207"></a>02207         }
<a name="l02208"></a>02208 
<a name="l02209"></a>02209         <span class="keywordflow">return</span> FindNextInternal(cwdDirCluster, dta, &amp;dummyClust);
<a name="l02210"></a>02210 }
<a name="l02211"></a>02211 
<a name="l02212"></a>02212 <span class="keywordtype">char</span>* removeTrailingSpaces(<span class="keywordtype">char</span>* str) {
<a name="l02213"></a>02213         <span class="keywordtype">char</span>* end = str + strlen(str) - 1;
<a name="l02214"></a>02214         <span class="keywordflow">while</span> (end &gt;= str &amp;&amp; *end == <span class="charliteral">&#39; &#39;</span>) end--;
<a name="l02215"></a>02215     <span class="comment">/* NTS: The loop will exit with &#39;end&#39; one char behind the last &#39; &#39; space character.</span>
<a name="l02216"></a>02216 <span class="comment">     *      So to ASCIIZ snip off the space, step forward one and overwrite with NUL.</span>
<a name="l02217"></a>02217 <span class="comment">     *      The loop may end with &#39;end&#39; one char behind &#39;ptr&#39; if the string was empty &quot;&quot;</span>
<a name="l02218"></a>02218 <span class="comment">     *      or nothing but spaces. This is OK because after the step forward, end &gt;= str</span>
<a name="l02219"></a>02219 <span class="comment">     *      in all cases. */</span>
<a name="l02220"></a>02220         *(++end) = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02221"></a>02221         <span class="keywordflow">return</span> str;
<a name="l02222"></a>02222 }
<a name="l02223"></a>02223 
<a name="l02224"></a>02224 <span class="keywordtype">char</span>* removeLeadingSpaces(<span class="keywordtype">char</span>* str) {
<a name="l02225"></a>02225         <span class="keywordtype">size_t</span> len = strlen(str);
<a name="l02226"></a>02226         <span class="keywordtype">size_t</span> pos = strspn(str,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02227"></a>02227         memmove(str,str + pos,len - pos + 1);
<a name="l02228"></a>02228         <span class="keywordflow">return</span> str;
<a name="l02229"></a>02229 }
<a name="l02230"></a>02230 
<a name="l02231"></a>02231 <span class="keywordtype">char</span>* trimString(<span class="keywordtype">char</span>* str) {
<a name="l02232"></a>02232         <span class="keywordflow">return</span> removeTrailingSpaces(removeLeadingSpaces(str));
<a name="l02233"></a>02233 }
<a name="l02234"></a>02234 
<a name="l02235"></a>02235 Bit32u fatDrive::GetSectorCount(<span class="keywordtype">void</span>) {
<a name="l02236"></a>02236     <span class="keywordflow">return</span> (loadedDisk-&gt;heads * loadedDisk-&gt;sectors * loadedDisk-&gt;cylinders) - partSectOff;
<a name="l02237"></a>02237 }
<a name="l02238"></a>02238 
<a name="l02239"></a>02239 Bit32u fatDrive::GetSectorSize(<span class="keywordtype">void</span>) {
<a name="l02240"></a>02240     <span class="keywordflow">return</span> getSectorSize();
<a name="l02241"></a>02241 }
<a name="l02242"></a>02242 
<a name="l02243"></a>02243 Bit8u fatDrive::Read_AbsoluteSector_INT25(Bit32u sectnum, <span class="keywordtype">void</span> * data) {
<a name="l02244"></a>02244     <span class="keywordflow">return</span> readSector(sectnum+partSectOff,data);
<a name="l02245"></a>02245 }
<a name="l02246"></a>02246 
<a name="l02247"></a>02247 Bit8u fatDrive::Write_AbsoluteSector_INT25(Bit32u sectnum, <span class="keywordtype">void</span> * data) {
<a name="l02248"></a>02248     <span class="keywordflow">return</span> writeSector(sectnum+partSectOff,data);
<a name="l02249"></a>02249 }
<a name="l02250"></a>02250 
<a name="l02251"></a>02251 <span class="keywordtype">bool</span> fatDrive::FindNextInternal(Bit32u dirClustNumber, <a class="code" href="classDOS__DTA.html">DOS_DTA</a> &amp;dta, <a class="code" href="structdirentry.html">direntry</a> *foundEntry) {
<a name="l02252"></a>02252         <a class="code" href="structdirentry.html">direntry</a> sectbuf[MAX_DIRENTS_PER_SECTOR]; <span class="comment">/* 16 directory entries per 512 byte sector */</span>
<a name="l02253"></a>02253         Bit32u logentsector; <span class="comment">/* Logical entry sector */</span>
<a name="l02254"></a>02254         Bit32u entryoffset;  <span class="comment">/* Index offset within sector */</span>
<a name="l02255"></a>02255         Bit32u tmpsector;
<a name="l02256"></a>02256         Bit8u attrs;
<a name="l02257"></a>02257         Bit16u dirPos;
<a name="l02258"></a>02258         <span class="keywordtype">char</span> srch_pattern[CROSS_LEN];
<a name="l02259"></a>02259         <span class="keywordtype">char</span> find_name[DOS_NAMELENGTH_ASCII];
<a name="l02260"></a>02260         <span class="keywordtype">char</span> lfind_name[LFN_NAMELENGTH+1];
<a name="l02261"></a>02261         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lfn_max_ord = 0;
<a name="l02262"></a>02262         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lfn_checksum = 0;
<a name="l02263"></a>02263         <span class="keywordtype">bool</span> lfn_ord_found[0x40];
<a name="l02264"></a>02264         <span class="keywordtype">char</span> extension[4];
<a name="l02265"></a>02265 
<a name="l02266"></a>02266     <span class="keywordtype">size_t</span> dirent_per_sector = getSectSize() / <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>);
<a name="l02267"></a>02267     assert(dirent_per_sector &lt;= MAX_DIRENTS_PER_SECTOR);
<a name="l02268"></a>02268     assert((dirent_per_sector * <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>)) &lt;= SECTOR_SIZE_MAX);
<a name="l02269"></a>02269 
<a name="l02270"></a>02270         dta.GetSearchParams(attrs, srch_pattern,uselfn);
<a name="l02271"></a>02271         dirPos = lfn_filefind_handle&gt;=LFN_FILEFIND_MAX?dta.GetDirID():dpos[lfn_filefind_handle]; <span class="comment">/* NTS: Windows 9x is said to have a 65536 dirent limit even for FAT32, so dirPos as 16-bit is acceptable */</span>
<a name="l02272"></a>02272 
<a name="l02273"></a>02273         memset(lfind_name,0,LFN_NAMELENGTH);
<a name="l02274"></a>02274         lfnRange.clear();
<a name="l02275"></a>02275 
<a name="l02276"></a>02276 nextfile:
<a name="l02277"></a>02277         logentsector = (Bit32u)((<span class="keywordtype">size_t</span>)dirPos / dirent_per_sector);
<a name="l02278"></a>02278         entryoffset = (Bit32u)((<span class="keywordtype">size_t</span>)dirPos % dirent_per_sector);
<a name="l02279"></a>02279 
<a name="l02280"></a>02280         <span class="keywordflow">if</span>(dirClustNumber==0) {
<a name="l02281"></a>02281         <span class="keywordflow">if</span> (BPB.is_fat32()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02282"></a>02282 
<a name="l02283"></a>02283                 <span class="keywordflow">if</span>(dirPos &gt;= BPB.v.BPB_RootEntCnt) {
<a name="l02284"></a>02284                         <span class="keywordflow">if</span> (lfn_filefind_handle&lt;LFN_FILEFIND_MAX) {
<a name="l02285"></a>02285                                 dpos[lfn_filefind_handle]=0;
<a name="l02286"></a>02286                                 dnum[lfn_filefind_handle]=0;
<a name="l02287"></a>02287                         }
<a name="l02288"></a>02288                         DOS_SetError(DOSERR_NO_MORE_FILES);
<a name="l02289"></a>02289                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02290"></a>02290                 }
<a name="l02291"></a>02291                 readSector(firstRootDirSect+logentsector,sectbuf);
<a name="l02292"></a>02292         } <span class="keywordflow">else</span> {
<a name="l02293"></a>02293                 tmpsector = getAbsoluteSectFromChain(dirClustNumber, logentsector);
<a name="l02294"></a>02294                 <span class="comment">/* A zero sector number can&#39;t happen */</span>
<a name="l02295"></a>02295                 <span class="keywordflow">if</span>(tmpsector == 0) {
<a name="l02296"></a>02296                         <span class="keywordflow">if</span> (lfn_filefind_handle&lt;LFN_FILEFIND_MAX) {
<a name="l02297"></a>02297                                 dpos[lfn_filefind_handle]=0;
<a name="l02298"></a>02298                                 dnum[lfn_filefind_handle]=0;
<a name="l02299"></a>02299                         }
<a name="l02300"></a>02300                         DOS_SetError(DOSERR_NO_MORE_FILES);
<a name="l02301"></a>02301                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02302"></a>02302                 }
<a name="l02303"></a>02303                 readSector(tmpsector,sectbuf);
<a name="l02304"></a>02304         }
<a name="l02305"></a>02305         dirPos++;
<a name="l02306"></a>02306         <span class="keywordflow">if</span> (lfn_filefind_handle&gt;=LFN_FILEFIND_MAX) dta.SetDirID(dirPos);
<a name="l02307"></a>02307         <span class="keywordflow">else</span> dpos[lfn_filefind_handle]=dirPos;
<a name="l02308"></a>02308 
<a name="l02309"></a>02309     <span class="comment">/* Deleted file entry */</span>
<a name="l02310"></a>02310     <span class="keywordflow">if</span> (sectbuf[entryoffset].entryname[0] == 0xe5) {
<a name="l02311"></a>02311         lfind_name[0] = 0; <span class="comment">/* LFN code will memset() it in full upon next dirent */</span>
<a name="l02312"></a>02312         lfn_max_ord = 0;
<a name="l02313"></a>02313         lfnRange.clear();
<a name="l02314"></a>02314         <span class="keywordflow">goto</span> nextfile;
<a name="l02315"></a>02315     }
<a name="l02316"></a>02316 
<a name="l02317"></a>02317         <span class="comment">/* End of directory list */</span>
<a name="l02318"></a>02318         <span class="keywordflow">if</span> (sectbuf[entryoffset].entryname[0] == 0x00) {
<a name="l02319"></a>02319                         <span class="keywordflow">if</span> (lfn_filefind_handle&lt;LFN_FILEFIND_MAX) {
<a name="l02320"></a>02320                                 dpos[lfn_filefind_handle]=0;
<a name="l02321"></a>02321                                 dnum[lfn_filefind_handle]=0;
<a name="l02322"></a>02322                         }
<a name="l02323"></a>02323                 DOS_SetError(DOSERR_NO_MORE_FILES);
<a name="l02324"></a>02324                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02325"></a>02325         }
<a name="l02326"></a>02326         memset(find_name,0,DOS_NAMELENGTH_ASCII);
<a name="l02327"></a>02327         memset(extension,0,4);
<a name="l02328"></a>02328         memcpy(find_name,&amp;sectbuf[entryoffset].entryname[0],8);
<a name="l02329"></a>02329     memcpy(extension,&amp;sectbuf[entryoffset].entryname[8],3);
<a name="l02330"></a>02330 
<a name="l02331"></a>02331     <span class="keywordflow">if</span> (!(sectbuf[entryoffset].attrib &amp; DOS_ATTR_VOLUME)) {
<a name="l02332"></a>02332         trimString(&amp;find_name[0]);
<a name="l02333"></a>02333         trimString(&amp;extension[0]);
<a name="l02334"></a>02334     }
<a name="l02335"></a>02335 
<a name="l02336"></a>02336         <span class="keywordflow">if</span> (extension[0]!=0) {
<a name="l02337"></a>02337                 <span class="keywordflow">if</span> (!(sectbuf[entryoffset].attrib &amp; DOS_ATTR_VOLUME)) {
<a name="l02338"></a>02338                         strcat(find_name, <span class="stringliteral">&quot;.&quot;</span>);
<a name="l02339"></a>02339                 }
<a name="l02340"></a>02340                 strcat(find_name, extension);
<a name="l02341"></a>02341         }
<a name="l02342"></a>02342 
<a name="l02343"></a>02343         <span class="keywordflow">if</span> (sectbuf[entryoffset].attrib &amp; DOS_ATTR_VOLUME)
<a name="l02344"></a>02344         trimString(find_name);
<a name="l02345"></a>02345 
<a name="l02346"></a>02346     <span class="comment">/* Compare attributes to search attributes */</span>
<a name="l02347"></a>02347 
<a name="l02348"></a>02348     <span class="comment">//TODO What about attrs = DOS_ATTR_VOLUME|DOS_ATTR_DIRECTORY ?</span>
<a name="l02349"></a>02349         <span class="keywordflow">if</span> (attrs == DOS_ATTR_VOLUME) {
<a name="l02350"></a>02350                 <span class="keywordflow">if</span> (dos.version.major &gt;= 7 || uselfn) {
<a name="l02351"></a>02351                         <span class="comment">/* skip LFN entries */</span>
<a name="l02352"></a>02352                         <span class="keywordflow">if</span> ((sectbuf[entryoffset].attrib &amp; 0x3F) == 0x0F)
<a name="l02353"></a>02353                                 <span class="keywordflow">goto</span> nextfile;
<a name="l02354"></a>02354                 }
<a name="l02355"></a>02355 
<a name="l02356"></a>02356                 <span class="keywordflow">if</span> (!(sectbuf[entryoffset].attrib &amp; DOS_ATTR_VOLUME)) <span class="keywordflow">goto</span> nextfile;
<a name="l02357"></a>02357                 labelCache.SetLabel(find_name, <span class="keyword">false</span>, <span class="keyword">true</span>);
<a name="l02358"></a>02358         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((dos.version.major &gt;= 7 || uselfn) &amp;&amp; (sectbuf[entryoffset].attrib &amp; 0x3F) == 0x0F) { <span class="comment">/* long filename piece */</span>
<a name="l02359"></a>02359                 <span class="keyword">struct </span><a class="code" href="structdirentry__lfn.html">direntry_lfn</a> *dlfn = (<span class="keyword">struct </span><a class="code" href="structdirentry__lfn.html">direntry_lfn</a>*)(&amp;sectbuf[entryoffset]);
<a name="l02360"></a>02360 
<a name="l02361"></a>02361                 <span class="comment">/* assume last entry comes first, because that&#39;s how Windows 9x does it and that is how you&#39;re supposed to do it according to Microsoft */</span>
<a name="l02362"></a>02362                 <span class="keywordflow">if</span> (dlfn-&gt;LDIR_Ord &amp; 0x40) {
<a name="l02363"></a>02363                         lfn_max_ord = (dlfn-&gt;LDIR_Ord &amp; 0x3F); <span class="comment">/* NTS: First entry has ordinal 1, this is the HIGHEST ordinal in the LFN. The other entries follow in descending ordinal. */</span>
<a name="l02364"></a>02364                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i &lt; 0x40;i++) lfn_ord_found[i] = <span class="keyword">false</span>;
<a name="l02365"></a>02365                         lfn_checksum = dlfn-&gt;LDIR_Chksum;
<a name="l02366"></a>02366                         memset(lfind_name,0,LFN_NAMELENGTH);
<a name="l02367"></a>02367                         lfnRange.clear();
<a name="l02368"></a>02368                         lfnRange.dirPos_start = dirPos - 1; <span class="comment">/* NTS: The code above has already incremented dirPos */</span>
<a name="l02369"></a>02369                 }
<a name="l02370"></a>02370 
<a name="l02371"></a>02371                 <span class="keywordflow">if</span> (lfn_max_ord != 0 &amp;&amp; (dlfn-&gt;LDIR_Ord &amp; 0x3F) &gt; 0 &amp;&amp; (dlfn-&gt;LDIR_Ord &amp; 0x3Fu) &lt;= lfn_max_ord &amp;&amp; dlfn-&gt;LDIR_Chksum == lfn_checksum) {
<a name="l02372"></a>02372                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oidx = (dlfn-&gt;LDIR_Ord &amp; 0x3Fu) - 1u;
<a name="l02373"></a>02373                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stridx = oidx * 13u;
<a name="l02374"></a>02374 
<a name="l02375"></a>02375                         <span class="keywordflow">if</span> ((stridx+13u) &lt;= LFN_NAMELENGTH) {
<a name="l02376"></a>02376                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i &lt; 5;i++)
<a name="l02377"></a>02377                                         lfind_name[stridx+i+0] = (<span class="keywordtype">char</span>)(dlfn-&gt;LDIR_Name1[i] &amp; 0xFF);
<a name="l02378"></a>02378                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i &lt; 6;i++)
<a name="l02379"></a>02379                                         lfind_name[stridx+i+5] = (<span class="keywordtype">char</span>)(dlfn-&gt;LDIR_Name2[i] &amp; 0xFF);
<a name="l02380"></a>02380                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i &lt; 2;i++)
<a name="l02381"></a>02381                                         lfind_name[stridx+i+11] = (<span class="keywordtype">char</span>)(dlfn-&gt;LDIR_Name3[i] &amp; 0xFF);
<a name="l02382"></a>02382 
<a name="l02383"></a>02383                                 lfn_ord_found[oidx] = <span class="keyword">true</span>;
<a name="l02384"></a>02384                         }
<a name="l02385"></a>02385                 }
<a name="l02386"></a>02386 
<a name="l02387"></a>02387                 <span class="keywordflow">goto</span> nextfile;
<a name="l02388"></a>02388         } <span class="keywordflow">else</span> {
<a name="l02389"></a>02389         <span class="keywordflow">if</span> (~attrs &amp; sectbuf[entryoffset].attrib &amp; (DOS_ATTR_DIRECTORY | DOS_ATTR_VOLUME) ) {
<a name="l02390"></a>02390             lfind_name[0] = 0; <span class="comment">/* LFN code will memset() it in full upon next dirent */</span>
<a name="l02391"></a>02391             lfn_max_ord = 0;
<a name="l02392"></a>02392             lfnRange.clear();
<a name="l02393"></a>02393             <span class="keywordflow">goto</span> nextfile;
<a name="l02394"></a>02394         }
<a name="l02395"></a>02395         }
<a name="l02396"></a>02396 
<a name="l02397"></a>02397         <span class="keywordflow">if</span> (lfn_max_ord != 0) {
<a name="l02398"></a>02398                 <span class="keywordtype">bool</span> ok = <span class="keyword">false</span>;
<a name="l02399"></a>02399                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> complete = 0;
<a name="l02400"></a>02400                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i &lt; lfn_max_ord;i++) complete += lfn_ord_found[i]?1:0;
<a name="l02401"></a>02401 
<a name="l02402"></a>02402                 <span class="keywordflow">if</span> (complete == lfn_max_ord) {
<a name="l02403"></a>02403                         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> chk = 0;
<a name="l02404"></a>02404                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i &lt; 11;i++) {
<a name="l02405"></a>02405                                 chk = ((chk &amp; 1u) ? 0x80u : 0x00u) + (chk &gt;&gt; 1u) + sectbuf[entryoffset].entryname[i];
<a name="l02406"></a>02406                         }
<a name="l02407"></a>02407 
<a name="l02408"></a>02408                         <span class="keywordflow">if</span> (lfn_checksum == chk) {
<a name="l02409"></a>02409                                 lfnRange.dirPos_end = dirPos - 1; <span class="comment">/* NTS: The code above has already incremented dirPos */</span>
<a name="l02410"></a>02410                                 ok = <span class="keyword">true</span>;
<a name="l02411"></a>02411                         }
<a name="l02412"></a>02412                 }
<a name="l02413"></a>02413 
<a name="l02414"></a>02414                 <span class="keywordflow">if</span> (!ok) {
<a name="l02415"></a>02415                         lfind_name[0] = 0; <span class="comment">/* LFN code will memset() it in full upon next dirent */</span>
<a name="l02416"></a>02416                         lfn_max_ord = 0;
<a name="l02417"></a>02417                         lfnRange.clear();
<a name="l02418"></a>02418                 }
<a name="l02419"></a>02419         }
<a name="l02420"></a>02420         <span class="keywordflow">else</span> {
<a name="l02421"></a>02421                 lfind_name[0] = 0; <span class="comment">/* LFN code will memset() it in full upon next dirent */</span>
<a name="l02422"></a>02422                 lfn_max_ord = 0;
<a name="l02423"></a>02423                 lfnRange.clear();
<a name="l02424"></a>02424         }
<a name="l02425"></a>02425 
<a name="l02426"></a>02426         <span class="comment">/* Compare name to search pattern. Skip long filename match if no long filename given. */</span>
<a name="l02427"></a>02427         <span class="keywordflow">if</span> (!(WildFileCmp(find_name,srch_pattern) || (lfn_max_ord != 0 &amp;&amp; lfind_name[0] != 0 &amp;&amp; LWildFileCmp(lfind_name,srch_pattern)))) {
<a name="l02428"></a>02428                 lfind_name[0] = 0; <span class="comment">/* LFN code will memset() it in full upon next dirent */</span>
<a name="l02429"></a>02429                 lfn_max_ord = 0;
<a name="l02430"></a>02430                 lfnRange.clear();
<a name="l02431"></a>02431                 <span class="keywordflow">goto</span> nextfile;
<a name="l02432"></a>02432         }
<a name="l02433"></a>02433 
<a name="l02434"></a>02434         <span class="comment">// Drive emulation does not need to require a LFN in case there is no corresponding 8.3 names.</span>
<a name="l02435"></a>02435         <span class="keywordflow">if</span> (lfind_name[0] == 0) strcpy(lfind_name,find_name);
<a name="l02436"></a>02436 
<a name="l02437"></a>02437         <span class="comment">//dta.SetResult(find_name, sectbuf[entryoffset].entrysize, sectbuf[entryoffset].crtDate, sectbuf[entryoffset].crtTime, sectbuf[entryoffset].attrib);</span>
<a name="l02438"></a>02438 
<a name="l02439"></a>02439         dta.SetResult(find_name, lfind_name, sectbuf[entryoffset].entrysize, sectbuf[entryoffset].modDate, sectbuf[entryoffset].modTime, sectbuf[entryoffset].attrib);
<a name="l02440"></a>02440 
<a name="l02441"></a>02441         memcpy(foundEntry, &amp;sectbuf[entryoffset], <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>));
<a name="l02442"></a>02442 
<a name="l02443"></a>02443         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02444"></a>02444 }
<a name="l02445"></a>02445 
<a name="l02446"></a>02446 <span class="keywordtype">bool</span> fatDrive::FindNext(<a class="code" href="classDOS__DTA.html">DOS_DTA</a> &amp;dta) {
<a name="l02447"></a>02447     <a class="code" href="structdirentry.html">direntry</a> dummyClust = {};
<a name="l02448"></a>02448 
<a name="l02449"></a>02449         <span class="keywordflow">return</span> FindNextInternal(lfn_filefind_handle&gt;=LFN_FILEFIND_MAX?dta.GetDirIDCluster():(dnum[lfn_filefind_handle]?dnum[lfn_filefind_handle]:0), dta, &amp;dummyClust);
<a name="l02450"></a>02450 }
<a name="l02451"></a>02451 
<a name="l02452"></a>02452 
<a name="l02453"></a>02453 <span class="keywordtype">bool</span> fatDrive::SetFileAttr(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, Bit16u attr) {
<a name="l02454"></a>02454     <span class="keywordflow">if</span> (readonly) {
<a name="l02455"></a>02455                 DOS_SetError(DOSERR_WRITE_PROTECTED);
<a name="l02456"></a>02456         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02457"></a>02457     }
<a name="l02458"></a>02458     <a class="code" href="structdirentry.html">direntry</a> fileEntry = {};
<a name="l02459"></a>02459         Bit32u dirClust, subEntry;
<a name="l02460"></a>02460 
<a name="l02461"></a>02461         <span class="comment">/* you cannot set file attr root directory (right?) */</span>
<a name="l02462"></a>02462         <span class="keywordflow">if</span> (*name == 0) {
<a name="l02463"></a>02463                 DOS_SetError(DOSERR_ACCESS_DENIED);
<a name="l02464"></a>02464                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02465"></a>02465         }
<a name="l02466"></a>02466 
<a name="l02467"></a>02467         <span class="keywordflow">if</span>(!getFileDirEntry(name, &amp;fileEntry, &amp;dirClust, &amp;subEntry, <span class="comment">/*dirOk*/</span><span class="keyword">true</span>)) {
<a name="l02468"></a>02468                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02469"></a>02469         } <span class="keywordflow">else</span> {
<a name="l02470"></a>02470                 fileEntry.attrib=(Bit8u)attr;
<a name="l02471"></a>02471                 directoryChange(dirClust, &amp;fileEntry, (Bit32s)subEntry);
<a name="l02472"></a>02472         }
<a name="l02473"></a>02473         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02474"></a>02474 }
<a name="l02475"></a>02475 
<a name="l02476"></a>02476 <span class="keywordtype">bool</span> fatDrive::GetFileAttr(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, Bit16u *attr) {
<a name="l02477"></a>02477     <a class="code" href="structdirentry.html">direntry</a> fileEntry = {};
<a name="l02478"></a>02478         Bit32u dirClust, subEntry;
<a name="l02479"></a>02479 
<a name="l02480"></a>02480         <span class="comment">/* you CAN get file attr root directory */</span>
<a name="l02481"></a>02481         <span class="keywordflow">if</span> (*name == 0) {
<a name="l02482"></a>02482                 *attr=DOS_ATTR_DIRECTORY;
<a name="l02483"></a>02483                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02484"></a>02484         }
<a name="l02485"></a>02485 
<a name="l02486"></a>02486         <span class="keywordflow">if</span>(!getFileDirEntry(name, &amp;fileEntry, &amp;dirClust, &amp;subEntry, <span class="comment">/*dirOk*/</span><span class="keyword">true</span>)) {
<a name="l02487"></a>02487                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02488"></a>02488         } <span class="keywordflow">else</span> *attr=fileEntry.attrib;
<a name="l02489"></a>02489         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02490"></a>02490 }
<a name="l02491"></a>02491 
<a name="l02492"></a>02492 <span class="keywordtype">bool</span> fatDrive::GetFileAttrEx(<span class="keywordtype">char</span>* name, <span class="keyword">struct</span> stat *status) {
<a name="l02493"></a>02493     (void)name;
<a name="l02494"></a>02494     (void)status;
<a name="l02495"></a>02495         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02496"></a>02496 }
<a name="l02497"></a>02497 
<a name="l02498"></a>02498 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatDrive::GetCompressedSize(<span class="keywordtype">char</span>* name) {
<a name="l02499"></a>02499     (void)name;
<a name="l02500"></a>02500         <span class="keywordflow">return</span> 0;
<a name="l02501"></a>02501 }
<a name="l02502"></a>02502 
<a name="l02503"></a>02503 <span class="preprocessor">#if defined (WIN32)</span>
<a name="l02504"></a>02504 <span class="preprocessor"></span>HANDLE fatDrive::CreateOpenFile(<span class="keyword">const</span> <span class="keywordtype">char</span>* name) {
<a name="l02505"></a>02505     (void)name;
<a name="l02506"></a>02506         DOS_SetError(1);
<a name="l02507"></a>02507         <span class="keywordflow">return</span> INVALID_HANDLE_VALUE;
<a name="l02508"></a>02508 }
<a name="l02509"></a>02509 <span class="preprocessor">#endif</span>
<a name="l02510"></a>02510 <span class="preprocessor"></span>
<a name="l02511"></a>02511 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fatDrive::GetSerial() {
<a name="l02512"></a>02512         <span class="keywordflow">if</span> (BPB.is_fat32())
<a name="l02513"></a>02513                 <span class="keywordflow">return</span> BPB.v32.BS_VolID?BPB.v32.BS_VolID:0x1234;
<a name="l02514"></a>02514         <span class="keywordflow">else</span>
<a name="l02515"></a>02515                 <span class="keywordflow">return</span> BPB.v.BPB_VolID?BPB.v.BPB_VolID:0x1234;
<a name="l02516"></a>02516 }
<a name="l02517"></a>02517 
<a name="l02518"></a>02518 <span class="keywordtype">bool</span> fatDrive::directoryBrowse(Bit32u dirClustNumber, <a class="code" href="structdirentry.html">direntry</a> *useEntry, Bit32s entNum, Bit32s start<span class="comment">/*=0*/</span>) {
<a name="l02519"></a>02519         <a class="code" href="structdirentry.html">direntry</a> sectbuf[MAX_DIRENTS_PER_SECTOR];       <span class="comment">/* 16 directory entries per 512 byte sector */</span>
<a name="l02520"></a>02520         Bit32u entryoffset = 0; <span class="comment">/* Index offset within sector */</span>
<a name="l02521"></a>02521         Bit32u tmpsector;
<a name="l02522"></a>02522         Bit16u dirPos = 0;
<a name="l02523"></a>02523 
<a name="l02524"></a>02524     (void)start;<span class="comment">//UNUSED</span>
<a name="l02525"></a>02525 
<a name="l02526"></a>02526     <span class="keywordtype">size_t</span> dirent_per_sector = getSectSize() / <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>);
<a name="l02527"></a>02527     assert(dirent_per_sector &lt;= MAX_DIRENTS_PER_SECTOR);
<a name="l02528"></a>02528     assert((dirent_per_sector * <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>)) &lt;= SECTOR_SIZE_MAX);
<a name="l02529"></a>02529 
<a name="l02530"></a>02530         <span class="keywordflow">while</span>(entNum&gt;=0) {
<a name="l02531"></a>02531                 Bit32u logentsector = ((Bit32u)((<span class="keywordtype">size_t</span>)dirPos / dirent_per_sector)); <span class="comment">/* Logical entry sector */</span>
<a name="l02532"></a>02532                 entryoffset = ((Bit32u)((<span class="keywordtype">size_t</span>)dirPos % dirent_per_sector));
<a name="l02533"></a>02533 
<a name="l02534"></a>02534                 <span class="keywordflow">if</span>(dirClustNumber==0) {
<a name="l02535"></a>02535             assert(!BPB.is_fat32());
<a name="l02536"></a>02536             <span class="keywordflow">if</span>(dirPos &gt;= BPB.v.BPB_RootEntCnt) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02537"></a>02537                         tmpsector = firstRootDirSect+logentsector;
<a name="l02538"></a>02538                         readSector(tmpsector,sectbuf);
<a name="l02539"></a>02539                 } <span class="keywordflow">else</span> {
<a name="l02540"></a>02540                         tmpsector = getAbsoluteSectFromChain(dirClustNumber, logentsector);
<a name="l02541"></a>02541                         <span class="comment">/* A zero sector number can&#39;t happen */</span>
<a name="l02542"></a>02542                         <span class="keywordflow">if</span>(tmpsector == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02543"></a>02543                         readSector(tmpsector,sectbuf);
<a name="l02544"></a>02544                 }
<a name="l02545"></a>02545                 dirPos++;
<a name="l02546"></a>02546 
<a name="l02547"></a>02547 
<a name="l02548"></a>02548                 <span class="comment">/* End of directory list */</span>
<a name="l02549"></a>02549                 <span class="keywordflow">if</span> (sectbuf[entryoffset].entryname[0] == 0x00) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02550"></a>02550                 --entNum;
<a name="l02551"></a>02551         }
<a name="l02552"></a>02552 
<a name="l02553"></a>02553         memcpy(useEntry, &amp;sectbuf[entryoffset],<span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>));
<a name="l02554"></a>02554         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02555"></a>02555 }
<a name="l02556"></a>02556 
<a name="l02557"></a>02557 <span class="keywordtype">bool</span> fatDrive::directoryChange(Bit32u dirClustNumber, <span class="keyword">const</span> <a class="code" href="structdirentry.html">direntry</a> *useEntry, Bit32s entNum) {
<a name="l02558"></a>02558         <a class="code" href="structdirentry.html">direntry</a> sectbuf[MAX_DIRENTS_PER_SECTOR];       <span class="comment">/* 16 directory entries per 512 byte sector */</span>
<a name="l02559"></a>02559         Bit32u entryoffset = 0; <span class="comment">/* Index offset within sector */</span>
<a name="l02560"></a>02560         Bit32u tmpsector = 0;
<a name="l02561"></a>02561         Bit16u dirPos = 0;
<a name="l02562"></a>02562         
<a name="l02563"></a>02563     <span class="keywordtype">size_t</span> dirent_per_sector = getSectSize() / <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>);
<a name="l02564"></a>02564     assert(dirent_per_sector &lt;= MAX_DIRENTS_PER_SECTOR);
<a name="l02565"></a>02565     assert((dirent_per_sector * <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>)) &lt;= SECTOR_SIZE_MAX);
<a name="l02566"></a>02566 
<a name="l02567"></a>02567         <span class="keywordflow">while</span>(entNum&gt;=0) {              
<a name="l02568"></a>02568                 Bit32u logentsector = ((Bit32u)((<span class="keywordtype">size_t</span>)dirPos / dirent_per_sector)); <span class="comment">/* Logical entry sector */</span>
<a name="l02569"></a>02569                 entryoffset = ((Bit32u)((<span class="keywordtype">size_t</span>)dirPos % dirent_per_sector));
<a name="l02570"></a>02570 
<a name="l02571"></a>02571                 <span class="keywordflow">if</span>(dirClustNumber==0) {
<a name="l02572"></a>02572             assert(!BPB.is_fat32());
<a name="l02573"></a>02573             <span class="keywordflow">if</span>(dirPos &gt;= BPB.v.BPB_RootEntCnt) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02574"></a>02574                         tmpsector = firstRootDirSect+logentsector;
<a name="l02575"></a>02575                         readSector(tmpsector,sectbuf);
<a name="l02576"></a>02576                 } <span class="keywordflow">else</span> {
<a name="l02577"></a>02577                         tmpsector = getAbsoluteSectFromChain(dirClustNumber, logentsector);
<a name="l02578"></a>02578                         <span class="comment">/* A zero sector number can&#39;t happen */</span>
<a name="l02579"></a>02579                         <span class="keywordflow">if</span>(tmpsector == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02580"></a>02580                         readSector(tmpsector,sectbuf);
<a name="l02581"></a>02581                 }
<a name="l02582"></a>02582                 dirPos++;
<a name="l02583"></a>02583 
<a name="l02584"></a>02584 
<a name="l02585"></a>02585                 <span class="comment">/* End of directory list */</span>
<a name="l02586"></a>02586                 <span class="keywordflow">if</span> (sectbuf[entryoffset].entryname[0] == 0x00) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02587"></a>02587                 --entNum;
<a name="l02588"></a>02588         }
<a name="l02589"></a>02589         <span class="keywordflow">if</span>(tmpsector != 0) {
<a name="l02590"></a>02590         memcpy(&amp;sectbuf[entryoffset], useEntry, <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>));
<a name="l02591"></a>02591                 writeSector(tmpsector, sectbuf);
<a name="l02592"></a>02592         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02593"></a>02593         } <span class="keywordflow">else</span> {
<a name="l02594"></a>02594                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02595"></a>02595         }
<a name="l02596"></a>02596 }
<a name="l02597"></a>02597 
<a name="l02598"></a>02598 <span class="keywordtype">bool</span> fatDrive::addDirectoryEntry(Bit32u dirClustNumber, <span class="keyword">const</span> <a class="code" href="structdirentry.html">direntry</a>&amp; useEntry,<span class="keyword">const</span> <span class="keywordtype">char</span> *lfn) {
<a name="l02599"></a>02599         <a class="code" href="structdirentry.html">direntry</a> sectbuf[MAX_DIRENTS_PER_SECTOR]; <span class="comment">/* 16 directory entries per 512 byte sector */</span>
<a name="l02600"></a>02600         Bit32u tmpsector;
<a name="l02601"></a>02601         Bit16u dirPos = 0;
<a name="l02602"></a>02602         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> need = 1;
<a name="l02603"></a>02603         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> found = 0;
<a name="l02604"></a>02604         Bit16u dirPosFound = 0;
<a name="l02605"></a>02605 
<a name="l02606"></a>02606         <span class="keywordflow">if</span> (lfn != NULL &amp;&amp; *lfn != 0) {
<a name="l02607"></a>02607                 <span class="comment">/* 13 characters per LFN entry.</span>
<a name="l02608"></a>02608 <span class="comment">                 * FIXME: When we convert the LFN to wchar using code page, strlen() prior to conversion will not work,</span>
<a name="l02609"></a>02609 <span class="comment">                 *        convert first then count wchar_t characters. */</span>
<a name="l02610"></a>02610                 need = (<span class="keywordtype">unsigned</span> int)(1 + ((strlen(lfn) + 12) / 13))<span class="comment">/*round up*/</span>;
<a name="l02611"></a>02611         }
<a name="l02612"></a>02612 
<a name="l02613"></a>02613         <span class="keywordtype">size_t</span> dirent_per_sector = getSectSize() / <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>);
<a name="l02614"></a>02614         assert(dirent_per_sector &lt;= MAX_DIRENTS_PER_SECTOR);
<a name="l02615"></a>02615         assert((dirent_per_sector * <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>)) &lt;= SECTOR_SIZE_MAX);
<a name="l02616"></a>02616 
<a name="l02617"></a>02617         <span class="keywordflow">for</span>(;;) {               
<a name="l02618"></a>02618                 Bit32u logentsector = ((Bit32u)((<span class="keywordtype">size_t</span>)dirPos / dirent_per_sector)); <span class="comment">/* Logical entry sector */</span>
<a name="l02619"></a>02619                 Bit32u entryoffset = ((Bit32u)((<span class="keywordtype">size_t</span>)dirPos % dirent_per_sector)); <span class="comment">/* Index offset within sector */</span>
<a name="l02620"></a>02620 
<a name="l02621"></a>02621                 <span class="keywordflow">if</span>(dirClustNumber==0) {
<a name="l02622"></a>02622                         assert(!BPB.is_fat32());
<a name="l02623"></a>02623                         <span class="keywordflow">if</span>(dirPos &gt;= BPB.v.BPB_RootEntCnt) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02624"></a>02624                         tmpsector = firstRootDirSect+logentsector;
<a name="l02625"></a>02625                 } <span class="keywordflow">else</span> {
<a name="l02626"></a>02626                         tmpsector = getAbsoluteSectFromChain(dirClustNumber, logentsector);
<a name="l02627"></a>02627                         <span class="comment">/* A zero sector number can&#39;t happen - we need to allocate more room for this directory*/</span>
<a name="l02628"></a>02628                         <span class="keywordflow">if</span>(tmpsector == 0) {
<a name="l02629"></a>02629                                 Bit32u newClust;
<a name="l02630"></a>02630                                 newClust = appendCluster(dirClustNumber);
<a name="l02631"></a>02631                                 <span class="keywordflow">if</span>(newClust == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02632"></a>02632                                 zeroOutCluster(newClust);
<a name="l02633"></a>02633                                 <span class="comment">/* Try again to get tmpsector */</span>
<a name="l02634"></a>02634                                 tmpsector = getAbsoluteSectFromChain(dirClustNumber, logentsector);
<a name="l02635"></a>02635                                 <span class="keywordflow">if</span>(tmpsector == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">/* Give up if still can&#39;t get more room for directory */</span>
<a name="l02636"></a>02636                         }
<a name="l02637"></a>02637                 }
<a name="l02638"></a>02638                 readSector(tmpsector,sectbuf);
<a name="l02639"></a>02639 
<a name="l02640"></a>02640                 <span class="comment">/* Deleted file entry or end of directory list */</span>
<a name="l02641"></a>02641                 <span class="keywordflow">if</span> ((sectbuf[entryoffset].entryname[0] == 0xe5) || (sectbuf[entryoffset].entryname[0] == 0x00)) {
<a name="l02642"></a>02642                         <span class="keywordflow">if</span> (found == 0) dirPosFound = dirPos;
<a name="l02643"></a>02643 
<a name="l02644"></a>02644                         <span class="keywordflow">if</span> ((++found) &gt;= need) {
<a name="l02645"></a>02645                                 sectbuf[entryoffset] = useEntry;
<a name="l02646"></a>02646                                 writeSector(tmpsector,sectbuf);
<a name="l02647"></a>02647 
<a name="l02648"></a>02648                                 <span class="comment">/* Add LFN entries */</span>
<a name="l02649"></a>02649                                 <span class="keywordflow">if</span> (need != 1<span class="comment">/*LFN*/</span>) {
<a name="l02650"></a>02650                                         Bit16u lfnbuf[LFN_NAMELENGTH+13]; <span class="comment">/* on disk, LFNs are WCHAR unicode (UCS-16) */</span>
<a name="l02651"></a>02651 
<a name="l02652"></a>02652                                         assert(lfn != NULL);
<a name="l02653"></a>02653                                         assert(*lfn != 0);
<a name="l02654"></a>02654 
<a name="l02655"></a>02655                                         <span class="comment">/* TODO: ANSI LFN convert to wchar here according to code page */</span>
<a name="l02656"></a>02656 
<a name="l02657"></a>02657                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> o = 0;
<a name="l02658"></a>02658                                         <span class="keyword">const</span> <span class="keywordtype">char</span> *scan = lfn;
<a name="l02659"></a>02659 
<a name="l02660"></a>02660                                         <span class="keywordflow">while</span> (*scan) {
<a name="l02661"></a>02661                                                 <span class="keywordflow">if</span> (o &gt;= LFN_NAMELENGTH) <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">/* Nope! */</span>
<a name="l02662"></a>02662                                                 lfnbuf[o++] = (Bit16u)((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(*scan++));
<a name="l02663"></a>02663                                         }
<a name="l02664"></a>02664 
<a name="l02665"></a>02665                                         <span class="comment">/* on disk, LFNs are padded with 0x0000 followed by a run of 0xFFFF to fill the dirent */</span>
<a name="l02666"></a>02666                                         lfnbuf[o++] = 0x0000;
<a name="l02667"></a>02667                                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i &lt; 13;i++) lfnbuf[o++] = 0xFFFF;
<a name="l02668"></a>02668                                         assert(o &lt;= (LFN_NAMELENGTH+13));
<a name="l02669"></a>02669 
<a name="l02670"></a>02670                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> chk = 0;
<a name="l02671"></a>02671                                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i &lt; 11;i++) {
<a name="l02672"></a>02672                                                 chk = ((chk &amp; 1u) ? 0x80u : 0x00u) + (chk &gt;&gt; 1u) + useEntry.entryname[i];
<a name="l02673"></a>02673                                         }
<a name="l02674"></a>02674 
<a name="l02675"></a>02675                                         dirPos = dirPosFound;
<a name="l02676"></a>02676                                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s=0;s &lt; (need-1u);s++) {
<a name="l02677"></a>02677                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lfnsrci = (need-2u-s);
<a name="l02678"></a>02678                                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lfnsrc = lfnsrci * 13;
<a name="l02679"></a>02679 
<a name="l02680"></a>02680                                                 logentsector = ((Bit32u)((<span class="keywordtype">size_t</span>)dirPos / dirent_per_sector)); <span class="comment">/* Logical entry sector */</span>
<a name="l02681"></a>02681                                                 entryoffset = ((Bit32u)((<span class="keywordtype">size_t</span>)dirPos % dirent_per_sector)); <span class="comment">/* Index offset within sector */</span>
<a name="l02682"></a>02682 
<a name="l02683"></a>02683                                                 <span class="keywordflow">if</span>(dirClustNumber==0) {
<a name="l02684"></a>02684                                                         assert(!BPB.is_fat32());
<a name="l02685"></a>02685                                                         <span class="keywordflow">if</span>(dirPos &gt;= BPB.v.BPB_RootEntCnt) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02686"></a>02686                                                         tmpsector = firstRootDirSect+logentsector;
<a name="l02687"></a>02687                                                 } <span class="keywordflow">else</span> {
<a name="l02688"></a>02688                                                         tmpsector = getAbsoluteSectFromChain(dirClustNumber, logentsector);
<a name="l02689"></a>02689                                                         <span class="comment">/* A zero sector number can&#39;t happen - we need to allocate more room for this directory*/</span>
<a name="l02690"></a>02690                                                         <span class="keywordflow">if</span>(tmpsector == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02691"></a>02691                                                 }
<a name="l02692"></a>02692                                                 readSector(tmpsector,sectbuf);
<a name="l02693"></a>02693 
<a name="l02694"></a>02694                                                 <a class="code" href="structdirentry__lfn.html">direntry_lfn</a> *dlfn = (<a class="code" href="structdirentry__lfn.html">direntry_lfn</a>*)(&amp;sectbuf[entryoffset]);
<a name="l02695"></a>02695 
<a name="l02696"></a>02696                                                 memset(dlfn,0,<span class="keyword">sizeof</span>(*dlfn));
<a name="l02697"></a>02697 
<a name="l02698"></a>02698                                                 dlfn-&gt;LDIR_Ord = (s == 0 ? 0x40 : 0x00) + lfnsrci + 1;
<a name="l02699"></a>02699                                                 dlfn-&gt;LDIR_Chksum = chk;
<a name="l02700"></a>02700                                                 dlfn-&gt;attrib = 0x0F;
<a name="l02701"></a>02701 
<a name="l02702"></a>02702                                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i &lt; 5;i++) dlfn-&gt;LDIR_Name1[i] = lfnbuf[lfnsrc++];
<a name="l02703"></a>02703                                                 for (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i &lt; 6;i++) dlfn-&gt;LDIR_Name2[i] = lfnbuf[lfnsrc++];
<a name="l02704"></a>02704                                                 for (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i &lt; 2;i++) dlfn-&gt;LDIR_Name3[i] = lfnbuf[lfnsrc++];
<a name="l02705"></a>02705 
<a name="l02706"></a>02706                                                 writeSector(tmpsector,sectbuf);
<a name="l02707"></a>02707                                                 dirPos++;
<a name="l02708"></a>02708                                         }
<a name="l02709"></a>02709                                 }
<a name="l02710"></a>02710 
<a name="l02711"></a>02711                                 <span class="keywordflow">break</span>;
<a name="l02712"></a>02712                         }
<a name="l02713"></a>02713                 }
<a name="l02714"></a>02714                 <span class="keywordflow">else</span> {
<a name="l02715"></a>02715                         found = 0;
<a name="l02716"></a>02716                 }
<a name="l02717"></a>02717 
<a name="l02718"></a>02718                 dirPos++;
<a name="l02719"></a>02719         }
<a name="l02720"></a>02720 
<a name="l02721"></a>02721         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02722"></a>02722 }
<a name="l02723"></a>02723 
<a name="l02724"></a>02724 <span class="keywordtype">void</span> fatDrive::zeroOutCluster(Bit32u clustNumber) {
<a name="l02725"></a>02725         Bit8u secBuffer[SECTOR_SIZE_MAX];
<a name="l02726"></a>02726 
<a name="l02727"></a>02727         memset(&amp;secBuffer[0], 0, SECTOR_SIZE_MAX);
<a name="l02728"></a>02728 
<a name="l02729"></a>02729         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l02730"></a>02730         <span class="keywordflow">for</span>(i=0;i&lt;BPB.v.BPB_SecPerClus;i++) {
<a name="l02731"></a>02731                 writeSector(getAbsoluteSectFromChain(clustNumber,i), &amp;secBuffer[0]);
<a name="l02732"></a>02732         }
<a name="l02733"></a>02733 }
<a name="l02734"></a>02734 
<a name="l02735"></a>02735 <span class="keywordtype">bool</span> fatDrive::MakeDir(<span class="keyword">const</span> <span class="keywordtype">char</span> *dir) {
<a name="l02736"></a>02736         <span class="keyword">const</span> <span class="keywordtype">char</span> *lfn = NULL;
<a name="l02737"></a>02737 
<a name="l02738"></a>02738     <span class="keywordflow">if</span> (readonly) {
<a name="l02739"></a>02739                 DOS_SetError(DOSERR_WRITE_PROTECTED);
<a name="l02740"></a>02740         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02741"></a>02741     }
<a name="l02742"></a>02742         Bit32u dummyClust, dirClust, subEntry;
<a name="l02743"></a>02743         <a class="code" href="structdirentry.html">direntry</a> tmpentry;
<a name="l02744"></a>02744         <span class="keywordtype">char</span> dirName[DOS_NAMELENGTH_ASCII];
<a name="l02745"></a>02745     <span class="keywordtype">char</span> pathName[11], path[DOS_PATHLENGTH];
<a name="l02746"></a>02746     Bit16u ct,cd;
<a name="l02747"></a>02747 
<a name="l02748"></a>02748         <span class="comment">/* you cannot mkdir root directory */</span>
<a name="l02749"></a>02749         <span class="keywordflow">if</span> (*dir == 0) {
<a name="l02750"></a>02750                 DOS_SetError(DOSERR_ACCESS_DENIED);
<a name="l02751"></a>02751                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02752"></a>02752         }
<a name="l02753"></a>02753 
<a name="l02754"></a>02754         <span class="comment">/* Can we even get the name of the directory itself? */</span>
<a name="l02755"></a>02755         <span class="keywordflow">if</span>(!getEntryName(dir, &amp;dirName[0])||!strlen(trim(dirName))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02756"></a>02756         convToDirFile(&amp;dirName[0], &amp;pathName[0]);
<a name="l02757"></a>02757 
<a name="l02758"></a>02758         <span class="comment">/* Fail to make directory if something of that name already exists */</span>
<a name="l02759"></a>02759         <span class="keywordflow">if</span>(getFileDirEntry(dir,&amp;tmpentry,&amp;dummyClust,&amp;subEntry,<span class="comment">/*dirOk*/</span><span class="keyword">true</span>)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02760"></a>02760 
<a name="l02761"></a>02761         <span class="comment">/* Can we find the base directory? */</span>
<a name="l02762"></a>02762         <span class="keywordflow">if</span>(!getDirClustNum(dir, &amp;dirClust, <span class="keyword">true</span>)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02763"></a>02763 
<a name="l02764"></a>02764         dummyClust = getFirstFreeClust();
<a name="l02765"></a>02765         <span class="comment">/* No more space */</span>
<a name="l02766"></a>02766         <span class="keywordflow">if</span>(dummyClust == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02767"></a>02767 
<a name="l02768"></a>02768         <span class="keywordflow">if</span>(!allocateCluster(dummyClust, 0)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02769"></a>02769 
<a name="l02770"></a>02770         <span class="comment">/* NTS: &quot;dir&quot; is the full relative path. For LFN creation to work we need only the final element of the path */</span>
<a name="l02771"></a>02771         <span class="keywordflow">if</span> (uselfn &amp;&amp; !force_sfn) {
<a name="l02772"></a>02772                 lfn = strrchr(dir,<span class="charliteral">&#39;\\&#39;</span>);
<a name="l02773"></a>02773 
<a name="l02774"></a>02774                 <span class="keywordflow">if</span> (lfn != NULL) {
<a name="l02775"></a>02775                         lfn++; <span class="comment">/* step past &#39;\&#39; */</span>
<a name="l02776"></a>02776                         strcpy(path, dir);
<a name="l02777"></a>02777                         *(strrchr(path,<span class="charliteral">&#39;\\&#39;</span>)+1)=0;
<a name="l02778"></a>02778                 } <span class="keywordflow">else</span> {
<a name="l02779"></a>02779                         lfn = dir; <span class="comment">/* no path elements */</span>
<a name="l02780"></a>02780                         *path=0;
<a name="l02781"></a>02781                 }
<a name="l02782"></a>02782 
<a name="l02783"></a>02783                 <span class="keywordflow">if</span> (filename_not_strict_8x3(lfn)) {
<a name="l02784"></a>02784                         <span class="keywordtype">char</span> *sfn=Generate_SFN(path, lfn);
<a name="l02785"></a>02785                         <span class="keywordflow">if</span> (sfn!=NULL) convToDirFile(sfn, &amp;pathName[0]);
<a name="l02786"></a>02786                 } <span class="keywordflow">else</span>
<a name="l02787"></a>02787                         lfn = NULL;
<a name="l02788"></a>02788         }
<a name="l02789"></a>02789 
<a name="l02790"></a>02790         zeroOutCluster(dummyClust);
<a name="l02791"></a>02791 
<a name="l02792"></a>02792         time_t_to_DOS_DateTime(<span class="comment">/*&amp;*/</span>ct,<span class="comment">/*&amp;*/</span>cd,::time(NULL));
<a name="l02793"></a>02793 
<a name="l02794"></a>02794         <span class="comment">/* Add the new directory to the base directory */</span>
<a name="l02795"></a>02795         memset(&amp;tmpentry,0, <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>));
<a name="l02796"></a>02796         memcpy(&amp;tmpentry.entryname, &amp;pathName[0], 11);
<a name="l02797"></a>02797         tmpentry.loFirstClust = (Bit16u)(dummyClust &amp; 0xffff);
<a name="l02798"></a>02798         tmpentry.hiFirstClust = (Bit16u)(dummyClust &gt;&gt; 16);
<a name="l02799"></a>02799         tmpentry.attrib = DOS_ATTR_DIRECTORY;
<a name="l02800"></a>02800     tmpentry.modTime = ct;
<a name="l02801"></a>02801     tmpentry.modDate = cd;
<a name="l02802"></a>02802     addDirectoryEntry(dirClust, tmpentry, lfn);
<a name="l02803"></a>02803 
<a name="l02804"></a>02804         <span class="comment">/* Add the [.] and [..] entries to our new directory*/</span>
<a name="l02805"></a>02805         <span class="comment">/* [.] entry */</span>
<a name="l02806"></a>02806         memset(&amp;tmpentry,0, <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>));
<a name="l02807"></a>02807         memcpy(&amp;tmpentry.entryname, <span class="stringliteral">&quot;.          &quot;</span>, 11);
<a name="l02808"></a>02808         tmpentry.loFirstClust = (Bit16u)(dummyClust &amp; 0xffff);
<a name="l02809"></a>02809         tmpentry.hiFirstClust = (Bit16u)(dummyClust &gt;&gt; 16);
<a name="l02810"></a>02810         tmpentry.attrib = DOS_ATTR_DIRECTORY;
<a name="l02811"></a>02811     tmpentry.modTime = ct;
<a name="l02812"></a>02812     tmpentry.modDate = cd;
<a name="l02813"></a>02813         addDirectoryEntry(dummyClust, tmpentry);
<a name="l02814"></a>02814 
<a name="l02815"></a>02815         <span class="comment">/* [..] entry */</span>
<a name="l02816"></a>02816         memset(&amp;tmpentry,0, <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>));
<a name="l02817"></a>02817         memcpy(&amp;tmpentry.entryname, <span class="stringliteral">&quot;..         &quot;</span>, 11);
<a name="l02818"></a>02818         <span class="keywordflow">if</span> (BPB.is_fat32() &amp;&amp; dirClust == BPB.v32.BPB_RootClus) {
<a name="l02819"></a>02819                 <span class="comment">/* Windows 98 SCANDISK.EXE considers it an error for the &#39;..&#39; entry of a top level</span>
<a name="l02820"></a>02820 <span class="comment">                 * directory to point at the actual cluster number of the root directory. The</span>
<a name="l02821"></a>02821 <span class="comment">                 * correct value is 0 apparently. */</span>
<a name="l02822"></a>02822                 tmpentry.loFirstClust = (Bit16u)0;
<a name="l02823"></a>02823                 tmpentry.hiFirstClust = (Bit16u)0;
<a name="l02824"></a>02824         }
<a name="l02825"></a>02825         <span class="keywordflow">else</span> {
<a name="l02826"></a>02826                 tmpentry.loFirstClust = (Bit16u)(dirClust &amp; 0xffff);
<a name="l02827"></a>02827                 tmpentry.hiFirstClust = (Bit16u)(dirClust &gt;&gt; 16);
<a name="l02828"></a>02828         }
<a name="l02829"></a>02829         tmpentry.attrib = DOS_ATTR_DIRECTORY;
<a name="l02830"></a>02830     tmpentry.modTime = ct;
<a name="l02831"></a>02831     tmpentry.modDate = cd;
<a name="l02832"></a>02832         addDirectoryEntry(dummyClust, tmpentry);
<a name="l02833"></a>02833         <span class="comment">//if(!getDirClustNum(dir, &amp;dummyClust, false)) return false;</span>
<a name="l02834"></a>02834 
<a name="l02835"></a>02835         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02836"></a>02836 }
<a name="l02837"></a>02837 
<a name="l02838"></a>02838 <span class="keywordtype">bool</span> fatDrive::RemoveDir(<span class="keyword">const</span> <span class="keywordtype">char</span> *dir) {
<a name="l02839"></a>02839     <span class="keywordflow">if</span> (readonly) {
<a name="l02840"></a>02840                 DOS_SetError(DOSERR_WRITE_PROTECTED);
<a name="l02841"></a>02841         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02842"></a>02842     }
<a name="l02843"></a>02843         Bit32u dummyClust, dirClust, subEntry;
<a name="l02844"></a>02844     <a class="code" href="structdirentry.html">direntry</a> tmpentry = {};
<a name="l02845"></a>02845         <span class="keywordtype">char</span> dirName[DOS_NAMELENGTH_ASCII];
<a name="l02846"></a>02846         <span class="keywordtype">char</span> pathName[11];
<a name="l02847"></a>02847 
<a name="l02848"></a>02848         <span class="comment">/* you cannot rmdir root directory */</span>
<a name="l02849"></a>02849         <span class="keywordflow">if</span> (*dir == 0) {
<a name="l02850"></a>02850                 DOS_SetError(DOSERR_ACCESS_DENIED);
<a name="l02851"></a>02851                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02852"></a>02852         }
<a name="l02853"></a>02853 
<a name="l02854"></a>02854         <span class="comment">/* Can we even get the name of the directory itself? */</span>
<a name="l02855"></a>02855         <span class="keywordflow">if</span>(!getEntryName(dir, &amp;dirName[0])||!strlen(trim(dirName))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02856"></a>02856         convToDirFile(&amp;dirName[0], &amp;pathName[0]);
<a name="l02857"></a>02857 
<a name="l02858"></a>02858         <span class="comment">/* directory must exist */</span>
<a name="l02859"></a>02859         lfnRange.clear();
<a name="l02860"></a>02860         <span class="keywordflow">if</span>(!getFileDirEntry(dir,&amp;tmpentry,&amp;dirClust,&amp;subEntry,<span class="comment">/*dirOk*/</span><span class="keyword">true</span>)) <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">/* dirClust is parent dir of directory */</span>
<a name="l02861"></a>02861         <span class="keywordflow">if</span> (!(tmpentry.attrib &amp; DOS_ATTR_DIRECTORY)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02862"></a>02862         dummyClust = (BPB.is_fat32() ? tmpentry.Cluster32() : tmpentry.loFirstClust);
<a name="l02863"></a>02863         lfnRange_t dir_lfn_range = lfnRange; <span class="comment">/* copy down LFN results before they are obliterated by the next call to FindNextInternal. */</span>
<a name="l02864"></a>02864 
<a name="l02865"></a>02865         <span class="comment">/* Can&#39;t remove root directory */</span>
<a name="l02866"></a>02866         <span class="keywordflow">if</span>(dummyClust == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02867"></a>02867         <span class="keywordflow">if</span>(BPB.is_fat32() &amp;&amp; dummyClust==BPB.v32.BPB_RootClus) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02868"></a>02868 
<a name="l02869"></a>02869         <span class="comment">/* Check to make sure directory is empty */</span>
<a name="l02870"></a>02870         Bit32u filecount = 0;
<a name="l02871"></a>02871         <span class="comment">/* Set to 2 to skip first 2 entries, [.] and [..] */</span>
<a name="l02872"></a>02872         Bit32s fileidx = 2;
<a name="l02873"></a>02873         <span class="keywordflow">while</span>(directoryBrowse(dummyClust, &amp;tmpentry, fileidx)) {
<a name="l02874"></a>02874                 <span class="comment">/* Check for non-deleted files */</span>
<a name="l02875"></a>02875                 <span class="keywordflow">if</span>(tmpentry.entryname[0] != 0xe5) filecount++;
<a name="l02876"></a>02876                 fileidx++;
<a name="l02877"></a>02877         }
<a name="l02878"></a>02878 
<a name="l02879"></a>02879         <span class="comment">/* Return if directory is not empty */</span>
<a name="l02880"></a>02880         <span class="keywordflow">if</span>(filecount &gt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02881"></a>02881 
<a name="l02882"></a>02882         <span class="comment">/* delete LFNs */</span>
<a name="l02883"></a>02883         <span class="keywordflow">if</span> (!dir_lfn_range.empty() &amp;&amp; (dos.version.major &gt;= 7 || uselfn)) {
<a name="l02884"></a>02884                 <span class="comment">/* last LFN entry should be fileidx */</span>
<a name="l02885"></a>02885                 assert(dir_lfn_range.dirPos_start &lt; dir_lfn_range.dirPos_end);
<a name="l02886"></a>02886                 <span class="keywordflow">if</span> (dir_lfn_range.dirPos_end != subEntry) LOG_MSG(<span class="stringliteral">&quot;FAT warning: LFN dirPos_end=%u fileidx=%u (mismatch)&quot;</span>,dir_lfn_range.dirPos_end,subEntry);
<a name="l02887"></a>02887                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> didx=dir_lfn_range.dirPos_start;didx &lt; dir_lfn_range.dirPos_end;didx++) {
<a name="l02888"></a>02888                         <span class="keywordflow">if</span> (directoryBrowse(dirClust,&amp;tmpentry,didx)) {
<a name="l02889"></a>02889                                 tmpentry.entryname[0] = 0xe5;
<a name="l02890"></a>02890                                 directoryChange(dirClust,&amp;tmpentry,didx);
<a name="l02891"></a>02891                         }
<a name="l02892"></a>02892                 }
<a name="l02893"></a>02893         }
<a name="l02894"></a>02894 
<a name="l02895"></a>02895         <span class="comment">/* remove primary 8.3 entry */</span>
<a name="l02896"></a>02896         <span class="keywordflow">if</span> (!directoryBrowse(dirClust, &amp;tmpentry, subEntry)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02897"></a>02897         tmpentry.entryname[0] = 0xe5;
<a name="l02898"></a>02898         <span class="keywordflow">if</span> (!directoryChange(dirClust, &amp;tmpentry, subEntry)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02899"></a>02899 
<a name="l02900"></a>02900         <span class="comment">/* delete allocation chain */</span>
<a name="l02901"></a>02901         deleteClustChain(dummyClust, 0);
<a name="l02902"></a>02902         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02903"></a>02903 }
<a name="l02904"></a>02904 
<a name="l02905"></a>02905 <span class="keywordtype">bool</span> fatDrive::Rename(<span class="keyword">const</span> <span class="keywordtype">char</span> * oldname, <span class="keyword">const</span> <span class="keywordtype">char</span> * newname) {
<a name="l02906"></a>02906         <span class="keyword">const</span> <span class="keywordtype">char</span> *lfn = NULL;
<a name="l02907"></a>02907 
<a name="l02908"></a>02908     <span class="keywordflow">if</span> (readonly) {
<a name="l02909"></a>02909                 DOS_SetError(DOSERR_WRITE_PROTECTED);
<a name="l02910"></a>02910         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02911"></a>02911     }
<a name="l02912"></a>02912 
<a name="l02913"></a>02913         <span class="comment">/* you cannot rename root directory */</span>
<a name="l02914"></a>02914         <span class="keywordflow">if</span> (*oldname == 0 || *newname == 0) {
<a name="l02915"></a>02915                 DOS_SetError(DOSERR_ACCESS_DENIED);
<a name="l02916"></a>02916                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02917"></a>02917         }
<a name="l02918"></a>02918 
<a name="l02919"></a>02919     <a class="code" href="structdirentry.html">direntry</a> fileEntry1 = {}, fileEntry2 = {};
<a name="l02920"></a>02920         Bit32u dirClust1, subEntry1, dirClust2, subEntry2;
<a name="l02921"></a>02921         <span class="keywordtype">char</span> dirName2[DOS_NAMELENGTH_ASCII];
<a name="l02922"></a>02922         <span class="keywordtype">char</span> pathName2[11], path[DOS_PATHLENGTH];
<a name="l02923"></a>02923         lfnRange_t dir_lfn_range;
<a name="l02924"></a>02924 
<a name="l02925"></a>02925         <span class="comment">/* Check that old name exists (file or directory) */</span>
<a name="l02926"></a>02926         lfnRange.clear();
<a name="l02927"></a>02927         <span class="keywordflow">if</span>(!getFileDirEntry(oldname, &amp;fileEntry1, &amp;dirClust1, &amp;subEntry1, <span class="comment">/*dirOk*/</span><span class="keyword">true</span>)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02928"></a>02928         dir_lfn_range = lfnRange;
<a name="l02929"></a>02929 
<a name="l02930"></a>02930         <span class="comment">/* Check if new name (file or directory) already exists, fail if so */</span>
<a name="l02931"></a>02931         <span class="keywordflow">if</span>(getFileDirEntry(newname, &amp;fileEntry2, &amp;dirClust2, &amp;subEntry2, <span class="comment">/*dirOk*/</span><span class="keyword">true</span>)&amp;&amp;!(uselfn&amp;&amp;!force_sfn&amp;&amp;strcmp(oldname, newname)&amp;&amp;!strcasecmp(oldname, newname))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02932"></a>02932 
<a name="l02933"></a>02933         <span class="comment">/* Can we even get the name of the file itself? */</span>
<a name="l02934"></a>02934         <span class="keywordflow">if</span>(!getEntryName(newname, &amp;dirName2[0])||!strlen(trim(dirName2))) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02935"></a>02935         convToDirFile(&amp;dirName2[0], &amp;pathName2[0]);
<a name="l02936"></a>02936 
<a name="l02937"></a>02937         <span class="comment">/* Can we find the base directory of the new name? (we know the parent dir of oldname in dirClust1) */</span>
<a name="l02938"></a>02938         <span class="keywordflow">if</span>(!getDirClustNum(newname, &amp;dirClust2, <span class="keyword">true</span>)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02939"></a>02939 
<a name="l02940"></a>02940         <span class="comment">/* NTS: &quot;newname&quot; is the full relative path. For LFN creation to work we need only the final element of the path */</span>
<a name="l02941"></a>02941         <span class="keywordflow">if</span> (uselfn &amp;&amp; !force_sfn) {
<a name="l02942"></a>02942                 lfn = strrchr(newname,<span class="charliteral">&#39;\\&#39;</span>);
<a name="l02943"></a>02943 
<a name="l02944"></a>02944                 <span class="keywordflow">if</span> (lfn != NULL) {
<a name="l02945"></a>02945                         lfn++; <span class="comment">/* step past &#39;\&#39; */</span>
<a name="l02946"></a>02946                         strcpy(path, newname);
<a name="l02947"></a>02947                         *(strrchr(path,<span class="charliteral">&#39;\\&#39;</span>)+1)=0;
<a name="l02948"></a>02948                 } <span class="keywordflow">else</span> {
<a name="l02949"></a>02949                         lfn = newname; <span class="comment">/* no path elements */</span>
<a name="l02950"></a>02950                         *path=0;
<a name="l02951"></a>02951                 }
<a name="l02952"></a>02952 
<a name="l02953"></a>02953                 <span class="keywordflow">if</span> (filename_not_strict_8x3(lfn)) {
<a name="l02954"></a>02954                         <span class="keywordtype">char</span> oldchar=fileEntry1.entryname[0];
<a name="l02955"></a>02955                         fileEntry1.entryname[0] = 0xe5;
<a name="l02956"></a>02956                         directoryChange(dirClust1, &amp;fileEntry1, (Bit32s)subEntry1);
<a name="l02957"></a>02957                         <span class="keywordtype">char</span> *sfn=Generate_SFN(path, lfn);
<a name="l02958"></a>02958                         <span class="keywordflow">if</span> (sfn!=NULL) convToDirFile(sfn, &amp;pathName2[0]);
<a name="l02959"></a>02959                         fileEntry1.entryname[0] = oldchar;
<a name="l02960"></a>02960                         directoryChange(dirClust1, &amp;fileEntry1, (Bit32s)subEntry1);
<a name="l02961"></a>02961                 } <span class="keywordflow">else</span>
<a name="l02962"></a>02962                         lfn = NULL;
<a name="l02963"></a>02963         }
<a name="l02964"></a>02964 
<a name="l02965"></a>02965         <span class="comment">/* add new dirent */</span>
<a name="l02966"></a>02966         memcpy(&amp;fileEntry2, &amp;fileEntry1, <span class="keyword">sizeof</span>(<a class="code" href="structdirentry.html">direntry</a>));
<a name="l02967"></a>02967         memcpy(&amp;fileEntry2.entryname, &amp;pathName2[0], 11);
<a name="l02968"></a>02968         addDirectoryEntry(dirClust2, fileEntry2, lfn);
<a name="l02969"></a>02969 
<a name="l02970"></a>02970         <span class="comment">/* Remove old 8.3 SFN entry */</span>
<a name="l02971"></a>02971         fileEntry1.entryname[0] = 0xe5;
<a name="l02972"></a>02972         directoryChange(dirClust1, &amp;fileEntry1, (Bit32s)subEntry1);
<a name="l02973"></a>02973 
<a name="l02974"></a>02974         <span class="comment">/* remove LFNs of old entry only if emulating LFNs or DOS version 7.0.</span>
<a name="l02975"></a>02975 <span class="comment">         * Earlier DOS versions ignore LFNs. */</span>
<a name="l02976"></a>02976         <span class="keywordflow">if</span> (!dir_lfn_range.empty() &amp;&amp; (dos.version.major &gt;= 7 || uselfn)) {
<a name="l02977"></a>02977                 <span class="comment">/* last LFN entry should be fileidx */</span>
<a name="l02978"></a>02978                 assert(dir_lfn_range.dirPos_start &lt; dir_lfn_range.dirPos_end);
<a name="l02979"></a>02979                 <span class="keywordflow">if</span> (dir_lfn_range.dirPos_end != subEntry1) LOG_MSG(<span class="stringliteral">&quot;FAT warning: LFN dirPos_end=%u fileidx=%u (mismatch)&quot;</span>,dir_lfn_range.dirPos_end,subEntry1);
<a name="l02980"></a>02980                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> didx=dir_lfn_range.dirPos_start;didx &lt; dir_lfn_range.dirPos_end;didx++) {
<a name="l02981"></a>02981                         <span class="keywordflow">if</span> (directoryBrowse(dirClust1,&amp;fileEntry1,didx)) {
<a name="l02982"></a>02982                                 fileEntry1.entryname[0] = 0xe5;
<a name="l02983"></a>02983                                 directoryChange(dirClust1,&amp;fileEntry1,didx);
<a name="l02984"></a>02984                         }
<a name="l02985"></a>02985                 }
<a name="l02986"></a>02986         }
<a name="l02987"></a>02987 
<a name="l02988"></a>02988         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02989"></a>02989 }
<a name="l02990"></a>02990 
<a name="l02991"></a>02991 <span class="keywordtype">bool</span> fatDrive::TestDir(<span class="keyword">const</span> <span class="keywordtype">char</span> *dir) {
<a name="l02992"></a>02992         Bit32u dummyClust;
<a name="l02993"></a>02993 
<a name="l02994"></a>02994         <span class="comment">/* root directory is directory */</span>
<a name="l02995"></a>02995         <span class="keywordflow">if</span> (*dir == 0) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02996"></a>02996 
<a name="l02997"></a>02997         <span class="keywordflow">return</span> getDirClustNum(dir, &amp;dummyClust, <span class="keyword">false</span>);
<a name="l02998"></a>02998 }
<a name="l02999"></a>02999 
<a name="l03000"></a>03000 Bit32u fatDrive::GetPartitionOffset(<span class="keywordtype">void</span>) {
<a name="l03001"></a>03001         <span class="keywordflow">return</span> partSectOff;
<a name="l03002"></a>03002 }
<a name="l03003"></a>03003 
<a name="l03004"></a>03004 Bit32u fatDrive::GetFirstClusterOffset(<span class="keywordtype">void</span>) {
<a name="l03005"></a>03005     <span class="keywordflow">return</span> firstDataSector - partSectOff;
<a name="l03006"></a>03006 }
<a name="l03007"></a>03007 
<a name="l03008"></a>03008 Bit32u fatDrive::GetHighestClusterNumber(<span class="keywordtype">void</span>) {
<a name="l03009"></a>03009     <span class="keywordflow">return</span> CountOfClusters + 1ul;
<a name="l03010"></a>03010 }
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 5 2020 13:11:35 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
