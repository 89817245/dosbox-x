<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/libs/decoders/stb_vorbis.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/libs/decoders/stb_vorbis.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Ogg Vorbis audio decoder - v1.19 - public domain</span>
<a name="l00002"></a>00002 <span class="comment">// http://nothings.org/stb_vorbis/</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">// Original version written by Sean Barrett in 2007.</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">// Originally sponsored by RAD Game Tools. Seeking implementation</span>
<a name="l00007"></a>00007 <span class="comment">// sponsored by Phillip Bennefall, Marc Andersen, Aaron Baker,</span>
<a name="l00008"></a>00008 <span class="comment">// Elias Software, Aras Pranckevicius, and Sean Barrett.</span>
<a name="l00009"></a>00009 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment">// LICENSE</span>
<a name="l00011"></a>00011 <span class="comment">//</span>
<a name="l00012"></a>00012 <span class="comment">//   See end of file for license information.</span>
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">// Limitations:</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">//   - floor 0 not supported (used in old ogg vorbis files pre-2004)</span>
<a name="l00017"></a>00017 <span class="comment">//   - lossless sample-truncation at beginning ignored</span>
<a name="l00018"></a>00018 <span class="comment">//   - cannot concatenate multiple vorbis streams</span>
<a name="l00019"></a>00019 <span class="comment">//   - sample positions are 32-bit, limiting seekable 192Khz</span>
<a name="l00020"></a>00020 <span class="comment">//       files to around 6 hours (Ogg supports 64-bit)</span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">// Feature contributors:</span>
<a name="l00023"></a>00023 <span class="comment">//    Dougall Johnson (sample-exact seeking)</span>
<a name="l00024"></a>00024 <span class="comment">//</span>
<a name="l00025"></a>00025 <span class="comment">// Bugfix/warning contributors:</span>
<a name="l00026"></a>00026 <span class="comment">//    Terje Mathisen     Niklas Frykholm     Andy Hill</span>
<a name="l00027"></a>00027 <span class="comment">//    Casey Muratori     John Bolton         Gargaj</span>
<a name="l00028"></a>00028 <span class="comment">//    Laurent Gomila     Marc LeBlanc        Ronny Chevalier</span>
<a name="l00029"></a>00029 <span class="comment">//    Bernhard Wodo      Evan Balster        github:alxprd</span>
<a name="l00030"></a>00030 <span class="comment">//    Tom Beaumont       Ingo Leitgeb        Nicolas Guillemot</span>
<a name="l00031"></a>00031 <span class="comment">//    Phillip Bennefall  Rohit               Thiago Goulart</span>
<a name="l00032"></a>00032 <span class="comment">//    github:manxorist   saga musix          github:infatum</span>
<a name="l00033"></a>00033 <span class="comment">//    Timur Gagiev       Maxwell Koo         Peter Waller</span>
<a name="l00034"></a>00034 <span class="comment">//    github:audinowho   Dougall Johnson</span>
<a name="l00035"></a>00035 <span class="comment">//</span>
<a name="l00036"></a>00036 <span class="comment">// Partial history:</span>
<a name="l00037"></a>00037 <span class="comment">//    1.19    - 2020-02-05 - warnings</span>
<a name="l00038"></a>00038 <span class="comment">//    1.18    - 2020-02-02 - fix seek bugs; parse header comments; misc warnings etc.</span>
<a name="l00039"></a>00039 <span class="comment">//    1.17    - 2019-07-08 - fix CVE-2019-13217..CVE-2019-13223 (by ForAllSecure)</span>
<a name="l00040"></a>00040 <span class="comment">//    1.16    - 2019-03-04 - fix warnings</span>
<a name="l00041"></a>00041 <span class="comment">//    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found</span>
<a name="l00042"></a>00042 <span class="comment">//    1.14    - 2018-02-11 - delete bogus dealloca usage</span>
<a name="l00043"></a>00043 <span class="comment">//    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)</span>
<a name="l00044"></a>00044 <span class="comment">//    1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files</span>
<a name="l00045"></a>00045 <span class="comment">//    1.11    - 2017-07-23 - fix MinGW compilation</span>
<a name="l00046"></a>00046 <span class="comment">//    1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory</span>
<a name="l00047"></a>00047 <span class="comment">//    1.09    - 2016-04-04 - back out &#39;truncation of last frame&#39; fix from previous version</span>
<a name="l00048"></a>00048 <span class="comment">//    1.08    - 2016-04-02 - warnings; setup memory leaks; truncation of last frame</span>
<a name="l00049"></a>00049 <span class="comment">//    1.07    - 2015-01-16 - fixes for crashes on invalid files; warning fixes; const</span>
<a name="l00050"></a>00050 <span class="comment">//    1.06    - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)</span>
<a name="l00051"></a>00051 <span class="comment">//                           some crash fixes when out of memory or with corrupt files</span>
<a name="l00052"></a>00052 <span class="comment">//                           fix some inappropriately signed shifts</span>
<a name="l00053"></a>00053 <span class="comment">//    1.05    - 2015-04-19 - don&#39;t define __forceinline if it&#39;s redundant</span>
<a name="l00054"></a>00054 <span class="comment">//    1.04    - 2014-08-27 - fix missing const-correct case in API</span>
<a name="l00055"></a>00055 <span class="comment">//    1.03    - 2014-08-07 - warning fixes</span>
<a name="l00056"></a>00056 <span class="comment">//    1.02    - 2014-07-09 - declare qsort comparison as explicitly _cdecl in Windows</span>
<a name="l00057"></a>00057 <span class="comment">//    1.01    - 2014-06-18 - fix stb_vorbis_get_samples_float (interleaved was correct)</span>
<a name="l00058"></a>00058 <span class="comment">//    1.0     - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in &gt;2-channel;</span>
<a name="l00059"></a>00059 <span class="comment">//                           (API change) report sample rate for decode-full-file funcs</span>
<a name="l00060"></a>00060 <span class="comment">//</span>
<a name="l00061"></a>00061 <span class="comment">// See end of file for full version history.</span>
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 
<a name="l00065"></a>00065 <span class="comment">//</span>
<a name="l00066"></a>00066 <span class="comment">//  HEADER BEGINS HERE</span>
<a name="l00067"></a>00067 <span class="comment">//</span>
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="preprocessor">#ifndef STB_VORBIS_INCLUDE_STB_VORBIS_H</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#define STB_VORBIS_INCLUDE_STB_VORBIS_H</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>
<a name="l00072"></a>00072 <span class="preprocessor">#if defined(STB_VORBIS_NO_CRT) &amp;&amp; !defined(STB_VORBIS_NO_STDIO)</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#define STB_VORBIS_NO_STDIO 1</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span>
<a name="l00076"></a>00076 <span class="preprocessor">#ifndef STB_VORBIS_NO_STDIO</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00078"></a>00078 <span class="preprocessor">#endif</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span>
<a name="l00080"></a>00080 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00082"></a>00082 <span class="preprocessor">#endif</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span>
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="comment">// Individual stb_vorbis* handles are not thread-safe; you cannot decode from</span>
<a name="l00087"></a>00087 <span class="comment">// them from multiple threads at the same time. However, you can have multiple</span>
<a name="l00088"></a>00088 <span class="comment">// stb_vorbis* handles and decode from them independently in multiple thrads.</span>
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="comment">// normally stb_vorbis uses malloc() to allocate memory at startup,</span>
<a name="l00094"></a>00094 <span class="comment">// and alloca() to allocate temporary memory during a frame on the</span>
<a name="l00095"></a>00095 <span class="comment">// stack. (Memory consumption will depend on the amount of setup</span>
<a name="l00096"></a>00096 <span class="comment">// data in the file and how you set the compile flags for speed</span>
<a name="l00097"></a>00097 <span class="comment">// vs. size. In my test files the maximal-size usage is ~150KB.)</span>
<a name="l00098"></a>00098 <span class="comment">//</span>
<a name="l00099"></a>00099 <span class="comment">// You can modify the wrapper functions in the source (setup_malloc,</span>
<a name="l00100"></a>00100 <span class="comment">// setup_temp_malloc, temp_malloc) to change this behavior, or you</span>
<a name="l00101"></a>00101 <span class="comment">// can use a simpler allocation model: you pass in a buffer from</span>
<a name="l00102"></a>00102 <span class="comment">// which stb_vorbis will allocate _all_ its memory (including the</span>
<a name="l00103"></a>00103 <span class="comment">// temp memory). &quot;open&quot; may fail with a VORBIS_outofmem if you</span>
<a name="l00104"></a>00104 <span class="comment">// do not pass in enough data; there is no way to determine how</span>
<a name="l00105"></a>00105 <span class="comment">// much you do need except to succeed (at which point you can</span>
<a name="l00106"></a>00106 <span class="comment">// query get_info to find the exact amount required. yes I know</span>
<a name="l00107"></a>00107 <span class="comment">// this is lame).</span>
<a name="l00108"></a>00108 <span class="comment">//</span>
<a name="l00109"></a>00109 <span class="comment">// If you pass in a non-NULL buffer of the type below, allocation</span>
<a name="l00110"></a>00110 <span class="comment">// will occur from it as described above. Otherwise just pass NULL</span>
<a name="l00111"></a>00111 <span class="comment">// to use malloc()/alloca()</span>
<a name="l00112"></a>00112 
<a name="l00113"></a><a class="code" href="structstb__vorbis__alloc.html">00113</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00114"></a>00114 {
<a name="l00115"></a>00115    <span class="keywordtype">char</span> *alloc_buffer;
<a name="l00116"></a>00116    <span class="keywordtype">int</span>   alloc_buffer_length_in_bytes;
<a name="l00117"></a>00117 } <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a>;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structstb__vorbis.html">stb_vorbis</a> <a class="code" href="structstb__vorbis.html">stb_vorbis</a>;
<a name="l00123"></a>00123 
<a name="l00124"></a><a class="code" href="structstb__vorbis__info.html">00124</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00125"></a>00125 {
<a name="l00126"></a>00126    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sample_rate;
<a name="l00127"></a>00127    <span class="keywordtype">int</span> channels;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> setup_memory_required;
<a name="l00130"></a>00130    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> setup_temp_memory_required;
<a name="l00131"></a>00131    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> temp_memory_required;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133    <span class="keywordtype">int</span> max_frame_size;
<a name="l00134"></a>00134 } <a class="code" href="structstb__vorbis__info.html">stb_vorbis_info</a>;
<a name="l00135"></a>00135 
<a name="l00136"></a><a class="code" href="structstb__vorbis__comment.html">00136</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00137"></a>00137 {
<a name="l00138"></a>00138    <span class="keywordtype">char</span> *vendor;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140    <span class="keywordtype">int</span> comment_list_length;
<a name="l00141"></a>00141    <span class="keywordtype">char</span> **comment_list;
<a name="l00142"></a>00142 } <a class="code" href="structstb__vorbis__comment.html">stb_vorbis_comment</a>;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="comment">// get general information about the file</span>
<a name="l00145"></a>00145 <span class="keyword">extern</span> <a class="code" href="structstb__vorbis__info.html">stb_vorbis_info</a> stb_vorbis_get_info(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f);
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="comment">// get ogg comments</span>
<a name="l00148"></a>00148 <span class="keyword">extern</span> <a class="code" href="structstb__vorbis__comment.html">stb_vorbis_comment</a> stb_vorbis_get_comment(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f);
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="comment">// get the last error detected (clears it, too)</span>
<a name="l00151"></a>00151 <span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_get_error(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f);
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="comment">// close an ogg vorbis file and free all memory in use</span>
<a name="l00154"></a>00154 <span class="keyword">extern</span> <span class="keywordtype">void</span> stb_vorbis_close(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f);
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="comment">// this function returns the offset (in samples) from the beginning of the</span>
<a name="l00157"></a>00157 <span class="comment">// file that will be returned by the next decode, if it is known, or -1</span>
<a name="l00158"></a>00158 <span class="comment">// otherwise. after a flush_pushdata() call, this may take a while before</span>
<a name="l00159"></a>00159 <span class="comment">// it becomes valid again.</span>
<a name="l00160"></a>00160 <span class="comment">// NOT WORKING YET after a seek with PULLDATA API</span>
<a name="l00161"></a>00161 <span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_get_sample_offset(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f);
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">// returns the current seek point within the file, or offset from the beginning</span>
<a name="l00164"></a>00164 <span class="comment">// of the memory buffer. In pushdata mode it returns 0.</span>
<a name="l00165"></a>00165 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stb_vorbis_get_file_offset(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f);
<a name="l00166"></a>00166 
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="preprocessor">#ifndef STB_VORBIS_NO_PUSHDATA_API</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span>
<a name="l00171"></a>00171 <span class="comment">// this API allows you to get blocks of data from any source and hand</span>
<a name="l00172"></a>00172 <span class="comment">// them to stb_vorbis. you have to buffer them; stb_vorbis will tell</span>
<a name="l00173"></a>00173 <span class="comment">// you how much it used, and you have to give it the rest next time;</span>
<a name="l00174"></a>00174 <span class="comment">// and stb_vorbis may not have enough data to work with and you will</span>
<a name="l00175"></a>00175 <span class="comment">// need to give it the same data again PLUS more. Note that the Vorbis</span>
<a name="l00176"></a>00176 <span class="comment">// specification does not bound the size of an individual frame.</span>
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 <span class="keyword">extern</span> <a class="code" href="structstb__vorbis.html">stb_vorbis</a> *stb_vorbis_open_pushdata(
<a name="l00179"></a>00179          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * datablock, <span class="keywordtype">int</span> datablock_length_in_bytes,
<a name="l00180"></a>00180          <span class="keywordtype">int</span> *datablock_memory_consumed_in_bytes,
<a name="l00181"></a>00181          <span class="keywordtype">int</span> *error,
<a name="l00182"></a>00182          <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc_buffer);
<a name="l00183"></a>00183 <span class="comment">// create a vorbis decoder by passing in the initial data block containing</span>
<a name="l00184"></a>00184 <span class="comment">//    the ogg&amp;vorbis headers (you don&#39;t need to do parse them, just provide</span>
<a name="l00185"></a>00185 <span class="comment">//    the first N bytes of the file--you&#39;re told if it&#39;s not enough, see below)</span>
<a name="l00186"></a>00186 <span class="comment">// on success, returns an stb_vorbis *, does not set error, returns the amount of</span>
<a name="l00187"></a>00187 <span class="comment">//    data parsed/consumed on this call in *datablock_memory_consumed_in_bytes;</span>
<a name="l00188"></a>00188 <span class="comment">// on failure, returns NULL on error and sets *error, does not change *datablock_memory_consumed</span>
<a name="l00189"></a>00189 <span class="comment">// if returns NULL and *error is VORBIS_need_more_data, then the input block was</span>
<a name="l00190"></a>00190 <span class="comment">//       incomplete and you need to pass in a larger block from the start of the file</span>
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_decode_frame_pushdata(
<a name="l00193"></a>00193          <a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f,
<a name="l00194"></a>00194          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *datablock, <span class="keywordtype">int</span> datablock_length_in_bytes,
<a name="l00195"></a>00195          <span class="keywordtype">int</span> *channels,             <span class="comment">// place to write number of float * buffers</span>
<a name="l00196"></a>00196          <span class="keywordtype">float</span> ***output,           <span class="comment">// place to write float ** array of float * buffers</span>
<a name="l00197"></a>00197          <span class="keywordtype">int</span> *samples               <span class="comment">// place to write number of output samples</span>
<a name="l00198"></a>00198      );
<a name="l00199"></a>00199 <span class="comment">// decode a frame of audio sample data if possible from the passed-in data block</span>
<a name="l00200"></a>00200 <span class="comment">//</span>
<a name="l00201"></a>00201 <span class="comment">// return value: number of bytes we used from datablock</span>
<a name="l00202"></a>00202 <span class="comment">//</span>
<a name="l00203"></a>00203 <span class="comment">// possible cases:</span>
<a name="l00204"></a>00204 <span class="comment">//     0 bytes used, 0 samples output (need more data)</span>
<a name="l00205"></a>00205 <span class="comment">//     N bytes used, 0 samples output (resynching the stream, keep going)</span>
<a name="l00206"></a>00206 <span class="comment">//     N bytes used, M samples output (one frame of data)</span>
<a name="l00207"></a>00207 <span class="comment">// note that after opening a file, you will ALWAYS get one N-bytes,0-sample</span>
<a name="l00208"></a>00208 <span class="comment">// frame, because Vorbis always &quot;discards&quot; the first frame.</span>
<a name="l00209"></a>00209 <span class="comment">//</span>
<a name="l00210"></a>00210 <span class="comment">// Note that on resynch, stb_vorbis will rarely consume all of the buffer,</span>
<a name="l00211"></a>00211 <span class="comment">// instead only datablock_length_in_bytes-3 or less. This is because it wants</span>
<a name="l00212"></a>00212 <span class="comment">// to avoid missing parts of a page header if they cross a datablock boundary,</span>
<a name="l00213"></a>00213 <span class="comment">// without writing state-machiney code to record a partial detection.</span>
<a name="l00214"></a>00214 <span class="comment">//</span>
<a name="l00215"></a>00215 <span class="comment">// The number of channels returned are stored in *channels (which can be</span>
<a name="l00216"></a>00216 <span class="comment">// NULL--it is always the same as the number of channels reported by</span>
<a name="l00217"></a>00217 <span class="comment">// get_info). *output will contain an array of float* buffers, one per</span>
<a name="l00218"></a>00218 <span class="comment">// channel. In other words, (*output)[0][0] contains the first sample from</span>
<a name="l00219"></a>00219 <span class="comment">// the first channel, and (*output)[1][0] contains the first sample from</span>
<a name="l00220"></a>00220 <span class="comment">// the second channel.</span>
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="keyword">extern</span> <span class="keywordtype">void</span> stb_vorbis_flush_pushdata(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f);
<a name="l00223"></a>00223 <span class="comment">// inform stb_vorbis that your next datablock will not be contiguous with</span>
<a name="l00224"></a>00224 <span class="comment">// previous ones (e.g. you&#39;ve seeked in the data); future attempts to decode</span>
<a name="l00225"></a>00225 <span class="comment">// frames will cause stb_vorbis to resynchronize (as noted above), and</span>
<a name="l00226"></a>00226 <span class="comment">// once it sees a valid Ogg page (typically 4-8KB, as large as 64KB), it</span>
<a name="l00227"></a>00227 <span class="comment">// will begin decoding the _next_ frame.</span>
<a name="l00228"></a>00228 <span class="comment">//</span>
<a name="l00229"></a>00229 <span class="comment">// if you want to seek using pushdata, you need to seek in your file, then</span>
<a name="l00230"></a>00230 <span class="comment">// call stb_vorbis_flush_pushdata(), then start calling decoding, then once</span>
<a name="l00231"></a>00231 <span class="comment">// decoding is returning you data, call stb_vorbis_get_sample_offset, and</span>
<a name="l00232"></a>00232 <span class="comment">// if you don&#39;t like the result, seek your file again and repeat.</span>
<a name="l00233"></a>00233 <span class="preprocessor">#endif</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span>
<a name="l00235"></a>00235 
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="preprocessor">#ifndef STB_VORBIS_NO_PULLDATA_API</span>
<a name="l00239"></a>00239 <span class="preprocessor"></span><span class="comment">// This API assumes stb_vorbis is allowed to pull data from a source--</span>
<a name="l00240"></a>00240 <span class="comment">// either a block of memory containing the _entire_ vorbis stream, or a</span>
<a name="l00241"></a>00241 <span class="comment">// FILE * that you or it create, or possibly some other reading mechanism</span>
<a name="l00242"></a>00242 <span class="comment">// if you go modify the source to replace the FILE * case with some kind</span>
<a name="l00243"></a>00243 <span class="comment">// of callback to your code. (But if you don&#39;t support seeking, you may</span>
<a name="l00244"></a>00244 <span class="comment">// just want to go ahead and use pushdata.)</span>
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 <span class="preprocessor">#if !defined(STB_VORBIS_NO_STDIO) &amp;&amp; !defined(STB_VORBIS_NO_INTEGER_CONVERSION)</span>
<a name="l00247"></a>00247 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_decode_filename(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> *channels, <span class="keywordtype">int</span> *sample_rate, <span class="keywordtype">short</span> **output);
<a name="l00248"></a>00248 <span class="preprocessor">#endif</span>
<a name="l00249"></a>00249 <span class="preprocessor"></span><span class="preprocessor">#if !defined(STB_VORBIS_NO_INTEGER_CONVERSION)</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_decode_memory(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *mem, <span class="keywordtype">int</span> len, <span class="keywordtype">int</span> *channels, <span class="keywordtype">int</span> *sample_rate, <span class="keywordtype">short</span> **output);
<a name="l00251"></a>00251 <span class="preprocessor">#endif</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span><span class="comment">// decode an entire file and output the data interleaved into a malloc()ed</span>
<a name="l00253"></a>00253 <span class="comment">// buffer stored in *output. The return value is the number of samples</span>
<a name="l00254"></a>00254 <span class="comment">// decoded, or -1 if the file could not be opened or was not an ogg vorbis file.</span>
<a name="l00255"></a>00255 <span class="comment">// When you&#39;re done with it, just free() the pointer returned in *output.</span>
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="keyword">extern</span> <a class="code" href="structstb__vorbis.html">stb_vorbis</a> * stb_vorbis_open_memory(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">int</span> len,
<a name="l00258"></a>00258                                   <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc_buffer);
<a name="l00259"></a>00259 <span class="comment">// create an ogg vorbis decoder from an ogg vorbis stream in memory (note</span>
<a name="l00260"></a>00260 <span class="comment">// this must be the entire stream!). on failure, returns NULL and sets *error</span>
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 <span class="preprocessor">#ifndef STB_VORBIS_NO_STDIO</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span><span class="keyword">extern</span> <a class="code" href="structstb__vorbis.html">stb_vorbis</a> * stb_vorbis_open_filename(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename,
<a name="l00264"></a>00264                                   <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc_buffer);
<a name="l00265"></a>00265 <span class="comment">// create an ogg vorbis decoder from a filename via fopen(). on failure,</span>
<a name="l00266"></a>00266 <span class="comment">// returns NULL and sets *error (possibly to VORBIS_file_open_failure).</span>
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 <span class="keyword">extern</span> <a class="code" href="structstb__vorbis.html">stb_vorbis</a> * stb_vorbis_open_file(FILE *f, <span class="keywordtype">int</span> close_handle_on_close,
<a name="l00269"></a>00269                                   <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc_buffer);
<a name="l00270"></a>00270 <span class="comment">// create an ogg vorbis decoder from an open FILE *, looking for a stream at</span>
<a name="l00271"></a>00271 <span class="comment">// the _current_ seek point (ftell). on failure, returns NULL and sets *error.</span>
<a name="l00272"></a>00272 <span class="comment">// note that stb_vorbis must &quot;own&quot; this stream; if you seek it in between</span>
<a name="l00273"></a>00273 <span class="comment">// calls to stb_vorbis, it will become confused. Moreover, if you attempt to</span>
<a name="l00274"></a>00274 <span class="comment">// perform stb_vorbis_seek_*() operations on this file, it will assume it</span>
<a name="l00275"></a>00275 <span class="comment">// owns the _entire_ rest of the file after the start point. Use the next</span>
<a name="l00276"></a>00276 <span class="comment">// function, stb_vorbis_open_file_section(), to limit it.</span>
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="keyword">extern</span> <a class="code" href="structstb__vorbis.html">stb_vorbis</a> * stb_vorbis_open_file_section(FILE *f, <span class="keywordtype">int</span> close_handle_on_close,
<a name="l00279"></a>00279                 <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc_buffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len);
<a name="l00280"></a>00280 <span class="comment">// create an ogg vorbis decoder from an open FILE *, looking for a stream at</span>
<a name="l00281"></a>00281 <span class="comment">// the _current_ seek point (ftell); the stream will be of length &#39;len&#39; bytes.</span>
<a name="l00282"></a>00282 <span class="comment">// on failure, returns NULL and sets *error. note that stb_vorbis must &quot;own&quot;</span>
<a name="l00283"></a>00283 <span class="comment">// this stream; if you seek it in between calls to stb_vorbis, it will become</span>
<a name="l00284"></a>00284 <span class="comment">// confused.</span>
<a name="l00285"></a>00285 <span class="preprocessor">#endif</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>
<a name="l00287"></a>00287 <span class="preprocessor">#ifdef __SDL_SOUND_INTERNAL__</span>
<a name="l00288"></a>00288 <span class="preprocessor"></span><span class="keyword">extern</span> <a class="code" href="structstb__vorbis.html">stb_vorbis</a> * stb_vorbis_open_rwops_section(SDL_RWops *rwops, <span class="keywordtype">int</span> close_on_free, <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length);
<a name="l00289"></a>00289 <span class="keyword">extern</span> <a class="code" href="structstb__vorbis.html">stb_vorbis</a> * stb_vorbis_open_rwops(SDL_RWops *rwops, <span class="keywordtype">int</span> close_on_free, <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc);
<a name="l00290"></a>00290 <span class="preprocessor">#endif</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span>
<a name="l00292"></a>00292 <span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_seek_frame(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sample_number);
<a name="l00293"></a>00293 <span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_seek(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sample_number);
<a name="l00294"></a>00294 <span class="comment">// these functions seek in the Vorbis file to (approximately) &#39;sample_number&#39;.</span>
<a name="l00295"></a>00295 <span class="comment">// after calling seek_frame(), the next call to get_frame_*() will include</span>
<a name="l00296"></a>00296 <span class="comment">// the specified sample. after calling stb_vorbis_seek(), the next call to</span>
<a name="l00297"></a>00297 <span class="comment">// stb_vorbis_get_samples_* will start with the specified sample. If you</span>
<a name="l00298"></a>00298 <span class="comment">// do not need to seek to EXACTLY the target sample when using get_samples_*,</span>
<a name="l00299"></a>00299 <span class="comment">// you can also use seek_frame().</span>
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_seek_start(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f);
<a name="l00302"></a>00302 <span class="comment">// this function is equivalent to stb_vorbis_seek(f,0)</span>
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stb_vorbis_stream_length_in_samples(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f);
<a name="l00305"></a>00305 <span class="keyword">extern</span> <span class="keywordtype">float</span>        stb_vorbis_stream_length_in_seconds(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f);
<a name="l00306"></a>00306 <span class="comment">// these functions return the total length of the vorbis stream</span>
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 <span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_get_frame_float(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> *channels, <span class="keywordtype">float</span> ***output);
<a name="l00309"></a>00309 <span class="comment">// decode the next frame and return the number of samples. the number of</span>
<a name="l00310"></a>00310 <span class="comment">// channels returned are stored in *channels (which can be NULL--it is always</span>
<a name="l00311"></a>00311 <span class="comment">// the same as the number of channels reported by get_info). *output will</span>
<a name="l00312"></a>00312 <span class="comment">// contain an array of float* buffers, one per channel. These outputs will</span>
<a name="l00313"></a>00313 <span class="comment">// be overwritten on the next call to stb_vorbis_get_frame_*.</span>
<a name="l00314"></a>00314 <span class="comment">//</span>
<a name="l00315"></a>00315 <span class="comment">// You generally should not intermix calls to stb_vorbis_get_frame_*()</span>
<a name="l00316"></a>00316 <span class="comment">// and stb_vorbis_get_samples_*(), since the latter calls the former.</span>
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 <span class="preprocessor">#ifndef STB_VORBIS_NO_INTEGER_CONVERSION</span>
<a name="l00319"></a>00319 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_get_frame_short_interleaved(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> num_c, <span class="keywordtype">short</span> *buffer, <span class="keywordtype">int</span> num_shorts);
<a name="l00320"></a>00320 <span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_get_frame_short            (<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> num_c, <span class="keywordtype">short</span> **buffer, <span class="keywordtype">int</span> num_samples);
<a name="l00321"></a>00321 <span class="preprocessor">#endif</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span><span class="comment">// decode the next frame and return the number of *samples* per channel.</span>
<a name="l00323"></a>00323 <span class="comment">// Note that for interleaved data, you pass in the number of shorts (the</span>
<a name="l00324"></a>00324 <span class="comment">// size of your array), but the return value is the number of samples per</span>
<a name="l00325"></a>00325 <span class="comment">// channel, not the total number of samples.</span>
<a name="l00326"></a>00326 <span class="comment">//</span>
<a name="l00327"></a>00327 <span class="comment">// The data is coerced to the number of channels you request according to the</span>
<a name="l00328"></a>00328 <span class="comment">// channel coercion rules (see below). You must pass in the size of your</span>
<a name="l00329"></a>00329 <span class="comment">// buffer(s) so that stb_vorbis will not overwrite the end of the buffer.</span>
<a name="l00330"></a>00330 <span class="comment">// The maximum buffer size needed can be gotten from get_info(); however,</span>
<a name="l00331"></a>00331 <span class="comment">// the Vorbis I specification implies an absolute maximum of 4096 samples</span>
<a name="l00332"></a>00332 <span class="comment">// per channel.</span>
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 <span class="comment">// Channel coercion rules:</span>
<a name="l00335"></a>00335 <span class="comment">//    Let M be the number of channels requested, and N the number of channels present,</span>
<a name="l00336"></a>00336 <span class="comment">//    and Cn be the nth channel; let stereo L be the sum of all L and center channels,</span>
<a name="l00337"></a>00337 <span class="comment">//    and stereo R be the sum of all R and center channels (channel assignment from the</span>
<a name="l00338"></a>00338 <span class="comment">//    vorbis spec).</span>
<a name="l00339"></a>00339 <span class="comment">//        M    N       output</span>
<a name="l00340"></a>00340 <span class="comment">//        1    k      sum(Ck) for all k</span>
<a name="l00341"></a>00341 <span class="comment">//        2    *      stereo L, stereo R</span>
<a name="l00342"></a>00342 <span class="comment">//        k    l      k &gt; l, the first l channels, then 0s</span>
<a name="l00343"></a>00343 <span class="comment">//        k    l      k &lt;= l, the first k channels</span>
<a name="l00344"></a>00344 <span class="comment">//    Note that this is not _good_ surround etc. mixing at all! It&#39;s just so</span>
<a name="l00345"></a>00345 <span class="comment">//    you get something useful.</span>
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_get_samples_float_interleaved(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> channels, <span class="keywordtype">float</span> *buffer, <span class="keywordtype">int</span> num_floats);
<a name="l00348"></a>00348 <span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_get_samples_float(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> channels, <span class="keywordtype">float</span> **buffer, <span class="keywordtype">int</span> num_samples);
<a name="l00349"></a>00349 <span class="comment">// gets num_samples samples, not necessarily on a frame boundary--this requires</span>
<a name="l00350"></a>00350 <span class="comment">// buffering so you have to supply the buffers. DOES NOT APPLY THE COERCION RULES.</span>
<a name="l00351"></a>00351 <span class="comment">// Returns the number of samples stored per channel; it may be less than requested</span>
<a name="l00352"></a>00352 <span class="comment">// at the end of the file. If there are no more samples in the file, returns 0.</span>
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 <span class="preprocessor">#ifndef STB_VORBIS_NO_INTEGER_CONVERSION</span>
<a name="l00355"></a>00355 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_get_samples_short_interleaved(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> channels, <span class="keywordtype">short</span> *buffer, <span class="keywordtype">int</span> num_shorts);
<a name="l00356"></a>00356 <span class="keyword">extern</span> <span class="keywordtype">int</span> stb_vorbis_get_samples_short(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> channels, <span class="keywordtype">short</span> **buffer, <span class="keywordtype">int</span> num_samples);
<a name="l00357"></a>00357 <span class="preprocessor">#endif</span>
<a name="l00358"></a>00358 <span class="preprocessor"></span><span class="comment">// gets num_samples samples, not necessarily on a frame boundary--this requires</span>
<a name="l00359"></a>00359 <span class="comment">// buffering so you have to supply the buffers. Applies the coercion rules above</span>
<a name="l00360"></a>00360 <span class="comment">// to produce &#39;channels&#39; channels. Returns the number of samples stored per channel;</span>
<a name="l00361"></a>00361 <span class="comment">// it may be less than requested at the end of the file. If there are no more</span>
<a name="l00362"></a>00362 <span class="comment">// samples in the file, returns 0.</span>
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 <span class="preprocessor">#endif</span>
<a name="l00365"></a>00365 <span class="preprocessor"></span>
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 <span class="keyword">enum</span> STBVorbisError
<a name="l00369"></a>00369 {
<a name="l00370"></a>00370    VORBIS__no_error = 0,
<a name="l00371"></a>00371 
<a name="l00372"></a>00372    VORBIS_need_more_data=1,             <span class="comment">// not a real error</span>
<a name="l00373"></a>00373 
<a name="l00374"></a>00374    VORBIS_invalid_api_mixing,           <span class="comment">// can&#39;t mix API modes</span>
<a name="l00375"></a>00375    VORBIS_outofmem,                     <span class="comment">// not enough memory</span>
<a name="l00376"></a>00376    VORBIS_feature_not_supported,        <span class="comment">// uses floor 0</span>
<a name="l00377"></a>00377    VORBIS_too_many_channels,            <span class="comment">// STB_VORBIS_MAX_CHANNELS is too small</span>
<a name="l00378"></a>00378    VORBIS_file_open_failure,            <span class="comment">// fopen() failed</span>
<a name="l00379"></a>00379    VORBIS_seek_without_length,          <span class="comment">// can&#39;t seek in unknown-length file</span>
<a name="l00380"></a>00380 
<a name="l00381"></a>00381    VORBIS_unexpected_eof=10,            <span class="comment">// file is truncated?</span>
<a name="l00382"></a>00382    VORBIS_seek_invalid,                 <span class="comment">// seek past EOF</span>
<a name="l00383"></a>00383 
<a name="l00384"></a>00384    <span class="comment">// decoding errors (corrupt/invalid stream) -- you probably</span>
<a name="l00385"></a>00385    <span class="comment">// don&#39;t care about the exact details of these</span>
<a name="l00386"></a>00386 
<a name="l00387"></a>00387    <span class="comment">// vorbis errors:</span>
<a name="l00388"></a>00388    VORBIS_invalid_setup=20,
<a name="l00389"></a>00389    VORBIS_invalid_stream,
<a name="l00390"></a>00390 
<a name="l00391"></a>00391    <span class="comment">// ogg errors:</span>
<a name="l00392"></a>00392    VORBIS_missing_capture_pattern=30,
<a name="l00393"></a>00393    VORBIS_invalid_stream_structure_version,
<a name="l00394"></a>00394    VORBIS_continued_packet_flag_invalid,
<a name="l00395"></a>00395    VORBIS_incorrect_stream_serial_number,
<a name="l00396"></a>00396    VORBIS_invalid_first_page,
<a name="l00397"></a>00397    VORBIS_bad_packet_type,
<a name="l00398"></a>00398    VORBIS_cant_find_last_page,
<a name="l00399"></a>00399    VORBIS_seek_failed,
<a name="l00400"></a>00400    VORBIS_ogg_skeleton_not_supported
<a name="l00401"></a>00401 };
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00405"></a>00405 <span class="preprocessor"></span>}
<a name="l00406"></a>00406 <span class="preprocessor">#endif</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span>
<a name="l00408"></a>00408 <span class="preprocessor">#endif // STB_VORBIS_INCLUDE_STB_VORBIS_H</span>
<a name="l00409"></a>00409 <span class="preprocessor"></span><span class="comment">//</span>
<a name="l00410"></a>00410 <span class="comment">//  HEADER ENDS HERE</span>
<a name="l00411"></a>00411 <span class="comment">//</span>
<a name="l00413"></a>00413 <span class="comment"></span>
<a name="l00414"></a>00414 <span class="preprocessor">#ifndef STB_VORBIS_HEADER_ONLY</span>
<a name="l00415"></a>00415 <span class="preprocessor"></span>
<a name="l00416"></a>00416 <span class="comment">// global configuration settings (e.g. set these in the project/makefile),</span>
<a name="l00417"></a>00417 <span class="comment">// or just set them in this file at the top (although ideally the first few</span>
<a name="l00418"></a>00418 <span class="comment">// should be visible when the header file is compiled too, although it&#39;s not</span>
<a name="l00419"></a>00419 <span class="comment">// crucial)</span>
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 <span class="comment">// STB_VORBIS_NO_PUSHDATA_API</span>
<a name="l00422"></a>00422 <span class="comment">//     does not compile the code for the various stb_vorbis_*_pushdata()</span>
<a name="l00423"></a>00423 <span class="comment">//     functions</span>
<a name="l00424"></a>00424 <span class="comment">// #define STB_VORBIS_NO_PUSHDATA_API</span>
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="comment">// STB_VORBIS_NO_PULLDATA_API</span>
<a name="l00427"></a>00427 <span class="comment">//     does not compile the code for the non-pushdata APIs</span>
<a name="l00428"></a>00428 <span class="comment">// #define STB_VORBIS_NO_PULLDATA_API</span>
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 <span class="comment">// STB_VORBIS_NO_STDIO</span>
<a name="l00431"></a>00431 <span class="comment">//     does not compile the code for the APIs that use FILE *s internally</span>
<a name="l00432"></a>00432 <span class="comment">//     or externally (implied by STB_VORBIS_NO_PULLDATA_API)</span>
<a name="l00433"></a>00433 <span class="comment">// #define STB_VORBIS_NO_STDIO</span>
<a name="l00434"></a>00434 
<a name="l00435"></a>00435 <span class="comment">// STB_VORBIS_NO_INTEGER_CONVERSION</span>
<a name="l00436"></a>00436 <span class="comment">//     does not compile the code for converting audio sample data from</span>
<a name="l00437"></a>00437 <span class="comment">//     float to integer (implied by STB_VORBIS_NO_PULLDATA_API)</span>
<a name="l00438"></a>00438 <span class="comment">// #define STB_VORBIS_NO_INTEGER_CONVERSION</span>
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="comment">// STB_VORBIS_NO_FAST_SCALED_FLOAT</span>
<a name="l00441"></a>00441 <span class="comment">//      does not use a fast float-to-int trick to accelerate float-to-int on</span>
<a name="l00442"></a>00442 <span class="comment">//      most platforms which requires endianness be defined correctly.</span>
<a name="l00443"></a>00443 <span class="comment">//#define STB_VORBIS_NO_FAST_SCALED_FLOAT</span>
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 
<a name="l00446"></a>00446 <span class="comment">// STB_VORBIS_MAX_CHANNELS [number]</span>
<a name="l00447"></a>00447 <span class="comment">//     globally define this to the maximum number of channels you need.</span>
<a name="l00448"></a>00448 <span class="comment">//     The spec does not put a restriction on channels except that</span>
<a name="l00449"></a>00449 <span class="comment">//     the count is stored in a byte, so 255 is the hard limit.</span>
<a name="l00450"></a>00450 <span class="comment">//     Reducing this saves about 16 bytes per value, so using 16 saves</span>
<a name="l00451"></a>00451 <span class="comment">//     (255-16)*16 or around 4KB. Plus anything other memory usage</span>
<a name="l00452"></a>00452 <span class="comment">//     I forgot to account for. Can probably go as low as 8 (7.1 audio),</span>
<a name="l00453"></a>00453 <span class="comment">//     6 (5.1 audio), or 2 (stereo only).</span>
<a name="l00454"></a>00454 <span class="preprocessor">#ifndef STB_VORBIS_MAX_CHANNELS</span>
<a name="l00455"></a>00455 <span class="preprocessor"></span><span class="preprocessor">#define STB_VORBIS_MAX_CHANNELS    16  // enough for anyone?</span>
<a name="l00456"></a>00456 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span>
<a name="l00458"></a>00458 <span class="comment">// STB_VORBIS_PUSHDATA_CRC_COUNT [number]</span>
<a name="l00459"></a>00459 <span class="comment">//     after a flush_pushdata(), stb_vorbis begins scanning for the</span>
<a name="l00460"></a>00460 <span class="comment">//     next valid page, without backtracking. when it finds something</span>
<a name="l00461"></a>00461 <span class="comment">//     that looks like a page, it streams through it and verifies its</span>
<a name="l00462"></a>00462 <span class="comment">//     CRC32. Should that validation fail, it keeps scanning. But it&#39;s</span>
<a name="l00463"></a>00463 <span class="comment">//     possible that _while_ streaming through to check the CRC32 of</span>
<a name="l00464"></a>00464 <span class="comment">//     one candidate page, it sees another candidate page. This #define</span>
<a name="l00465"></a>00465 <span class="comment">//     determines how many &quot;overlapping&quot; candidate pages it can search</span>
<a name="l00466"></a>00466 <span class="comment">//     at once. Note that &quot;real&quot; pages are typically ~4KB to ~8KB, whereas</span>
<a name="l00467"></a>00467 <span class="comment">//     garbage pages could be as big as 64KB, but probably average ~16KB.</span>
<a name="l00468"></a>00468 <span class="comment">//     So don&#39;t hose ourselves by scanning an apparent 64KB page and</span>
<a name="l00469"></a>00469 <span class="comment">//     missing a ton of real ones in the interim; so minimum of 2</span>
<a name="l00470"></a>00470 <span class="preprocessor">#ifndef STB_VORBIS_PUSHDATA_CRC_COUNT</span>
<a name="l00471"></a>00471 <span class="preprocessor"></span><span class="preprocessor">#define STB_VORBIS_PUSHDATA_CRC_COUNT  4</span>
<a name="l00472"></a>00472 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00473"></a>00473 <span class="preprocessor"></span>
<a name="l00474"></a>00474 <span class="comment">// STB_VORBIS_FAST_HUFFMAN_LENGTH [number]</span>
<a name="l00475"></a>00475 <span class="comment">//     sets the log size of the huffman-acceleration table.  Maximum</span>
<a name="l00476"></a>00476 <span class="comment">//     supported value is 24. with larger numbers, more decodings are O(1),</span>
<a name="l00477"></a>00477 <span class="comment">//     but the table size is larger so worse cache missing, so you&#39;ll have</span>
<a name="l00478"></a>00478 <span class="comment">//     to probe (and try multiple ogg vorbis files) to find the sweet spot.</span>
<a name="l00479"></a>00479 <span class="preprocessor">#ifndef STB_VORBIS_FAST_HUFFMAN_LENGTH</span>
<a name="l00480"></a>00480 <span class="preprocessor"></span><span class="preprocessor">#define STB_VORBIS_FAST_HUFFMAN_LENGTH   10</span>
<a name="l00481"></a>00481 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00482"></a>00482 <span class="preprocessor"></span>
<a name="l00483"></a>00483 <span class="comment">// STB_VORBIS_FAST_BINARY_LENGTH [number]</span>
<a name="l00484"></a>00484 <span class="comment">//     sets the log size of the binary-search acceleration table. this</span>
<a name="l00485"></a>00485 <span class="comment">//     is used in similar fashion to the fast-huffman size to set initial</span>
<a name="l00486"></a>00486 <span class="comment">//     parameters for the binary search</span>
<a name="l00487"></a>00487 
<a name="l00488"></a>00488 <span class="comment">// STB_VORBIS_FAST_HUFFMAN_INT</span>
<a name="l00489"></a>00489 <span class="comment">//     The fast huffman tables are much more efficient if they can be</span>
<a name="l00490"></a>00490 <span class="comment">//     stored as 16-bit results instead of 32-bit results. This restricts</span>
<a name="l00491"></a>00491 <span class="comment">//     the codebooks to having only 65535 possible outcomes, though.</span>
<a name="l00492"></a>00492 <span class="comment">//     (At least, accelerated by the huffman table.)</span>
<a name="l00493"></a>00493 <span class="preprocessor">#ifndef STB_VORBIS_FAST_HUFFMAN_INT</span>
<a name="l00494"></a>00494 <span class="preprocessor"></span><span class="preprocessor">#define STB_VORBIS_FAST_HUFFMAN_SHORT</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00496"></a>00496 <span class="preprocessor"></span>
<a name="l00497"></a>00497 <span class="comment">// STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH</span>
<a name="l00498"></a>00498 <span class="comment">//     If the &#39;fast huffman&#39; search doesn&#39;t succeed, then stb_vorbis falls</span>
<a name="l00499"></a>00499 <span class="comment">//     back on binary searching for the correct one. This requires storing</span>
<a name="l00500"></a>00500 <span class="comment">//     extra tables with the huffman codes in sorted order. Defining this</span>
<a name="l00501"></a>00501 <span class="comment">//     symbol trades off space for speed by forcing a linear search in the</span>
<a name="l00502"></a>00502 <span class="comment">//     non-fast case, except for &quot;sparse&quot; codebooks.</span>
<a name="l00503"></a>00503 <span class="comment">// #define STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH</span>
<a name="l00504"></a>00504 
<a name="l00505"></a>00505 <span class="comment">// STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l00506"></a>00506 <span class="comment">//     stb_vorbis precomputes the result of the scalar residue decoding</span>
<a name="l00507"></a>00507 <span class="comment">//     that would otherwise require a divide per chunk. you can trade off</span>
<a name="l00508"></a>00508 <span class="comment">//     space for time by defining this symbol.</span>
<a name="l00509"></a>00509 <span class="comment">// #define STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 <span class="comment">// STB_VORBIS_DIVIDES_IN_CODEBOOK</span>
<a name="l00512"></a>00512 <span class="comment">//     vorbis VQ codebooks can be encoded two ways: with every case explicitly</span>
<a name="l00513"></a>00513 <span class="comment">//     stored, or with all elements being chosen from a small range of values,</span>
<a name="l00514"></a>00514 <span class="comment">//     and all values possible in all elements. By default, stb_vorbis expands</span>
<a name="l00515"></a>00515 <span class="comment">//     this latter kind out to look like the former kind for ease of decoding,</span>
<a name="l00516"></a>00516 <span class="comment">//     because otherwise an integer divide-per-vector-element is required to</span>
<a name="l00517"></a>00517 <span class="comment">//     unpack the index. If you define STB_VORBIS_DIVIDES_IN_CODEBOOK, you can</span>
<a name="l00518"></a>00518 <span class="comment">//     trade off storage for speed.</span>
<a name="l00519"></a>00519 <span class="comment">//#define STB_VORBIS_DIVIDES_IN_CODEBOOK</span>
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 <span class="preprocessor">#ifdef STB_VORBIS_CODEBOOK_SHORTS</span>
<a name="l00522"></a>00522 <span class="preprocessor"></span><span class="preprocessor">#error &quot;STB_VORBIS_CODEBOOK_SHORTS is no longer supported as it produced incorrect results for some input formats&quot;</span>
<a name="l00523"></a>00523 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00524"></a>00524 <span class="preprocessor"></span>
<a name="l00525"></a>00525 <span class="comment">// STB_VORBIS_DIVIDE_TABLE</span>
<a name="l00526"></a>00526 <span class="comment">//     this replaces small integer divides in the floor decode loop with</span>
<a name="l00527"></a>00527 <span class="comment">//     table lookups. made less than 1% difference, so disabled by default.</span>
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="comment">// STB_VORBIS_NO_INLINE_DECODE</span>
<a name="l00530"></a>00530 <span class="comment">//     disables the inlining of the scalar codebook fast-huffman decode.</span>
<a name="l00531"></a>00531 <span class="comment">//     might save a little codespace; useful for debugging</span>
<a name="l00532"></a>00532 <span class="comment">// #define STB_VORBIS_NO_INLINE_DECODE</span>
<a name="l00533"></a>00533 
<a name="l00534"></a>00534 <span class="comment">// STB_VORBIS_NO_DEFER_FLOOR</span>
<a name="l00535"></a>00535 <span class="comment">//     Normally we only decode the floor without synthesizing the actual</span>
<a name="l00536"></a>00536 <span class="comment">//     full curve. We can instead synthesize the curve immediately. This</span>
<a name="l00537"></a>00537 <span class="comment">//     requires more memory and is very likely slower, so I don&#39;t think</span>
<a name="l00538"></a>00538 <span class="comment">//     you&#39;d ever want to do it except for debugging.</span>
<a name="l00539"></a>00539 <span class="comment">// #define STB_VORBIS_NO_DEFER_FLOOR</span>
<a name="l00540"></a>00540 
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 
<a name="l00545"></a>00545 
<a name="l00546"></a>00546 <span class="preprocessor">#ifdef STB_VORBIS_NO_PULLDATA_API</span>
<a name="l00547"></a>00547 <span class="preprocessor"></span><span class="preprocessor">   #define STB_VORBIS_NO_INTEGER_CONVERSION</span>
<a name="l00548"></a>00548 <span class="preprocessor"></span><span class="preprocessor">   #define STB_VORBIS_NO_STDIO</span>
<a name="l00549"></a>00549 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00550"></a>00550 <span class="preprocessor"></span>
<a name="l00551"></a>00551 <span class="preprocessor">#if defined(STB_VORBIS_NO_CRT) &amp;&amp; !defined(STB_VORBIS_NO_STDIO)</span>
<a name="l00552"></a>00552 <span class="preprocessor"></span><span class="preprocessor">   #define STB_VORBIS_NO_STDIO 1</span>
<a name="l00553"></a>00553 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00554"></a>00554 <span class="preprocessor"></span>
<a name="l00555"></a>00555 <span class="preprocessor">#ifndef STB_VORBIS_NO_INTEGER_CONVERSION</span>
<a name="l00556"></a>00556 <span class="preprocessor"></span><span class="preprocessor">#ifndef STB_VORBIS_NO_FAST_SCALED_FLOAT</span>
<a name="l00557"></a>00557 <span class="preprocessor"></span>
<a name="l00558"></a>00558    <span class="comment">// only need endianness for fast-float-to-int, which we don&#39;t</span>
<a name="l00559"></a>00559    <span class="comment">// use for pushdata</span>
<a name="l00560"></a>00560 
<a name="l00561"></a>00561 <span class="preprocessor">   #ifndef STB_VORBIS_BIG_ENDIAN</span>
<a name="l00562"></a>00562 <span class="preprocessor"></span><span class="preprocessor">     #define STB_VORBIS_ENDIAN  0</span>
<a name="l00563"></a>00563 <span class="preprocessor"></span><span class="preprocessor">   #else</span>
<a name="l00564"></a>00564 <span class="preprocessor"></span><span class="preprocessor">     #define STB_VORBIS_ENDIAN  1</span>
<a name="l00565"></a>00565 <span class="preprocessor"></span><span class="preprocessor">   #endif</span>
<a name="l00566"></a>00566 <span class="preprocessor"></span>
<a name="l00567"></a>00567 <span class="preprocessor">#endif</span>
<a name="l00568"></a>00568 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00569"></a>00569 <span class="preprocessor"></span>
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 <span class="preprocessor">#ifndef STB_VORBIS_NO_STDIO</span>
<a name="l00572"></a>00572 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00573"></a>00573 <span class="preprocessor">#endif</span>
<a name="l00574"></a>00574 <span class="preprocessor"></span>
<a name="l00575"></a>00575 <span class="preprocessor">#ifndef STB_VORBIS_NO_CRT</span>
<a name="l00576"></a>00576 <span class="preprocessor"></span><span class="preprocessor">   #include &lt;stdlib.h&gt;</span>
<a name="l00577"></a>00577 <span class="preprocessor">   #include &lt;string.h&gt;</span>
<a name="l00578"></a>00578 <span class="preprocessor">   #include &lt;assert.h&gt;</span>
<a name="l00579"></a>00579 <span class="preprocessor">   #include &lt;math.h&gt;</span>
<a name="l00580"></a>00580 
<a name="l00581"></a>00581    <span class="comment">// find definition of alloca if it&#39;s not in stdlib.h:</span>
<a name="l00582"></a>00582 <span class="preprocessor">   #if defined(_MSC_VER) || defined(__MINGW32__)</span>
<a name="l00583"></a>00583 <span class="preprocessor"></span><span class="preprocessor">      #include &lt;malloc.h&gt;</span>
<a name="l00584"></a>00584 <span class="preprocessor">   #endif</span>
<a name="l00585"></a>00585 <span class="preprocessor"></span><span class="preprocessor">   #if defined(__linux__) || defined(__linux) || defined(__EMSCRIPTEN__)</span>
<a name="l00586"></a>00586 <span class="preprocessor"></span><span class="preprocessor">      #include &lt;alloca.h&gt;</span>
<a name="l00587"></a>00587 <span class="preprocessor">   #endif</span>
<a name="l00588"></a>00588 <span class="preprocessor"></span><span class="preprocessor">#else // STB_VORBIS_NO_CRT</span>
<a name="l00589"></a>00589 <span class="preprocessor"></span><span class="preprocessor">   #ifndef NULL</span>
<a name="l00590"></a>00590 <span class="preprocessor"></span><span class="preprocessor">   #define NULL 0</span>
<a name="l00591"></a>00591 <span class="preprocessor"></span><span class="preprocessor">   #endif</span>
<a name="l00592"></a>00592 <span class="preprocessor"></span>
<a name="l00593"></a>00593 <span class="preprocessor">#endif // STB_VORBIS_NO_CRT</span>
<a name="l00594"></a>00594 <span class="preprocessor"></span>
<a name="l00595"></a>00595 <span class="preprocessor">#include &lt;limits.h&gt;</span>
<a name="l00596"></a>00596 
<a name="l00597"></a>00597 <span class="preprocessor">#ifdef __MINGW32__</span>
<a name="l00598"></a>00598 <span class="preprocessor"></span>   <span class="comment">// eff you mingw:</span>
<a name="l00599"></a>00599    <span class="comment">//     &quot;fixed&quot;:</span>
<a name="l00600"></a>00600    <span class="comment">//         http://sourceforge.net/p/mingw-w64/mailman/message/32882927/</span>
<a name="l00601"></a>00601    <span class="comment">//     &quot;no that broke the build, reverted, who cares about C&quot;:</span>
<a name="l00602"></a>00602    <span class="comment">//         http://sourceforge.net/p/mingw-w64/mailman/message/32890381/</span>
<a name="l00603"></a>00603 <span class="preprocessor">   #ifdef __forceinline</span>
<a name="l00604"></a>00604 <span class="preprocessor"></span><span class="preprocessor">   #undef __forceinline</span>
<a name="l00605"></a>00605 <span class="preprocessor"></span><span class="preprocessor">   #endif</span>
<a name="l00606"></a>00606 <span class="preprocessor"></span><span class="preprocessor">   #define __forceinline</span>
<a name="l00607"></a>00607 <span class="preprocessor"></span>
<a name="l00608"></a>00608 <span class="preprocessor">   #ifdef alloca</span>
<a name="l00609"></a>00609 <span class="preprocessor"></span><span class="preprocessor">   #undef alloca</span>
<a name="l00610"></a>00610 <span class="preprocessor"></span><span class="preprocessor">   #endif</span>
<a name="l00611"></a>00611 <span class="preprocessor"></span><span class="preprocessor">   #define alloca __builtin_alloca</span>
<a name="l00612"></a>00612 <span class="preprocessor"></span><span class="preprocessor">#elif !defined(_MSC_VER)</span>
<a name="l00613"></a>00613 <span class="preprocessor"></span><span class="preprocessor">   #if __GNUC__</span>
<a name="l00614"></a>00614 <span class="preprocessor"></span><span class="preprocessor">      #define __forceinline inline</span>
<a name="l00615"></a>00615 <span class="preprocessor"></span><span class="preprocessor">   #else</span>
<a name="l00616"></a>00616 <span class="preprocessor"></span><span class="preprocessor">      #define __forceinline</span>
<a name="l00617"></a>00617 <span class="preprocessor"></span><span class="preprocessor">   #endif</span>
<a name="l00618"></a>00618 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00619"></a>00619 <span class="preprocessor"></span>
<a name="l00620"></a>00620 <span class="preprocessor">#if STB_VORBIS_MAX_CHANNELS &gt; 256</span>
<a name="l00621"></a>00621 <span class="preprocessor"></span><span class="preprocessor">#error &quot;Value of STB_VORBIS_MAX_CHANNELS outside of allowed range&quot;</span>
<a name="l00622"></a>00622 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00623"></a>00623 <span class="preprocessor"></span>
<a name="l00624"></a>00624 <span class="preprocessor">#if STB_VORBIS_FAST_HUFFMAN_LENGTH &gt; 24</span>
<a name="l00625"></a>00625 <span class="preprocessor"></span><span class="preprocessor">#error &quot;Value of STB_VORBIS_FAST_HUFFMAN_LENGTH outside of allowed range&quot;</span>
<a name="l00626"></a>00626 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00627"></a>00627 <span class="preprocessor"></span>
<a name="l00628"></a>00628 
<a name="l00629"></a>00629 <span class="preprocessor">#if 0</span>
<a name="l00630"></a>00630 <span class="preprocessor"></span><span class="preprocessor">#include &lt;crtdbg.h&gt;</span>
<a name="l00631"></a>00631 <span class="preprocessor">#define CHECK(f)   _CrtIsValidHeapPointer(f-&gt;channel_buffers[1])</span>
<a name="l00632"></a>00632 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00633"></a>00633 <span class="preprocessor"></span><span class="preprocessor">#define CHECK(f)   ((void) 0)</span>
<a name="l00634"></a>00634 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00635"></a>00635 <span class="preprocessor"></span>
<a name="l00636"></a>00636 <span class="preprocessor">#define MAX_BLOCKSIZE_LOG  13   // from specification</span>
<a name="l00637"></a>00637 <span class="preprocessor"></span><span class="preprocessor">#define MAX_BLOCKSIZE      (1 &lt;&lt; MAX_BLOCKSIZE_LOG)</span>
<a name="l00638"></a>00638 <span class="preprocessor"></span>
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 <span class="preprocessor">#ifdef __SDL_SOUND_INTERNAL__</span>
<a name="l00641"></a>00641 <span class="preprocessor"></span><span class="keyword">typedef</span> Uint8 uint8;
<a name="l00642"></a>00642 <span class="keyword">typedef</span> Sint8 int8;
<a name="l00643"></a>00643 <span class="keyword">typedef</span> Uint16 uint16;
<a name="l00644"></a>00644 <span class="keyword">typedef</span> Sint16 int16;
<a name="l00645"></a>00645 <span class="keyword">typedef</span> Uint32 uint32;
<a name="l00646"></a>00646 <span class="keyword">typedef</span> Sint32 int32;
<a name="l00647"></a>00647 <span class="preprocessor">#else</span>
<a name="l00648"></a>00648 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  uint8;
<a name="l00649"></a>00649 <span class="keyword">typedef</span>   <span class="keywordtype">signed</span> <span class="keywordtype">char</span>   int8;
<a name="l00650"></a>00650 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> uint16;
<a name="l00651"></a>00651 <span class="keyword">typedef</span>   <span class="keywordtype">signed</span> <span class="keywordtype">short</span>  int16;
<a name="l00652"></a>00652 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   uint32;
<a name="l00653"></a>00653 <span class="keyword">typedef</span>   <span class="keywordtype">signed</span> <span class="keywordtype">int</span>    int32;
<a name="l00654"></a>00654 <span class="preprocessor">#endif</span>
<a name="l00655"></a>00655 <span class="preprocessor"></span>
<a name="l00656"></a>00656 <span class="preprocessor">#ifndef TRUE</span>
<a name="l00657"></a>00657 <span class="preprocessor"></span><span class="preprocessor">#define TRUE 1</span>
<a name="l00658"></a>00658 <span class="preprocessor"></span><span class="preprocessor">#define FALSE 0</span>
<a name="l00659"></a>00659 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00660"></a>00660 <span class="preprocessor"></span>
<a name="l00661"></a>00661 <span class="keyword">typedef</span> <span class="keywordtype">float</span> codetype;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663 <span class="comment">// @NOTE</span>
<a name="l00664"></a>00664 <span class="comment">//</span>
<a name="l00665"></a>00665 <span class="comment">// Some arrays below are tagged &quot;//varies&quot;, which means it&#39;s actually</span>
<a name="l00666"></a>00666 <span class="comment">// a variable-sized piece of data, but rather than malloc I assume it&#39;s</span>
<a name="l00667"></a>00667 <span class="comment">// small enough it&#39;s better to just allocate it all together with the</span>
<a name="l00668"></a>00668 <span class="comment">// main thing</span>
<a name="l00669"></a>00669 <span class="comment">//</span>
<a name="l00670"></a>00670 <span class="comment">// Most of the variables are specified with the smallest size I could pack</span>
<a name="l00671"></a>00671 <span class="comment">// them into. It might give better performance to make them all full-sized</span>
<a name="l00672"></a>00672 <span class="comment">// integers. It should be safe to freely rearrange the structures or change</span>
<a name="l00673"></a>00673 <span class="comment">// the sizes larger--nothing relies on silently truncating etc., nor the</span>
<a name="l00674"></a>00674 <span class="comment">// order of variables.</span>
<a name="l00675"></a>00675 
<a name="l00676"></a>00676 <span class="preprocessor">#define FAST_HUFFMAN_TABLE_SIZE   (1 &lt;&lt; STB_VORBIS_FAST_HUFFMAN_LENGTH)</span>
<a name="l00677"></a>00677 <span class="preprocessor"></span><span class="preprocessor">#define FAST_HUFFMAN_TABLE_MASK   (FAST_HUFFMAN_TABLE_SIZE - 1)</span>
<a name="l00678"></a>00678 <span class="preprocessor"></span>
<a name="l00679"></a><a class="code" href="structCodebook.html">00679</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00680"></a>00680 {
<a name="l00681"></a>00681    <span class="keywordtype">int</span> dimensions, <a class="code" href="structentries.html">entries</a>;
<a name="l00682"></a>00682    uint8 *codeword_lengths;
<a name="l00683"></a>00683    <span class="keywordtype">float</span>  minimum_value;
<a name="l00684"></a>00684    <span class="keywordtype">float</span>  delta_value;
<a name="l00685"></a>00685    uint8  value_bits;
<a name="l00686"></a>00686    uint8  lookup_type;
<a name="l00687"></a>00687    uint8  sequence_p;
<a name="l00688"></a>00688    uint8  sparse;
<a name="l00689"></a>00689    uint32 lookup_values;
<a name="l00690"></a>00690    codetype *multiplicands;
<a name="l00691"></a>00691    uint32 *codewords;
<a name="l00692"></a>00692 <span class="preprocessor">   #ifdef STB_VORBIS_FAST_HUFFMAN_SHORT</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span>    int16  fast_huffman[FAST_HUFFMAN_TABLE_SIZE];
<a name="l00694"></a>00694 <span class="preprocessor">   #else</span>
<a name="l00695"></a>00695 <span class="preprocessor"></span>    int32  fast_huffman[FAST_HUFFMAN_TABLE_SIZE];
<a name="l00696"></a>00696 <span class="preprocessor">   #endif</span>
<a name="l00697"></a>00697 <span class="preprocessor"></span>   uint32 *sorted_codewords;
<a name="l00698"></a>00698    <span class="keywordtype">int</span>    *sorted_values;
<a name="l00699"></a>00699    <span class="keywordtype">int</span>     sorted_entries;
<a name="l00700"></a>00700 } <a class="code" href="structCodebook.html">Codebook</a>;
<a name="l00701"></a>00701 
<a name="l00702"></a><a class="code" href="structFloor0.html">00702</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00703"></a>00703 {
<a name="l00704"></a>00704    uint16 rate;
<a name="l00705"></a>00705    uint16 bark_map_size;
<a name="l00706"></a>00706    uint8 order;
<a name="l00707"></a>00707    uint8 amplitude_bits;
<a name="l00708"></a>00708    uint8 amplitude_offset;
<a name="l00709"></a>00709    uint8 number_of_books;
<a name="l00710"></a>00710    uint8 book_list[16]; <span class="comment">// varies</span>
<a name="l00711"></a>00711 } <a class="code" href="structFloor0.html">Floor0</a>;
<a name="l00712"></a>00712 
<a name="l00713"></a><a class="code" href="structFloor1.html">00713</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00714"></a>00714 {
<a name="l00715"></a>00715    uint8 partitions;
<a name="l00716"></a>00716    uint8 partition_class_list[32]; <span class="comment">// varies</span>
<a name="l00717"></a>00717    uint8 class_dimensions[16]; <span class="comment">// varies</span>
<a name="l00718"></a>00718    uint8 class_subclasses[16]; <span class="comment">// varies</span>
<a name="l00719"></a>00719    uint8 class_masterbooks[16]; <span class="comment">// varies</span>
<a name="l00720"></a>00720    int16 subclass_books[16][8]; <span class="comment">// varies</span>
<a name="l00721"></a>00721    uint16 Xlist[31*8+2]; <span class="comment">// varies</span>
<a name="l00722"></a>00722    uint8 sorted_order[31*8+2];
<a name="l00723"></a>00723    uint8 neighbors[31*8+2][2];
<a name="l00724"></a>00724    uint8 floor1_multiplier;
<a name="l00725"></a>00725    uint8 rangebits;
<a name="l00726"></a>00726    <span class="keywordtype">int</span> values;
<a name="l00727"></a>00727 } <a class="code" href="structFloor1.html">Floor1</a>;
<a name="l00728"></a>00728 
<a name="l00729"></a><a class="code" href="unionFloor.html">00729</a> <span class="keyword">typedef</span> <span class="keyword">union</span>
<a name="l00730"></a>00730 {
<a name="l00731"></a>00731    <a class="code" href="structFloor0.html">Floor0</a> floor0;
<a name="l00732"></a>00732    <a class="code" href="structFloor1.html">Floor1</a> floor1;
<a name="l00733"></a>00733 } <a class="code" href="unionFloor.html">Floor</a>;
<a name="l00734"></a>00734 
<a name="l00735"></a><a class="code" href="structResidue.html">00735</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00736"></a>00736 {
<a name="l00737"></a>00737    uint32 begin, end;
<a name="l00738"></a>00738    uint32 part_size;
<a name="l00739"></a>00739    uint8 classifications;
<a name="l00740"></a>00740    uint8 classbook;
<a name="l00741"></a>00741    uint8 **classdata;
<a name="l00742"></a>00742    int16 (*residue_books)[8];
<a name="l00743"></a>00743 } <a class="code" href="structResidue.html">Residue</a>;
<a name="l00744"></a>00744 
<a name="l00745"></a><a class="code" href="structMappingChannel.html">00745</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00746"></a>00746 {
<a name="l00747"></a>00747    uint8 magnitude;
<a name="l00748"></a>00748    uint8 angle;
<a name="l00749"></a>00749    uint8 mux;
<a name="l00750"></a>00750 } <a class="code" href="structMappingChannel.html">MappingChannel</a>;
<a name="l00751"></a>00751 
<a name="l00752"></a><a class="code" href="structMapping.html">00752</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00753"></a>00753 {
<a name="l00754"></a>00754    uint16 coupling_steps;
<a name="l00755"></a>00755    <a class="code" href="structMappingChannel.html">MappingChannel</a> *chan;
<a name="l00756"></a>00756    uint8  submaps;
<a name="l00757"></a>00757    uint8  submap_floor[15]; <span class="comment">// varies</span>
<a name="l00758"></a>00758    uint8  submap_residue[15]; <span class="comment">// varies</span>
<a name="l00759"></a>00759 } <a class="code" href="structMapping.html">Mapping</a>;
<a name="l00760"></a>00760 
<a name="l00761"></a><a class="code" href="structMode.html">00761</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00762"></a>00762 {
<a name="l00763"></a>00763    uint8 blockflag;
<a name="l00764"></a>00764    uint8 mapping;
<a name="l00765"></a>00765    uint16 windowtype;
<a name="l00766"></a>00766    uint16 transformtype;
<a name="l00767"></a>00767 } <a class="code" href="structMode.html">Mode</a>;
<a name="l00768"></a>00768 
<a name="l00769"></a><a class="code" href="structCRCscan.html">00769</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00770"></a>00770 {
<a name="l00771"></a>00771    uint32  goal_crc;    <span class="comment">// expected crc if match</span>
<a name="l00772"></a>00772    <span class="keywordtype">int</span>     bytes_left;  <span class="comment">// bytes left in packet</span>
<a name="l00773"></a>00773    uint32  crc_so_far;  <span class="comment">// running crc</span>
<a name="l00774"></a>00774    <span class="keywordtype">int</span>     bytes_done;  <span class="comment">// bytes processed in _current_ chunk</span>
<a name="l00775"></a>00775    uint32  sample_loc;  <span class="comment">// granule pos encoded in page</span>
<a name="l00776"></a>00776 } <a class="code" href="structCRCscan.html">CRCscan</a>;
<a name="l00777"></a>00777 
<a name="l00778"></a><a class="code" href="structProbedPage.html">00778</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00779"></a>00779 {
<a name="l00780"></a>00780    uint32 page_start, page_end;
<a name="l00781"></a>00781    uint32 last_decoded_sample;
<a name="l00782"></a>00782 } <a class="code" href="structProbedPage.html">ProbedPage</a>;
<a name="l00783"></a>00783 
<a name="l00784"></a><a class="code" href="structstb__vorbis.html">00784</a> <span class="keyword">struct </span><a class="code" href="structstb__vorbis.html">stb_vorbis</a>
<a name="l00785"></a>00785 {
<a name="l00786"></a>00786   <span class="comment">// user-accessible info</span>
<a name="l00787"></a>00787    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sample_rate;
<a name="l00788"></a>00788    <span class="keywordtype">int</span> channels;
<a name="l00789"></a>00789 
<a name="l00790"></a>00790    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> setup_memory_required;
<a name="l00791"></a>00791    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> temp_memory_required;
<a name="l00792"></a>00792    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> setup_temp_memory_required;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794    <span class="keywordtype">char</span> *vendor;
<a name="l00795"></a>00795    <span class="keywordtype">int</span> comment_list_length;
<a name="l00796"></a>00796    <span class="keywordtype">char</span> **comment_list;
<a name="l00797"></a>00797 
<a name="l00798"></a>00798   <span class="comment">// input config</span>
<a name="l00799"></a>00799 <span class="preprocessor">#ifndef STB_VORBIS_NO_STDIO</span>
<a name="l00800"></a>00800 <span class="preprocessor"></span>   FILE *f;
<a name="l00801"></a>00801    uint32 f_start;
<a name="l00802"></a>00802    <span class="keywordtype">int</span> close_on_free;
<a name="l00803"></a>00803 <span class="preprocessor">#endif</span>
<a name="l00804"></a>00804 <span class="preprocessor"></span>
<a name="l00805"></a>00805 <span class="preprocessor">   #ifdef __SDL_SOUND_INTERNAL__</span>
<a name="l00806"></a>00806 <span class="preprocessor"></span>   SDL_RWops *rwops;
<a name="l00807"></a>00807    uint32 rwops_start;
<a name="l00808"></a>00808    <span class="keywordtype">int</span> close_on_free;
<a name="l00809"></a>00809 <span class="preprocessor">   #endif</span>
<a name="l00810"></a>00810 <span class="preprocessor"></span>
<a name="l00811"></a>00811    uint8 *stream;
<a name="l00812"></a>00812    uint8 *stream_start;
<a name="l00813"></a>00813    uint8 *stream_end;
<a name="l00814"></a>00814 
<a name="l00815"></a>00815    uint32 stream_len;
<a name="l00816"></a>00816 
<a name="l00817"></a>00817    uint8  push_mode;
<a name="l00818"></a>00818 
<a name="l00819"></a>00819    <span class="comment">// the page to seek to when seeking to start, may be zero</span>
<a name="l00820"></a>00820    uint32 first_audio_page_offset;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822    <span class="comment">// p_first is the page on which the first audio packet ends</span>
<a name="l00823"></a>00823    <span class="comment">// (but not necessarily the page on which it starts)</span>
<a name="l00824"></a>00824    <a class="code" href="structProbedPage.html">ProbedPage</a> p_first, p_last;
<a name="l00825"></a>00825 
<a name="l00826"></a>00826   <span class="comment">// memory management</span>
<a name="l00827"></a>00827    <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> alloc;
<a name="l00828"></a>00828    <span class="keywordtype">int</span> setup_offset;
<a name="l00829"></a>00829    <span class="keywordtype">int</span> temp_offset;
<a name="l00830"></a>00830 
<a name="l00831"></a>00831   <span class="comment">// run-time results</span>
<a name="l00832"></a>00832    <span class="keywordtype">int</span> eof;
<a name="l00833"></a>00833    <span class="keyword">enum</span> STBVorbisError error;
<a name="l00834"></a>00834 
<a name="l00835"></a>00835   <span class="comment">// user-useful data</span>
<a name="l00836"></a>00836 
<a name="l00837"></a>00837   <span class="comment">// header info</span>
<a name="l00838"></a>00838    <span class="keywordtype">int</span> blocksize[2];
<a name="l00839"></a>00839    <span class="keywordtype">int</span> blocksize_0, blocksize_1;
<a name="l00840"></a>00840    <span class="keywordtype">int</span> codebook_count;
<a name="l00841"></a>00841    <a class="code" href="structCodebook.html">Codebook</a> *codebooks;
<a name="l00842"></a>00842    <span class="keywordtype">int</span> floor_count;
<a name="l00843"></a>00843    uint16 floor_types[64]; <span class="comment">// varies</span>
<a name="l00844"></a>00844    <a class="code" href="unionFloor.html">Floor</a> *floor_config;
<a name="l00845"></a>00845    <span class="keywordtype">int</span> residue_count;
<a name="l00846"></a>00846    uint16 residue_types[64]; <span class="comment">// varies</span>
<a name="l00847"></a>00847    <a class="code" href="structResidue.html">Residue</a> *residue_config;
<a name="l00848"></a>00848    <span class="keywordtype">int</span> mapping_count;
<a name="l00849"></a>00849    <a class="code" href="structMapping.html">Mapping</a> *mapping;
<a name="l00850"></a>00850    <span class="keywordtype">int</span> mode_count;
<a name="l00851"></a>00851    <a class="code" href="structMode.html">Mode</a> mode_config[64];  <span class="comment">// varies</span>
<a name="l00852"></a>00852 
<a name="l00853"></a>00853    uint32 total_samples;
<a name="l00854"></a>00854 
<a name="l00855"></a>00855   <span class="comment">// decode buffer</span>
<a name="l00856"></a>00856    <span class="keywordtype">float</span> *channel_buffers[STB_VORBIS_MAX_CHANNELS];
<a name="l00857"></a>00857    <span class="keywordtype">float</span> *outputs        [STB_VORBIS_MAX_CHANNELS];
<a name="l00858"></a>00858 
<a name="l00859"></a>00859    <span class="keywordtype">float</span> *previous_window[STB_VORBIS_MAX_CHANNELS];
<a name="l00860"></a>00860    <span class="keywordtype">int</span> previous_length;
<a name="l00861"></a>00861 
<a name="l00862"></a>00862 <span class="preprocessor">   #ifndef STB_VORBIS_NO_DEFER_FLOOR</span>
<a name="l00863"></a>00863 <span class="preprocessor"></span>   int16 *finalY[STB_VORBIS_MAX_CHANNELS];
<a name="l00864"></a>00864 <span class="preprocessor">   #else</span>
<a name="l00865"></a>00865 <span class="preprocessor"></span>   <span class="keywordtype">float</span> *floor_buffers[STB_VORBIS_MAX_CHANNELS];
<a name="l00866"></a>00866 <span class="preprocessor">   #endif</span>
<a name="l00867"></a>00867 <span class="preprocessor"></span>
<a name="l00868"></a>00868    uint32 current_loc; <span class="comment">// sample location of next frame to decode</span>
<a name="l00869"></a>00869    <span class="keywordtype">int</span>    current_loc_valid;
<a name="l00870"></a>00870 
<a name="l00871"></a>00871   <span class="comment">// per-blocksize precomputed data</span>
<a name="l00872"></a>00872 
<a name="l00873"></a>00873    <span class="comment">// twiddle factors</span>
<a name="l00874"></a>00874    <span class="keywordtype">float</span> *A[2],*B[2],*C[2];
<a name="l00875"></a>00875    <span class="keywordtype">float</span> *window[2];
<a name="l00876"></a>00876    uint16 *bit_reverse[2];
<a name="l00877"></a>00877 
<a name="l00878"></a>00878   <span class="comment">// current page/packet/segment streaming info</span>
<a name="l00879"></a>00879    uint32 serial; <span class="comment">// stream serial number for verification</span>
<a name="l00880"></a>00880    <span class="keywordtype">int</span> last_page;
<a name="l00881"></a>00881    <span class="keywordtype">int</span> segment_count;
<a name="l00882"></a>00882    uint8 segments[255];
<a name="l00883"></a>00883    uint8 page_flag;
<a name="l00884"></a>00884    uint8 bytes_in_seg;
<a name="l00885"></a>00885    uint8 first_decode;
<a name="l00886"></a>00886    <span class="keywordtype">int</span> next_seg;
<a name="l00887"></a>00887    <span class="keywordtype">int</span> last_seg;  <span class="comment">// flag that we&#39;re on the last segment</span>
<a name="l00888"></a>00888    <span class="keywordtype">int</span> last_seg_which; <span class="comment">// what was the segment number of the last seg?</span>
<a name="l00889"></a>00889    uint32 acc;
<a name="l00890"></a>00890    <span class="keywordtype">int</span> valid_bits;
<a name="l00891"></a>00891    <span class="keywordtype">int</span> packet_bytes;
<a name="l00892"></a>00892    <span class="keywordtype">int</span> end_seg_with_known_loc;
<a name="l00893"></a>00893    uint32 known_loc_for_packet;
<a name="l00894"></a>00894    <span class="keywordtype">int</span> discard_samples_deferred;
<a name="l00895"></a>00895    uint32 samples_output;
<a name="l00896"></a>00896 
<a name="l00897"></a>00897   <span class="comment">// push mode scanning</span>
<a name="l00898"></a>00898    <span class="keywordtype">int</span> page_crc_tests; <span class="comment">// only in push_mode: number of tests active; -1 if not searching</span>
<a name="l00899"></a>00899 <span class="preprocessor">#ifndef STB_VORBIS_NO_PUSHDATA_API</span>
<a name="l00900"></a>00900 <span class="preprocessor"></span>   <a class="code" href="structCRCscan.html">CRCscan</a> scan[STB_VORBIS_PUSHDATA_CRC_COUNT];
<a name="l00901"></a>00901 <span class="preprocessor">#endif</span>
<a name="l00902"></a>00902 <span class="preprocessor"></span>
<a name="l00903"></a>00903   <span class="comment">// sample-access</span>
<a name="l00904"></a>00904    <span class="keywordtype">int</span> channel_buffer_start;
<a name="l00905"></a>00905    <span class="keywordtype">int</span> channel_buffer_end;
<a name="l00906"></a>00906 };
<a name="l00907"></a>00907 
<a name="l00908"></a>00908 <span class="preprocessor">#if defined(STB_VORBIS_NO_PUSHDATA_API)</span>
<a name="l00909"></a>00909 <span class="preprocessor"></span><span class="preprocessor">   #define IS_PUSH_MODE(f)   FALSE</span>
<a name="l00910"></a>00910 <span class="preprocessor"></span><span class="preprocessor">#elif defined(STB_VORBIS_NO_PULLDATA_API)</span>
<a name="l00911"></a>00911 <span class="preprocessor"></span><span class="preprocessor">   #define IS_PUSH_MODE(f)   TRUE</span>
<a name="l00912"></a>00912 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00913"></a>00913 <span class="preprocessor"></span><span class="preprocessor">   #define IS_PUSH_MODE(f)   ((f)-&gt;push_mode)</span>
<a name="l00914"></a>00914 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00915"></a>00915 <span class="preprocessor"></span>
<a name="l00916"></a>00916 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structstb__vorbis.html">stb_vorbis</a> <a class="code" href="structstb__vorbis.html">vorb</a>;
<a name="l00917"></a>00917 
<a name="l00918"></a>00918 <span class="keyword">static</span> <span class="keywordtype">int</span> error(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keyword">enum</span> STBVorbisError e)
<a name="l00919"></a>00919 {
<a name="l00920"></a>00920    f-&gt;error = e;
<a name="l00921"></a>00921    <span class="keywordflow">return</span> 0;
<a name="l00922"></a>00922 }
<a name="l00923"></a>00923 
<a name="l00924"></a>00924 
<a name="l00925"></a>00925 <span class="comment">// these functions are used for allocating temporary memory</span>
<a name="l00926"></a>00926 <span class="comment">// while decoding. if you can afford the stack space, use</span>
<a name="l00927"></a>00927 <span class="comment">// alloca(); otherwise, provide a temp buffer and it will</span>
<a name="l00928"></a>00928 <span class="comment">// allocate out of those.</span>
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 <span class="preprocessor">#define array_size_required(count,size)  (count*(sizeof(void *)+(size)))</span>
<a name="l00931"></a>00931 <span class="preprocessor"></span>
<a name="l00932"></a>00932 <span class="preprocessor">#define temp_alloc(f,size)              (f-&gt;alloc.alloc_buffer ? setup_temp_malloc(f,size) : alloca(size))</span>
<a name="l00933"></a>00933 <span class="preprocessor"></span><span class="comment">// #define temp_free(f,p)                  0</span>
<a name="l00934"></a>00934 <span class="preprocessor">#define temp_alloc_save(f)              ((f)-&gt;temp_offset)</span>
<a name="l00935"></a>00935 <span class="preprocessor"></span><span class="preprocessor">#define temp_alloc_restore(f,p)         ((f)-&gt;temp_offset = (p))</span>
<a name="l00936"></a>00936 <span class="preprocessor"></span>
<a name="l00937"></a>00937 <span class="preprocessor">#define temp_block_array(f,count,size)  make_block_array(temp_alloc(f,array_size_required(count,size)), count, size)</span>
<a name="l00938"></a>00938 <span class="preprocessor"></span>
<a name="l00939"></a>00939 <span class="comment">// given a sufficiently large block of memory, make an array of pointers to subblocks of it</span>
<a name="l00940"></a>00940 <span class="keyword">static</span> <span class="keywordtype">void</span> *make_block_array(<span class="keywordtype">void</span> *mem, <span class="keywordtype">int</span> count, <span class="keywordtype">int</span> size)
<a name="l00941"></a>00941 {
<a name="l00942"></a>00942    <span class="keywordtype">int</span> i;
<a name="l00943"></a>00943    <span class="keywordtype">void</span> ** p = (<span class="keywordtype">void</span> **) mem;
<a name="l00944"></a>00944    <span class="keywordtype">char</span> *q = (<span class="keywordtype">char</span> *) (p + count);
<a name="l00945"></a>00945    <span class="keywordflow">for</span> (i=0; i &lt; count; ++i) {
<a name="l00946"></a>00946       p[i] = q;
<a name="l00947"></a>00947       q += size;
<a name="l00948"></a>00948    }
<a name="l00949"></a>00949    <span class="keywordflow">return</span> p;
<a name="l00950"></a>00950 }
<a name="l00951"></a>00951 
<a name="l00952"></a>00952 <span class="keyword">static</span> <span class="keywordtype">void</span> *setup_malloc(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> sz)
<a name="l00953"></a>00953 {
<a name="l00954"></a>00954    sz = (sz+7) &amp; ~7; <span class="comment">// round up to nearest 8 for alignment of future allocs.</span>
<a name="l00955"></a>00955    f-&gt;setup_memory_required += sz;
<a name="l00956"></a>00956    <span class="keywordflow">if</span> (f-&gt;alloc.alloc_buffer) {
<a name="l00957"></a>00957       <span class="keywordtype">void</span> *p = (<span class="keywordtype">char</span> *) f-&gt;alloc.alloc_buffer + f-&gt;setup_offset;
<a name="l00958"></a>00958       if (f-&gt;setup_offset + sz &gt; f-&gt;temp_offset) <span class="keywordflow">return</span> NULL;
<a name="l00959"></a>00959       f-&gt;setup_offset += sz;
<a name="l00960"></a>00960       <span class="keywordflow">return</span> p;
<a name="l00961"></a>00961    }
<a name="l00962"></a>00962    <span class="keywordflow">return</span> sz ? malloc(sz) : NULL;
<a name="l00963"></a>00963 }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 <span class="keyword">static</span> <span class="keywordtype">void</span> setup_free(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">void</span> *p)
<a name="l00966"></a>00966 {
<a name="l00967"></a>00967    <span class="keywordflow">if</span> (f-&gt;alloc.alloc_buffer) <span class="keywordflow">return</span>; <span class="comment">// do nothing; setup mem is a stack</span>
<a name="l00968"></a>00968    free(p);
<a name="l00969"></a>00969 }
<a name="l00970"></a>00970 
<a name="l00971"></a>00971 <span class="keyword">static</span> <span class="keywordtype">void</span> *setup_temp_malloc(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> sz)
<a name="l00972"></a>00972 {
<a name="l00973"></a>00973    sz = (sz+7) &amp; ~7; <span class="comment">// round up to nearest 8 for alignment of future allocs.</span>
<a name="l00974"></a>00974    <span class="keywordflow">if</span> (f-&gt;alloc.alloc_buffer) {
<a name="l00975"></a>00975       <span class="keywordflow">if</span> (f-&gt;temp_offset - sz &lt; f-&gt;setup_offset) <span class="keywordflow">return</span> NULL;
<a name="l00976"></a>00976       f-&gt;temp_offset -= sz;
<a name="l00977"></a>00977       <span class="keywordflow">return</span> (<span class="keywordtype">char</span> *) f-&gt;alloc.alloc_buffer + f-&gt;temp_offset;
<a name="l00978"></a>00978    }
<a name="l00979"></a>00979    <span class="keywordflow">return</span> malloc(sz);
<a name="l00980"></a>00980 }
<a name="l00981"></a>00981 
<a name="l00982"></a>00982 <span class="keyword">static</span> <span class="keywordtype">void</span> setup_temp_free(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">void</span> *p, <span class="keywordtype">int</span> sz)
<a name="l00983"></a>00983 {
<a name="l00984"></a>00984    <span class="keywordflow">if</span> (f-&gt;alloc.alloc_buffer) {
<a name="l00985"></a>00985       f-&gt;temp_offset += (sz+3)&amp;~3;
<a name="l00986"></a>00986       <span class="keywordflow">return</span>;
<a name="l00987"></a>00987    }
<a name="l00988"></a>00988    free(p);
<a name="l00989"></a>00989 }
<a name="l00990"></a>00990 
<a name="l00991"></a>00991 <span class="preprocessor">#define CRC32_POLY    0x04c11db7   // from spec</span>
<a name="l00992"></a>00992 <span class="preprocessor"></span>
<a name="l00993"></a>00993 <span class="keyword">static</span> uint32 crc_table[256];
<a name="l00994"></a>00994 <span class="keyword">static</span> <span class="keywordtype">void</span> crc32_init(<span class="keywordtype">void</span>)
<a name="l00995"></a>00995 {
<a name="l00996"></a>00996    <span class="keywordtype">int</span> i,j;
<a name="l00997"></a>00997    uint32 s;
<a name="l00998"></a>00998    <span class="keywordflow">for</span>(i=0; i &lt; 256; i++) {
<a name="l00999"></a>00999       <span class="keywordflow">for</span> (s=(uint32) i &lt;&lt; 24, j=0; j &lt; 8; ++j)
<a name="l01000"></a>01000          s = (s &lt;&lt; 1) ^ (s &gt;= (1U&lt;&lt;31) ? CRC32_POLY : 0);
<a name="l01001"></a>01001       crc_table[i] = s;
<a name="l01002"></a>01002    }
<a name="l01003"></a>01003 }
<a name="l01004"></a>01004 
<a name="l01005"></a>01005 <span class="keyword">static</span> __forceinline uint32 crc32_update(uint32 crc, uint8 byte)
<a name="l01006"></a>01006 {
<a name="l01007"></a>01007    <span class="keywordflow">return</span> (crc &lt;&lt; 8) ^ crc_table[byte ^ (crc &gt;&gt; 24)];
<a name="l01008"></a>01008 }
<a name="l01009"></a>01009 
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 <span class="comment">// used in setup, and for huffman that doesn&#39;t go fast path</span>
<a name="l01012"></a>01012 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bit_reverse(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n)
<a name="l01013"></a>01013 {
<a name="l01014"></a>01014   n = ((n &amp; 0xAAAAAAAA) &gt;&gt;  1) | ((n &amp; 0x55555555) &lt;&lt; 1);
<a name="l01015"></a>01015   n = ((n &amp; 0xCCCCCCCC) &gt;&gt;  2) | ((n &amp; 0x33333333) &lt;&lt; 2);
<a name="l01016"></a>01016   n = ((n &amp; 0xF0F0F0F0) &gt;&gt;  4) | ((n &amp; 0x0F0F0F0F) &lt;&lt; 4);
<a name="l01017"></a>01017   n = ((n &amp; 0xFF00FF00) &gt;&gt;  8) | ((n &amp; 0x00FF00FF) &lt;&lt; 8);
<a name="l01018"></a>01018   <span class="keywordflow">return</span> (n &gt;&gt; 16) | (n &lt;&lt; 16);
<a name="l01019"></a>01019 }
<a name="l01020"></a>01020 
<a name="l01021"></a>01021 <span class="keyword">static</span> <span class="keywordtype">float</span> square(<span class="keywordtype">float</span> x)
<a name="l01022"></a>01022 {
<a name="l01023"></a>01023    <span class="keywordflow">return</span> x*x;
<a name="l01024"></a>01024 }
<a name="l01025"></a>01025 
<a name="l01026"></a>01026 <span class="comment">// this is a weird definition of log2() for which log2(1) = 1, log2(2) = 2, log2(4) = 3</span>
<a name="l01027"></a>01027 <span class="comment">// as required by the specification. fast(?) implementation from stb.h</span>
<a name="l01028"></a>01028 <span class="comment">// @OPTIMIZE: called multiple times per-packet with &quot;constants&quot;; move to setup</span>
<a name="l01029"></a>01029 <span class="keyword">static</span> <span class="keywordtype">int</span> ilog(int32 n)
<a name="l01030"></a>01030 {
<a name="l01031"></a>01031    <span class="keyword">static</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span> log2_4[16] = { 0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4 };
<a name="l01032"></a>01032 
<a name="l01033"></a>01033    <span class="keywordflow">if</span> (n &lt; 0) <span class="keywordflow">return</span> 0; <span class="comment">// signed n returns 0</span>
<a name="l01034"></a>01034 
<a name="l01035"></a>01035    <span class="comment">// 2 compares if n &lt; 16, 3 compares otherwise (4 if signed or n &gt; 1&lt;&lt;29)</span>
<a name="l01036"></a>01036    <span class="keywordflow">if</span> (n &lt; (1 &lt;&lt; 14))
<a name="l01037"></a>01037         <span class="keywordflow">if</span> (n &lt; (1 &lt;&lt;  4))            <span class="keywordflow">return</span>  0 + log2_4[n      ];
<a name="l01038"></a>01038         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n &lt; (1 &lt;&lt;  9))       <span class="keywordflow">return</span>  5 + log2_4[n &gt;&gt;  5];
<a name="l01039"></a>01039              <span class="keywordflow">else</span>                     <span class="keywordflow">return</span> 10 + log2_4[n &gt;&gt; 10];
<a name="l01040"></a>01040    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n &lt; (1 &lt;&lt; 24))
<a name="l01041"></a>01041              <span class="keywordflow">if</span> (n &lt; (1 &lt;&lt; 19))       <span class="keywordflow">return</span> 15 + log2_4[n &gt;&gt; 15];
<a name="l01042"></a>01042              <span class="keywordflow">else</span>                     <span class="keywordflow">return</span> 20 + log2_4[n &gt;&gt; 20];
<a name="l01043"></a>01043         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n &lt; (1 &lt;&lt; 29))       <span class="keywordflow">return</span> 25 + log2_4[n &gt;&gt; 25];
<a name="l01044"></a>01044              <span class="keywordflow">else</span>                     <span class="keywordflow">return</span> 30 + log2_4[n &gt;&gt; 30];
<a name="l01045"></a>01045 }
<a name="l01046"></a>01046 
<a name="l01047"></a>01047 <span class="preprocessor">#ifndef M_PI</span>
<a name="l01048"></a>01048 <span class="preprocessor"></span><span class="preprocessor">  #define M_PI  3.14159265358979323846264f  // from CRC</span>
<a name="l01049"></a>01049 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01050"></a>01050 <span class="preprocessor"></span>
<a name="l01051"></a>01051 <span class="comment">// code length assigned to a value with no huffman encoding</span>
<a name="l01052"></a>01052 <span class="preprocessor">#define NO_CODE   255</span>
<a name="l01053"></a>01053 <span class="preprocessor"></span>
<a name="l01055"></a>01055 <span class="comment">//</span>
<a name="l01056"></a>01056 <span class="comment">// these functions are only called at setup, and only a few times</span>
<a name="l01057"></a>01057 <span class="comment">// per file</span>
<a name="l01058"></a>01058 
<a name="l01059"></a>01059 <span class="keyword">static</span> <span class="keywordtype">float</span> float32_unpack(uint32 x)
<a name="l01060"></a>01060 {
<a name="l01061"></a>01061    <span class="comment">// from the specification</span>
<a name="l01062"></a>01062    uint32 mantissa = x &amp; 0x1fffff;
<a name="l01063"></a>01063    uint32 sign = x &amp; 0x80000000;
<a name="l01064"></a>01064    uint32 exp = (x &amp; 0x7fe00000) &gt;&gt; 21;
<a name="l01065"></a>01065    <span class="keywordtype">double</span> res = sign ? -(double)mantissa : (<span class="keywordtype">double</span>)mantissa;
<a name="l01066"></a>01066    return (<span class="keywordtype">float</span>) ldexp((<span class="keywordtype">float</span>)res, exp-788);
<a name="l01067"></a>01067 }
<a name="l01068"></a>01068 
<a name="l01069"></a>01069 
<a name="l01070"></a>01070 <span class="comment">// zlib &amp; jpeg huffman tables assume that the output symbols</span>
<a name="l01071"></a>01071 <span class="comment">// can either be arbitrarily arranged, or have monotonically</span>
<a name="l01072"></a>01072 <span class="comment">// increasing frequencies--they rely on the lengths being sorted;</span>
<a name="l01073"></a>01073 <span class="comment">// this makes for a very simple generation algorithm.</span>
<a name="l01074"></a>01074 <span class="comment">// vorbis allows a huffman table with non-sorted lengths. This</span>
<a name="l01075"></a>01075 <span class="comment">// requires a more sophisticated construction, since symbols in</span>
<a name="l01076"></a>01076 <span class="comment">// order do not map to huffman codes &quot;in order&quot;.</span>
<a name="l01077"></a>01077 static <span class="keywordtype">void</span> add_entry(<a class="code" href="structCodebook.html">Codebook</a> *c, uint32 huff_code, <span class="keywordtype">int</span> symbol, <span class="keywordtype">int</span> count, <span class="keywordtype">int</span> len, uint32 *values)
<a name="l01078"></a>01078 {
<a name="l01079"></a>01079    <span class="keywordflow">if</span> (!c-&gt;sparse) {
<a name="l01080"></a>01080       c-&gt;codewords      [symbol] = huff_code;
<a name="l01081"></a>01081    } <span class="keywordflow">else</span> {
<a name="l01082"></a>01082       c-&gt;codewords       [count] = huff_code;
<a name="l01083"></a>01083       c-&gt;codeword_lengths[count] = len;
<a name="l01084"></a>01084       values             [count] = symbol;
<a name="l01085"></a>01085    }
<a name="l01086"></a>01086 }
<a name="l01087"></a>01087 
<a name="l01088"></a>01088 <span class="keyword">static</span> <span class="keywordtype">int</span> compute_codewords(<a class="code" href="structCodebook.html">Codebook</a> *c, uint8 *len, <span class="keywordtype">int</span> n, uint32 *values)
<a name="l01089"></a>01089 {
<a name="l01090"></a>01090    <span class="keywordtype">int</span> i,k,m=0;
<a name="l01091"></a>01091    uint32 available[32];
<a name="l01092"></a>01092 
<a name="l01093"></a>01093    memset(available, 0, <span class="keyword">sizeof</span>(available));
<a name="l01094"></a>01094    <span class="comment">// find the first entry</span>
<a name="l01095"></a>01095    <span class="keywordflow">for</span> (k=0; k &lt; n; ++k) <span class="keywordflow">if</span> (len[k] &lt; NO_CODE) <span class="keywordflow">break</span>;
<a name="l01096"></a>01096    <span class="keywordflow">if</span> (k == n) { assert(c-&gt;sorted_entries == 0); <span class="keywordflow">return</span> TRUE; }
<a name="l01097"></a>01097    <span class="comment">// add to the list</span>
<a name="l01098"></a>01098    add_entry(c, 0, k, m++, len[k], values);
<a name="l01099"></a>01099    <span class="comment">// add all available leaves</span>
<a name="l01100"></a>01100    <span class="keywordflow">for</span> (i=1; i &lt;= len[k]; ++i)
<a name="l01101"></a>01101       available[i] = 1U &lt;&lt; (32-i);
<a name="l01102"></a>01102    <span class="comment">// note that the above code treats the first case specially,</span>
<a name="l01103"></a>01103    <span class="comment">// but it&#39;s really the same as the following code, so they</span>
<a name="l01104"></a>01104    <span class="comment">// could probably be combined (except the initial code is 0,</span>
<a name="l01105"></a>01105    <span class="comment">// and I use 0 in available[] to mean &#39;empty&#39;)</span>
<a name="l01106"></a>01106    <span class="keywordflow">for</span> (i=k+1; i &lt; n; ++i) {
<a name="l01107"></a>01107       uint32 res;
<a name="l01108"></a>01108       <span class="keywordtype">int</span> z = len[i], y;
<a name="l01109"></a>01109       <span class="keywordflow">if</span> (z == NO_CODE) <span class="keywordflow">continue</span>;
<a name="l01110"></a>01110       <span class="comment">// find lowest available leaf (should always be earliest,</span>
<a name="l01111"></a>01111       <span class="comment">// which is what the specification calls for)</span>
<a name="l01112"></a>01112       <span class="comment">// note that this property, and the fact we can never have</span>
<a name="l01113"></a>01113       <span class="comment">// more than one free leaf at a given level, isn&#39;t totally</span>
<a name="l01114"></a>01114       <span class="comment">// trivial to prove, but it seems true and the assert never</span>
<a name="l01115"></a>01115       <span class="comment">// fires, so!</span>
<a name="l01116"></a>01116       <span class="keywordflow">while</span> (z &gt; 0 &amp;&amp; !available[z]) --z;
<a name="l01117"></a>01117       <span class="keywordflow">if</span> (z == 0) { <span class="keywordflow">return</span> FALSE; }
<a name="l01118"></a>01118       res = available[z];
<a name="l01119"></a>01119       assert(z &gt;= 0 &amp;&amp; z &lt; 32);
<a name="l01120"></a>01120       available[z] = 0;
<a name="l01121"></a>01121       add_entry(c, bit_reverse(res), i, m++, len[i], values);
<a name="l01122"></a>01122       <span class="comment">// propagate availability up the tree</span>
<a name="l01123"></a>01123       <span class="keywordflow">if</span> (z != len[i]) {
<a name="l01124"></a>01124          assert(<span class="comment">/*len[i] &gt;= 0 always true, len is unsigned char ptr &amp;&amp; */</span>len[i] &lt; 32u);
<a name="l01125"></a>01125          <span class="keywordflow">for</span> (y=len[i]; y &gt; z; --y) {
<a name="l01126"></a>01126             assert(available[y] == 0);
<a name="l01127"></a>01127             available[y] = res + (1 &lt;&lt; (32-y));
<a name="l01128"></a>01128          }
<a name="l01129"></a>01129       }
<a name="l01130"></a>01130    }
<a name="l01131"></a>01131    <span class="keywordflow">return</span> TRUE;
<a name="l01132"></a>01132 }
<a name="l01133"></a>01133 
<a name="l01134"></a>01134 <span class="comment">// accelerated huffman table allows fast O(1) match of all symbols</span>
<a name="l01135"></a>01135 <span class="comment">// of length &lt;= STB_VORBIS_FAST_HUFFMAN_LENGTH</span>
<a name="l01136"></a>01136 <span class="keyword">static</span> <span class="keywordtype">void</span> compute_accelerated_huffman(<a class="code" href="structCodebook.html">Codebook</a> *c)
<a name="l01137"></a>01137 {
<a name="l01138"></a>01138    <span class="keywordtype">int</span> i, len;
<a name="l01139"></a>01139    <span class="keywordflow">for</span> (i=0; i &lt; FAST_HUFFMAN_TABLE_SIZE; ++i)
<a name="l01140"></a>01140       c-&gt;fast_huffman[i] = -1;
<a name="l01141"></a>01141 
<a name="l01142"></a>01142    len = c-&gt;sparse ? c-&gt;sorted_entries : c-&gt;entries;
<a name="l01143"></a>01143    #ifdef STB_VORBIS_FAST_HUFFMAN_SHORT
<a name="l01144"></a>01144    if (len &gt; 32767) len = 32767; <span class="comment">// largest possible value we can encode!</span>
<a name="l01145"></a>01145 <span class="preprocessor">   #endif</span>
<a name="l01146"></a>01146 <span class="preprocessor"></span>   <span class="keywordflow">for</span> (i=0; i &lt; len; ++i) {
<a name="l01147"></a>01147       <span class="keywordflow">if</span> (c-&gt;codeword_lengths[i] &lt;= STB_VORBIS_FAST_HUFFMAN_LENGTH) {
<a name="l01148"></a>01148          uint32 z = c-&gt;sparse ? bit_reverse(c-&gt;sorted_codewords[i]) : c-&gt;codewords[i];
<a name="l01149"></a>01149          <span class="comment">// set table entries for all bit combinations in the higher bits</span>
<a name="l01150"></a>01150          <span class="keywordflow">while</span> (z &lt; FAST_HUFFMAN_TABLE_SIZE) {
<a name="l01151"></a>01151              c-&gt;fast_huffman[z] = i;
<a name="l01152"></a>01152              z += 1 &lt;&lt; c-&gt;codeword_lengths[i];
<a name="l01153"></a>01153          }
<a name="l01154"></a>01154       }
<a name="l01155"></a>01155    }
<a name="l01156"></a>01156 }
<a name="l01157"></a>01157 
<a name="l01158"></a>01158 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l01159"></a>01159 <span class="preprocessor"></span><span class="preprocessor">#define STBV_CDECL __cdecl</span>
<a name="l01160"></a>01160 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01161"></a>01161 <span class="preprocessor"></span><span class="preprocessor">#define STBV_CDECL</span>
<a name="l01162"></a>01162 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01163"></a>01163 <span class="preprocessor"></span>
<a name="l01164"></a>01164 <span class="keyword">static</span> <span class="keywordtype">int</span> STBV_CDECL uint32_compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *p, <span class="keyword">const</span> <span class="keywordtype">void</span> *q)
<a name="l01165"></a>01165 {
<a name="l01166"></a>01166    uint32 x = * (uint32 *) p;
<a name="l01167"></a>01167    uint32 y = * (uint32 *) q;
<a name="l01168"></a>01168    <span class="keywordflow">return</span> x &lt; y ? -1 : x &gt; y;
<a name="l01169"></a>01169 }
<a name="l01170"></a>01170 
<a name="l01171"></a>01171 <span class="keyword">static</span> <span class="keywordtype">int</span> include_in_sort(<a class="code" href="structCodebook.html">Codebook</a> *c, uint8 len)
<a name="l01172"></a>01172 {
<a name="l01173"></a>01173    <span class="keywordflow">if</span> (c-&gt;sparse) { assert(len != NO_CODE); <span class="keywordflow">return</span> TRUE; }
<a name="l01174"></a>01174    <span class="keywordflow">if</span> (len == NO_CODE) <span class="keywordflow">return</span> FALSE;
<a name="l01175"></a>01175    <span class="keywordflow">if</span> (len &gt; STB_VORBIS_FAST_HUFFMAN_LENGTH) <span class="keywordflow">return</span> TRUE;
<a name="l01176"></a>01176    <span class="keywordflow">return</span> FALSE;
<a name="l01177"></a>01177 }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179 <span class="comment">// if the fast table above doesn&#39;t work, we want to binary</span>
<a name="l01180"></a>01180 <span class="comment">// search them... need to reverse the bits</span>
<a name="l01181"></a>01181 <span class="keyword">static</span> <span class="keywordtype">void</span> compute_sorted_huffman(<a class="code" href="structCodebook.html">Codebook</a> *c, uint8 *lengths, uint32 *values)
<a name="l01182"></a>01182 {
<a name="l01183"></a>01183    <span class="keywordtype">int</span> i, len;
<a name="l01184"></a>01184    <span class="comment">// build a list of all the entries</span>
<a name="l01185"></a>01185    <span class="comment">// OPTIMIZATION: don&#39;t include the short ones, since they&#39;ll be caught by FAST_HUFFMAN.</span>
<a name="l01186"></a>01186    <span class="comment">// this is kind of a frivolous optimization--I don&#39;t see any performance improvement,</span>
<a name="l01187"></a>01187    <span class="comment">// but it&#39;s like 4 extra lines of code, so.</span>
<a name="l01188"></a>01188    <span class="keywordflow">if</span> (!c-&gt;sparse) {
<a name="l01189"></a>01189       <span class="keywordtype">int</span> k = 0;
<a name="l01190"></a>01190       <span class="keywordflow">for</span> (i=0; i &lt; c-&gt;entries; ++i)
<a name="l01191"></a>01191          <span class="keywordflow">if</span> (include_in_sort(c, lengths[i]))
<a name="l01192"></a>01192             c-&gt;sorted_codewords[k++] = bit_reverse(c-&gt;codewords[i]);
<a name="l01193"></a>01193       assert(k == c-&gt;sorted_entries);
<a name="l01194"></a>01194    } <span class="keywordflow">else</span> {
<a name="l01195"></a>01195       <span class="keywordflow">for</span> (i=0; i &lt; c-&gt;sorted_entries; ++i)
<a name="l01196"></a>01196          c-&gt;sorted_codewords[i] = bit_reverse(c-&gt;codewords[i]);
<a name="l01197"></a>01197    }
<a name="l01198"></a>01198 
<a name="l01199"></a>01199    qsort(c-&gt;sorted_codewords, c-&gt;sorted_entries, <span class="keyword">sizeof</span>(c-&gt;sorted_codewords[0]), uint32_compare);
<a name="l01200"></a>01200    c-&gt;sorted_codewords[c-&gt;sorted_entries] = 0xffffffff;
<a name="l01201"></a>01201 
<a name="l01202"></a>01202    len = c-&gt;sparse ? c-&gt;sorted_entries : c-&gt;entries;
<a name="l01203"></a>01203    <span class="comment">// now we need to indicate how they correspond; we could either</span>
<a name="l01204"></a>01204    <span class="comment">//   #1: sort a different data structure that says who they correspond to</span>
<a name="l01205"></a>01205    <span class="comment">//   #2: for each sorted entry, search the original list to find who corresponds</span>
<a name="l01206"></a>01206    <span class="comment">//   #3: for each original entry, find the sorted entry</span>
<a name="l01207"></a>01207    <span class="comment">// #1 requires extra storage, #2 is slow, #3 can use binary search!</span>
<a name="l01208"></a>01208    <span class="keywordflow">for</span> (i=0; i &lt; len; ++i) {
<a name="l01209"></a>01209       <span class="keywordtype">int</span> huff_len = c-&gt;sparse ? lengths[values[i]] : lengths[i];
<a name="l01210"></a>01210       <span class="keywordflow">if</span> (include_in_sort(c,huff_len)) {
<a name="l01211"></a>01211          uint32 code = bit_reverse(c-&gt;codewords[i]);
<a name="l01212"></a>01212          <span class="keywordtype">int</span> x=0, n=c-&gt;sorted_entries;
<a name="l01213"></a>01213          <span class="keywordflow">while</span> (n &gt; 1) {
<a name="l01214"></a>01214             <span class="comment">// invariant: sc[x] &lt;= code &lt; sc[x+n]</span>
<a name="l01215"></a>01215             <span class="keywordtype">int</span> m = x + (n &gt;&gt; 1);
<a name="l01216"></a>01216             <span class="keywordflow">if</span> (c-&gt;sorted_codewords[m] &lt;= code) {
<a name="l01217"></a>01217                x = m;
<a name="l01218"></a>01218                n -= (n&gt;&gt;1);
<a name="l01219"></a>01219             } <span class="keywordflow">else</span> {
<a name="l01220"></a>01220                n &gt;&gt;= 1;
<a name="l01221"></a>01221             }
<a name="l01222"></a>01222          }
<a name="l01223"></a>01223          assert(c-&gt;sorted_codewords[x] == code);
<a name="l01224"></a>01224          <span class="keywordflow">if</span> (c-&gt;sparse) {
<a name="l01225"></a>01225             c-&gt;sorted_values[x] = values[i];
<a name="l01226"></a>01226             c-&gt;codeword_lengths[x] = huff_len;
<a name="l01227"></a>01227          } <span class="keywordflow">else</span> {
<a name="l01228"></a>01228             c-&gt;sorted_values[x] = i;
<a name="l01229"></a>01229          }
<a name="l01230"></a>01230       }
<a name="l01231"></a>01231    }
<a name="l01232"></a>01232 }
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 <span class="comment">// only run while parsing the header (3 times)</span>
<a name="l01235"></a>01235 <span class="keyword">static</span> <span class="keywordtype">int</span> vorbis_validate(uint8 *data)
<a name="l01236"></a>01236 {
<a name="l01237"></a>01237    <span class="keyword">static</span> uint8 vorbis[6] = { <span class="charliteral">&#39;v&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;s&#39;</span> };
<a name="l01238"></a>01238    <span class="keywordflow">return</span> memcmp(data, vorbis, 6) == 0;
<a name="l01239"></a>01239 }
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 <span class="comment">// called from setup only, once per code book</span>
<a name="l01242"></a>01242 <span class="comment">// (formula implied by specification)</span>
<a name="l01243"></a>01243 <span class="keyword">static</span> <span class="keywordtype">int</span> lookup1_values(<span class="keywordtype">int</span> <a class="code" href="structentries.html">entries</a>, <span class="keywordtype">int</span> dim)
<a name="l01244"></a>01244 {
<a name="l01245"></a>01245    <span class="keywordtype">int</span> r = (int) floor(exp((<span class="keywordtype">float</span>) log((<span class="keywordtype">float</span>) entries) / dim));
<a name="l01246"></a>01246    <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>) floor(pow((<span class="keywordtype">float</span>) r+1, dim)) &lt;= entries)   <span class="comment">// (int) cast for MinGW warning;</span>
<a name="l01247"></a>01247       ++r;                                              <span class="comment">// floor() to avoid _ftol() when non-CRT</span>
<a name="l01248"></a>01248    <span class="keywordflow">if</span> (pow((<span class="keywordtype">float</span>) r+1, dim) &lt;= entries)
<a name="l01249"></a>01249       <span class="keywordflow">return</span> -1;
<a name="l01250"></a>01250    <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>) floor(pow((<span class="keywordtype">float</span>) r, dim)) &gt; entries)
<a name="l01251"></a>01251       <span class="keywordflow">return</span> -1;
<a name="l01252"></a>01252    <span class="keywordflow">return</span> r;
<a name="l01253"></a>01253 }
<a name="l01254"></a>01254 
<a name="l01255"></a>01255 <span class="comment">// called twice per file</span>
<a name="l01256"></a>01256 <span class="keyword">static</span> <span class="keywordtype">void</span> compute_twiddle_factors(<span class="keywordtype">int</span> n, <span class="keywordtype">float</span> *A, <span class="keywordtype">float</span> *B, <span class="keywordtype">float</span> *C)
<a name="l01257"></a>01257 {
<a name="l01258"></a>01258    <span class="keywordtype">int</span> n4 = n &gt;&gt; 2, n8 = n &gt;&gt; 3;
<a name="l01259"></a>01259    <span class="keywordtype">int</span> k,k2;
<a name="l01260"></a>01260 
<a name="l01261"></a>01261    <span class="keywordflow">for</span> (k=k2=0; k &lt; n4; ++k,k2+=2) {
<a name="l01262"></a>01262       A[k2  ] = (float)  cos(4*k*M_PI/n);
<a name="l01263"></a>01263       A[k2+1] = (float) -sin(4*k*M_PI/n);
<a name="l01264"></a>01264       B[k2  ] = (float)  cos((k2+1)*M_PI/n/2) * 0.5f;
<a name="l01265"></a>01265       B[k2+1] = (float)  sin((k2+1)*M_PI/n/2) * 0.5f;
<a name="l01266"></a>01266    }
<a name="l01267"></a>01267    <span class="keywordflow">for</span> (k=k2=0; k &lt; n8; ++k,k2+=2) {
<a name="l01268"></a>01268       C[k2  ] = (float)  cos(2*(k2+1)*M_PI/n);
<a name="l01269"></a>01269       C[k2+1] = (float) -sin(2*(k2+1)*M_PI/n);
<a name="l01270"></a>01270    }
<a name="l01271"></a>01271 }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273 <span class="keyword">static</span> <span class="keywordtype">void</span> compute_window(<span class="keywordtype">int</span> n, <span class="keywordtype">float</span> *window)
<a name="l01274"></a>01274 {
<a name="l01275"></a>01275    <span class="keywordtype">int</span> n2 = n &gt;&gt; 1, i;
<a name="l01276"></a>01276    <span class="keywordflow">for</span> (i=0; i &lt; n2; ++i)
<a name="l01277"></a>01277       window[i] = (<span class="keywordtype">float</span>) sin(0.5 * M_PI * square((<span class="keywordtype">float</span>) sin((i - 0 + 0.5) / n2 * 0.5 * M_PI)));
<a name="l01278"></a>01278 }
<a name="l01279"></a>01279 
<a name="l01280"></a>01280 <span class="keyword">static</span> <span class="keywordtype">void</span> compute_bitreverse(<span class="keywordtype">int</span> n, uint16 *rev)
<a name="l01281"></a>01281 {
<a name="l01282"></a>01282    <span class="keywordtype">int</span> ld = ilog(n) - 1; <span class="comment">// ilog is off-by-one from normal definitions</span>
<a name="l01283"></a>01283    <span class="keywordtype">int</span> i, n8 = n &gt;&gt; 3;
<a name="l01284"></a>01284    <span class="keywordflow">for</span> (i=0; i &lt; n8; ++i)
<a name="l01285"></a>01285       rev[i] = (bit_reverse(i) &gt;&gt; (32-ld+3)) &lt;&lt; 2;
<a name="l01286"></a>01286 }
<a name="l01287"></a>01287 
<a name="l01288"></a>01288 <span class="keyword">static</span> <span class="keywordtype">int</span> init_blocksize(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span> n)
<a name="l01289"></a>01289 {
<a name="l01290"></a>01290    <span class="keywordtype">int</span> n2 = n &gt;&gt; 1, n4 = n &gt;&gt; 2, n8 = n &gt;&gt; 3;
<a name="l01291"></a>01291    f-&gt;A[b] = (<span class="keywordtype">float</span> *) setup_malloc(f, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * n2);
<a name="l01292"></a>01292    f-&gt;B[b] = (<span class="keywordtype">float</span> *) setup_malloc(f, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * n2);
<a name="l01293"></a>01293    f-&gt;C[b] = (<span class="keywordtype">float</span> *) setup_malloc(f, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * n4);
<a name="l01294"></a>01294    <span class="keywordflow">if</span> (!f-&gt;A[b] || !f-&gt;B[b] || !f-&gt;C[b]) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l01295"></a>01295    compute_twiddle_factors(n, f-&gt;A[b], f-&gt;B[b], f-&gt;C[b]);
<a name="l01296"></a>01296    f-&gt;window[b] = (<span class="keywordtype">float</span> *) setup_malloc(f, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * n2);
<a name="l01297"></a>01297    <span class="keywordflow">if</span> (!f-&gt;window[b]) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l01298"></a>01298    compute_window(n, f-&gt;window[b]);
<a name="l01299"></a>01299    f-&gt;bit_reverse[b] = (uint16 *) setup_malloc(f, <span class="keyword">sizeof</span>(uint16) * n8);
<a name="l01300"></a>01300    <span class="keywordflow">if</span> (!f-&gt;bit_reverse[b]) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l01301"></a>01301    compute_bitreverse(n, f-&gt;bit_reverse[b]);
<a name="l01302"></a>01302    <span class="keywordflow">return</span> TRUE;
<a name="l01303"></a>01303 }
<a name="l01304"></a>01304 
<a name="l01305"></a>01305 <span class="keyword">static</span> <span class="keywordtype">void</span> neighbors(uint16 *x, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> *plow, <span class="keywordtype">int</span> *phigh)
<a name="l01306"></a>01306 {
<a name="l01307"></a>01307    <span class="keywordtype">int</span> low = -1;
<a name="l01308"></a>01308    <span class="keywordtype">int</span> high = 65536;
<a name="l01309"></a>01309    <span class="keywordtype">int</span> i;
<a name="l01310"></a>01310    <span class="keywordflow">for</span> (i=0; i &lt; n; ++i) {
<a name="l01311"></a>01311       <span class="keywordflow">if</span> (x[i] &gt; low  &amp;&amp; x[i] &lt; x[n]) { *plow  = i; low = x[i]; }
<a name="l01312"></a>01312       <span class="keywordflow">if</span> (x[i] &lt; high &amp;&amp; x[i] &gt; x[n]) { *phigh = i; high = x[i]; }
<a name="l01313"></a>01313    }
<a name="l01314"></a>01314 }
<a name="l01315"></a>01315 
<a name="l01316"></a>01316 <span class="comment">// this has been repurposed so y is now the original index instead of y</span>
<a name="l01317"></a><a class="code" href="structstbv____floor__ordering.html">01317</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l01318"></a>01318 {
<a name="l01319"></a>01319    uint16 x,id;
<a name="l01320"></a>01320 } <a class="code" href="structstbv____floor__ordering.html">stbv__floor_ordering</a>;
<a name="l01321"></a>01321 
<a name="l01322"></a>01322 <span class="keyword">static</span> <span class="keywordtype">int</span> STBV_CDECL point_compare(<span class="keyword">const</span> <span class="keywordtype">void</span> *p, <span class="keyword">const</span> <span class="keywordtype">void</span> *q)
<a name="l01323"></a>01323 {
<a name="l01324"></a>01324    <a class="code" href="structstbv____floor__ordering.html">stbv__floor_ordering</a> *a = (<a class="code" href="structstbv____floor__ordering.html">stbv__floor_ordering</a> *) p;
<a name="l01325"></a>01325    <a class="code" href="structstbv____floor__ordering.html">stbv__floor_ordering</a> *b = (<a class="code" href="structstbv____floor__ordering.html">stbv__floor_ordering</a> *) q;
<a name="l01326"></a>01326    <span class="keywordflow">return</span> a-&gt;x &lt; b-&gt;x ? -1 : a-&gt;x &gt; b-&gt;x;
<a name="l01327"></a>01327 }
<a name="l01328"></a>01328 
<a name="l01329"></a>01329 <span class="comment">//</span>
<a name="l01331"></a>01331 <span class="comment"></span>
<a name="l01332"></a>01332 <span class="preprocessor">#ifdef __SDL_SOUND_INTERNAL__</span>
<a name="l01333"></a>01333 <span class="preprocessor"></span><span class="preprocessor">   #define USE_MEMORY(z)    FALSE</span>
<a name="l01334"></a>01334 <span class="preprocessor"></span><span class="preprocessor">#elif defined(STB_VORBIS_NO_STDIO)</span>
<a name="l01335"></a>01335 <span class="preprocessor"></span><span class="preprocessor">   #define USE_MEMORY(z)    TRUE</span>
<a name="l01336"></a>01336 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01337"></a>01337 <span class="preprocessor"></span><span class="preprocessor">   #define USE_MEMORY(z)    ((z)-&gt;stream)</span>
<a name="l01338"></a>01338 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01339"></a>01339 <span class="preprocessor"></span>
<a name="l01340"></a>01340 <span class="keyword">static</span> uint8 get8(<a class="code" href="structstb__vorbis.html">vorb</a> *z)
<a name="l01341"></a>01341 {
<a name="l01342"></a>01342    <span class="keywordflow">if</span> (USE_MEMORY(z)) {
<a name="l01343"></a>01343       <span class="keywordflow">if</span> (z-&gt;stream &gt;= z-&gt;stream_end) { z-&gt;eof = TRUE; <span class="keywordflow">return</span> 0; }
<a name="l01344"></a>01344       <span class="keywordflow">return</span> *z-&gt;stream++;
<a name="l01345"></a>01345    }
<a name="l01346"></a>01346 
<a name="l01347"></a>01347 <span class="preprocessor">   #ifdef __SDL_SOUND_INTERNAL__</span>
<a name="l01348"></a>01348 <span class="preprocessor"></span>   {
<a name="l01349"></a>01349       uint8 c;
<a name="l01350"></a>01350       <span class="keywordflow">if</span> (z-&gt;rwops == NULL || SDL_RWread(z-&gt;rwops, &amp;c, 1, 1) != 1) {
<a name="l01351"></a>01351           z-&gt;eof = TRUE;
<a name="l01352"></a>01352           <span class="keywordflow">return</span> 0;
<a name="l01353"></a>01353       }
<a name="l01354"></a>01354       <span class="keywordflow">return</span> c;
<a name="l01355"></a>01355    }
<a name="l01356"></a>01356 <span class="preprocessor">   #endif</span>
<a name="l01357"></a>01357 <span class="preprocessor"></span>
<a name="l01358"></a>01358 
<a name="l01359"></a>01359 <span class="preprocessor">   #ifndef STB_VORBIS_NO_STDIO</span>
<a name="l01360"></a>01360 <span class="preprocessor"></span>   {
<a name="l01361"></a>01361    <span class="keywordtype">int</span> c = fgetc(z-&gt;f);
<a name="l01362"></a>01362    <span class="keywordflow">if</span> (c == EOF) { z-&gt;eof = TRUE; <span class="keywordflow">return</span> 0; }
<a name="l01363"></a>01363    <span class="keywordflow">return</span> c;
<a name="l01364"></a>01364    }
<a name="l01365"></a>01365 <span class="preprocessor">   #endif</span>
<a name="l01366"></a>01366 <span class="preprocessor"></span>}
<a name="l01367"></a>01367 
<a name="l01368"></a>01368 <span class="keyword">static</span> uint32 get32(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l01369"></a>01369 {
<a name="l01370"></a>01370    uint32 x;
<a name="l01371"></a>01371    x = get8(f);
<a name="l01372"></a>01372    x += get8(f) &lt;&lt; 8;
<a name="l01373"></a>01373    x += get8(f) &lt;&lt; 16;
<a name="l01374"></a>01374    x += (uint32) get8(f) &lt;&lt; 24;
<a name="l01375"></a>01375    <span class="keywordflow">return</span> x;
<a name="l01376"></a>01376 }
<a name="l01377"></a>01377 
<a name="l01378"></a>01378 <span class="keyword">static</span> <span class="keywordtype">int</span> getn(<a class="code" href="structstb__vorbis.html">vorb</a> *z, uint8 *data, <span class="keywordtype">int</span> n)
<a name="l01379"></a>01379 {
<a name="l01380"></a>01380    <span class="keywordflow">if</span> (USE_MEMORY(z)) {
<a name="l01381"></a>01381       <span class="keywordflow">if</span> (z-&gt;stream+n &gt; z-&gt;stream_end) { z-&gt;eof = 1; <span class="keywordflow">return</span> 0; }
<a name="l01382"></a>01382       memcpy(data, z-&gt;stream, n);
<a name="l01383"></a>01383       z-&gt;stream += n;
<a name="l01384"></a>01384       <span class="keywordflow">return</span> 1;
<a name="l01385"></a>01385    }
<a name="l01386"></a>01386 
<a name="l01387"></a>01387 <span class="preprocessor">   #ifdef __SDL_SOUND_INTERNAL__</span>
<a name="l01388"></a>01388 <span class="preprocessor"></span>   {
<a name="l01389"></a>01389       <span class="keywordflow">if</span> (SDL_RWread(z-&gt;rwops, data, n, 1) == 1) { <span class="keywordflow">return</span> 1; }
<a name="l01390"></a>01390       z-&gt;eof = 1;
<a name="l01391"></a>01391       <span class="keywordflow">return</span> 0;
<a name="l01392"></a>01392    }
<a name="l01393"></a>01393 <span class="preprocessor">   #endif</span>
<a name="l01394"></a>01394 <span class="preprocessor"></span>
<a name="l01395"></a>01395 <span class="preprocessor">   #ifndef STB_VORBIS_NO_STDIO   </span>
<a name="l01396"></a>01396 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (fread(data, n, 1, z-&gt;f) == 1)
<a name="l01397"></a>01397       <span class="keywordflow">return</span> 1;
<a name="l01398"></a>01398    <span class="keywordflow">else</span> {
<a name="l01399"></a>01399       z-&gt;eof = 1;
<a name="l01400"></a>01400       <span class="keywordflow">return</span> 0;
<a name="l01401"></a>01401    }
<a name="l01402"></a>01402 <span class="preprocessor">   #endif</span>
<a name="l01403"></a>01403 <span class="preprocessor"></span>}
<a name="l01404"></a>01404 
<a name="l01405"></a>01405 <span class="keyword">static</span> <span class="keywordtype">void</span> skip(<a class="code" href="structstb__vorbis.html">vorb</a> *z, <span class="keywordtype">int</span> n)
<a name="l01406"></a>01406 {
<a name="l01407"></a>01407    <span class="keywordflow">if</span> (USE_MEMORY(z)) {
<a name="l01408"></a>01408       z-&gt;stream += n;
<a name="l01409"></a>01409       <span class="keywordflow">if</span> (z-&gt;stream &gt;= z-&gt;stream_end) z-&gt;eof = 1;
<a name="l01410"></a>01410       <span class="keywordflow">return</span>;
<a name="l01411"></a>01411    }
<a name="l01412"></a>01412 
<a name="l01413"></a>01413 <span class="preprocessor">   #ifdef __SDL_SOUND_INTERNAL__</span>
<a name="l01414"></a>01414 <span class="preprocessor"></span>   {
<a name="l01415"></a>01415       SDL_RWseek(z-&gt;rwops, n, RW_SEEK_CUR);
<a name="l01416"></a>01416    }
<a name="l01417"></a>01417 <span class="preprocessor">   #endif</span>
<a name="l01418"></a>01418 <span class="preprocessor"></span>
<a name="l01419"></a>01419 <span class="preprocessor">   #ifndef STB_VORBIS_NO_STDIO</span>
<a name="l01420"></a>01420 <span class="preprocessor"></span>   {
<a name="l01421"></a>01421       <span class="keywordtype">long</span> x = ftell(z-&gt;f);
<a name="l01422"></a>01422       fseek(z-&gt;f, x+n, SEEK_SET);
<a name="l01423"></a>01423    }
<a name="l01424"></a>01424 <span class="preprocessor">   #endif</span>
<a name="l01425"></a>01425 <span class="preprocessor"></span>}
<a name="l01426"></a>01426 
<a name="l01427"></a>01427 <span class="keyword">static</span> <span class="keywordtype">int</span> set_file_offset(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loc)
<a name="l01428"></a>01428 {
<a name="l01429"></a>01429 <span class="preprocessor">   #ifndef STB_VORBIS_NO_PUSHDATA_API</span>
<a name="l01430"></a>01430 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (f-&gt;push_mode) <span class="keywordflow">return</span> 0;
<a name="l01431"></a>01431 <span class="preprocessor">   #endif</span>
<a name="l01432"></a>01432 <span class="preprocessor"></span>   f-&gt;eof = 0;
<a name="l01433"></a>01433    <span class="keywordflow">if</span> (USE_MEMORY(f)) {
<a name="l01434"></a>01434       <span class="keywordflow">if</span> (f-&gt;stream_start + loc &gt;= f-&gt;stream_end || f-&gt;stream_start + loc &lt; f-&gt;stream_start) {
<a name="l01435"></a>01435          f-&gt;stream = f-&gt;stream_end;
<a name="l01436"></a>01436          f-&gt;eof = 1;
<a name="l01437"></a>01437          <span class="keywordflow">return</span> 0;
<a name="l01438"></a>01438       } <span class="keywordflow">else</span> {
<a name="l01439"></a>01439          f-&gt;stream = f-&gt;stream_start + loc;
<a name="l01440"></a>01440          <span class="keywordflow">return</span> 1;
<a name="l01441"></a>01441       }
<a name="l01442"></a>01442    }
<a name="l01443"></a>01443 
<a name="l01444"></a>01444 <span class="preprocessor">   #ifdef __SDL_SOUND_INTERNAL__</span>
<a name="l01445"></a>01445 <span class="preprocessor"></span>   {
<a name="l01446"></a>01446    <span class="keywordflow">if</span> (loc + f-&gt;rwops_start &lt; loc || loc &gt;= 0x80000000) {
<a name="l01447"></a>01447       loc = 0x7fffffff;
<a name="l01448"></a>01448       f-&gt;eof = 1;
<a name="l01449"></a>01449    } <span class="keywordflow">else</span> {
<a name="l01450"></a>01450       loc += f-&gt;rwops_start;
<a name="l01451"></a>01451    }
<a name="l01452"></a>01452    <span class="keywordflow">if</span> (SDL_RWseek(f-&gt;rwops, loc, RW_SEEK_SET) != -1)
<a name="l01453"></a>01453       <span class="keywordflow">return</span> 1;
<a name="l01454"></a>01454    f-&gt;eof = 1;
<a name="l01455"></a>01455    SDL_RWseek(f-&gt;rwops, f-&gt;rwops_start, RW_SEEK_END);
<a name="l01456"></a>01456    <span class="keywordflow">return</span> 0;
<a name="l01457"></a>01457    }
<a name="l01458"></a>01458 <span class="preprocessor">   #endif</span>
<a name="l01459"></a>01459 <span class="preprocessor"></span>
<a name="l01460"></a>01460 <span class="preprocessor">   #ifndef STB_VORBIS_NO_STDIO</span>
<a name="l01461"></a>01461 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (loc + f-&gt;f_start &lt; loc || loc &gt;= 0x80000000) {
<a name="l01462"></a>01462       loc = 0x7fffffff;
<a name="l01463"></a>01463       f-&gt;eof = 1;
<a name="l01464"></a>01464    } <span class="keywordflow">else</span> {
<a name="l01465"></a>01465       loc += f-&gt;f_start;
<a name="l01466"></a>01466    }
<a name="l01467"></a>01467    <span class="keywordflow">if</span> (!fseek(f-&gt;f, loc, SEEK_SET))
<a name="l01468"></a>01468       <span class="keywordflow">return</span> 1;
<a name="l01469"></a>01469    f-&gt;eof = 1;
<a name="l01470"></a>01470    fseek(f-&gt;f, f-&gt;f_start, SEEK_END);
<a name="l01471"></a>01471    <span class="keywordflow">return</span> 0;
<a name="l01472"></a>01472 <span class="preprocessor">   #endif</span>
<a name="l01473"></a>01473 <span class="preprocessor"></span>}
<a name="l01474"></a>01474 
<a name="l01475"></a>01475 
<a name="l01476"></a>01476 <span class="keyword">static</span> uint8 ogg_page_header[4] = { 0x4f, 0x67, 0x67, 0x53 };
<a name="l01477"></a>01477 
<a name="l01478"></a>01478 <span class="keyword">static</span> <span class="keywordtype">int</span> capture_pattern(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l01479"></a>01479 {
<a name="l01480"></a>01480    <span class="keywordflow">if</span> (0x4f != get8(f)) <span class="keywordflow">return</span> FALSE;
<a name="l01481"></a>01481    <span class="keywordflow">if</span> (0x67 != get8(f)) <span class="keywordflow">return</span> FALSE;
<a name="l01482"></a>01482    <span class="keywordflow">if</span> (0x67 != get8(f)) <span class="keywordflow">return</span> FALSE;
<a name="l01483"></a>01483    <span class="keywordflow">if</span> (0x53 != get8(f)) <span class="keywordflow">return</span> FALSE;
<a name="l01484"></a>01484    <span class="keywordflow">return</span> TRUE;
<a name="l01485"></a>01485 }
<a name="l01486"></a>01486 
<a name="l01487"></a>01487 <span class="preprocessor">#define PAGEFLAG_continued_packet   1</span>
<a name="l01488"></a>01488 <span class="preprocessor"></span><span class="preprocessor">#define PAGEFLAG_first_page         2</span>
<a name="l01489"></a>01489 <span class="preprocessor"></span><span class="preprocessor">#define PAGEFLAG_last_page          4</span>
<a name="l01490"></a>01490 <span class="preprocessor"></span>
<a name="l01491"></a>01491 <span class="keyword">static</span> <span class="keywordtype">int</span> start_page_no_capturepattern(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l01492"></a>01492 {
<a name="l01493"></a>01493    uint32 loc0,loc1,n;
<a name="l01494"></a>01494    <span class="keywordflow">if</span> (f-&gt;first_decode &amp;&amp; !IS_PUSH_MODE(f)) {
<a name="l01495"></a>01495       f-&gt;p_first.page_start = stb_vorbis_get_file_offset(f) - 4;
<a name="l01496"></a>01496    }
<a name="l01497"></a>01497    <span class="comment">// stream structure version</span>
<a name="l01498"></a>01498    <span class="keywordflow">if</span> (0 != get8(f)) <span class="keywordflow">return</span> error(f, VORBIS_invalid_stream_structure_version);
<a name="l01499"></a>01499    <span class="comment">// header flag</span>
<a name="l01500"></a>01500    f-&gt;page_flag = get8(f);
<a name="l01501"></a>01501    <span class="comment">// absolute granule position</span>
<a name="l01502"></a>01502    loc0 = get32(f);
<a name="l01503"></a>01503    loc1 = get32(f);
<a name="l01504"></a>01504    <span class="comment">// @TODO: validate loc0,loc1 as valid positions?</span>
<a name="l01505"></a>01505    <span class="comment">// stream serial number -- vorbis doesn&#39;t interleave, so discard</span>
<a name="l01506"></a>01506    get32(f);
<a name="l01507"></a>01507    <span class="comment">//if (f-&gt;serial != get32(f)) return error(f, VORBIS_incorrect_stream_serial_number);</span>
<a name="l01508"></a>01508    <span class="comment">// page sequence number</span>
<a name="l01509"></a>01509    n = get32(f);
<a name="l01510"></a>01510    f-&gt;last_page = n;
<a name="l01511"></a>01511    <span class="comment">// CRC32</span>
<a name="l01512"></a>01512    get32(f);
<a name="l01513"></a>01513    <span class="comment">// page_segments</span>
<a name="l01514"></a>01514    f-&gt;segment_count = get8(f);
<a name="l01515"></a>01515    <span class="keywordflow">if</span> (!getn(f, f-&gt;segments, f-&gt;segment_count))
<a name="l01516"></a>01516       <span class="keywordflow">return</span> error(f, VORBIS_unexpected_eof);
<a name="l01517"></a>01517    <span class="comment">// assume we _don&#39;t_ know any the sample position of any segments</span>
<a name="l01518"></a>01518    f-&gt;end_seg_with_known_loc = -2;
<a name="l01519"></a>01519    <span class="keywordflow">if</span> (loc0 != ~0U || loc1 != ~0U) {
<a name="l01520"></a>01520       <span class="keywordtype">int</span> i;
<a name="l01521"></a>01521       <span class="comment">// determine which packet is the last one that will complete</span>
<a name="l01522"></a>01522       <span class="keywordflow">for</span> (i=f-&gt;segment_count-1; i &gt;= 0; --i)
<a name="l01523"></a>01523          <span class="keywordflow">if</span> (f-&gt;segments[i] &lt; 255)
<a name="l01524"></a>01524             <span class="keywordflow">break</span>;
<a name="l01525"></a>01525       <span class="comment">// &#39;i&#39; is now the index of the _last_ segment of a packet that ends</span>
<a name="l01526"></a>01526       <span class="keywordflow">if</span> (i &gt;= 0) {
<a name="l01527"></a>01527          f-&gt;end_seg_with_known_loc = i;
<a name="l01528"></a>01528          f-&gt;known_loc_for_packet   = loc0;
<a name="l01529"></a>01529       }
<a name="l01530"></a>01530    }
<a name="l01531"></a>01531    <span class="keywordflow">if</span> (f-&gt;first_decode) {
<a name="l01532"></a>01532       <span class="keywordtype">int</span> i,len;
<a name="l01533"></a>01533       len = 0;
<a name="l01534"></a>01534       <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;segment_count; ++i)
<a name="l01535"></a>01535          len += f-&gt;segments[i];
<a name="l01536"></a>01536       len += 27 + f-&gt;segment_count;
<a name="l01537"></a>01537       f-&gt;p_first.page_end = f-&gt;p_first.page_start + len;
<a name="l01538"></a>01538       f-&gt;p_first.last_decoded_sample = loc0;
<a name="l01539"></a>01539    }
<a name="l01540"></a>01540    f-&gt;next_seg = 0;
<a name="l01541"></a>01541    <span class="keywordflow">return</span> TRUE;
<a name="l01542"></a>01542 }
<a name="l01543"></a>01543 
<a name="l01544"></a>01544 <span class="keyword">static</span> <span class="keywordtype">int</span> start_page(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l01545"></a>01545 {
<a name="l01546"></a>01546    <span class="keywordflow">if</span> (!capture_pattern(f)) <span class="keywordflow">return</span> error(f, VORBIS_missing_capture_pattern);
<a name="l01547"></a>01547    <span class="keywordflow">return</span> start_page_no_capturepattern(f);
<a name="l01548"></a>01548 }
<a name="l01549"></a>01549 
<a name="l01550"></a>01550 <span class="keyword">static</span> <span class="keywordtype">int</span> start_packet(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l01551"></a>01551 {
<a name="l01552"></a>01552    <span class="keywordflow">while</span> (f-&gt;next_seg == -1) {
<a name="l01553"></a>01553       <span class="keywordflow">if</span> (!start_page(f)) <span class="keywordflow">return</span> FALSE;
<a name="l01554"></a>01554       <span class="keywordflow">if</span> (f-&gt;page_flag &amp; PAGEFLAG_continued_packet)
<a name="l01555"></a>01555          <span class="keywordflow">return</span> error(f, VORBIS_continued_packet_flag_invalid);
<a name="l01556"></a>01556    }
<a name="l01557"></a>01557    f-&gt;last_seg = FALSE;
<a name="l01558"></a>01558    f-&gt;valid_bits = 0;
<a name="l01559"></a>01559    f-&gt;packet_bytes = 0;
<a name="l01560"></a>01560    f-&gt;bytes_in_seg = 0;
<a name="l01561"></a>01561    <span class="comment">// f-&gt;next_seg is now valid</span>
<a name="l01562"></a>01562    <span class="keywordflow">return</span> TRUE;
<a name="l01563"></a>01563 }
<a name="l01564"></a>01564 
<a name="l01565"></a>01565 <span class="keyword">static</span> <span class="keywordtype">int</span> maybe_start_packet(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l01566"></a>01566 {
<a name="l01567"></a>01567    <span class="keywordflow">if</span> (f-&gt;next_seg == -1) {
<a name="l01568"></a>01568       <span class="keywordtype">int</span> x = get8(f);
<a name="l01569"></a>01569       <span class="keywordflow">if</span> (f-&gt;eof) <span class="keywordflow">return</span> FALSE; <span class="comment">// EOF at page boundary is not an error!</span>
<a name="l01570"></a>01570       <span class="keywordflow">if</span> (0x4f != x      ) <span class="keywordflow">return</span> error(f, VORBIS_missing_capture_pattern);
<a name="l01571"></a>01571       <span class="keywordflow">if</span> (0x67 != get8(f)) <span class="keywordflow">return</span> error(f, VORBIS_missing_capture_pattern);
<a name="l01572"></a>01572       <span class="keywordflow">if</span> (0x67 != get8(f)) <span class="keywordflow">return</span> error(f, VORBIS_missing_capture_pattern);
<a name="l01573"></a>01573       <span class="keywordflow">if</span> (0x53 != get8(f)) <span class="keywordflow">return</span> error(f, VORBIS_missing_capture_pattern);
<a name="l01574"></a>01574       <span class="keywordflow">if</span> (!start_page_no_capturepattern(f)) <span class="keywordflow">return</span> FALSE;
<a name="l01575"></a>01575       <span class="keywordflow">if</span> (f-&gt;page_flag &amp; PAGEFLAG_continued_packet) {
<a name="l01576"></a>01576          <span class="comment">// set up enough state that we can read this packet if we want,</span>
<a name="l01577"></a>01577          <span class="comment">// e.g. during recovery</span>
<a name="l01578"></a>01578          f-&gt;last_seg = FALSE;
<a name="l01579"></a>01579          f-&gt;bytes_in_seg = 0;
<a name="l01580"></a>01580          <span class="keywordflow">return</span> error(f, VORBIS_continued_packet_flag_invalid);
<a name="l01581"></a>01581       }
<a name="l01582"></a>01582    }
<a name="l01583"></a>01583    <span class="keywordflow">return</span> start_packet(f);
<a name="l01584"></a>01584 }
<a name="l01585"></a>01585 
<a name="l01586"></a>01586 <span class="keyword">static</span> <span class="keywordtype">int</span> next_segment(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l01587"></a>01587 {
<a name="l01588"></a>01588    <span class="keywordtype">int</span> len;
<a name="l01589"></a>01589    <span class="keywordflow">if</span> (f-&gt;last_seg) <span class="keywordflow">return</span> 0;
<a name="l01590"></a>01590    <span class="keywordflow">if</span> (f-&gt;next_seg == -1) {
<a name="l01591"></a>01591       f-&gt;last_seg_which = f-&gt;segment_count-1; <span class="comment">// in case start_page fails</span>
<a name="l01592"></a>01592       <span class="keywordflow">if</span> (!start_page(f)) { f-&gt;last_seg = 1; <span class="keywordflow">return</span> 0; }
<a name="l01593"></a>01593       <span class="keywordflow">if</span> (!(f-&gt;page_flag &amp; PAGEFLAG_continued_packet)) <span class="keywordflow">return</span> error(f, VORBIS_continued_packet_flag_invalid);
<a name="l01594"></a>01594    }
<a name="l01595"></a>01595    len = f-&gt;segments[f-&gt;next_seg++];
<a name="l01596"></a>01596    <span class="keywordflow">if</span> (len &lt; 255) {
<a name="l01597"></a>01597       f-&gt;last_seg = TRUE;
<a name="l01598"></a>01598       f-&gt;last_seg_which = f-&gt;next_seg-1;
<a name="l01599"></a>01599    }
<a name="l01600"></a>01600    <span class="keywordflow">if</span> (f-&gt;next_seg &gt;= f-&gt;segment_count)
<a name="l01601"></a>01601       f-&gt;next_seg = -1;
<a name="l01602"></a>01602    assert(f-&gt;bytes_in_seg == 0);
<a name="l01603"></a>01603    f-&gt;bytes_in_seg = len;
<a name="l01604"></a>01604    <span class="keywordflow">return</span> len;
<a name="l01605"></a>01605 }
<a name="l01606"></a>01606 
<a name="l01607"></a>01607 <span class="preprocessor">#define EOP    (-1)</span>
<a name="l01608"></a>01608 <span class="preprocessor"></span><span class="preprocessor">#define INVALID_BITS  (-1)</span>
<a name="l01609"></a>01609 <span class="preprocessor"></span>
<a name="l01610"></a>01610 <span class="keyword">static</span> <span class="keywordtype">int</span> get8_packet_raw(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l01611"></a>01611 {
<a name="l01612"></a>01612    <span class="keywordflow">if</span> (!f-&gt;bytes_in_seg) {  <span class="comment">// CLANG!</span>
<a name="l01613"></a>01613       <span class="keywordflow">if</span> (f-&gt;last_seg) <span class="keywordflow">return</span> EOP;
<a name="l01614"></a>01614       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!next_segment(f)) <span class="keywordflow">return</span> EOP;
<a name="l01615"></a>01615    }
<a name="l01616"></a>01616    assert(f-&gt;bytes_in_seg &gt; 0);
<a name="l01617"></a>01617    --f-&gt;bytes_in_seg;
<a name="l01618"></a>01618    ++f-&gt;packet_bytes;
<a name="l01619"></a>01619    <span class="keywordflow">return</span> get8(f);
<a name="l01620"></a>01620 }
<a name="l01621"></a>01621 
<a name="l01622"></a>01622 <span class="keyword">static</span> <span class="keywordtype">int</span> get8_packet(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l01623"></a>01623 {
<a name="l01624"></a>01624    <span class="keywordtype">int</span> x = get8_packet_raw(f);
<a name="l01625"></a>01625    f-&gt;valid_bits = 0;
<a name="l01626"></a>01626    <span class="keywordflow">return</span> x;
<a name="l01627"></a>01627 }
<a name="l01628"></a>01628 
<a name="l01629"></a>01629 <span class="keyword">static</span> <span class="keywordtype">int</span> get32_packet(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l01630"></a>01630 {
<a name="l01631"></a>01631    uint32 x;
<a name="l01632"></a>01632    x = get8_packet(f);
<a name="l01633"></a>01633    x += get8_packet(f) &lt;&lt; 8;
<a name="l01634"></a>01634    x += get8_packet(f) &lt;&lt; 16;
<a name="l01635"></a>01635    x += (uint32) get8_packet(f) &lt;&lt; 24;
<a name="l01636"></a>01636    <span class="keywordflow">return</span> x;
<a name="l01637"></a>01637 }
<a name="l01638"></a>01638 
<a name="l01639"></a>01639 <span class="keyword">static</span> <span class="keywordtype">void</span> flush_packet(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l01640"></a>01640 {
<a name="l01641"></a>01641    <span class="keywordflow">while</span> (get8_packet_raw(f) != EOP);
<a name="l01642"></a>01642 }
<a name="l01643"></a>01643 
<a name="l01644"></a>01644 <span class="comment">// @OPTIMIZE: this is the secondary bit decoder, so it&#39;s probably not as important</span>
<a name="l01645"></a>01645 <span class="comment">// as the huffman decoder?</span>
<a name="l01646"></a>01646 <span class="keyword">static</span> uint32 get_bits(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> n)
<a name="l01647"></a>01647 {
<a name="l01648"></a>01648    uint32 z;
<a name="l01649"></a>01649 
<a name="l01650"></a>01650    <span class="keywordflow">if</span> (f-&gt;valid_bits &lt; 0) <span class="keywordflow">return</span> 0;
<a name="l01651"></a>01651    <span class="keywordflow">if</span> (f-&gt;valid_bits &lt; n) {
<a name="l01652"></a>01652       <span class="keywordflow">if</span> (n &gt; 24) {
<a name="l01653"></a>01653          <span class="comment">// the accumulator technique below would not work correctly in this case</span>
<a name="l01654"></a>01654          z = get_bits(f, 24);
<a name="l01655"></a>01655          z += get_bits(f, n-24) &lt;&lt; 24;
<a name="l01656"></a>01656          <span class="keywordflow">return</span> z;
<a name="l01657"></a>01657       }
<a name="l01658"></a>01658       <span class="keywordflow">if</span> (f-&gt;valid_bits == 0) f-&gt;acc = 0;
<a name="l01659"></a>01659       <span class="keywordflow">while</span> (f-&gt;valid_bits &lt; n) {
<a name="l01660"></a>01660          <span class="keywordtype">int</span> z = get8_packet_raw(f);
<a name="l01661"></a>01661          <span class="keywordflow">if</span> (z == EOP) {
<a name="l01662"></a>01662             f-&gt;valid_bits = INVALID_BITS;
<a name="l01663"></a>01663             <span class="keywordflow">return</span> 0;
<a name="l01664"></a>01664          }
<a name="l01665"></a>01665          f-&gt;acc += z &lt;&lt; f-&gt;valid_bits;
<a name="l01666"></a>01666          f-&gt;valid_bits += 8;
<a name="l01667"></a>01667       }
<a name="l01668"></a>01668    }
<a name="l01669"></a>01669    z = f-&gt;acc &amp; ((1 &lt;&lt; n)-1);
<a name="l01670"></a>01670    f-&gt;acc &gt;&gt;= n;
<a name="l01671"></a>01671    f-&gt;valid_bits -= n;
<a name="l01672"></a>01672    <span class="keywordflow">return</span> z;
<a name="l01673"></a>01673 }
<a name="l01674"></a>01674 
<a name="l01675"></a>01675 <span class="comment">// @OPTIMIZE: primary accumulator for huffman</span>
<a name="l01676"></a>01676 <span class="comment">// expand the buffer to as many bits as possible without reading off end of packet</span>
<a name="l01677"></a>01677 <span class="comment">// it might be nice to allow f-&gt;valid_bits and f-&gt;acc to be stored in registers,</span>
<a name="l01678"></a>01678 <span class="comment">// e.g. cache them locally and decode locally</span>
<a name="l01679"></a>01679 <span class="keyword">static</span> __forceinline <span class="keywordtype">void</span> prep_huffman(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l01680"></a>01680 {
<a name="l01681"></a>01681    <span class="keywordflow">if</span> (f-&gt;valid_bits &lt;= 24) {
<a name="l01682"></a>01682       <span class="keywordflow">if</span> (f-&gt;valid_bits == 0) f-&gt;acc = 0;
<a name="l01683"></a>01683       <span class="keywordflow">do</span> {
<a name="l01684"></a>01684          <span class="keywordtype">int</span> z;
<a name="l01685"></a>01685          <span class="keywordflow">if</span> (f-&gt;last_seg &amp;&amp; !f-&gt;bytes_in_seg) <span class="keywordflow">return</span>;
<a name="l01686"></a>01686          z = get8_packet_raw(f);
<a name="l01687"></a>01687          <span class="keywordflow">if</span> (z == EOP) <span class="keywordflow">return</span>;
<a name="l01688"></a>01688          f-&gt;acc += (unsigned) z &lt;&lt; f-&gt;valid_bits;
<a name="l01689"></a>01689          f-&gt;valid_bits += 8;
<a name="l01690"></a>01690       } <span class="keywordflow">while</span> (f-&gt;valid_bits &lt;= 24);
<a name="l01691"></a>01691    }
<a name="l01692"></a>01692 }
<a name="l01693"></a>01693 
<a name="l01694"></a>01694 <span class="keyword">enum</span>
<a name="l01695"></a>01695 {
<a name="l01696"></a>01696    VORBIS_packet_id = 1,
<a name="l01697"></a>01697    VORBIS_packet_comment = 3,
<a name="l01698"></a>01698    VORBIS_packet_setup = 5
<a name="l01699"></a>01699 };
<a name="l01700"></a>01700 
<a name="l01701"></a>01701 <span class="keyword">static</span> <span class="keywordtype">int</span> codebook_decode_scalar_raw(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <a class="code" href="structCodebook.html">Codebook</a> *c)
<a name="l01702"></a>01702 {
<a name="l01703"></a>01703    <span class="keywordtype">int</span> i;
<a name="l01704"></a>01704    prep_huffman(f);
<a name="l01705"></a>01705 
<a name="l01706"></a>01706    <span class="keywordflow">if</span> (c-&gt;codewords == NULL &amp;&amp; c-&gt;sorted_codewords == NULL)
<a name="l01707"></a>01707       <span class="keywordflow">return</span> -1;
<a name="l01708"></a>01708 
<a name="l01709"></a>01709    <span class="comment">// cases to use binary search: sorted_codewords &amp;&amp; !c-&gt;codewords</span>
<a name="l01710"></a>01710    <span class="comment">//                             sorted_codewords &amp;&amp; c-&gt;entries &gt; 8</span>
<a name="l01711"></a>01711    <span class="keywordflow">if</span> (c-&gt;entries &gt; 8 ? c-&gt;sorted_codewords!=NULL : !c-&gt;codewords) {
<a name="l01712"></a>01712       <span class="comment">// binary search</span>
<a name="l01713"></a>01713       uint32 code = bit_reverse(f-&gt;acc);
<a name="l01714"></a>01714       <span class="keywordtype">int</span> x=0, n=c-&gt;sorted_entries, len;
<a name="l01715"></a>01715 
<a name="l01716"></a>01716       <span class="keywordflow">while</span> (n &gt; 1) {
<a name="l01717"></a>01717          <span class="comment">// invariant: sc[x] &lt;= code &lt; sc[x+n]</span>
<a name="l01718"></a>01718          <span class="keywordtype">int</span> m = x + (n &gt;&gt; 1);
<a name="l01719"></a>01719          <span class="keywordflow">if</span> (c-&gt;sorted_codewords[m] &lt;= code) {
<a name="l01720"></a>01720             x = m;
<a name="l01721"></a>01721             n -= (n&gt;&gt;1);
<a name="l01722"></a>01722          } <span class="keywordflow">else</span> {
<a name="l01723"></a>01723             n &gt;&gt;= 1;
<a name="l01724"></a>01724          }
<a name="l01725"></a>01725       }
<a name="l01726"></a>01726       <span class="comment">// x is now the sorted index</span>
<a name="l01727"></a>01727       <span class="keywordflow">if</span> (!c-&gt;sparse) x = c-&gt;sorted_values[x];
<a name="l01728"></a>01728       <span class="comment">// x is now sorted index if sparse, or symbol otherwise</span>
<a name="l01729"></a>01729       len = c-&gt;codeword_lengths[x];
<a name="l01730"></a>01730       <span class="keywordflow">if</span> (f-&gt;valid_bits &gt;= len) {
<a name="l01731"></a>01731          f-&gt;acc &gt;&gt;= len;
<a name="l01732"></a>01732          f-&gt;valid_bits -= len;
<a name="l01733"></a>01733          <span class="keywordflow">return</span> x;
<a name="l01734"></a>01734       }
<a name="l01735"></a>01735 
<a name="l01736"></a>01736       f-&gt;valid_bits = 0;
<a name="l01737"></a>01737       <span class="keywordflow">return</span> -1;
<a name="l01738"></a>01738    }
<a name="l01739"></a>01739 
<a name="l01740"></a>01740    <span class="comment">// if small, linear search</span>
<a name="l01741"></a>01741    assert(!c-&gt;sparse);
<a name="l01742"></a>01742    <span class="keywordflow">for</span> (i=0; i &lt; c-&gt;entries; ++i) {
<a name="l01743"></a>01743       <span class="keywordflow">if</span> (c-&gt;codeword_lengths[i] == NO_CODE) <span class="keywordflow">continue</span>;
<a name="l01744"></a>01744       <span class="keywordflow">if</span> (c-&gt;codewords[i] == (f-&gt;acc &amp; ((1 &lt;&lt; c-&gt;codeword_lengths[i])-1))) {
<a name="l01745"></a>01745          <span class="keywordflow">if</span> (f-&gt;valid_bits &gt;= c-&gt;codeword_lengths[i]) {
<a name="l01746"></a>01746             f-&gt;acc &gt;&gt;= c-&gt;codeword_lengths[i];
<a name="l01747"></a>01747             f-&gt;valid_bits -= c-&gt;codeword_lengths[i];
<a name="l01748"></a>01748             <span class="keywordflow">return</span> i;
<a name="l01749"></a>01749          }
<a name="l01750"></a>01750          f-&gt;valid_bits = 0;
<a name="l01751"></a>01751          <span class="keywordflow">return</span> -1;
<a name="l01752"></a>01752       }
<a name="l01753"></a>01753    }
<a name="l01754"></a>01754 
<a name="l01755"></a>01755    error(f, VORBIS_invalid_stream);
<a name="l01756"></a>01756    f-&gt;valid_bits = 0;
<a name="l01757"></a>01757    <span class="keywordflow">return</span> -1;
<a name="l01758"></a>01758 }
<a name="l01759"></a>01759 
<a name="l01760"></a>01760 <span class="preprocessor">#ifndef STB_VORBIS_NO_INLINE_DECODE</span>
<a name="l01761"></a>01761 <span class="preprocessor"></span>
<a name="l01762"></a>01762 <span class="preprocessor">#define DECODE_RAW(var, f,c)                                  \</span>
<a name="l01763"></a>01763 <span class="preprocessor">   if (f-&gt;valid_bits &lt; STB_VORBIS_FAST_HUFFMAN_LENGTH)        \</span>
<a name="l01764"></a>01764 <span class="preprocessor">      prep_huffman(f);                                        \</span>
<a name="l01765"></a>01765 <span class="preprocessor">   var = f-&gt;acc &amp; FAST_HUFFMAN_TABLE_MASK;                    \</span>
<a name="l01766"></a>01766 <span class="preprocessor">   var = c-&gt;fast_huffman[var];                                \</span>
<a name="l01767"></a>01767 <span class="preprocessor">   if (var &gt;= 0) {                                            \</span>
<a name="l01768"></a>01768 <span class="preprocessor">      int n = c-&gt;codeword_lengths[var];                       \</span>
<a name="l01769"></a>01769 <span class="preprocessor">      f-&gt;acc &gt;&gt;= n;                                           \</span>
<a name="l01770"></a>01770 <span class="preprocessor">      f-&gt;valid_bits -= n;                                     \</span>
<a name="l01771"></a>01771 <span class="preprocessor">      if (f-&gt;valid_bits &lt; 0) { f-&gt;valid_bits = 0; var = -1; } \</span>
<a name="l01772"></a>01772 <span class="preprocessor">   } else {                                                   \</span>
<a name="l01773"></a>01773 <span class="preprocessor">      var = codebook_decode_scalar_raw(f,c);                  \</span>
<a name="l01774"></a>01774 <span class="preprocessor">   }</span>
<a name="l01775"></a>01775 <span class="preprocessor"></span>
<a name="l01776"></a>01776 <span class="preprocessor">#else</span>
<a name="l01777"></a>01777 <span class="preprocessor"></span>
<a name="l01778"></a>01778 <span class="keyword">static</span> <span class="keywordtype">int</span> codebook_decode_scalar(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <a class="code" href="structCodebook.html">Codebook</a> *c)
<a name="l01779"></a>01779 {
<a name="l01780"></a>01780    <span class="keywordtype">int</span> i;
<a name="l01781"></a>01781    <span class="keywordflow">if</span> (f-&gt;valid_bits &lt; STB_VORBIS_FAST_HUFFMAN_LENGTH)
<a name="l01782"></a>01782       prep_huffman(f);
<a name="l01783"></a>01783    <span class="comment">// fast huffman table lookup</span>
<a name="l01784"></a>01784    i = f-&gt;acc &amp; FAST_HUFFMAN_TABLE_MASK;
<a name="l01785"></a>01785    i = c-&gt;fast_huffman[i];
<a name="l01786"></a>01786    <span class="keywordflow">if</span> (i &gt;= 0) {
<a name="l01787"></a>01787       f-&gt;acc &gt;&gt;= c-&gt;codeword_lengths[i];
<a name="l01788"></a>01788       f-&gt;valid_bits -= c-&gt;codeword_lengths[i];
<a name="l01789"></a>01789       <span class="keywordflow">if</span> (f-&gt;valid_bits &lt; 0) { f-&gt;valid_bits = 0; <span class="keywordflow">return</span> -1; }
<a name="l01790"></a>01790       <span class="keywordflow">return</span> i;
<a name="l01791"></a>01791    }
<a name="l01792"></a>01792    <span class="keywordflow">return</span> codebook_decode_scalar_raw(f,c);
<a name="l01793"></a>01793 }
<a name="l01794"></a>01794 
<a name="l01795"></a>01795 <span class="preprocessor">#define DECODE_RAW(var,f,c)    var = codebook_decode_scalar(f,c);</span>
<a name="l01796"></a>01796 <span class="preprocessor"></span>
<a name="l01797"></a>01797 <span class="preprocessor">#endif</span>
<a name="l01798"></a>01798 <span class="preprocessor"></span>
<a name="l01799"></a>01799 <span class="preprocessor">#define DECODE(var,f,c)                                       \</span>
<a name="l01800"></a>01800 <span class="preprocessor">   DECODE_RAW(var,f,c)                                        \</span>
<a name="l01801"></a>01801 <span class="preprocessor">   if (c-&gt;sparse) var = c-&gt;sorted_values[var];</span>
<a name="l01802"></a>01802 <span class="preprocessor"></span>
<a name="l01803"></a>01803 <span class="preprocessor">#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK</span>
<a name="l01804"></a>01804 <span class="preprocessor"></span><span class="preprocessor">  #define DECODE_VQ(var,f,c)   DECODE_RAW(var,f,c)</span>
<a name="l01805"></a>01805 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l01806"></a>01806 <span class="preprocessor"></span><span class="preprocessor">  #define DECODE_VQ(var,f,c)   DECODE(var,f,c)</span>
<a name="l01807"></a>01807 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01808"></a>01808 <span class="preprocessor"></span>
<a name="l01809"></a>01809 
<a name="l01810"></a>01810 
<a name="l01811"></a>01811 
<a name="l01812"></a>01812 
<a name="l01813"></a>01813 
<a name="l01814"></a>01814 <span class="comment">// CODEBOOK_ELEMENT_FAST is an optimization for the CODEBOOK_FLOATS case</span>
<a name="l01815"></a>01815 <span class="comment">// where we avoid one addition</span>
<a name="l01816"></a>01816 <span class="preprocessor">#define CODEBOOK_ELEMENT(c,off)          (c-&gt;multiplicands[off])</span>
<a name="l01817"></a>01817 <span class="preprocessor"></span><span class="preprocessor">#define CODEBOOK_ELEMENT_FAST(c,off)     (c-&gt;multiplicands[off])</span>
<a name="l01818"></a>01818 <span class="preprocessor"></span><span class="preprocessor">#define CODEBOOK_ELEMENT_BASE(c)         (0)</span>
<a name="l01819"></a>01819 <span class="preprocessor"></span>
<a name="l01820"></a>01820 <span class="keyword">static</span> <span class="keywordtype">int</span> codebook_decode_start(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <a class="code" href="structCodebook.html">Codebook</a> *c)
<a name="l01821"></a>01821 {
<a name="l01822"></a>01822    <span class="keywordtype">int</span> z = -1;
<a name="l01823"></a>01823 
<a name="l01824"></a>01824    <span class="comment">// type 0 is only legal in a scalar context</span>
<a name="l01825"></a>01825    <span class="keywordflow">if</span> (c-&gt;lookup_type == 0)
<a name="l01826"></a>01826       error(f, VORBIS_invalid_stream);
<a name="l01827"></a>01827    <span class="keywordflow">else</span> {
<a name="l01828"></a>01828       DECODE_VQ(z,f,c);
<a name="l01829"></a>01829       <span class="keywordflow">if</span> (c-&gt;sparse) assert(z &lt; c-&gt;sorted_entries);
<a name="l01830"></a>01830       <span class="keywordflow">if</span> (z &lt; 0) {  <span class="comment">// check for EOP</span>
<a name="l01831"></a>01831          <span class="keywordflow">if</span> (!f-&gt;bytes_in_seg)
<a name="l01832"></a>01832             <span class="keywordflow">if</span> (f-&gt;last_seg)
<a name="l01833"></a>01833                <span class="keywordflow">return</span> z;
<a name="l01834"></a>01834          error(f, VORBIS_invalid_stream);
<a name="l01835"></a>01835       }
<a name="l01836"></a>01836    }
<a name="l01837"></a>01837    <span class="keywordflow">return</span> z;
<a name="l01838"></a>01838 }
<a name="l01839"></a>01839 
<a name="l01840"></a>01840 <span class="keyword">static</span> <span class="keywordtype">int</span> codebook_decode(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <a class="code" href="structCodebook.html">Codebook</a> *c, <span class="keywordtype">float</span> *output, <span class="keywordtype">int</span> len)
<a name="l01841"></a>01841 {
<a name="l01842"></a>01842    <span class="keywordtype">int</span> i,z = codebook_decode_start(f,c);
<a name="l01843"></a>01843    <span class="keywordflow">if</span> (z &lt; 0) <span class="keywordflow">return</span> FALSE;
<a name="l01844"></a>01844    <span class="keywordflow">if</span> (len &gt; c-&gt;dimensions) len = c-&gt;dimensions;
<a name="l01845"></a>01845 
<a name="l01846"></a>01846 <span class="preprocessor">#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK</span>
<a name="l01847"></a>01847 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (c-&gt;lookup_type == 1) {
<a name="l01848"></a>01848       <span class="keywordtype">float</span> last = CODEBOOK_ELEMENT_BASE(c);
<a name="l01849"></a>01849       <span class="keywordtype">int</span> div = 1;
<a name="l01850"></a>01850       <span class="keywordflow">for</span> (i=0; i &lt; len; ++i) {
<a name="l01851"></a>01851          <span class="keywordtype">int</span> off = (z / div) % c-&gt;lookup_values;
<a name="l01852"></a>01852          <span class="keywordtype">float</span> val = CODEBOOK_ELEMENT_FAST(c,off) + last;
<a name="l01853"></a>01853          output[i] += val;
<a name="l01854"></a>01854          <span class="keywordflow">if</span> (c-&gt;sequence_p) last = val + c-&gt;minimum_value;
<a name="l01855"></a>01855          div *= c-&gt;lookup_values;
<a name="l01856"></a>01856       }
<a name="l01857"></a>01857       <span class="keywordflow">return</span> TRUE;
<a name="l01858"></a>01858    }
<a name="l01859"></a>01859 <span class="preprocessor">#endif</span>
<a name="l01860"></a>01860 <span class="preprocessor"></span>
<a name="l01861"></a>01861    z *= c-&gt;dimensions;
<a name="l01862"></a>01862    <span class="keywordflow">if</span> (c-&gt;sequence_p) {
<a name="l01863"></a>01863       <span class="keywordtype">float</span> last = CODEBOOK_ELEMENT_BASE(c);
<a name="l01864"></a>01864       <span class="keywordflow">for</span> (i=0; i &lt; len; ++i) {
<a name="l01865"></a>01865          <span class="keywordtype">float</span> val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;
<a name="l01866"></a>01866          output[i] += val;
<a name="l01867"></a>01867          last = val + c-&gt;minimum_value;
<a name="l01868"></a>01868       }
<a name="l01869"></a>01869    } <span class="keywordflow">else</span> {
<a name="l01870"></a>01870       <span class="keywordtype">float</span> last = CODEBOOK_ELEMENT_BASE(c);
<a name="l01871"></a>01871       <span class="keywordflow">for</span> (i=0; i &lt; len; ++i) {
<a name="l01872"></a>01872          output[i] += CODEBOOK_ELEMENT_FAST(c,z+i) + last;
<a name="l01873"></a>01873       }
<a name="l01874"></a>01874    }
<a name="l01875"></a>01875 
<a name="l01876"></a>01876    <span class="keywordflow">return</span> TRUE;
<a name="l01877"></a>01877 }
<a name="l01878"></a>01878 
<a name="l01879"></a>01879 <span class="keyword">static</span> <span class="keywordtype">int</span> codebook_decode_step(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <a class="code" href="structCodebook.html">Codebook</a> *c, <span class="keywordtype">float</span> *output, <span class="keywordtype">int</span> len, <span class="keywordtype">int</span> step)
<a name="l01880"></a>01880 {
<a name="l01881"></a>01881    <span class="keywordtype">int</span> i,z = codebook_decode_start(f,c);
<a name="l01882"></a>01882    <span class="keywordtype">float</span> last = CODEBOOK_ELEMENT_BASE(c);
<a name="l01883"></a>01883    <span class="keywordflow">if</span> (z &lt; 0) <span class="keywordflow">return</span> FALSE;
<a name="l01884"></a>01884    <span class="keywordflow">if</span> (len &gt; c-&gt;dimensions) len = c-&gt;dimensions;
<a name="l01885"></a>01885 
<a name="l01886"></a>01886 <span class="preprocessor">#ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK</span>
<a name="l01887"></a>01887 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (c-&gt;lookup_type == 1) {
<a name="l01888"></a>01888       <span class="keywordtype">int</span> div = 1;
<a name="l01889"></a>01889       <span class="keywordflow">for</span> (i=0; i &lt; len; ++i) {
<a name="l01890"></a>01890          <span class="keywordtype">int</span> off = (z / div) % c-&gt;lookup_values;
<a name="l01891"></a>01891          <span class="keywordtype">float</span> val = CODEBOOK_ELEMENT_FAST(c,off) + last;
<a name="l01892"></a>01892          output[i*step] += val;
<a name="l01893"></a>01893          <span class="keywordflow">if</span> (c-&gt;sequence_p) last = val;
<a name="l01894"></a>01894          div *= c-&gt;lookup_values;
<a name="l01895"></a>01895       }
<a name="l01896"></a>01896       <span class="keywordflow">return</span> TRUE;
<a name="l01897"></a>01897    }
<a name="l01898"></a>01898 <span class="preprocessor">#endif</span>
<a name="l01899"></a>01899 <span class="preprocessor"></span>
<a name="l01900"></a>01900    z *= c-&gt;dimensions;
<a name="l01901"></a>01901    <span class="keywordflow">for</span> (i=0; i &lt; len; ++i) {
<a name="l01902"></a>01902       <span class="keywordtype">float</span> val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;
<a name="l01903"></a>01903       output[i*step] += val;
<a name="l01904"></a>01904       <span class="keywordflow">if</span> (c-&gt;sequence_p) last = val;
<a name="l01905"></a>01905    }
<a name="l01906"></a>01906 
<a name="l01907"></a>01907    <span class="keywordflow">return</span> TRUE;
<a name="l01908"></a>01908 }
<a name="l01909"></a>01909 
<a name="l01910"></a>01910 <span class="keyword">static</span> <span class="keywordtype">int</span> codebook_decode_deinterleave_repeat(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <a class="code" href="structCodebook.html">Codebook</a> *c, <span class="keywordtype">float</span> **outputs, <span class="keywordtype">int</span> ch, <span class="keywordtype">int</span> *c_inter_p, <span class="keywordtype">int</span> *p_inter_p, <span class="keywordtype">int</span> len, <span class="keywordtype">int</span> total_decode)
<a name="l01911"></a>01911 {
<a name="l01912"></a>01912    <span class="keywordtype">int</span> c_inter = *c_inter_p;
<a name="l01913"></a>01913    <span class="keywordtype">int</span> p_inter = *p_inter_p;
<a name="l01914"></a>01914    <span class="keywordtype">int</span> i,z, effective = c-&gt;dimensions;
<a name="l01915"></a>01915 
<a name="l01916"></a>01916    <span class="comment">// type 0 is only legal in a scalar context</span>
<a name="l01917"></a>01917    <span class="keywordflow">if</span> (c-&gt;lookup_type == 0)   <span class="keywordflow">return</span> error(f, VORBIS_invalid_stream);
<a name="l01918"></a>01918 
<a name="l01919"></a>01919    <span class="keywordflow">while</span> (total_decode &gt; 0) {
<a name="l01920"></a>01920       <span class="keywordtype">float</span> last = CODEBOOK_ELEMENT_BASE(c);
<a name="l01921"></a>01921       DECODE_VQ(z,f,c);
<a name="l01922"></a>01922 <span class="preprocessor">      #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK</span>
<a name="l01923"></a>01923 <span class="preprocessor"></span>      assert(!c-&gt;sparse || z &lt; c-&gt;sorted_entries);
<a name="l01924"></a>01924 <span class="preprocessor">      #endif</span>
<a name="l01925"></a>01925 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (z &lt; 0) {
<a name="l01926"></a>01926          <span class="keywordflow">if</span> (!f-&gt;bytes_in_seg)
<a name="l01927"></a>01927             <span class="keywordflow">if</span> (f-&gt;last_seg) <span class="keywordflow">return</span> FALSE;
<a name="l01928"></a>01928          <span class="keywordflow">return</span> error(f, VORBIS_invalid_stream);
<a name="l01929"></a>01929       }
<a name="l01930"></a>01930 
<a name="l01931"></a>01931       <span class="comment">// if this will take us off the end of the buffers, stop short!</span>
<a name="l01932"></a>01932       <span class="comment">// we check by computing the length of the virtual interleaved</span>
<a name="l01933"></a>01933       <span class="comment">// buffer (len*ch), our current offset within it (p_inter*ch)+(c_inter),</span>
<a name="l01934"></a>01934       <span class="comment">// and the length we&#39;ll be using (effective)</span>
<a name="l01935"></a>01935       <span class="keywordflow">if</span> (c_inter + p_inter*ch + effective &gt; len * ch) {
<a name="l01936"></a>01936          effective = len*ch - (p_inter*ch - c_inter);
<a name="l01937"></a>01937       }
<a name="l01938"></a>01938 
<a name="l01939"></a>01939 <span class="preprocessor">   #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK</span>
<a name="l01940"></a>01940 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (c-&gt;lookup_type == 1) {
<a name="l01941"></a>01941          <span class="keywordtype">int</span> div = 1;
<a name="l01942"></a>01942          <span class="keywordflow">for</span> (i=0; i &lt; effective; ++i) {
<a name="l01943"></a>01943             <span class="keywordtype">int</span> off = (z / div) % c-&gt;lookup_values;
<a name="l01944"></a>01944             <span class="keywordtype">float</span> val = CODEBOOK_ELEMENT_FAST(c,off) + last;
<a name="l01945"></a>01945             <span class="keywordflow">if</span> (outputs[c_inter])
<a name="l01946"></a>01946                outputs[c_inter][p_inter] += val;
<a name="l01947"></a>01947             <span class="keywordflow">if</span> (++c_inter == ch) { c_inter = 0; ++p_inter; }
<a name="l01948"></a>01948             <span class="keywordflow">if</span> (c-&gt;sequence_p) last = val;
<a name="l01949"></a>01949             div *= c-&gt;lookup_values;
<a name="l01950"></a>01950          }
<a name="l01951"></a>01951       } <span class="keywordflow">else</span>
<a name="l01952"></a>01952 <span class="preprocessor">   #endif</span>
<a name="l01953"></a>01953 <span class="preprocessor"></span>      {
<a name="l01954"></a>01954          z *= c-&gt;dimensions;
<a name="l01955"></a>01955          <span class="keywordflow">if</span> (c-&gt;sequence_p) {
<a name="l01956"></a>01956             <span class="keywordflow">for</span> (i=0; i &lt; effective; ++i) {
<a name="l01957"></a>01957                <span class="keywordtype">float</span> val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;
<a name="l01958"></a>01958                <span class="keywordflow">if</span> (outputs[c_inter])
<a name="l01959"></a>01959                   outputs[c_inter][p_inter] += val;
<a name="l01960"></a>01960                <span class="keywordflow">if</span> (++c_inter == ch) { c_inter = 0; ++p_inter; }
<a name="l01961"></a>01961                last = val;
<a name="l01962"></a>01962             }
<a name="l01963"></a>01963          } <span class="keywordflow">else</span> {
<a name="l01964"></a>01964             <span class="keywordflow">for</span> (i=0; i &lt; effective; ++i) {
<a name="l01965"></a>01965                <span class="keywordtype">float</span> val = CODEBOOK_ELEMENT_FAST(c,z+i) + last;
<a name="l01966"></a>01966                <span class="keywordflow">if</span> (outputs[c_inter])
<a name="l01967"></a>01967                   outputs[c_inter][p_inter] += val;
<a name="l01968"></a>01968                <span class="keywordflow">if</span> (++c_inter == ch) { c_inter = 0; ++p_inter; }
<a name="l01969"></a>01969             }
<a name="l01970"></a>01970          }
<a name="l01971"></a>01971       }
<a name="l01972"></a>01972 
<a name="l01973"></a>01973       total_decode -= effective;
<a name="l01974"></a>01974    }
<a name="l01975"></a>01975    *c_inter_p = c_inter;
<a name="l01976"></a>01976    *p_inter_p = p_inter;
<a name="l01977"></a>01977    <span class="keywordflow">return</span> TRUE;
<a name="l01978"></a>01978 }
<a name="l01979"></a>01979 
<a name="l01980"></a>01980 <span class="keyword">static</span> <span class="keywordtype">int</span> predict_point(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> x0, <span class="keywordtype">int</span> x1, <span class="keywordtype">int</span> y0, <span class="keywordtype">int</span> y1)
<a name="l01981"></a>01981 {
<a name="l01982"></a>01982    <span class="keywordtype">int</span> dy = y1 - y0;
<a name="l01983"></a>01983    <span class="keywordtype">int</span> adx = x1 - x0;
<a name="l01984"></a>01984    <span class="comment">// @OPTIMIZE: force int division to round in the right direction... is this necessary on x86?</span>
<a name="l01985"></a>01985    <span class="keywordtype">int</span> err = abs(dy) * (x - x0);
<a name="l01986"></a>01986    <span class="keywordtype">int</span> off = err / adx;
<a name="l01987"></a>01987    <span class="keywordflow">return</span> dy &lt; 0 ? y0 - off : y0 + off;
<a name="l01988"></a>01988 }
<a name="l01989"></a>01989 
<a name="l01990"></a>01990 <span class="comment">// the following table is block-copied from the specification</span>
<a name="l01991"></a>01991 <span class="keyword">static</span> <span class="keywordtype">float</span> inverse_db_table[256] =
<a name="l01992"></a>01992 {
<a name="l01993"></a>01993   1.0649863e-07f, 1.1341951e-07f, 1.2079015e-07f, 1.2863978e-07f,
<a name="l01994"></a>01994   1.3699951e-07f, 1.4590251e-07f, 1.5538408e-07f, 1.6548181e-07f,
<a name="l01995"></a>01995   1.7623575e-07f, 1.8768855e-07f, 1.9988561e-07f, 2.1287530e-07f,
<a name="l01996"></a>01996   2.2670913e-07f, 2.4144197e-07f, 2.5713223e-07f, 2.7384213e-07f,
<a name="l01997"></a>01997   2.9163793e-07f, 3.1059021e-07f, 3.3077411e-07f, 3.5226968e-07f,
<a name="l01998"></a>01998   3.7516214e-07f, 3.9954229e-07f, 4.2550680e-07f, 4.5315863e-07f,
<a name="l01999"></a>01999   4.8260743e-07f, 5.1396998e-07f, 5.4737065e-07f, 5.8294187e-07f,
<a name="l02000"></a>02000   6.2082472e-07f, 6.6116941e-07f, 7.0413592e-07f, 7.4989464e-07f,
<a name="l02001"></a>02001   7.9862701e-07f, 8.5052630e-07f, 9.0579828e-07f, 9.6466216e-07f,
<a name="l02002"></a>02002   1.0273513e-06f, 1.0941144e-06f, 1.1652161e-06f, 1.2409384e-06f,
<a name="l02003"></a>02003   1.3215816e-06f, 1.4074654e-06f, 1.4989305e-06f, 1.5963394e-06f,
<a name="l02004"></a>02004   1.7000785e-06f, 1.8105592e-06f, 1.9282195e-06f, 2.0535261e-06f,
<a name="l02005"></a>02005   2.1869758e-06f, 2.3290978e-06f, 2.4804557e-06f, 2.6416497e-06f,
<a name="l02006"></a>02006   2.8133190e-06f, 2.9961443e-06f, 3.1908506e-06f, 3.3982101e-06f,
<a name="l02007"></a>02007   3.6190449e-06f, 3.8542308e-06f, 4.1047004e-06f, 4.3714470e-06f,
<a name="l02008"></a>02008   4.6555282e-06f, 4.9580707e-06f, 5.2802740e-06f, 5.6234160e-06f,
<a name="l02009"></a>02009   5.9888572e-06f, 6.3780469e-06f, 6.7925283e-06f, 7.2339451e-06f,
<a name="l02010"></a>02010   7.7040476e-06f, 8.2047000e-06f, 8.7378876e-06f, 9.3057248e-06f,
<a name="l02011"></a>02011   9.9104632e-06f, 1.0554501e-05f, 1.1240392e-05f, 1.1970856e-05f,
<a name="l02012"></a>02012   1.2748789e-05f, 1.3577278e-05f, 1.4459606e-05f, 1.5399272e-05f,
<a name="l02013"></a>02013   1.6400004e-05f, 1.7465768e-05f, 1.8600792e-05f, 1.9809576e-05f,
<a name="l02014"></a>02014   2.1096914e-05f, 2.2467911e-05f, 2.3928002e-05f, 2.5482978e-05f,
<a name="l02015"></a>02015   2.7139006e-05f, 2.8902651e-05f, 3.0780908e-05f, 3.2781225e-05f,
<a name="l02016"></a>02016   3.4911534e-05f, 3.7180282e-05f, 3.9596466e-05f, 4.2169667e-05f,
<a name="l02017"></a>02017   4.4910090e-05f, 4.7828601e-05f, 5.0936773e-05f, 5.4246931e-05f,
<a name="l02018"></a>02018   5.7772202e-05f, 6.1526565e-05f, 6.5524908e-05f, 6.9783085e-05f,
<a name="l02019"></a>02019   7.4317983e-05f, 7.9147585e-05f, 8.4291040e-05f, 8.9768747e-05f,
<a name="l02020"></a>02020   9.5602426e-05f, 0.00010181521f, 0.00010843174f, 0.00011547824f,
<a name="l02021"></a>02021   0.00012298267f, 0.00013097477f, 0.00013948625f, 0.00014855085f,
<a name="l02022"></a>02022   0.00015820453f, 0.00016848555f, 0.00017943469f, 0.00019109536f,
<a name="l02023"></a>02023   0.00020351382f, 0.00021673929f, 0.00023082423f, 0.00024582449f,
<a name="l02024"></a>02024   0.00026179955f, 0.00027881276f, 0.00029693158f, 0.00031622787f,
<a name="l02025"></a>02025   0.00033677814f, 0.00035866388f, 0.00038197188f, 0.00040679456f,
<a name="l02026"></a>02026   0.00043323036f, 0.00046138411f, 0.00049136745f, 0.00052329927f,
<a name="l02027"></a>02027   0.00055730621f, 0.00059352311f, 0.00063209358f, 0.00067317058f,
<a name="l02028"></a>02028   0.00071691700f, 0.00076350630f, 0.00081312324f, 0.00086596457f,
<a name="l02029"></a>02029   0.00092223983f, 0.00098217216f, 0.0010459992f,  0.0011139742f,
<a name="l02030"></a>02030   0.0011863665f,  0.0012634633f,  0.0013455702f,  0.0014330129f,
<a name="l02031"></a>02031   0.0015261382f,  0.0016253153f,  0.0017309374f,  0.0018434235f,
<a name="l02032"></a>02032   0.0019632195f,  0.0020908006f,  0.0022266726f,  0.0023713743f,
<a name="l02033"></a>02033   0.0025254795f,  0.0026895994f,  0.0028643847f,  0.0030505286f,
<a name="l02034"></a>02034   0.0032487691f,  0.0034598925f,  0.0036847358f,  0.0039241906f,
<a name="l02035"></a>02035   0.0041792066f,  0.0044507950f,  0.0047400328f,  0.0050480668f,
<a name="l02036"></a>02036   0.0053761186f,  0.0057254891f,  0.0060975636f,  0.0064938176f,
<a name="l02037"></a>02037   0.0069158225f,  0.0073652516f,  0.0078438871f,  0.0083536271f,
<a name="l02038"></a>02038   0.0088964928f,  0.009474637f,   0.010090352f,   0.010746080f,
<a name="l02039"></a>02039   0.011444421f,   0.012188144f,   0.012980198f,   0.013823725f,
<a name="l02040"></a>02040   0.014722068f,   0.015678791f,   0.016697687f,   0.017782797f,
<a name="l02041"></a>02041   0.018938423f,   0.020169149f,   0.021479854f,   0.022875735f,
<a name="l02042"></a>02042   0.024362330f,   0.025945531f,   0.027631618f,   0.029427276f,
<a name="l02043"></a>02043   0.031339626f,   0.033376252f,   0.035545228f,   0.037855157f,
<a name="l02044"></a>02044   0.040315199f,   0.042935108f,   0.045725273f,   0.048696758f,
<a name="l02045"></a>02045   0.051861348f,   0.055231591f,   0.058820850f,   0.062643361f,
<a name="l02046"></a>02046   0.066714279f,   0.071049749f,   0.075666962f,   0.080584227f,
<a name="l02047"></a>02047   0.085821044f,   0.091398179f,   0.097337747f,   0.10366330f,
<a name="l02048"></a>02048   0.11039993f,    0.11757434f,    0.12521498f,    0.13335215f,
<a name="l02049"></a>02049   0.14201813f,    0.15124727f,    0.16107617f,    0.17154380f,
<a name="l02050"></a>02050   0.18269168f,    0.19456402f,    0.20720788f,    0.22067342f,
<a name="l02051"></a>02051   0.23501402f,    0.25028656f,    0.26655159f,    0.28387361f,
<a name="l02052"></a>02052   0.30232132f,    0.32196786f,    0.34289114f,    0.36517414f,
<a name="l02053"></a>02053   0.38890521f,    0.41417847f,    0.44109412f,    0.46975890f,
<a name="l02054"></a>02054   0.50028648f,    0.53279791f,    0.56742212f,    0.60429640f,
<a name="l02055"></a>02055   0.64356699f,    0.68538959f,    0.72993007f,    0.77736504f,
<a name="l02056"></a>02056   0.82788260f,    0.88168307f,    0.9389798f,     1.0f
<a name="l02057"></a>02057 };
<a name="l02058"></a>02058 
<a name="l02059"></a>02059 
<a name="l02060"></a>02060 <span class="comment">// @OPTIMIZE: if you want to replace this bresenham line-drawing routine,</span>
<a name="l02061"></a>02061 <span class="comment">// note that you must produce bit-identical output to decode correctly;</span>
<a name="l02062"></a>02062 <span class="comment">// this specific sequence of operations is specified in the spec (it&#39;s</span>
<a name="l02063"></a>02063 <span class="comment">// drawing integer-quantized frequency-space lines that the encoder</span>
<a name="l02064"></a>02064 <span class="comment">// expects to be exactly the same)</span>
<a name="l02065"></a>02065 <span class="comment">//     ... also, isn&#39;t the whole point of Bresenham&#39;s algorithm to NOT</span>
<a name="l02066"></a>02066 <span class="comment">// have to divide in the setup? sigh.</span>
<a name="l02067"></a>02067 <span class="preprocessor">#ifndef STB_VORBIS_NO_DEFER_FLOOR</span>
<a name="l02068"></a>02068 <span class="preprocessor"></span><span class="preprocessor">#define LINE_OP(a,b)   a *= b</span>
<a name="l02069"></a>02069 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l02070"></a>02070 <span class="preprocessor"></span><span class="preprocessor">#define LINE_OP(a,b)   a = b</span>
<a name="l02071"></a>02071 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02072"></a>02072 <span class="preprocessor"></span>
<a name="l02073"></a>02073 <span class="preprocessor">#ifdef STB_VORBIS_DIVIDE_TABLE</span>
<a name="l02074"></a>02074 <span class="preprocessor"></span><span class="preprocessor">#define DIVTAB_NUMER   32</span>
<a name="l02075"></a>02075 <span class="preprocessor"></span><span class="preprocessor">#define DIVTAB_DENOM   64</span>
<a name="l02076"></a>02076 <span class="preprocessor"></span>int8 integer_divide_table[DIVTAB_NUMER][DIVTAB_DENOM]; <span class="comment">// 2KB</span>
<a name="l02077"></a>02077 <span class="preprocessor">#endif</span>
<a name="l02078"></a>02078 <span class="preprocessor"></span>
<a name="l02079"></a>02079 <span class="keyword">static</span> __forceinline <span class="keywordtype">void</span> draw_line(<span class="keywordtype">float</span> *output, <span class="keywordtype">int</span> x0, <span class="keywordtype">int</span> y0, <span class="keywordtype">int</span> x1, <span class="keywordtype">int</span> y1, <span class="keywordtype">int</span> n)
<a name="l02080"></a>02080 {
<a name="l02081"></a>02081    <span class="keywordtype">int</span> dy = y1 - y0;
<a name="l02082"></a>02082    <span class="keywordtype">int</span> adx = x1 - x0;
<a name="l02083"></a>02083    <span class="keywordtype">int</span> ady = abs(dy);
<a name="l02084"></a>02084    <span class="keywordtype">int</span> base;
<a name="l02085"></a>02085    <span class="keywordtype">int</span> x=x0,y=y0;
<a name="l02086"></a>02086    <span class="keywordtype">int</span> err = 0;
<a name="l02087"></a>02087    <span class="keywordtype">int</span> sy;
<a name="l02088"></a>02088 
<a name="l02089"></a>02089 <span class="preprocessor">#ifdef STB_VORBIS_DIVIDE_TABLE</span>
<a name="l02090"></a>02090 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (adx &lt; DIVTAB_DENOM &amp;&amp; ady &lt; DIVTAB_NUMER) {
<a name="l02091"></a>02091       <span class="keywordflow">if</span> (dy &lt; 0) {
<a name="l02092"></a>02092          base = -integer_divide_table[ady][adx];
<a name="l02093"></a>02093          sy = base-1;
<a name="l02094"></a>02094       } <span class="keywordflow">else</span> {
<a name="l02095"></a>02095          base =  integer_divide_table[ady][adx];
<a name="l02096"></a>02096          sy = base+1;
<a name="l02097"></a>02097       }
<a name="l02098"></a>02098    } <span class="keywordflow">else</span> {
<a name="l02099"></a>02099       base = dy / adx;
<a name="l02100"></a>02100       <span class="keywordflow">if</span> (dy &lt; 0)
<a name="l02101"></a>02101          sy = base - 1;
<a name="l02102"></a>02102       <span class="keywordflow">else</span>
<a name="l02103"></a>02103          sy = base+1;
<a name="l02104"></a>02104    }
<a name="l02105"></a>02105 <span class="preprocessor">#else</span>
<a name="l02106"></a>02106 <span class="preprocessor"></span>   base = dy / adx;
<a name="l02107"></a>02107    <span class="keywordflow">if</span> (dy &lt; 0)
<a name="l02108"></a>02108       sy = base - 1;
<a name="l02109"></a>02109    <span class="keywordflow">else</span>
<a name="l02110"></a>02110       sy = base+1;
<a name="l02111"></a>02111 <span class="preprocessor">#endif</span>
<a name="l02112"></a>02112 <span class="preprocessor"></span>   ady -= abs(base) * adx;
<a name="l02113"></a>02113    <span class="keywordflow">if</span> (x1 &gt; n) x1 = n;
<a name="l02114"></a>02114    <span class="keywordflow">if</span> (x &lt; x1) {
<a name="l02115"></a>02115       LINE_OP(output[x], inverse_db_table[y&amp;255]);
<a name="l02116"></a>02116       <span class="keywordflow">for</span> (++x; x &lt; x1; ++x) {
<a name="l02117"></a>02117          err += ady;
<a name="l02118"></a>02118          <span class="keywordflow">if</span> (err &gt;= adx) {
<a name="l02119"></a>02119             err -= adx;
<a name="l02120"></a>02120             y += sy;
<a name="l02121"></a>02121          } <span class="keywordflow">else</span>
<a name="l02122"></a>02122             y += base;
<a name="l02123"></a>02123          LINE_OP(output[x], inverse_db_table[y&amp;255]);
<a name="l02124"></a>02124       }
<a name="l02125"></a>02125    }
<a name="l02126"></a>02126 }
<a name="l02127"></a>02127 
<a name="l02128"></a>02128 <span class="keyword">static</span> <span class="keywordtype">int</span> residue_decode(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <a class="code" href="structCodebook.html">Codebook</a> *book, <span class="keywordtype">float</span> *target, <span class="keywordtype">int</span> offset, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> rtype)
<a name="l02129"></a>02129 {
<a name="l02130"></a>02130    <span class="keywordtype">int</span> k;
<a name="l02131"></a>02131    <span class="keywordflow">if</span> (rtype == 0) {
<a name="l02132"></a>02132       <span class="keywordtype">int</span> step = n / book-&gt;dimensions;
<a name="l02133"></a>02133       <span class="keywordflow">for</span> (k=0; k &lt; step; ++k)
<a name="l02134"></a>02134          <span class="keywordflow">if</span> (!codebook_decode_step(f, book, target+offset+k, n-offset-k, step))
<a name="l02135"></a>02135             <span class="keywordflow">return</span> FALSE;
<a name="l02136"></a>02136    } <span class="keywordflow">else</span> {
<a name="l02137"></a>02137       <span class="keywordflow">for</span> (k=0; k &lt; n; ) {
<a name="l02138"></a>02138          <span class="keywordflow">if</span> (!codebook_decode(f, book, target+offset, n-k))
<a name="l02139"></a>02139             <span class="keywordflow">return</span> FALSE;
<a name="l02140"></a>02140          k += book-&gt;dimensions;
<a name="l02141"></a>02141          offset += book-&gt;dimensions;
<a name="l02142"></a>02142       }
<a name="l02143"></a>02143    }
<a name="l02144"></a>02144    <span class="keywordflow">return</span> TRUE;
<a name="l02145"></a>02145 }
<a name="l02146"></a>02146 
<a name="l02147"></a>02147 <span class="comment">// n is 1/2 of the blocksize --</span>
<a name="l02148"></a>02148 <span class="comment">// specification: &quot;Correct per-vector decode length is [n]/2&quot;</span>
<a name="l02149"></a>02149 <span class="keyword">static</span> <span class="keywordtype">void</span> decode_residue(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">float</span> *residue_buffers[], <span class="keywordtype">int</span> ch, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> rn, uint8 *do_not_decode)
<a name="l02150"></a>02150 {
<a name="l02151"></a>02151    <span class="keywordtype">int</span> i,j,pass;
<a name="l02152"></a>02152    <a class="code" href="structResidue.html">Residue</a> *r = f-&gt;residue_config + rn;
<a name="l02153"></a>02153    <span class="keywordtype">int</span> rtype = f-&gt;residue_types[rn];
<a name="l02154"></a>02154    <span class="keywordtype">int</span> c = r-&gt;classbook;
<a name="l02155"></a>02155    <span class="keywordtype">int</span> classwords = f-&gt;codebooks[c].dimensions;
<a name="l02156"></a>02156    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> actual_size = rtype == 2 ? n*2 : n;
<a name="l02157"></a>02157    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> limit_r_begin = (r-&gt;begin &lt; actual_size ? r-&gt;begin : actual_size);
<a name="l02158"></a>02158    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> limit_r_end   = (r-&gt;end   &lt; actual_size ? r-&gt;end   : actual_size);
<a name="l02159"></a>02159    <span class="keywordtype">int</span> n_read = limit_r_end - limit_r_begin;
<a name="l02160"></a>02160    <span class="keywordtype">int</span> part_read = n_read / r-&gt;part_size;
<a name="l02161"></a>02161    <span class="keywordtype">int</span> temp_alloc_point = temp_alloc_save(f);
<a name="l02162"></a>02162 <span class="preprocessor">   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l02163"></a>02163 <span class="preprocessor"></span>   uint8 ***part_classdata = (uint8 ***) temp_block_array(f,f-&gt;channels, part_read * <span class="keyword">sizeof</span>(**part_classdata));
<a name="l02164"></a>02164 <span class="preprocessor">   #else</span>
<a name="l02165"></a>02165 <span class="preprocessor"></span>   <span class="keywordtype">int</span> **classifications = (<span class="keywordtype">int</span> **) temp_block_array(f,f-&gt;channels, part_read * <span class="keyword">sizeof</span>(**classifications));
<a name="l02166"></a>02166 <span class="preprocessor">   #endif</span>
<a name="l02167"></a>02167 <span class="preprocessor"></span>
<a name="l02168"></a>02168    CHECK(f);
<a name="l02169"></a>02169 
<a name="l02170"></a>02170    <span class="keywordflow">for</span> (i=0; i &lt; ch; ++i)
<a name="l02171"></a>02171       <span class="keywordflow">if</span> (!do_not_decode[i])
<a name="l02172"></a>02172          memset(residue_buffers[i], 0, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * n);
<a name="l02173"></a>02173 
<a name="l02174"></a>02174    <span class="keywordflow">if</span> (rtype == 2 &amp;&amp; ch != 1) {
<a name="l02175"></a>02175       <span class="keywordflow">for</span> (j=0; j &lt; ch; ++j)
<a name="l02176"></a>02176          <span class="keywordflow">if</span> (!do_not_decode[j])
<a name="l02177"></a>02177             <span class="keywordflow">break</span>;
<a name="l02178"></a>02178       <span class="keywordflow">if</span> (j == ch)
<a name="l02179"></a>02179          <span class="keywordflow">goto</span> done;
<a name="l02180"></a>02180 
<a name="l02181"></a>02181       <span class="keywordflow">for</span> (pass=0; pass &lt; 8; ++pass) {
<a name="l02182"></a>02182          <span class="keywordtype">int</span> pcount = 0, class_set = 0;
<a name="l02183"></a>02183          <span class="keywordflow">if</span> (ch == 2) {
<a name="l02184"></a>02184             <span class="keywordflow">while</span> (pcount &lt; part_read) {
<a name="l02185"></a>02185                <span class="keywordtype">int</span> z = r-&gt;begin + pcount*r-&gt;part_size;
<a name="l02186"></a>02186                <span class="keywordtype">int</span> c_inter = (z &amp; 1), p_inter = z&gt;&gt;1;
<a name="l02187"></a>02187                <span class="keywordflow">if</span> (pass == 0) {
<a name="l02188"></a>02188                   <a class="code" href="structCodebook.html">Codebook</a> *c = f-&gt;codebooks+r-&gt;classbook;
<a name="l02189"></a>02189                   <span class="keywordtype">int</span> q;
<a name="l02190"></a>02190                   DECODE(q,f,c);
<a name="l02191"></a>02191                   <span class="keywordflow">if</span> (q == EOP) <span class="keywordflow">goto</span> done;
<a name="l02192"></a>02192 <span class="preprocessor">                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l02193"></a>02193 <span class="preprocessor"></span>                  part_classdata[0][class_set] = r-&gt;classdata[q];
<a name="l02194"></a>02194 <span class="preprocessor">                  #else</span>
<a name="l02195"></a>02195 <span class="preprocessor"></span>                  <span class="keywordflow">for</span> (i=classwords-1; i &gt;= 0; --i) {
<a name="l02196"></a>02196                      classifications[0][i+pcount] = q % r-&gt;classifications;
<a name="l02197"></a>02197                      q /= r-&gt;classifications;
<a name="l02198"></a>02198                   }
<a name="l02199"></a>02199 <span class="preprocessor">                  #endif</span>
<a name="l02200"></a>02200 <span class="preprocessor"></span>               }
<a name="l02201"></a>02201                <span class="keywordflow">for</span> (i=0; i &lt; classwords &amp;&amp; pcount &lt; part_read; ++i, ++pcount) {
<a name="l02202"></a>02202                   <span class="keywordtype">int</span> z = r-&gt;begin + pcount*r-&gt;part_size;
<a name="l02203"></a>02203 <span class="preprocessor">                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l02204"></a>02204 <span class="preprocessor"></span>                  <span class="keywordtype">int</span> c = part_classdata[0][class_set][i];
<a name="l02205"></a>02205 <span class="preprocessor">                  #else</span>
<a name="l02206"></a>02206 <span class="preprocessor"></span>                  <span class="keywordtype">int</span> c = classifications[0][pcount];
<a name="l02207"></a>02207 <span class="preprocessor">                  #endif</span>
<a name="l02208"></a>02208 <span class="preprocessor"></span>                  <span class="keywordtype">int</span> b = r-&gt;residue_books[c][pass];
<a name="l02209"></a>02209                   <span class="keywordflow">if</span> (b &gt;= 0) {
<a name="l02210"></a>02210                      <a class="code" href="structCodebook.html">Codebook</a> *book = f-&gt;codebooks + b;
<a name="l02211"></a>02211 <span class="preprocessor">                     #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK</span>
<a name="l02212"></a>02212 <span class="preprocessor"></span>                     <span class="keywordflow">if</span> (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &amp;c_inter, &amp;p_inter, n, r-&gt;part_size))
<a name="l02213"></a>02213                         <span class="keywordflow">goto</span> done;
<a name="l02214"></a>02214 <span class="preprocessor">                     #else</span>
<a name="l02215"></a>02215 <span class="preprocessor"></span>                     <span class="comment">// saves 1%</span>
<a name="l02216"></a>02216                      <span class="keywordflow">if</span> (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &amp;c_inter, &amp;p_inter, n, r-&gt;part_size))
<a name="l02217"></a>02217                         <span class="keywordflow">goto</span> done;
<a name="l02218"></a>02218 <span class="preprocessor">                     #endif</span>
<a name="l02219"></a>02219 <span class="preprocessor"></span>                  } <span class="keywordflow">else</span> {
<a name="l02220"></a>02220                      z += r-&gt;part_size;
<a name="l02221"></a>02221                      c_inter = z &amp; 1;
<a name="l02222"></a>02222                      p_inter = z &gt;&gt; 1;
<a name="l02223"></a>02223                   }
<a name="l02224"></a>02224                }
<a name="l02225"></a>02225 <span class="preprocessor">               #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l02226"></a>02226 <span class="preprocessor"></span>               ++class_set;
<a name="l02227"></a>02227 <span class="preprocessor">               #endif</span>
<a name="l02228"></a>02228 <span class="preprocessor"></span>            }
<a name="l02229"></a>02229          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &gt; 2) {
<a name="l02230"></a>02230             <span class="keywordflow">while</span> (pcount &lt; part_read) {
<a name="l02231"></a>02231                <span class="keywordtype">int</span> z = r-&gt;begin + pcount*r-&gt;part_size;
<a name="l02232"></a>02232                <span class="keywordtype">int</span> c_inter = z % ch, p_inter = z/ch;
<a name="l02233"></a>02233                <span class="keywordflow">if</span> (pass == 0) {
<a name="l02234"></a>02234                   <a class="code" href="structCodebook.html">Codebook</a> *c = f-&gt;codebooks+r-&gt;classbook;
<a name="l02235"></a>02235                   <span class="keywordtype">int</span> q;
<a name="l02236"></a>02236                   DECODE(q,f,c);
<a name="l02237"></a>02237                   <span class="keywordflow">if</span> (q == EOP) <span class="keywordflow">goto</span> done;
<a name="l02238"></a>02238 <span class="preprocessor">                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l02239"></a>02239 <span class="preprocessor"></span>                  part_classdata[0][class_set] = r-&gt;classdata[q];
<a name="l02240"></a>02240 <span class="preprocessor">                  #else</span>
<a name="l02241"></a>02241 <span class="preprocessor"></span>                  <span class="keywordflow">for</span> (i=classwords-1; i &gt;= 0; --i) {
<a name="l02242"></a>02242                      classifications[0][i+pcount] = q % r-&gt;classifications;
<a name="l02243"></a>02243                      q /= r-&gt;classifications;
<a name="l02244"></a>02244                   }
<a name="l02245"></a>02245 <span class="preprocessor">                  #endif</span>
<a name="l02246"></a>02246 <span class="preprocessor"></span>               }
<a name="l02247"></a>02247                <span class="keywordflow">for</span> (i=0; i &lt; classwords &amp;&amp; pcount &lt; part_read; ++i, ++pcount) {
<a name="l02248"></a>02248                   <span class="keywordtype">int</span> z = r-&gt;begin + pcount*r-&gt;part_size;
<a name="l02249"></a>02249 <span class="preprocessor">                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l02250"></a>02250 <span class="preprocessor"></span>                  <span class="keywordtype">int</span> c = part_classdata[0][class_set][i];
<a name="l02251"></a>02251 <span class="preprocessor">                  #else</span>
<a name="l02252"></a>02252 <span class="preprocessor"></span>                  <span class="keywordtype">int</span> c = classifications[0][pcount];
<a name="l02253"></a>02253 <span class="preprocessor">                  #endif</span>
<a name="l02254"></a>02254 <span class="preprocessor"></span>                  <span class="keywordtype">int</span> b = r-&gt;residue_books[c][pass];
<a name="l02255"></a>02255                   <span class="keywordflow">if</span> (b &gt;= 0) {
<a name="l02256"></a>02256                      <a class="code" href="structCodebook.html">Codebook</a> *book = f-&gt;codebooks + b;
<a name="l02257"></a>02257                      <span class="keywordflow">if</span> (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &amp;c_inter, &amp;p_inter, n, r-&gt;part_size))
<a name="l02258"></a>02258                         <span class="keywordflow">goto</span> done;
<a name="l02259"></a>02259                   } <span class="keywordflow">else</span> {
<a name="l02260"></a>02260                      z += r-&gt;part_size;
<a name="l02261"></a>02261                      c_inter = z % ch;
<a name="l02262"></a>02262                      p_inter = z / ch;
<a name="l02263"></a>02263                   }
<a name="l02264"></a>02264                }
<a name="l02265"></a>02265 <span class="preprocessor">               #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l02266"></a>02266 <span class="preprocessor"></span>               ++class_set;
<a name="l02267"></a>02267 <span class="preprocessor">               #endif</span>
<a name="l02268"></a>02268 <span class="preprocessor"></span>            }
<a name="l02269"></a>02269          }
<a name="l02270"></a>02270       }
<a name="l02271"></a>02271       <span class="keywordflow">goto</span> done;
<a name="l02272"></a>02272    }
<a name="l02273"></a>02273    CHECK(f);
<a name="l02274"></a>02274 
<a name="l02275"></a>02275    <span class="keywordflow">for</span> (pass=0; pass &lt; 8; ++pass) {
<a name="l02276"></a>02276       <span class="keywordtype">int</span> pcount = 0, class_set=0;
<a name="l02277"></a>02277       <span class="keywordflow">while</span> (pcount &lt; part_read) {
<a name="l02278"></a>02278          <span class="keywordflow">if</span> (pass == 0) {
<a name="l02279"></a>02279             <span class="keywordflow">for</span> (j=0; j &lt; ch; ++j) {
<a name="l02280"></a>02280                <span class="keywordflow">if</span> (!do_not_decode[j]) {
<a name="l02281"></a>02281                   <a class="code" href="structCodebook.html">Codebook</a> *c = f-&gt;codebooks+r-&gt;classbook;
<a name="l02282"></a>02282                   <span class="keywordtype">int</span> temp;
<a name="l02283"></a>02283                   DECODE(temp,f,c);
<a name="l02284"></a>02284                   <span class="keywordflow">if</span> (temp == EOP) <span class="keywordflow">goto</span> done;
<a name="l02285"></a>02285 <span class="preprocessor">                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l02286"></a>02286 <span class="preprocessor"></span>                  part_classdata[j][class_set] = r-&gt;classdata[temp];
<a name="l02287"></a>02287 <span class="preprocessor">                  #else</span>
<a name="l02288"></a>02288 <span class="preprocessor"></span>                  <span class="keywordflow">for</span> (i=classwords-1; i &gt;= 0; --i) {
<a name="l02289"></a>02289                      classifications[j][i+pcount] = temp % r-&gt;classifications;
<a name="l02290"></a>02290                      temp /= r-&gt;classifications;
<a name="l02291"></a>02291                   }
<a name="l02292"></a>02292 <span class="preprocessor">                  #endif</span>
<a name="l02293"></a>02293 <span class="preprocessor"></span>               }
<a name="l02294"></a>02294             }
<a name="l02295"></a>02295          }
<a name="l02296"></a>02296          <span class="keywordflow">for</span> (i=0; i &lt; classwords &amp;&amp; pcount &lt; part_read; ++i, ++pcount) {
<a name="l02297"></a>02297             <span class="keywordflow">for</span> (j=0; j &lt; ch; ++j) {
<a name="l02298"></a>02298                <span class="keywordflow">if</span> (!do_not_decode[j]) {
<a name="l02299"></a>02299 <span class="preprocessor">                  #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l02300"></a>02300 <span class="preprocessor"></span>                  <span class="keywordtype">int</span> c = part_classdata[j][class_set][i];
<a name="l02301"></a>02301 <span class="preprocessor">                  #else</span>
<a name="l02302"></a>02302 <span class="preprocessor"></span>                  <span class="keywordtype">int</span> c = classifications[j][pcount];
<a name="l02303"></a>02303 <span class="preprocessor">                  #endif</span>
<a name="l02304"></a>02304 <span class="preprocessor"></span>                  <span class="keywordtype">int</span> b = r-&gt;residue_books[c][pass];
<a name="l02305"></a>02305                   <span class="keywordflow">if</span> (b &gt;= 0) {
<a name="l02306"></a>02306                      <span class="keywordtype">float</span> *target = residue_buffers[j];
<a name="l02307"></a>02307                      <span class="keywordtype">int</span> offset = r-&gt;begin + pcount * r-&gt;part_size;
<a name="l02308"></a>02308                      <span class="keywordtype">int</span> n = r-&gt;part_size;
<a name="l02309"></a>02309                      <a class="code" href="structCodebook.html">Codebook</a> *book = f-&gt;codebooks + b;
<a name="l02310"></a>02310                      <span class="keywordflow">if</span> (!residue_decode(f, book, target, offset, n, rtype))
<a name="l02311"></a>02311                         <span class="keywordflow">goto</span> done;
<a name="l02312"></a>02312                   }
<a name="l02313"></a>02313                }
<a name="l02314"></a>02314             }
<a name="l02315"></a>02315          }
<a name="l02316"></a>02316 <span class="preprocessor">         #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l02317"></a>02317 <span class="preprocessor"></span>         ++class_set;
<a name="l02318"></a>02318 <span class="preprocessor">         #endif</span>
<a name="l02319"></a>02319 <span class="preprocessor"></span>      }
<a name="l02320"></a>02320    }
<a name="l02321"></a>02321   done:
<a name="l02322"></a>02322    CHECK(f);
<a name="l02323"></a>02323 <span class="preprocessor">   #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l02324"></a>02324 <span class="preprocessor"></span>   <span class="comment">// temp_free(f,part_classdata);</span>
<a name="l02325"></a>02325 <span class="preprocessor">   #else</span>
<a name="l02326"></a>02326 <span class="preprocessor"></span>   <span class="comment">// temp_free(f,classifications);</span>
<a name="l02327"></a>02327 <span class="preprocessor">   #endif</span>
<a name="l02328"></a>02328 <span class="preprocessor"></span>   temp_alloc_restore(f,temp_alloc_point);
<a name="l02329"></a>02329 }
<a name="l02330"></a>02330 
<a name="l02331"></a>02331 
<a name="l02332"></a>02332 <span class="preprocessor">#if 0</span>
<a name="l02333"></a>02333 <span class="preprocessor"></span><span class="comment">// slow way for debugging</span>
<a name="l02334"></a>02334 <span class="keywordtype">void</span> inverse_mdct_slow(<span class="keywordtype">float</span> *buffer, <span class="keywordtype">int</span> n)
<a name="l02335"></a>02335 {
<a name="l02336"></a>02336    <span class="keywordtype">int</span> i,j;
<a name="l02337"></a>02337    <span class="keywordtype">int</span> n2 = n &gt;&gt; 1;
<a name="l02338"></a>02338    <span class="keywordtype">float</span> *x = (<span class="keywordtype">float</span> *) malloc(<span class="keyword">sizeof</span>(*x) * n2);
<a name="l02339"></a>02339    memcpy(x, buffer, <span class="keyword">sizeof</span>(*x) * n2);
<a name="l02340"></a>02340    <span class="keywordflow">for</span> (i=0; i &lt; n; ++i) {
<a name="l02341"></a>02341       <span class="keywordtype">float</span> acc = 0;
<a name="l02342"></a>02342       <span class="keywordflow">for</span> (j=0; j &lt; n2; ++j)
<a name="l02343"></a>02343          <span class="comment">// formula from paper:</span>
<a name="l02344"></a>02344          <span class="comment">//acc += n/4.0f * x[j] * (float) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));</span>
<a name="l02345"></a>02345          <span class="comment">// formula from wikipedia</span>
<a name="l02346"></a>02346          <span class="comment">//acc += 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));</span>
<a name="l02347"></a>02347          <span class="comment">// these are equivalent, except the formula from the paper inverts the multiplier!</span>
<a name="l02348"></a>02348          <span class="comment">// however, what actually works is NO MULTIPLIER!?!</span>
<a name="l02349"></a>02349          <span class="comment">//acc += 64 * 2.0f / n2 * x[j] * (float) cos(M_PI/n2 * (i + 0.5 + n2/2)*(j + 0.5));</span>
<a name="l02350"></a>02350          acc += x[j] * (<span class="keywordtype">float</span>) cos(M_PI / 2 / n * (2 * i + 1 + n/2.0)*(2*j+1));
<a name="l02351"></a>02351       buffer[i] = acc;
<a name="l02352"></a>02352    }
<a name="l02353"></a>02353    free(x);
<a name="l02354"></a>02354 }
<a name="l02355"></a>02355 <span class="preprocessor">#elif 0</span>
<a name="l02356"></a>02356 <span class="preprocessor"></span><span class="comment">// same as above, but just barely able to run in real time on modern machines</span>
<a name="l02357"></a>02357 <span class="keywordtype">void</span> inverse_mdct_slow(<span class="keywordtype">float</span> *buffer, <span class="keywordtype">int</span> n, <a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> blocktype)
<a name="l02358"></a>02358 {
<a name="l02359"></a>02359    <span class="keywordtype">float</span> mcos[16384];
<a name="l02360"></a>02360    <span class="keywordtype">int</span> i,j;
<a name="l02361"></a>02361    <span class="keywordtype">int</span> n2 = n &gt;&gt; 1, nmask = (n &lt;&lt; 2) -1;
<a name="l02362"></a>02362    <span class="keywordtype">float</span> *x = (<span class="keywordtype">float</span> *) malloc(<span class="keyword">sizeof</span>(*x) * n2);
<a name="l02363"></a>02363    memcpy(x, buffer, <span class="keyword">sizeof</span>(*x) * n2);
<a name="l02364"></a>02364    <span class="keywordflow">for</span> (i=0; i &lt; 4*n; ++i)
<a name="l02365"></a>02365       mcos[i] = (<span class="keywordtype">float</span>) cos(M_PI / 2 * i / n);
<a name="l02366"></a>02366 
<a name="l02367"></a>02367    <span class="keywordflow">for</span> (i=0; i &lt; n; ++i) {
<a name="l02368"></a>02368       <span class="keywordtype">float</span> acc = 0;
<a name="l02369"></a>02369       <span class="keywordflow">for</span> (j=0; j &lt; n2; ++j)
<a name="l02370"></a>02370          acc += x[j] * mcos[(2 * i + 1 + n2)*(2*j+1) &amp; nmask];
<a name="l02371"></a>02371       buffer[i] = acc;
<a name="l02372"></a>02372    }
<a name="l02373"></a>02373    free(x);
<a name="l02374"></a>02374 }
<a name="l02375"></a>02375 <span class="preprocessor">#elif 0</span>
<a name="l02376"></a>02376 <span class="preprocessor"></span><span class="comment">// transform to use a slow dct-iv; this is STILL basically trivial,</span>
<a name="l02377"></a>02377 <span class="comment">// but only requires half as many ops</span>
<a name="l02378"></a>02378 <span class="keywordtype">void</span> dct_iv_slow(<span class="keywordtype">float</span> *buffer, <span class="keywordtype">int</span> n)
<a name="l02379"></a>02379 {
<a name="l02380"></a>02380    <span class="keywordtype">float</span> mcos[16384];
<a name="l02381"></a>02381    <span class="keywordtype">float</span> x[2048];
<a name="l02382"></a>02382    <span class="keywordtype">int</span> i,j;
<a name="l02383"></a>02383    <span class="keywordtype">int</span> n2 = n &gt;&gt; 1, nmask = (n &lt;&lt; 3) - 1;
<a name="l02384"></a>02384    memcpy(x, buffer, <span class="keyword">sizeof</span>(*x) * n);
<a name="l02385"></a>02385    <span class="keywordflow">for</span> (i=0; i &lt; 8*n; ++i)
<a name="l02386"></a>02386       mcos[i] = (<span class="keywordtype">float</span>) cos(M_PI / 4 * i / n);
<a name="l02387"></a>02387    <span class="keywordflow">for</span> (i=0; i &lt; n; ++i) {
<a name="l02388"></a>02388       <span class="keywordtype">float</span> acc = 0;
<a name="l02389"></a>02389       <span class="keywordflow">for</span> (j=0; j &lt; n; ++j)
<a name="l02390"></a>02390          acc += x[j] * mcos[((2 * i + 1)*(2*j+1)) &amp; nmask];
<a name="l02391"></a>02391       buffer[i] = acc;
<a name="l02392"></a>02392    }
<a name="l02393"></a>02393 }
<a name="l02394"></a>02394 
<a name="l02395"></a>02395 <span class="keywordtype">void</span> inverse_mdct_slow(<span class="keywordtype">float</span> *buffer, <span class="keywordtype">int</span> n, <a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> blocktype)
<a name="l02396"></a>02396 {
<a name="l02397"></a>02397    <span class="keywordtype">int</span> i, n4 = n &gt;&gt; 2, n2 = n &gt;&gt; 1, n3_4 = n - n4;
<a name="l02398"></a>02398    <span class="keywordtype">float</span> temp[4096];
<a name="l02399"></a>02399 
<a name="l02400"></a>02400    memcpy(temp, buffer, n2 * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l02401"></a>02401    dct_iv_slow(temp, n2);  <span class="comment">// returns -c&#39;-d, a-b&#39;</span>
<a name="l02402"></a>02402 
<a name="l02403"></a>02403    <span class="keywordflow">for</span> (i=0; i &lt; n4  ; ++i) buffer[i] = temp[i+n4];            <span class="comment">// a-b&#39;</span>
<a name="l02404"></a>02404    <span class="keywordflow">for</span> (   ; i &lt; n3_4; ++i) buffer[i] = -temp[n3_4 - i - 1];   <span class="comment">// b-a&#39;, c+d&#39;</span>
<a name="l02405"></a>02405    <span class="keywordflow">for</span> (   ; i &lt; n   ; ++i) buffer[i] = -temp[i - n3_4];       <span class="comment">// c&#39;+d</span>
<a name="l02406"></a>02406 }
<a name="l02407"></a>02407 <span class="preprocessor">#endif</span>
<a name="l02408"></a>02408 <span class="preprocessor"></span>
<a name="l02409"></a>02409 <span class="preprocessor">#ifndef LIBVORBIS_MDCT</span>
<a name="l02410"></a>02410 <span class="preprocessor"></span><span class="preprocessor">#define LIBVORBIS_MDCT 0</span>
<a name="l02411"></a>02411 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02412"></a>02412 <span class="preprocessor"></span>
<a name="l02413"></a>02413 <span class="preprocessor">#if LIBVORBIS_MDCT</span>
<a name="l02414"></a>02414 <span class="preprocessor"></span><span class="comment">// directly call the vorbis MDCT using an interface documented</span>
<a name="l02415"></a>02415 <span class="comment">// by Jeff Roberts... useful for performance comparison</span>
<a name="l02416"></a>02416 <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l02417"></a>02417 {
<a name="l02418"></a>02418   <span class="keywordtype">int</span> n;
<a name="l02419"></a>02419   <span class="keywordtype">int</span> log2n;
<a name="l02420"></a>02420 
<a name="l02421"></a>02421   <span class="keywordtype">float</span> *trig;
<a name="l02422"></a>02422   <span class="keywordtype">int</span>   *bitrev;
<a name="l02423"></a>02423 
<a name="l02424"></a>02424   <span class="keywordtype">float</span> scale;
<a name="l02425"></a>02425 } mdct_lookup;
<a name="l02426"></a>02426 
<a name="l02427"></a>02427 <span class="keyword">extern</span> <span class="keywordtype">void</span> mdct_init(mdct_lookup *lookup, <span class="keywordtype">int</span> n);
<a name="l02428"></a>02428 <span class="keyword">extern</span> <span class="keywordtype">void</span> mdct_clear(mdct_lookup *l);
<a name="l02429"></a>02429 <span class="keyword">extern</span> <span class="keywordtype">void</span> mdct_backward(mdct_lookup *init, <span class="keywordtype">float</span> *in, <span class="keywordtype">float</span> *out);
<a name="l02430"></a>02430 
<a name="l02431"></a>02431 mdct_lookup M1,M2;
<a name="l02432"></a>02432 
<a name="l02433"></a>02433 <span class="keywordtype">void</span> inverse_mdct(<span class="keywordtype">float</span> *buffer, <span class="keywordtype">int</span> n, <a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> blocktype)
<a name="l02434"></a>02434 {
<a name="l02435"></a>02435    mdct_lookup *M;
<a name="l02436"></a>02436    <span class="keywordflow">if</span> (M1.n == n) M = &amp;M1;
<a name="l02437"></a>02437    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (M2.n == n) M = &amp;M2;
<a name="l02438"></a>02438    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (M1.n == 0) { mdct_init(&amp;M1, n); M = &amp;M1; }
<a name="l02439"></a>02439    <span class="keywordflow">else</span> {
<a name="l02440"></a>02440       <span class="keywordflow">if</span> (M2.n) __asm <span class="keywordtype">int</span> 3;
<a name="l02441"></a>02441       mdct_init(&amp;M2, n);
<a name="l02442"></a>02442       M = &amp;M2;
<a name="l02443"></a>02443    }
<a name="l02444"></a>02444 
<a name="l02445"></a>02445    mdct_backward(M, buffer, buffer);
<a name="l02446"></a>02446 }
<a name="l02447"></a>02447 <span class="preprocessor">#endif</span>
<a name="l02448"></a>02448 <span class="preprocessor"></span>
<a name="l02449"></a>02449 
<a name="l02450"></a>02450 <span class="comment">// the following were split out into separate functions while optimizing;</span>
<a name="l02451"></a>02451 <span class="comment">// they could be pushed back up but eh. __forceinline showed no change;</span>
<a name="l02452"></a>02452 <span class="comment">// they&#39;re probably already being inlined.</span>
<a name="l02453"></a>02453 <span class="keyword">static</span> <span class="keywordtype">void</span> imdct_step3_iter0_loop(<span class="keywordtype">int</span> n, <span class="keywordtype">float</span> *e, <span class="keywordtype">int</span> i_off, <span class="keywordtype">int</span> k_off, <span class="keywordtype">float</span> *A)
<a name="l02454"></a>02454 {
<a name="l02455"></a>02455    <span class="keywordtype">float</span> *ee0 = e + i_off;
<a name="l02456"></a>02456    <span class="keywordtype">float</span> *ee2 = ee0 + k_off;
<a name="l02457"></a>02457    <span class="keywordtype">int</span> i;
<a name="l02458"></a>02458 
<a name="l02459"></a>02459    assert((n &amp; 3) == 0);
<a name="l02460"></a>02460    <span class="keywordflow">for</span> (i=(n&gt;&gt;2); i &gt; 0; --i) {
<a name="l02461"></a>02461       <span class="keywordtype">float</span> k00_20, k01_21;
<a name="l02462"></a>02462       k00_20  = ee0[ 0] - ee2[ 0];
<a name="l02463"></a>02463       k01_21  = ee0[-1] - ee2[-1];
<a name="l02464"></a>02464       ee0[ 0] += ee2[ 0];<span class="comment">//ee0[ 0] = ee0[ 0] + ee2[ 0];</span>
<a name="l02465"></a>02465       ee0[-1] += ee2[-1];<span class="comment">//ee0[-1] = ee0[-1] + ee2[-1];</span>
<a name="l02466"></a>02466       ee2[ 0] = k00_20 * A[0] - k01_21 * A[1];
<a name="l02467"></a>02467       ee2[-1] = k01_21 * A[0] + k00_20 * A[1];
<a name="l02468"></a>02468       A += 8;
<a name="l02469"></a>02469 
<a name="l02470"></a>02470       k00_20  = ee0[-2] - ee2[-2];
<a name="l02471"></a>02471       k01_21  = ee0[-3] - ee2[-3];
<a name="l02472"></a>02472       ee0[-2] += ee2[-2];<span class="comment">//ee0[-2] = ee0[-2] + ee2[-2];</span>
<a name="l02473"></a>02473       ee0[-3] += ee2[-3];<span class="comment">//ee0[-3] = ee0[-3] + ee2[-3];</span>
<a name="l02474"></a>02474       ee2[-2] = k00_20 * A[0] - k01_21 * A[1];
<a name="l02475"></a>02475       ee2[-3] = k01_21 * A[0] + k00_20 * A[1];
<a name="l02476"></a>02476       A += 8;
<a name="l02477"></a>02477 
<a name="l02478"></a>02478       k00_20  = ee0[-4] - ee2[-4];
<a name="l02479"></a>02479       k01_21  = ee0[-5] - ee2[-5];
<a name="l02480"></a>02480       ee0[-4] += ee2[-4];<span class="comment">//ee0[-4] = ee0[-4] + ee2[-4];</span>
<a name="l02481"></a>02481       ee0[-5] += ee2[-5];<span class="comment">//ee0[-5] = ee0[-5] + ee2[-5];</span>
<a name="l02482"></a>02482       ee2[-4] = k00_20 * A[0] - k01_21 * A[1];
<a name="l02483"></a>02483       ee2[-5] = k01_21 * A[0] + k00_20 * A[1];
<a name="l02484"></a>02484       A += 8;
<a name="l02485"></a>02485 
<a name="l02486"></a>02486       k00_20  = ee0[-6] - ee2[-6];
<a name="l02487"></a>02487       k01_21  = ee0[-7] - ee2[-7];
<a name="l02488"></a>02488       ee0[-6] += ee2[-6];<span class="comment">//ee0[-6] = ee0[-6] + ee2[-6];</span>
<a name="l02489"></a>02489       ee0[-7] += ee2[-7];<span class="comment">//ee0[-7] = ee0[-7] + ee2[-7];</span>
<a name="l02490"></a>02490       ee2[-6] = k00_20 * A[0] - k01_21 * A[1];
<a name="l02491"></a>02491       ee2[-7] = k01_21 * A[0] + k00_20 * A[1];
<a name="l02492"></a>02492       A += 8;
<a name="l02493"></a>02493       ee0 -= 8;
<a name="l02494"></a>02494       ee2 -= 8;
<a name="l02495"></a>02495    }
<a name="l02496"></a>02496 }
<a name="l02497"></a>02497 
<a name="l02498"></a>02498 <span class="keyword">static</span> <span class="keywordtype">void</span> imdct_step3_inner_r_loop(<span class="keywordtype">int</span> lim, <span class="keywordtype">float</span> *e, <span class="keywordtype">int</span> d0, <span class="keywordtype">int</span> k_off, <span class="keywordtype">float</span> *A, <span class="keywordtype">int</span> k1)
<a name="l02499"></a>02499 {
<a name="l02500"></a>02500    <span class="keywordtype">int</span> i;
<a name="l02501"></a>02501    <span class="keywordtype">float</span> k00_20, k01_21;
<a name="l02502"></a>02502 
<a name="l02503"></a>02503    <span class="keywordtype">float</span> *e0 = e + d0;
<a name="l02504"></a>02504    <span class="keywordtype">float</span> *e2 = e0 + k_off;
<a name="l02505"></a>02505 
<a name="l02506"></a>02506    <span class="keywordflow">for</span> (i=lim &gt;&gt; 2; i &gt; 0; --i) {
<a name="l02507"></a>02507       k00_20 = e0[-0] - e2[-0];
<a name="l02508"></a>02508       k01_21 = e0[-1] - e2[-1];
<a name="l02509"></a>02509       e0[-0] += e2[-0];<span class="comment">//e0[-0] = e0[-0] + e2[-0];</span>
<a name="l02510"></a>02510       e0[-1] += e2[-1];<span class="comment">//e0[-1] = e0[-1] + e2[-1];</span>
<a name="l02511"></a>02511       e2[-0] = (k00_20)*A[0] - (k01_21) * A[1];
<a name="l02512"></a>02512       e2[-1] = (k01_21)*A[0] + (k00_20) * A[1];
<a name="l02513"></a>02513 
<a name="l02514"></a>02514       A += k1;
<a name="l02515"></a>02515 
<a name="l02516"></a>02516       k00_20 = e0[-2] - e2[-2];
<a name="l02517"></a>02517       k01_21 = e0[-3] - e2[-3];
<a name="l02518"></a>02518       e0[-2] += e2[-2];<span class="comment">//e0[-2] = e0[-2] + e2[-2];</span>
<a name="l02519"></a>02519       e0[-3] += e2[-3];<span class="comment">//e0[-3] = e0[-3] + e2[-3];</span>
<a name="l02520"></a>02520       e2[-2] = (k00_20)*A[0] - (k01_21) * A[1];
<a name="l02521"></a>02521       e2[-3] = (k01_21)*A[0] + (k00_20) * A[1];
<a name="l02522"></a>02522 
<a name="l02523"></a>02523       A += k1;
<a name="l02524"></a>02524 
<a name="l02525"></a>02525       k00_20 = e0[-4] - e2[-4];
<a name="l02526"></a>02526       k01_21 = e0[-5] - e2[-5];
<a name="l02527"></a>02527       e0[-4] += e2[-4];<span class="comment">//e0[-4] = e0[-4] + e2[-4];</span>
<a name="l02528"></a>02528       e0[-5] += e2[-5];<span class="comment">//e0[-5] = e0[-5] + e2[-5];</span>
<a name="l02529"></a>02529       e2[-4] = (k00_20)*A[0] - (k01_21) * A[1];
<a name="l02530"></a>02530       e2[-5] = (k01_21)*A[0] + (k00_20) * A[1];
<a name="l02531"></a>02531 
<a name="l02532"></a>02532       A += k1;
<a name="l02533"></a>02533 
<a name="l02534"></a>02534       k00_20 = e0[-6] - e2[-6];
<a name="l02535"></a>02535       k01_21 = e0[-7] - e2[-7];
<a name="l02536"></a>02536       e0[-6] += e2[-6];<span class="comment">//e0[-6] = e0[-6] + e2[-6];</span>
<a name="l02537"></a>02537       e0[-7] += e2[-7];<span class="comment">//e0[-7] = e0[-7] + e2[-7];</span>
<a name="l02538"></a>02538       e2[-6] = (k00_20)*A[0] - (k01_21) * A[1];
<a name="l02539"></a>02539       e2[-7] = (k01_21)*A[0] + (k00_20) * A[1];
<a name="l02540"></a>02540 
<a name="l02541"></a>02541       e0 -= 8;
<a name="l02542"></a>02542       e2 -= 8;
<a name="l02543"></a>02543 
<a name="l02544"></a>02544       A += k1;
<a name="l02545"></a>02545    }
<a name="l02546"></a>02546 }
<a name="l02547"></a>02547 
<a name="l02548"></a>02548 <span class="keyword">static</span> <span class="keywordtype">void</span> imdct_step3_inner_s_loop(<span class="keywordtype">int</span> n, <span class="keywordtype">float</span> *e, <span class="keywordtype">int</span> i_off, <span class="keywordtype">int</span> k_off, <span class="keywordtype">float</span> *A, <span class="keywordtype">int</span> a_off, <span class="keywordtype">int</span> k0)
<a name="l02549"></a>02549 {
<a name="l02550"></a>02550    <span class="keywordtype">int</span> i;
<a name="l02551"></a>02551    <span class="keywordtype">float</span> A0 = A[0];
<a name="l02552"></a>02552    <span class="keywordtype">float</span> A1 = A[0+1];
<a name="l02553"></a>02553    <span class="keywordtype">float</span> A2 = A[0+a_off];
<a name="l02554"></a>02554    <span class="keywordtype">float</span> A3 = A[0+a_off+1];
<a name="l02555"></a>02555    <span class="keywordtype">float</span> A4 = A[0+a_off*2+0];
<a name="l02556"></a>02556    <span class="keywordtype">float</span> A5 = A[0+a_off*2+1];
<a name="l02557"></a>02557    <span class="keywordtype">float</span> A6 = A[0+a_off*3+0];
<a name="l02558"></a>02558    <span class="keywordtype">float</span> A7 = A[0+a_off*3+1];
<a name="l02559"></a>02559 
<a name="l02560"></a>02560    <span class="keywordtype">float</span> k00,k11;
<a name="l02561"></a>02561 
<a name="l02562"></a>02562    <span class="keywordtype">float</span> *ee0 = e  +i_off;
<a name="l02563"></a>02563    <span class="keywordtype">float</span> *ee2 = ee0+k_off;
<a name="l02564"></a>02564 
<a name="l02565"></a>02565    <span class="keywordflow">for</span> (i=n; i &gt; 0; --i) {
<a name="l02566"></a>02566       k00     = ee0[ 0] - ee2[ 0];
<a name="l02567"></a>02567       k11     = ee0[-1] - ee2[-1];
<a name="l02568"></a>02568       ee0[ 0] =  ee0[ 0] + ee2[ 0];
<a name="l02569"></a>02569       ee0[-1] =  ee0[-1] + ee2[-1];
<a name="l02570"></a>02570       ee2[ 0] = (k00) * A0 - (k11) * A1;
<a name="l02571"></a>02571       ee2[-1] = (k11) * A0 + (k00) * A1;
<a name="l02572"></a>02572 
<a name="l02573"></a>02573       k00     = ee0[-2] - ee2[-2];
<a name="l02574"></a>02574       k11     = ee0[-3] - ee2[-3];
<a name="l02575"></a>02575       ee0[-2] =  ee0[-2] + ee2[-2];
<a name="l02576"></a>02576       ee0[-3] =  ee0[-3] + ee2[-3];
<a name="l02577"></a>02577       ee2[-2] = (k00) * A2 - (k11) * A3;
<a name="l02578"></a>02578       ee2[-3] = (k11) * A2 + (k00) * A3;
<a name="l02579"></a>02579 
<a name="l02580"></a>02580       k00     = ee0[-4] - ee2[-4];
<a name="l02581"></a>02581       k11     = ee0[-5] - ee2[-5];
<a name="l02582"></a>02582       ee0[-4] =  ee0[-4] + ee2[-4];
<a name="l02583"></a>02583       ee0[-5] =  ee0[-5] + ee2[-5];
<a name="l02584"></a>02584       ee2[-4] = (k00) * A4 - (k11) * A5;
<a name="l02585"></a>02585       ee2[-5] = (k11) * A4 + (k00) * A5;
<a name="l02586"></a>02586 
<a name="l02587"></a>02587       k00     = ee0[-6] - ee2[-6];
<a name="l02588"></a>02588       k11     = ee0[-7] - ee2[-7];
<a name="l02589"></a>02589       ee0[-6] =  ee0[-6] + ee2[-6];
<a name="l02590"></a>02590       ee0[-7] =  ee0[-7] + ee2[-7];
<a name="l02591"></a>02591       ee2[-6] = (k00) * A6 - (k11) * A7;
<a name="l02592"></a>02592       ee2[-7] = (k11) * A6 + (k00) * A7;
<a name="l02593"></a>02593 
<a name="l02594"></a>02594       ee0 -= k0;
<a name="l02595"></a>02595       ee2 -= k0;
<a name="l02596"></a>02596    }
<a name="l02597"></a>02597 }
<a name="l02598"></a>02598 
<a name="l02599"></a>02599 <span class="keyword">static</span> __forceinline <span class="keywordtype">void</span> iter_54(<span class="keywordtype">float</span> *z)
<a name="l02600"></a>02600 {
<a name="l02601"></a>02601    <span class="keywordtype">float</span> k00,k11,k22,k33;
<a name="l02602"></a>02602    <span class="keywordtype">float</span> y0,y1,y2,y3;
<a name="l02603"></a>02603 
<a name="l02604"></a>02604    k00  = z[ 0] - z[-4];
<a name="l02605"></a>02605    y0   = z[ 0] + z[-4];
<a name="l02606"></a>02606    y2   = z[-2] + z[-6];
<a name="l02607"></a>02607    k22  = z[-2] - z[-6];
<a name="l02608"></a>02608 
<a name="l02609"></a>02609    z[-0] = y0 + y2;      <span class="comment">// z0 + z4 + z2 + z6</span>
<a name="l02610"></a>02610    z[-2] = y0 - y2;      <span class="comment">// z0 + z4 - z2 - z6</span>
<a name="l02611"></a>02611 
<a name="l02612"></a>02612    <span class="comment">// done with y0,y2</span>
<a name="l02613"></a>02613 
<a name="l02614"></a>02614    k33  = z[-3] - z[-7];
<a name="l02615"></a>02615 
<a name="l02616"></a>02616    z[-4] = k00 + k33;    <span class="comment">// z0 - z4 + z3 - z7</span>
<a name="l02617"></a>02617    z[-6] = k00 - k33;    <span class="comment">// z0 - z4 - z3 + z7</span>
<a name="l02618"></a>02618 
<a name="l02619"></a>02619    <span class="comment">// done with k33</span>
<a name="l02620"></a>02620 
<a name="l02621"></a>02621    k11  = z[-1] - z[-5];
<a name="l02622"></a>02622    y1   = z[-1] + z[-5];
<a name="l02623"></a>02623    y3   = z[-3] + z[-7];
<a name="l02624"></a>02624 
<a name="l02625"></a>02625    z[-1] = y1 + y3;      <span class="comment">// z1 + z5 + z3 + z7</span>
<a name="l02626"></a>02626    z[-3] = y1 - y3;      <span class="comment">// z1 + z5 - z3 - z7</span>
<a name="l02627"></a>02627    z[-5] = k11 - k22;    <span class="comment">// z1 - z5 + z2 - z6</span>
<a name="l02628"></a>02628    z[-7] = k11 + k22;    <span class="comment">// z1 - z5 - z2 + z6</span>
<a name="l02629"></a>02629 }
<a name="l02630"></a>02630 
<a name="l02631"></a>02631 <span class="keyword">static</span> <span class="keywordtype">void</span> imdct_step3_inner_s_loop_ld654(<span class="keywordtype">int</span> n, <span class="keywordtype">float</span> *e, <span class="keywordtype">int</span> i_off, <span class="keywordtype">float</span> *A, <span class="keywordtype">int</span> base_n)
<a name="l02632"></a>02632 {
<a name="l02633"></a>02633    <span class="keywordtype">int</span> a_off = base_n &gt;&gt; 3;
<a name="l02634"></a>02634    <span class="keywordtype">float</span> A2 = A[0+a_off];
<a name="l02635"></a>02635    <span class="keywordtype">float</span> *z = e + i_off;
<a name="l02636"></a>02636    <span class="keywordtype">float</span> *base = z - 16 * n;
<a name="l02637"></a>02637 
<a name="l02638"></a>02638    <span class="keywordflow">while</span> (z &gt; base) {
<a name="l02639"></a>02639       <span class="keywordtype">float</span> k00,k11;
<a name="l02640"></a>02640 
<a name="l02641"></a>02641       k00   = z[-0] - z[-8];
<a name="l02642"></a>02642       k11   = z[-1] - z[-9];
<a name="l02643"></a>02643       z[-0] = z[-0] + z[-8];
<a name="l02644"></a>02644       z[-1] = z[-1] + z[-9];
<a name="l02645"></a>02645       z[-8] =  k00;
<a name="l02646"></a>02646       z[-9] =  k11 ;
<a name="l02647"></a>02647 
<a name="l02648"></a>02648       k00    = z[ -2] - z[-10];
<a name="l02649"></a>02649       k11    = z[ -3] - z[-11];
<a name="l02650"></a>02650       z[ -2] = z[ -2] + z[-10];
<a name="l02651"></a>02651       z[ -3] = z[ -3] + z[-11];
<a name="l02652"></a>02652       z[-10] = (k00+k11) * A2;
<a name="l02653"></a>02653       z[-11] = (k11-k00) * A2;
<a name="l02654"></a>02654 
<a name="l02655"></a>02655       k00    = z[-12] - z[ -4];  <span class="comment">// reverse to avoid a unary negation</span>
<a name="l02656"></a>02656       k11    = z[ -5] - z[-13];
<a name="l02657"></a>02657       z[ -4] = z[ -4] + z[-12];
<a name="l02658"></a>02658       z[ -5] = z[ -5] + z[-13];
<a name="l02659"></a>02659       z[-12] = k11;
<a name="l02660"></a>02660       z[-13] = k00;
<a name="l02661"></a>02661 
<a name="l02662"></a>02662       k00    = z[-14] - z[ -6];  <span class="comment">// reverse to avoid a unary negation</span>
<a name="l02663"></a>02663       k11    = z[ -7] - z[-15];
<a name="l02664"></a>02664       z[ -6] = z[ -6] + z[-14];
<a name="l02665"></a>02665       z[ -7] = z[ -7] + z[-15];
<a name="l02666"></a>02666       z[-14] = (k00+k11) * A2;
<a name="l02667"></a>02667       z[-15] = (k00-k11) * A2;
<a name="l02668"></a>02668 
<a name="l02669"></a>02669       iter_54(z);
<a name="l02670"></a>02670       iter_54(z-8);
<a name="l02671"></a>02671       z -= 16;
<a name="l02672"></a>02672    }
<a name="l02673"></a>02673 }
<a name="l02674"></a>02674 
<a name="l02675"></a>02675 <span class="keyword">static</span> <span class="keywordtype">void</span> inverse_mdct(<span class="keywordtype">float</span> *buffer, <span class="keywordtype">int</span> n, <a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> blocktype)
<a name="l02676"></a>02676 {
<a name="l02677"></a>02677    <span class="keywordtype">int</span> n2 = n &gt;&gt; 1, n4 = n &gt;&gt; 2, n8 = n &gt;&gt; 3, l;
<a name="l02678"></a>02678    <span class="keywordtype">int</span> ld;
<a name="l02679"></a>02679    <span class="comment">// @OPTIMIZE: reduce register pressure by using fewer variables?</span>
<a name="l02680"></a>02680    <span class="keywordtype">int</span> save_point = temp_alloc_save(f);
<a name="l02681"></a>02681    <span class="keywordtype">float</span> *buf2 = (<span class="keywordtype">float</span> *) temp_alloc(f, n2 * <span class="keyword">sizeof</span>(*buf2));
<a name="l02682"></a>02682    <span class="keywordtype">float</span> *u=NULL,*v=NULL;
<a name="l02683"></a>02683    <span class="comment">// twiddle factors</span>
<a name="l02684"></a>02684    <span class="keywordtype">float</span> *A = f-&gt;A[blocktype];
<a name="l02685"></a>02685 
<a name="l02686"></a>02686    <span class="comment">// IMDCT algorithm from &quot;The use of multirate filter banks for coding of high quality digital audio&quot;</span>
<a name="l02687"></a>02687    <span class="comment">// See notes about bugs in that paper in less-optimal implementation &#39;inverse_mdct_old&#39; after this function.</span>
<a name="l02688"></a>02688 
<a name="l02689"></a>02689    <span class="comment">// kernel from paper</span>
<a name="l02690"></a>02690 
<a name="l02691"></a>02691 
<a name="l02692"></a>02692    <span class="comment">// merged:</span>
<a name="l02693"></a>02693    <span class="comment">//   copy and reflect spectral data</span>
<a name="l02694"></a>02694    <span class="comment">//   step 0</span>
<a name="l02695"></a>02695 
<a name="l02696"></a>02696    <span class="comment">// note that it turns out that the items added together during</span>
<a name="l02697"></a>02697    <span class="comment">// this step are, in fact, being added to themselves (as reflected</span>
<a name="l02698"></a>02698    <span class="comment">// by step 0). inexplicable inefficiency! this became obvious</span>
<a name="l02699"></a>02699    <span class="comment">// once I combined the passes.</span>
<a name="l02700"></a>02700 
<a name="l02701"></a>02701    <span class="comment">// so there&#39;s a missing &#39;times 2&#39; here (for adding X to itself).</span>
<a name="l02702"></a>02702    <span class="comment">// this propagates through linearly to the end, where the numbers</span>
<a name="l02703"></a>02703    <span class="comment">// are 1/2 too small, and need to be compensated for.</span>
<a name="l02704"></a>02704 
<a name="l02705"></a>02705    {
<a name="l02706"></a>02706       <span class="keywordtype">float</span> *d,*e, *AA, *e_stop;
<a name="l02707"></a>02707       d = &amp;buf2[n2-2];
<a name="l02708"></a>02708       AA = A;
<a name="l02709"></a>02709       e = &amp;buffer[0];
<a name="l02710"></a>02710       e_stop = &amp;buffer[n2];
<a name="l02711"></a>02711       <span class="keywordflow">while</span> (e != e_stop) {
<a name="l02712"></a>02712          d[1] = (e[0] * AA[0] - e[2]*AA[1]);
<a name="l02713"></a>02713          d[0] = (e[0] * AA[1] + e[2]*AA[0]);
<a name="l02714"></a>02714          d -= 2;
<a name="l02715"></a>02715          AA += 2;
<a name="l02716"></a>02716          e += 4;
<a name="l02717"></a>02717       }
<a name="l02718"></a>02718 
<a name="l02719"></a>02719       e = &amp;buffer[n2-3];
<a name="l02720"></a>02720       <span class="keywordflow">while</span> (d &gt;= buf2) {
<a name="l02721"></a>02721          d[1] = (-e[2] * AA[0] - -e[0]*AA[1]);
<a name="l02722"></a>02722          d[0] = (-e[2] * AA[1] + -e[0]*AA[0]);
<a name="l02723"></a>02723          d -= 2;
<a name="l02724"></a>02724          AA += 2;
<a name="l02725"></a>02725          e -= 4;
<a name="l02726"></a>02726       }
<a name="l02727"></a>02727    }
<a name="l02728"></a>02728 
<a name="l02729"></a>02729    <span class="comment">// now we use symbolic names for these, so that we can</span>
<a name="l02730"></a>02730    <span class="comment">// possibly swap their meaning as we change which operations</span>
<a name="l02731"></a>02731    <span class="comment">// are in place</span>
<a name="l02732"></a>02732 
<a name="l02733"></a>02733    u = buffer;
<a name="l02734"></a>02734    v = buf2;
<a name="l02735"></a>02735 
<a name="l02736"></a>02736    <span class="comment">// step 2    (paper output is w, now u)</span>
<a name="l02737"></a>02737    <span class="comment">// this could be in place, but the data ends up in the wrong</span>
<a name="l02738"></a>02738    <span class="comment">// place... _somebody_&#39;s got to swap it, so this is nominated</span>
<a name="l02739"></a>02739    {
<a name="l02740"></a>02740       <span class="keywordtype">float</span> *AA = &amp;A[n2-8];
<a name="l02741"></a>02741       <span class="keywordtype">float</span> *d0,*d1, *e0, *e1;
<a name="l02742"></a>02742 
<a name="l02743"></a>02743       e0 = &amp;v[n4];
<a name="l02744"></a>02744       e1 = &amp;v[0];
<a name="l02745"></a>02745 
<a name="l02746"></a>02746       d0 = &amp;u[n4];
<a name="l02747"></a>02747       d1 = &amp;u[0];
<a name="l02748"></a>02748 
<a name="l02749"></a>02749       <span class="keywordflow">while</span> (AA &gt;= A) {
<a name="l02750"></a>02750          <span class="keywordtype">float</span> v40_20, v41_21;
<a name="l02751"></a>02751 
<a name="l02752"></a>02752          v41_21 = e0[1] - e1[1];
<a name="l02753"></a>02753          v40_20 = e0[0] - e1[0];
<a name="l02754"></a>02754          d0[1]  = e0[1] + e1[1];
<a name="l02755"></a>02755          d0[0]  = e0[0] + e1[0];
<a name="l02756"></a>02756          d1[1]  = v41_21*AA[4] - v40_20*AA[5];
<a name="l02757"></a>02757          d1[0]  = v40_20*AA[4] + v41_21*AA[5];
<a name="l02758"></a>02758 
<a name="l02759"></a>02759          v41_21 = e0[3] - e1[3];
<a name="l02760"></a>02760          v40_20 = e0[2] - e1[2];
<a name="l02761"></a>02761          d0[3]  = e0[3] + e1[3];
<a name="l02762"></a>02762          d0[2]  = e0[2] + e1[2];
<a name="l02763"></a>02763          d1[3]  = v41_21*AA[0] - v40_20*AA[1];
<a name="l02764"></a>02764          d1[2]  = v40_20*AA[0] + v41_21*AA[1];
<a name="l02765"></a>02765 
<a name="l02766"></a>02766          AA -= 8;
<a name="l02767"></a>02767 
<a name="l02768"></a>02768          d0 += 4;
<a name="l02769"></a>02769          d1 += 4;
<a name="l02770"></a>02770          e0 += 4;
<a name="l02771"></a>02771          e1 += 4;
<a name="l02772"></a>02772       }
<a name="l02773"></a>02773    }
<a name="l02774"></a>02774 
<a name="l02775"></a>02775    <span class="comment">// step 3</span>
<a name="l02776"></a>02776    ld = ilog(n) - 1; <span class="comment">// ilog is off-by-one from normal definitions</span>
<a name="l02777"></a>02777 
<a name="l02778"></a>02778    <span class="comment">// optimized step 3:</span>
<a name="l02779"></a>02779 
<a name="l02780"></a>02780    <span class="comment">// the original step3 loop can be nested r inside s or s inside r;</span>
<a name="l02781"></a>02781    <span class="comment">// it&#39;s written originally as s inside r, but this is dumb when r</span>
<a name="l02782"></a>02782    <span class="comment">// iterates many times, and s few. So I have two copies of it and</span>
<a name="l02783"></a>02783    <span class="comment">// switch between them halfway.</span>
<a name="l02784"></a>02784 
<a name="l02785"></a>02785    <span class="comment">// this is iteration 0 of step 3</span>
<a name="l02786"></a>02786    imdct_step3_iter0_loop(n &gt;&gt; 4, u, n2-1-n4*0, -(n &gt;&gt; 3), A);
<a name="l02787"></a>02787    imdct_step3_iter0_loop(n &gt;&gt; 4, u, n2-1-n4*1, -(n &gt;&gt; 3), A);
<a name="l02788"></a>02788 
<a name="l02789"></a>02789    <span class="comment">// this is iteration 1 of step 3</span>
<a name="l02790"></a>02790    imdct_step3_inner_r_loop(n &gt;&gt; 5, u, n2-1 - n8*0, -(n &gt;&gt; 4), A, 16);
<a name="l02791"></a>02791    imdct_step3_inner_r_loop(n &gt;&gt; 5, u, n2-1 - n8*1, -(n &gt;&gt; 4), A, 16);
<a name="l02792"></a>02792    imdct_step3_inner_r_loop(n &gt;&gt; 5, u, n2-1 - n8*2, -(n &gt;&gt; 4), A, 16);
<a name="l02793"></a>02793    imdct_step3_inner_r_loop(n &gt;&gt; 5, u, n2-1 - n8*3, -(n &gt;&gt; 4), A, 16);
<a name="l02794"></a>02794 
<a name="l02795"></a>02795    l=2;
<a name="l02796"></a>02796    <span class="keywordflow">for</span> (; l &lt; (ld-3)&gt;&gt;1; ++l) {
<a name="l02797"></a>02797       <span class="keywordtype">int</span> k0 = n &gt;&gt; (l+2), k0_2 = k0&gt;&gt;1;
<a name="l02798"></a>02798       <span class="keywordtype">int</span> lim = 1 &lt;&lt; (l+1);
<a name="l02799"></a>02799       <span class="keywordtype">int</span> i;
<a name="l02800"></a>02800       <span class="keywordflow">for</span> (i=0; i &lt; lim; ++i)
<a name="l02801"></a>02801          imdct_step3_inner_r_loop(n &gt;&gt; (l+4), u, n2-1 - k0*i, -k0_2, A, 1 &lt;&lt; (l+3));
<a name="l02802"></a>02802    }
<a name="l02803"></a>02803 
<a name="l02804"></a>02804    <span class="keywordflow">for</span> (; l &lt; ld-6; ++l) {
<a name="l02805"></a>02805       <span class="keywordtype">int</span> k0 = n &gt;&gt; (l+2), k1 = 1 &lt;&lt; (l+3), k0_2 = k0&gt;&gt;1;
<a name="l02806"></a>02806       <span class="keywordtype">int</span> rlim = n &gt;&gt; (l+6), r;
<a name="l02807"></a>02807       <span class="keywordtype">int</span> lim = 1 &lt;&lt; (l+1);
<a name="l02808"></a>02808       <span class="keywordtype">int</span> i_off;
<a name="l02809"></a>02809       <span class="keywordtype">float</span> *A0 = A;
<a name="l02810"></a>02810       i_off = n2-1;
<a name="l02811"></a>02811       <span class="keywordflow">for</span> (r=rlim; r &gt; 0; --r) {
<a name="l02812"></a>02812          imdct_step3_inner_s_loop(lim, u, i_off, -k0_2, A0, k1, k0);
<a name="l02813"></a>02813          A0 += k1*4;
<a name="l02814"></a>02814          i_off -= 8;
<a name="l02815"></a>02815       }
<a name="l02816"></a>02816    }
<a name="l02817"></a>02817 
<a name="l02818"></a>02818    <span class="comment">// iterations with count:</span>
<a name="l02819"></a>02819    <span class="comment">//   ld-6,-5,-4 all interleaved together</span>
<a name="l02820"></a>02820    <span class="comment">//       the big win comes from getting rid of needless flops</span>
<a name="l02821"></a>02821    <span class="comment">//         due to the constants on pass 5 &amp; 4 being all 1 and 0;</span>
<a name="l02822"></a>02822    <span class="comment">//       combining them to be simultaneous to improve cache made little difference</span>
<a name="l02823"></a>02823    imdct_step3_inner_s_loop_ld654(n &gt;&gt; 5, u, n2-1, A, n);
<a name="l02824"></a>02824 
<a name="l02825"></a>02825    <span class="comment">// output is u</span>
<a name="l02826"></a>02826 
<a name="l02827"></a>02827    <span class="comment">// step 4, 5, and 6</span>
<a name="l02828"></a>02828    <span class="comment">// cannot be in-place because of step 5</span>
<a name="l02829"></a>02829    {
<a name="l02830"></a>02830       uint16 *bitrev = f-&gt;bit_reverse[blocktype];
<a name="l02831"></a>02831       <span class="comment">// weirdly, I&#39;d have thought reading sequentially and writing</span>
<a name="l02832"></a>02832       <span class="comment">// erratically would have been better than vice-versa, but in</span>
<a name="l02833"></a>02833       <span class="comment">// fact that&#39;s not what my testing showed. (That is, with</span>
<a name="l02834"></a>02834       <span class="comment">// j = bitreverse(i), do you read i and write j, or read j and write i.)</span>
<a name="l02835"></a>02835 
<a name="l02836"></a>02836       <span class="keywordtype">float</span> *d0 = &amp;v[n4-4];
<a name="l02837"></a>02837       <span class="keywordtype">float</span> *d1 = &amp;v[n2-4];
<a name="l02838"></a>02838       <span class="keywordflow">while</span> (d0 &gt;= v) {
<a name="l02839"></a>02839          <span class="keywordtype">int</span> k4;
<a name="l02840"></a>02840 
<a name="l02841"></a>02841          k4 = bitrev[0];
<a name="l02842"></a>02842          d1[3] = u[k4+0];
<a name="l02843"></a>02843          d1[2] = u[k4+1];
<a name="l02844"></a>02844          d0[3] = u[k4+2];
<a name="l02845"></a>02845          d0[2] = u[k4+3];
<a name="l02846"></a>02846 
<a name="l02847"></a>02847          k4 = bitrev[1];
<a name="l02848"></a>02848          d1[1] = u[k4+0];
<a name="l02849"></a>02849          d1[0] = u[k4+1];
<a name="l02850"></a>02850          d0[1] = u[k4+2];
<a name="l02851"></a>02851          d0[0] = u[k4+3];
<a name="l02852"></a>02852 
<a name="l02853"></a>02853          d0 -= 4;
<a name="l02854"></a>02854          d1 -= 4;
<a name="l02855"></a>02855          bitrev += 2;
<a name="l02856"></a>02856       }
<a name="l02857"></a>02857    }
<a name="l02858"></a>02858    <span class="comment">// (paper output is u, now v)</span>
<a name="l02859"></a>02859 
<a name="l02860"></a>02860 
<a name="l02861"></a>02861    <span class="comment">// data must be in buf2</span>
<a name="l02862"></a>02862    assert(v == buf2);
<a name="l02863"></a>02863 
<a name="l02864"></a>02864    <span class="comment">// step 7   (paper output is v, now v)</span>
<a name="l02865"></a>02865    <span class="comment">// this is now in place</span>
<a name="l02866"></a>02866    {
<a name="l02867"></a>02867       <span class="keywordtype">float</span> *C = f-&gt;C[blocktype];
<a name="l02868"></a>02868       <span class="keywordtype">float</span> *d, *e;
<a name="l02869"></a>02869 
<a name="l02870"></a>02870       d = v;
<a name="l02871"></a>02871       e = v + n2 - 4;
<a name="l02872"></a>02872 
<a name="l02873"></a>02873       <span class="keywordflow">while</span> (d &lt; e) {
<a name="l02874"></a>02874          <span class="keywordtype">float</span> a02,a11,b0,b1,b2,b3;
<a name="l02875"></a>02875 
<a name="l02876"></a>02876          a02 = d[0] - e[2];
<a name="l02877"></a>02877          a11 = d[1] + e[3];
<a name="l02878"></a>02878 
<a name="l02879"></a>02879          b0 = C[1]*a02 + C[0]*a11;
<a name="l02880"></a>02880          b1 = C[1]*a11 - C[0]*a02;
<a name="l02881"></a>02881 
<a name="l02882"></a>02882          b2 = d[0] + e[ 2];
<a name="l02883"></a>02883          b3 = d[1] - e[ 3];
<a name="l02884"></a>02884 
<a name="l02885"></a>02885          d[0] = b2 + b0;
<a name="l02886"></a>02886          d[1] = b3 + b1;
<a name="l02887"></a>02887          e[2] = b2 - b0;
<a name="l02888"></a>02888          e[3] = b1 - b3;
<a name="l02889"></a>02889 
<a name="l02890"></a>02890          a02 = d[2] - e[0];
<a name="l02891"></a>02891          a11 = d[3] + e[1];
<a name="l02892"></a>02892 
<a name="l02893"></a>02893          b0 = C[3]*a02 + C[2]*a11;
<a name="l02894"></a>02894          b1 = C[3]*a11 - C[2]*a02;
<a name="l02895"></a>02895 
<a name="l02896"></a>02896          b2 = d[2] + e[ 0];
<a name="l02897"></a>02897          b3 = d[3] - e[ 1];
<a name="l02898"></a>02898 
<a name="l02899"></a>02899          d[2] = b2 + b0;
<a name="l02900"></a>02900          d[3] = b3 + b1;
<a name="l02901"></a>02901          e[0] = b2 - b0;
<a name="l02902"></a>02902          e[1] = b1 - b3;
<a name="l02903"></a>02903 
<a name="l02904"></a>02904          C += 4;
<a name="l02905"></a>02905          d += 4;
<a name="l02906"></a>02906          e -= 4;
<a name="l02907"></a>02907       }
<a name="l02908"></a>02908    }
<a name="l02909"></a>02909 
<a name="l02910"></a>02910    <span class="comment">// data must be in buf2</span>
<a name="l02911"></a>02911 
<a name="l02912"></a>02912 
<a name="l02913"></a>02913    <span class="comment">// step 8+decode   (paper output is X, now buffer)</span>
<a name="l02914"></a>02914    <span class="comment">// this generates pairs of data a la 8 and pushes them directly through</span>
<a name="l02915"></a>02915    <span class="comment">// the decode kernel (pushing rather than pulling) to avoid having</span>
<a name="l02916"></a>02916    <span class="comment">// to make another pass later</span>
<a name="l02917"></a>02917 
<a name="l02918"></a>02918    <span class="comment">// this cannot POSSIBLY be in place, so we refer to the buffers directly</span>
<a name="l02919"></a>02919 
<a name="l02920"></a>02920    {
<a name="l02921"></a>02921       <span class="keywordtype">float</span> *d0,*d1,*d2,*d3;
<a name="l02922"></a>02922 
<a name="l02923"></a>02923       <span class="keywordtype">float</span> *B = f-&gt;B[blocktype] + n2 - 8;
<a name="l02924"></a>02924       <span class="keywordtype">float</span> *e = buf2 + n2 - 8;
<a name="l02925"></a>02925       d0 = &amp;buffer[0];
<a name="l02926"></a>02926       d1 = &amp;buffer[n2-4];
<a name="l02927"></a>02927       d2 = &amp;buffer[n2];
<a name="l02928"></a>02928       d3 = &amp;buffer[n-4];
<a name="l02929"></a>02929       <span class="keywordflow">while</span> (e &gt;= v) {
<a name="l02930"></a>02930          <span class="keywordtype">float</span> p0,p1,p2,p3;
<a name="l02931"></a>02931 
<a name="l02932"></a>02932          p3 =  e[6]*B[7] - e[7]*B[6];
<a name="l02933"></a>02933          p2 = -e[6]*B[6] - e[7]*B[7];
<a name="l02934"></a>02934 
<a name="l02935"></a>02935          d0[0] =   p3;
<a name="l02936"></a>02936          d1[3] = - p3;
<a name="l02937"></a>02937          d2[0] =   p2;
<a name="l02938"></a>02938          d3[3] =   p2;
<a name="l02939"></a>02939 
<a name="l02940"></a>02940          p1 =  e[4]*B[5] - e[5]*B[4];
<a name="l02941"></a>02941          p0 = -e[4]*B[4] - e[5]*B[5];
<a name="l02942"></a>02942 
<a name="l02943"></a>02943          d0[1] =   p1;
<a name="l02944"></a>02944          d1[2] = - p1;
<a name="l02945"></a>02945          d2[1] =   p0;
<a name="l02946"></a>02946          d3[2] =   p0;
<a name="l02947"></a>02947 
<a name="l02948"></a>02948          p3 =  e[2]*B[3] - e[3]*B[2];
<a name="l02949"></a>02949          p2 = -e[2]*B[2] - e[3]*B[3];
<a name="l02950"></a>02950 
<a name="l02951"></a>02951          d0[2] =   p3;
<a name="l02952"></a>02952          d1[1] = - p3;
<a name="l02953"></a>02953          d2[2] =   p2;
<a name="l02954"></a>02954          d3[1] =   p2;
<a name="l02955"></a>02955 
<a name="l02956"></a>02956          p1 =  e[0]*B[1] - e[1]*B[0];
<a name="l02957"></a>02957          p0 = -e[0]*B[0] - e[1]*B[1];
<a name="l02958"></a>02958 
<a name="l02959"></a>02959          d0[3] =   p1;
<a name="l02960"></a>02960          d1[0] = - p1;
<a name="l02961"></a>02961          d2[3] =   p0;
<a name="l02962"></a>02962          d3[0] =   p0;
<a name="l02963"></a>02963 
<a name="l02964"></a>02964          B -= 8;
<a name="l02965"></a>02965          e -= 8;
<a name="l02966"></a>02966          d0 += 4;
<a name="l02967"></a>02967          d2 += 4;
<a name="l02968"></a>02968          d1 -= 4;
<a name="l02969"></a>02969          d3 -= 4;
<a name="l02970"></a>02970       }
<a name="l02971"></a>02971    }
<a name="l02972"></a>02972 
<a name="l02973"></a>02973    <span class="comment">// temp_free(f,buf2);</span>
<a name="l02974"></a>02974    temp_alloc_restore(f,save_point);
<a name="l02975"></a>02975 }
<a name="l02976"></a>02976 
<a name="l02977"></a>02977 <span class="preprocessor">#if 0</span>
<a name="l02978"></a>02978 <span class="preprocessor"></span><span class="comment">// this is the original version of the above code, if you want to optimize it from scratch</span>
<a name="l02979"></a>02979 <span class="keywordtype">void</span> inverse_mdct_naive(<span class="keywordtype">float</span> *buffer, <span class="keywordtype">int</span> n)
<a name="l02980"></a>02980 {
<a name="l02981"></a>02981    <span class="keywordtype">float</span> s;
<a name="l02982"></a>02982    <span class="keywordtype">float</span> A[1 &lt;&lt; 12], B[1 &lt;&lt; 12], C[1 &lt;&lt; 11];
<a name="l02983"></a>02983    <span class="keywordtype">int</span> i,k,k2,k4, n2 = n &gt;&gt; 1, n4 = n &gt;&gt; 2, n8 = n &gt;&gt; 3, l;
<a name="l02984"></a>02984    <span class="keywordtype">int</span> n3_4 = n - n4, ld;
<a name="l02985"></a>02985    <span class="comment">// how can they claim this only uses N words?!</span>
<a name="l02986"></a>02986    <span class="comment">// oh, because they&#39;re only used sparsely, whoops</span>
<a name="l02987"></a>02987    <span class="keywordtype">float</span> u[1 &lt;&lt; 13], X[1 &lt;&lt; 13], v[1 &lt;&lt; 13], w[1 &lt;&lt; 13];
<a name="l02988"></a>02988    <span class="comment">// set up twiddle factors</span>
<a name="l02989"></a>02989 
<a name="l02990"></a>02990    <span class="keywordflow">for</span> (k=k2=0; k &lt; n4; ++k,k2+=2) {
<a name="l02991"></a>02991       A[k2  ] = (float)  cos(4*k*M_PI/n);
<a name="l02992"></a>02992       A[k2+1] = (float) -sin(4*k*M_PI/n);
<a name="l02993"></a>02993       B[k2  ] = (float)  cos((k2+1)*M_PI/n/2);
<a name="l02994"></a>02994       B[k2+1] = (float)  sin((k2+1)*M_PI/n/2);
<a name="l02995"></a>02995    }
<a name="l02996"></a>02996    <span class="keywordflow">for</span> (k=k2=0; k &lt; n8; ++k,k2+=2) {
<a name="l02997"></a>02997       C[k2  ] = (float)  cos(2*(k2+1)*M_PI/n);
<a name="l02998"></a>02998       C[k2+1] = (float) -sin(2*(k2+1)*M_PI/n);
<a name="l02999"></a>02999    }
<a name="l03000"></a>03000 
<a name="l03001"></a>03001    <span class="comment">// IMDCT algorithm from &quot;The use of multirate filter banks for coding of high quality digital audio&quot;</span>
<a name="l03002"></a>03002    <span class="comment">// Note there are bugs in that pseudocode, presumably due to them attempting</span>
<a name="l03003"></a>03003    <span class="comment">// to rename the arrays nicely rather than representing the way their actual</span>
<a name="l03004"></a>03004    <span class="comment">// implementation bounces buffers back and forth. As a result, even in the</span>
<a name="l03005"></a>03005    <span class="comment">// &quot;some formulars corrected&quot; version, a direct implementation fails. These</span>
<a name="l03006"></a>03006    <span class="comment">// are noted below as &quot;paper bug&quot;.</span>
<a name="l03007"></a>03007 
<a name="l03008"></a>03008    <span class="comment">// copy and reflect spectral data</span>
<a name="l03009"></a>03009    <span class="keywordflow">for</span> (k=0; k &lt; n2; ++k) u[k] = buffer[k];
<a name="l03010"></a>03010    <span class="keywordflow">for</span> (   ; k &lt; n ; ++k) u[k] = -buffer[n - k - 1];
<a name="l03011"></a>03011    <span class="comment">// kernel from paper</span>
<a name="l03012"></a>03012    <span class="comment">// step 1</span>
<a name="l03013"></a>03013    <span class="keywordflow">for</span> (k=k2=k4=0; k &lt; n4; k+=1, k2+=2, k4+=4) {
<a name="l03014"></a>03014       v[n-k4-1] = (u[k4] - u[n-k4-1]) * A[k2]   - (u[k4+2] - u[n-k4-3])*A[k2+1];
<a name="l03015"></a>03015       v[n-k4-3] = (u[k4] - u[n-k4-1]) * A[k2+1] + (u[k4+2] - u[n-k4-3])*A[k2];
<a name="l03016"></a>03016    }
<a name="l03017"></a>03017    <span class="comment">// step 2</span>
<a name="l03018"></a>03018    <span class="keywordflow">for</span> (k=k4=0; k &lt; n8; k+=1, k4+=4) {
<a name="l03019"></a>03019       w[n2+3+k4] = v[n2+3+k4] + v[k4+3];
<a name="l03020"></a>03020       w[n2+1+k4] = v[n2+1+k4] + v[k4+1];
<a name="l03021"></a>03021       w[k4+3]    = (v[n2+3+k4] - v[k4+3])*A[n2-4-k4] - (v[n2+1+k4]-v[k4+1])*A[n2-3-k4];
<a name="l03022"></a>03022       w[k4+1]    = (v[n2+1+k4] - v[k4+1])*A[n2-4-k4] + (v[n2+3+k4]-v[k4+3])*A[n2-3-k4];
<a name="l03023"></a>03023    }
<a name="l03024"></a>03024    <span class="comment">// step 3</span>
<a name="l03025"></a>03025    ld = ilog(n) - 1; <span class="comment">// ilog is off-by-one from normal definitions</span>
<a name="l03026"></a>03026    <span class="keywordflow">for</span> (l=0; l &lt; ld-3; ++l) {
<a name="l03027"></a>03027       <span class="keywordtype">int</span> k0 = n &gt;&gt; (l+2), k1 = 1 &lt;&lt; (l+3);
<a name="l03028"></a>03028       <span class="keywordtype">int</span> rlim = n &gt;&gt; (l+4), r4, r;
<a name="l03029"></a>03029       <span class="keywordtype">int</span> s2lim = 1 &lt;&lt; (l+2), s2;
<a name="l03030"></a>03030       <span class="keywordflow">for</span> (r=r4=0; r &lt; rlim; r4+=4,++r) {
<a name="l03031"></a>03031          <span class="keywordflow">for</span> (s2=0; s2 &lt; s2lim; s2+=2) {
<a name="l03032"></a>03032             u[n-1-k0*s2-r4] = w[n-1-k0*s2-r4] + w[n-1-k0*(s2+1)-r4];
<a name="l03033"></a>03033             u[n-3-k0*s2-r4] = w[n-3-k0*s2-r4] + w[n-3-k0*(s2+1)-r4];
<a name="l03034"></a>03034             u[n-1-k0*(s2+1)-r4] = (w[n-1-k0*s2-r4] - w[n-1-k0*(s2+1)-r4]) * A[r*k1]
<a name="l03035"></a>03035                                 - (w[n-3-k0*s2-r4] - w[n-3-k0*(s2+1)-r4]) * A[r*k1+1];
<a name="l03036"></a>03036             u[n-3-k0*(s2+1)-r4] = (w[n-3-k0*s2-r4] - w[n-3-k0*(s2+1)-r4]) * A[r*k1]
<a name="l03037"></a>03037                                 + (w[n-1-k0*s2-r4] - w[n-1-k0*(s2+1)-r4]) * A[r*k1+1];
<a name="l03038"></a>03038          }
<a name="l03039"></a>03039       }
<a name="l03040"></a>03040       <span class="keywordflow">if</span> (l+1 &lt; ld-3) {
<a name="l03041"></a>03041          <span class="comment">// paper bug: ping-ponging of u&amp;w here is omitted</span>
<a name="l03042"></a>03042          memcpy(w, u, <span class="keyword">sizeof</span>(u));
<a name="l03043"></a>03043       }
<a name="l03044"></a>03044    }
<a name="l03045"></a>03045 
<a name="l03046"></a>03046    <span class="comment">// step 4</span>
<a name="l03047"></a>03047    <span class="keywordflow">for</span> (i=0; i &lt; n8; ++i) {
<a name="l03048"></a>03048       <span class="keywordtype">int</span> j = bit_reverse(i) &gt;&gt; (32-ld+3);
<a name="l03049"></a>03049       assert(j &lt; n8);
<a name="l03050"></a>03050       <span class="keywordflow">if</span> (i == j) {
<a name="l03051"></a>03051          <span class="comment">// paper bug: original code probably swapped in place; if copying,</span>
<a name="l03052"></a>03052          <span class="comment">//            need to directly copy in this case</span>
<a name="l03053"></a>03053          <span class="keywordtype">int</span> i8 = i &lt;&lt; 3;
<a name="l03054"></a>03054          v[i8+1] = u[i8+1];
<a name="l03055"></a>03055          v[i8+3] = u[i8+3];
<a name="l03056"></a>03056          v[i8+5] = u[i8+5];
<a name="l03057"></a>03057          v[i8+7] = u[i8+7];
<a name="l03058"></a>03058       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i &lt; j) {
<a name="l03059"></a>03059          <span class="keywordtype">int</span> i8 = i &lt;&lt; 3, j8 = j &lt;&lt; 3;
<a name="l03060"></a>03060          v[j8+1] = u[i8+1], v[i8+1] = u[j8 + 1];
<a name="l03061"></a>03061          v[j8+3] = u[i8+3], v[i8+3] = u[j8 + 3];
<a name="l03062"></a>03062          v[j8+5] = u[i8+5], v[i8+5] = u[j8 + 5];
<a name="l03063"></a>03063          v[j8+7] = u[i8+7], v[i8+7] = u[j8 + 7];
<a name="l03064"></a>03064       }
<a name="l03065"></a>03065    }
<a name="l03066"></a>03066    <span class="comment">// step 5</span>
<a name="l03067"></a>03067    <span class="keywordflow">for</span> (k=0; k &lt; n2; ++k) {
<a name="l03068"></a>03068       w[k] = v[k*2+1];
<a name="l03069"></a>03069    }
<a name="l03070"></a>03070    <span class="comment">// step 6</span>
<a name="l03071"></a>03071    <span class="keywordflow">for</span> (k=k2=k4=0; k &lt; n8; ++k, k2 += 2, k4 += 4) {
<a name="l03072"></a>03072       u[n-1-k2] = w[k4];
<a name="l03073"></a>03073       u[n-2-k2] = w[k4+1];
<a name="l03074"></a>03074       u[n3_4 - 1 - k2] = w[k4+2];
<a name="l03075"></a>03075       u[n3_4 - 2 - k2] = w[k4+3];
<a name="l03076"></a>03076    }
<a name="l03077"></a>03077    <span class="comment">// step 7</span>
<a name="l03078"></a>03078    <span class="keywordflow">for</span> (k=k2=0; k &lt; n8; ++k, k2 += 2) {
<a name="l03079"></a>03079       v[n2 + k2 ] = ( u[n2 + k2] + u[n-2-k2] + C[k2+1]*(u[n2+k2]-u[n-2-k2]) + C[k2]*(u[n2+k2+1]+u[n-2-k2+1]))/2;
<a name="l03080"></a>03080       v[n-2 - k2] = ( u[n2 + k2] + u[n-2-k2] - C[k2+1]*(u[n2+k2]-u[n-2-k2]) - C[k2]*(u[n2+k2+1]+u[n-2-k2+1]))/2;
<a name="l03081"></a>03081       v[n2+1+ k2] = ( u[n2+1+k2] - u[n-1-k2] + C[k2+1]*(u[n2+1+k2]+u[n-1-k2]) - C[k2]*(u[n2+k2]-u[n-2-k2]))/2;
<a name="l03082"></a>03082       v[n-1 - k2] = (-u[n2+1+k2] + u[n-1-k2] + C[k2+1]*(u[n2+1+k2]+u[n-1-k2]) - C[k2]*(u[n2+k2]-u[n-2-k2]))/2;
<a name="l03083"></a>03083    }
<a name="l03084"></a>03084    <span class="comment">// step 8</span>
<a name="l03085"></a>03085    <span class="keywordflow">for</span> (k=k2=0; k &lt; n4; ++k,k2 += 2) {
<a name="l03086"></a>03086       X[k]      = v[k2+n2]*B[k2  ] + v[k2+1+n2]*B[k2+1];
<a name="l03087"></a>03087       X[n2-1-k] = v[k2+n2]*B[k2+1] - v[k2+1+n2]*B[k2  ];
<a name="l03088"></a>03088    }
<a name="l03089"></a>03089 
<a name="l03090"></a>03090    <span class="comment">// decode kernel to output</span>
<a name="l03091"></a>03091    <span class="comment">// determined the following value experimentally</span>
<a name="l03092"></a>03092    <span class="comment">// (by first figuring out what made inverse_mdct_slow work); then matching that here</span>
<a name="l03093"></a>03093    <span class="comment">// (probably vorbis encoder premultiplies by n or n/2, to save it on the decoder?)</span>
<a name="l03094"></a>03094    s = 0.5; <span class="comment">// theoretically would be n4</span>
<a name="l03095"></a>03095 
<a name="l03096"></a>03096    <span class="comment">// [[[ note! the s value of 0.5 is compensated for by the B[] in the current code,</span>
<a name="l03097"></a>03097    <span class="comment">//     so it needs to use the &quot;old&quot; B values to behave correctly, or else</span>
<a name="l03098"></a>03098    <span class="comment">//     set s to 1.0 ]]]</span>
<a name="l03099"></a>03099    <span class="keywordflow">for</span> (i=0; i &lt; n4  ; ++i) buffer[i] = s * X[i+n4];
<a name="l03100"></a>03100    <span class="keywordflow">for</span> (   ; i &lt; n3_4; ++i) buffer[i] = -s * X[n3_4 - i - 1];
<a name="l03101"></a>03101    <span class="keywordflow">for</span> (   ; i &lt; n   ; ++i) buffer[i] = -s * X[i - n3_4];
<a name="l03102"></a>03102 }
<a name="l03103"></a>03103 <span class="preprocessor">#endif</span>
<a name="l03104"></a>03104 <span class="preprocessor"></span>
<a name="l03105"></a>03105 <span class="keyword">static</span> <span class="keywordtype">float</span> *get_window(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> len)
<a name="l03106"></a>03106 {
<a name="l03107"></a>03107    len &lt;&lt;= 1;
<a name="l03108"></a>03108    <span class="keywordflow">if</span> (len == f-&gt;blocksize_0) <span class="keywordflow">return</span> f-&gt;window[0];
<a name="l03109"></a>03109    <span class="keywordflow">if</span> (len == f-&gt;blocksize_1) <span class="keywordflow">return</span> f-&gt;window[1];
<a name="l03110"></a>03110    <span class="keywordflow">return</span> NULL;
<a name="l03111"></a>03111 }
<a name="l03112"></a>03112 
<a name="l03113"></a>03113 <span class="preprocessor">#ifndef STB_VORBIS_NO_DEFER_FLOOR</span>
<a name="l03114"></a>03114 <span class="preprocessor"></span><span class="keyword">typedef</span> int16 YTYPE;
<a name="l03115"></a>03115 <span class="preprocessor">#else</span>
<a name="l03116"></a>03116 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">int</span> YTYPE;
<a name="l03117"></a>03117 <span class="preprocessor">#endif</span>
<a name="l03118"></a>03118 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> do_floor(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <a class="code" href="structMapping.html">Mapping</a> *map, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> n, <span class="keywordtype">float</span> *target, YTYPE *finalY, uint8 *step2_flag)
<a name="l03119"></a>03119 {
<a name="l03120"></a>03120    (void)step2_flag; 
<a name="l03121"></a>03121    <span class="keywordtype">int</span> n2 = n &gt;&gt; 1;
<a name="l03122"></a>03122    <span class="keywordtype">int</span> s = map-&gt;chan[i].mux, floor;
<a name="l03123"></a>03123    floor = map-&gt;submap_floor[s];
<a name="l03124"></a>03124    <span class="keywordflow">if</span> (f-&gt;floor_types[floor] == 0) {
<a name="l03125"></a>03125       <span class="keywordflow">return</span> error(f, VORBIS_invalid_stream);
<a name="l03126"></a>03126    } <span class="keywordflow">else</span> {
<a name="l03127"></a>03127       <a class="code" href="structFloor1.html">Floor1</a> *g = &amp;f-&gt;floor_config[floor].floor1;
<a name="l03128"></a>03128       <span class="keywordtype">int</span> j,q;
<a name="l03129"></a>03129       <span class="keywordtype">int</span> lx = 0, ly = finalY[0] * g-&gt;floor1_multiplier;
<a name="l03130"></a>03130       <span class="keywordflow">for</span> (q=1; q &lt; g-&gt;values; ++q) {
<a name="l03131"></a>03131          j = g-&gt;sorted_order[q];
<a name="l03132"></a>03132 <span class="preprocessor">         #ifndef STB_VORBIS_NO_DEFER_FLOOR</span>
<a name="l03133"></a>03133 <span class="preprocessor"></span>         <span class="keywordflow">if</span> (finalY[j] &gt;= 0)
<a name="l03134"></a>03134 <span class="preprocessor">         #else</span>
<a name="l03135"></a>03135 <span class="preprocessor"></span>         <span class="keywordflow">if</span> (step2_flag[j])
<a name="l03136"></a>03136 <span class="preprocessor">         #endif</span>
<a name="l03137"></a>03137 <span class="preprocessor"></span>         {
<a name="l03138"></a>03138             <span class="keywordtype">int</span> hy = finalY[j] * g-&gt;floor1_multiplier;
<a name="l03139"></a>03139             <span class="keywordtype">int</span> hx = g-&gt;Xlist[j];
<a name="l03140"></a>03140             <span class="keywordflow">if</span> (lx != hx)
<a name="l03141"></a>03141                draw_line(target, lx,ly, hx,hy, n2);
<a name="l03142"></a>03142             CHECK(f);
<a name="l03143"></a>03143             lx = hx, ly = hy;
<a name="l03144"></a>03144          }
<a name="l03145"></a>03145       }
<a name="l03146"></a>03146       <span class="keywordflow">if</span> (lx &lt; n2) {
<a name="l03147"></a>03147          <span class="comment">// optimization of: draw_line(target, lx,ly, n,ly, n2);</span>
<a name="l03148"></a>03148          <span class="keywordflow">for</span> (j=lx; j &lt; n2; ++j)
<a name="l03149"></a>03149             LINE_OP(target[j], inverse_db_table[ly]);
<a name="l03150"></a>03150          CHECK(f);
<a name="l03151"></a>03151       }
<a name="l03152"></a>03152    }
<a name="l03153"></a>03153    <span class="keywordflow">return</span> TRUE;
<a name="l03154"></a>03154 }
<a name="l03155"></a>03155 
<a name="l03156"></a>03156 <span class="comment">// The meaning of &quot;left&quot; and &quot;right&quot;</span>
<a name="l03157"></a>03157 <span class="comment">//</span>
<a name="l03158"></a>03158 <span class="comment">// For a given frame:</span>
<a name="l03159"></a>03159 <span class="comment">//     we compute samples from 0..n</span>
<a name="l03160"></a>03160 <span class="comment">//     window_center is n/2</span>
<a name="l03161"></a>03161 <span class="comment">//     we&#39;ll window and mix the samples from left_start to left_end with data from the previous frame</span>
<a name="l03162"></a>03162 <span class="comment">//     all of the samples from left_end to right_start can be output without mixing; however,</span>
<a name="l03163"></a>03163 <span class="comment">//        this interval is 0-length except when transitioning between short and long frames</span>
<a name="l03164"></a>03164 <span class="comment">//     all of the samples from right_start to right_end need to be mixed with the next frame,</span>
<a name="l03165"></a>03165 <span class="comment">//        which we don&#39;t have, so those get saved in a buffer</span>
<a name="l03166"></a>03166 <span class="comment">//     frame N&#39;s right_end-right_start, the number of samples to mix with the next frame,</span>
<a name="l03167"></a>03167 <span class="comment">//        has to be the same as frame N+1&#39;s left_end-left_start (which they are by</span>
<a name="l03168"></a>03168 <span class="comment">//        construction)</span>
<a name="l03169"></a>03169 
<a name="l03170"></a>03170 <span class="keyword">static</span> <span class="keywordtype">int</span> vorbis_decode_initial(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> *p_left_start, <span class="keywordtype">int</span> *p_left_end, <span class="keywordtype">int</span> *p_right_start, <span class="keywordtype">int</span> *p_right_end, <span class="keywordtype">int</span> *mode)
<a name="l03171"></a>03171 {
<a name="l03172"></a>03172    <a class="code" href="structMode.html">Mode</a> *m;
<a name="l03173"></a>03173    <span class="keywordtype">int</span> i, n, prev, next, window_center;
<a name="l03174"></a>03174    f-&gt;channel_buffer_start = f-&gt;channel_buffer_end = 0;
<a name="l03175"></a>03175 
<a name="l03176"></a>03176   retry:
<a name="l03177"></a>03177    <span class="keywordflow">if</span> (f-&gt;eof) <span class="keywordflow">return</span> FALSE;
<a name="l03178"></a>03178    <span class="keywordflow">if</span> (!maybe_start_packet(f))
<a name="l03179"></a>03179       <span class="keywordflow">return</span> FALSE;
<a name="l03180"></a>03180    <span class="comment">// check packet type</span>
<a name="l03181"></a>03181    <span class="keywordflow">if</span> (get_bits(f,1) != 0) {
<a name="l03182"></a>03182       <span class="keywordflow">if</span> (IS_PUSH_MODE(f))
<a name="l03183"></a>03183          <span class="keywordflow">return</span> error(f,VORBIS_bad_packet_type);
<a name="l03184"></a>03184       <span class="keywordflow">while</span> (EOP != get8_packet(f));
<a name="l03185"></a>03185       <span class="keywordflow">goto</span> retry;
<a name="l03186"></a>03186    }
<a name="l03187"></a>03187 
<a name="l03188"></a>03188    <span class="keywordflow">if</span> (f-&gt;alloc.alloc_buffer)
<a name="l03189"></a>03189       assert(f-&gt;alloc.alloc_buffer_length_in_bytes == f-&gt;temp_offset);
<a name="l03190"></a>03190 
<a name="l03191"></a>03191    i = get_bits(f, ilog(f-&gt;mode_count-1));
<a name="l03192"></a>03192    <span class="keywordflow">if</span> (i == EOP) <span class="keywordflow">return</span> FALSE;
<a name="l03193"></a>03193    <span class="keywordflow">if</span> (i &gt;= f-&gt;mode_count) <span class="keywordflow">return</span> FALSE;
<a name="l03194"></a>03194    *mode = i;
<a name="l03195"></a>03195    m = f-&gt;mode_config + i;
<a name="l03196"></a>03196    <span class="keywordflow">if</span> (m-&gt;blockflag) {
<a name="l03197"></a>03197       n = f-&gt;blocksize_1;
<a name="l03198"></a>03198       prev = get_bits(f,1);
<a name="l03199"></a>03199       next = get_bits(f,1);
<a name="l03200"></a>03200    } <span class="keywordflow">else</span> {
<a name="l03201"></a>03201       prev = next = 0;
<a name="l03202"></a>03202       n = f-&gt;blocksize_0;
<a name="l03203"></a>03203    }
<a name="l03204"></a>03204 
<a name="l03205"></a>03205 <span class="comment">// WINDOWING</span>
<a name="l03206"></a>03206 
<a name="l03207"></a>03207    window_center = n &gt;&gt; 1;
<a name="l03208"></a>03208    <span class="keywordflow">if</span> (m-&gt;blockflag &amp;&amp; !prev) {
<a name="l03209"></a>03209       *p_left_start = (n - f-&gt;blocksize_0) &gt;&gt; 2;
<a name="l03210"></a>03210       *p_left_end   = (n + f-&gt;blocksize_0) &gt;&gt; 2;
<a name="l03211"></a>03211    } <span class="keywordflow">else</span> {
<a name="l03212"></a>03212       *p_left_start = 0;
<a name="l03213"></a>03213       *p_left_end   = window_center;
<a name="l03214"></a>03214    }
<a name="l03215"></a>03215    <span class="keywordflow">if</span> (m-&gt;blockflag &amp;&amp; !next) {
<a name="l03216"></a>03216       *p_right_start = (n*3 - f-&gt;blocksize_0) &gt;&gt; 2;
<a name="l03217"></a>03217       *p_right_end   = (n*3 + f-&gt;blocksize_0) &gt;&gt; 2;
<a name="l03218"></a>03218    } <span class="keywordflow">else</span> {
<a name="l03219"></a>03219       *p_right_start = window_center;
<a name="l03220"></a>03220       *p_right_end   = n;
<a name="l03221"></a>03221    }
<a name="l03222"></a>03222 
<a name="l03223"></a>03223    <span class="keywordflow">return</span> TRUE;
<a name="l03224"></a>03224 }
<a name="l03225"></a>03225 
<a name="l03226"></a>03226 <span class="keyword">static</span> <span class="keywordtype">int</span> vorbis_decode_packet_rest(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> *len, <a class="code" href="structMode.html">Mode</a> *m, <span class="keywordtype">int</span> left_start, <span class="keywordtype">int</span> left_end, <span class="keywordtype">int</span> right_start, <span class="keywordtype">int</span> right_end, <span class="keywordtype">int</span> *p_left)
<a name="l03227"></a>03227 {
<a name="l03228"></a>03228    (void)left_end;
<a name="l03229"></a>03229    <a class="code" href="structMapping.html">Mapping</a> *map;
<a name="l03230"></a>03230    <span class="keywordtype">int</span> i,j,k,n,n2;
<a name="l03231"></a>03231    <span class="keywordtype">int</span> zero_channel[256];
<a name="l03232"></a>03232    <span class="keywordtype">int</span> really_zero_channel[256];
<a name="l03233"></a>03233 
<a name="l03234"></a>03234 <span class="comment">// WINDOWING</span>
<a name="l03235"></a>03235 
<a name="l03236"></a>03236    n = f-&gt;blocksize[m-&gt;blockflag];
<a name="l03237"></a>03237    map = &amp;f-&gt;mapping[m-&gt;mapping];
<a name="l03238"></a>03238 
<a name="l03239"></a>03239 <span class="comment">// FLOORS</span>
<a name="l03240"></a>03240    n2 = n &gt;&gt; 1;
<a name="l03241"></a>03241 
<a name="l03242"></a>03242    CHECK(f);
<a name="l03243"></a>03243 
<a name="l03244"></a>03244    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;channels; ++i) {
<a name="l03245"></a>03245       <span class="keywordtype">int</span> s = map-&gt;chan[i].mux, floor;
<a name="l03246"></a>03246       zero_channel[i] = FALSE;
<a name="l03247"></a>03247       floor = map-&gt;submap_floor[s];
<a name="l03248"></a>03248       <span class="keywordflow">if</span> (f-&gt;floor_types[floor] == 0) {
<a name="l03249"></a>03249          <span class="keywordflow">return</span> error(f, VORBIS_invalid_stream);
<a name="l03250"></a>03250       } <span class="keywordflow">else</span> {
<a name="l03251"></a>03251          <a class="code" href="structFloor1.html">Floor1</a> *g = &amp;f-&gt;floor_config[floor].floor1;
<a name="l03252"></a>03252          <span class="keywordflow">if</span> (get_bits(f, 1)) {
<a name="l03253"></a>03253             <span class="keywordtype">short</span> *finalY;
<a name="l03254"></a>03254             uint8 step2_flag[256];
<a name="l03255"></a>03255             <span class="keyword">static</span> <span class="keywordtype">int</span> range_list[4] = { 256, 128, 86, 64 };
<a name="l03256"></a>03256             <span class="keywordtype">int</span> range = range_list[g-&gt;floor1_multiplier-1];
<a name="l03257"></a>03257             <span class="keywordtype">int</span> offset = 2;
<a name="l03258"></a>03258             finalY = f-&gt;finalY[i];
<a name="l03259"></a>03259             finalY[0] = get_bits(f, ilog(range)-1);
<a name="l03260"></a>03260             finalY[1] = get_bits(f, ilog(range)-1);
<a name="l03261"></a>03261             <span class="keywordflow">for</span> (j=0; j &lt; g-&gt;partitions; ++j) {
<a name="l03262"></a>03262                <span class="keywordtype">int</span> pclass = g-&gt;partition_class_list[j];
<a name="l03263"></a>03263                <span class="keywordtype">int</span> cdim = g-&gt;class_dimensions[pclass];
<a name="l03264"></a>03264                <span class="keywordtype">int</span> cbits = g-&gt;class_subclasses[pclass];
<a name="l03265"></a>03265                <span class="keywordtype">int</span> csub = (1 &lt;&lt; cbits)-1;
<a name="l03266"></a>03266                <span class="keywordtype">int</span> cval = 0;
<a name="l03267"></a>03267                <span class="keywordflow">if</span> (cbits) {
<a name="l03268"></a>03268                   <a class="code" href="structCodebook.html">Codebook</a> *c = f-&gt;codebooks + g-&gt;class_masterbooks[pclass];
<a name="l03269"></a>03269                   DECODE(cval,f,c);
<a name="l03270"></a>03270                }
<a name="l03271"></a>03271                <span class="keywordflow">for</span> (k=0; k &lt; cdim; ++k) {
<a name="l03272"></a>03272                   <span class="keywordtype">int</span> book = g-&gt;subclass_books[pclass][cval &amp; csub];
<a name="l03273"></a>03273                   cval = cval &gt;&gt; cbits;
<a name="l03274"></a>03274                   <span class="keywordflow">if</span> (book &gt;= 0) {
<a name="l03275"></a>03275                      <span class="keywordtype">int</span> temp;
<a name="l03276"></a>03276                      <a class="code" href="structCodebook.html">Codebook</a> *c = f-&gt;codebooks + book;
<a name="l03277"></a>03277                      DECODE(temp,f,c);
<a name="l03278"></a>03278                      finalY[offset++] = temp;
<a name="l03279"></a>03279                   } <span class="keywordflow">else</span>
<a name="l03280"></a>03280                      finalY[offset++] = 0;
<a name="l03281"></a>03281                }
<a name="l03282"></a>03282             }
<a name="l03283"></a>03283             <span class="keywordflow">if</span> (f-&gt;valid_bits == INVALID_BITS) <span class="keywordflow">goto</span> error; <span class="comment">// behavior according to spec</span>
<a name="l03284"></a>03284             step2_flag[0] = step2_flag[1] = 1;
<a name="l03285"></a>03285             <span class="keywordflow">for</span> (j=2; j &lt; g-&gt;values; ++j) {
<a name="l03286"></a>03286                <span class="keywordtype">int</span> low, high, pred, highroom, lowroom, room, val;
<a name="l03287"></a>03287                low = g-&gt;neighbors[j][0];
<a name="l03288"></a>03288                high = g-&gt;neighbors[j][1];
<a name="l03289"></a>03289                <span class="comment">//neighbors(g-&gt;Xlist, j, &amp;low, &amp;high);</span>
<a name="l03290"></a>03290                pred = predict_point(g-&gt;Xlist[j], g-&gt;Xlist[low], g-&gt;Xlist[high], finalY[low], finalY[high]);
<a name="l03291"></a>03291                val = finalY[j];
<a name="l03292"></a>03292                highroom = range - pred;
<a name="l03293"></a>03293                lowroom = pred;
<a name="l03294"></a>03294                <span class="keywordflow">if</span> (highroom &lt; lowroom)
<a name="l03295"></a>03295                   room = highroom * 2;
<a name="l03296"></a>03296                <span class="keywordflow">else</span>
<a name="l03297"></a>03297                   room = lowroom * 2;
<a name="l03298"></a>03298                <span class="keywordflow">if</span> (val) {
<a name="l03299"></a>03299                   step2_flag[low] = step2_flag[high] = 1;
<a name="l03300"></a>03300                   step2_flag[j] = 1;
<a name="l03301"></a>03301                   <span class="keywordflow">if</span> (val &gt;= room) {
<a name="l03302"></a>03302                      <span class="keywordflow">if</span> (highroom &lt;= lowroom)
<a name="l03303"></a>03303                         finalY[j] = pred - val + highroom - 1;
<a name="l03304"></a>03304                   }
<a name="l03305"></a>03305                   <span class="keywordflow">else</span>
<a name="l03306"></a>03306                      <span class="keywordflow">if</span> (val &amp; 1)
<a name="l03307"></a>03307                         finalY[j] = pred - ((val+1)&gt;&gt;1);
<a name="l03308"></a>03308                      <span class="keywordflow">else</span>
<a name="l03309"></a>03309                         finalY[j] = pred + (val&gt;&gt;1);
<a name="l03310"></a>03310                } <span class="keywordflow">else</span> {
<a name="l03311"></a>03311                   step2_flag[j] = 0;
<a name="l03312"></a>03312                   finalY[j] = pred;
<a name="l03313"></a>03313                }
<a name="l03314"></a>03314             }
<a name="l03315"></a>03315 
<a name="l03316"></a>03316 <span class="preprocessor">#ifdef STB_VORBIS_NO_DEFER_FLOOR</span>
<a name="l03317"></a>03317 <span class="preprocessor"></span>            do_floor(f, map, i, n, f-&gt;floor_buffers[i], finalY, step2_flag);
<a name="l03318"></a>03318 <span class="preprocessor">#else</span>
<a name="l03319"></a>03319 <span class="preprocessor"></span>            <span class="comment">// defer final floor computation until _after_ residue</span>
<a name="l03320"></a>03320             <span class="keywordflow">for</span> (j=0; j &lt; g-&gt;values; ++j) {
<a name="l03321"></a>03321                <span class="keywordflow">if</span> (!step2_flag[j])
<a name="l03322"></a>03322                   finalY[j] = -1;
<a name="l03323"></a>03323             }
<a name="l03324"></a>03324 <span class="preprocessor">#endif</span>
<a name="l03325"></a>03325 <span class="preprocessor"></span>         } <span class="keywordflow">else</span> {
<a name="l03326"></a>03326            error:
<a name="l03327"></a>03327             zero_channel[i] = TRUE;
<a name="l03328"></a>03328          }
<a name="l03329"></a>03329          <span class="comment">// So we just defer everything else to later</span>
<a name="l03330"></a>03330 
<a name="l03331"></a>03331          <span class="comment">// at this point we&#39;ve decoded the floor into buffer</span>
<a name="l03332"></a>03332       }
<a name="l03333"></a>03333    }
<a name="l03334"></a>03334    CHECK(f);
<a name="l03335"></a>03335    <span class="comment">// at this point we&#39;ve decoded all floors</span>
<a name="l03336"></a>03336 
<a name="l03337"></a>03337    <span class="keywordflow">if</span> (f-&gt;alloc.alloc_buffer)
<a name="l03338"></a>03338       assert(f-&gt;alloc.alloc_buffer_length_in_bytes == f-&gt;temp_offset);
<a name="l03339"></a>03339 
<a name="l03340"></a>03340    <span class="comment">// re-enable coupled channels if necessary</span>
<a name="l03341"></a>03341    memcpy(really_zero_channel, zero_channel, <span class="keyword">sizeof</span>(really_zero_channel[0]) * f-&gt;channels);
<a name="l03342"></a>03342    <span class="keywordflow">for</span> (i=0; i &lt; map-&gt;coupling_steps; ++i)
<a name="l03343"></a>03343       <span class="keywordflow">if</span> (!zero_channel[map-&gt;chan[i].magnitude] || !zero_channel[map-&gt;chan[i].angle]) {
<a name="l03344"></a>03344          zero_channel[map-&gt;chan[i].magnitude] = zero_channel[map-&gt;chan[i].angle] = FALSE;
<a name="l03345"></a>03345       }
<a name="l03346"></a>03346 
<a name="l03347"></a>03347    CHECK(f);
<a name="l03348"></a>03348 <span class="comment">// RESIDUE DECODE</span>
<a name="l03349"></a>03349    <span class="keywordflow">for</span> (i=0; i &lt; map-&gt;submaps; ++i) {
<a name="l03350"></a>03350       <span class="keywordtype">float</span> *residue_buffers[STB_VORBIS_MAX_CHANNELS];
<a name="l03351"></a>03351       <span class="keywordtype">int</span> r;
<a name="l03352"></a>03352       uint8 do_not_decode[256];
<a name="l03353"></a>03353       <span class="keywordtype">int</span> ch = 0;
<a name="l03354"></a>03354       <span class="keywordflow">for</span> (j=0; j &lt; f-&gt;channels; ++j) {
<a name="l03355"></a>03355          <span class="keywordflow">if</span> (map-&gt;chan[j].mux == i) {
<a name="l03356"></a>03356             <span class="keywordflow">if</span> (zero_channel[j]) {
<a name="l03357"></a>03357                do_not_decode[ch] = TRUE;
<a name="l03358"></a>03358                residue_buffers[ch] = NULL;
<a name="l03359"></a>03359             } <span class="keywordflow">else</span> {
<a name="l03360"></a>03360                do_not_decode[ch] = FALSE;
<a name="l03361"></a>03361                residue_buffers[ch] = f-&gt;channel_buffers[j];
<a name="l03362"></a>03362             }
<a name="l03363"></a>03363             ++ch;
<a name="l03364"></a>03364          }
<a name="l03365"></a>03365       }
<a name="l03366"></a>03366       r = map-&gt;submap_residue[i];
<a name="l03367"></a>03367       decode_residue(f, residue_buffers, ch, n2, r, do_not_decode);
<a name="l03368"></a>03368    }
<a name="l03369"></a>03369 
<a name="l03370"></a>03370    <span class="keywordflow">if</span> (f-&gt;alloc.alloc_buffer)
<a name="l03371"></a>03371       assert(f-&gt;alloc.alloc_buffer_length_in_bytes == f-&gt;temp_offset);
<a name="l03372"></a>03372    CHECK(f);
<a name="l03373"></a>03373 
<a name="l03374"></a>03374 <span class="comment">// INVERSE COUPLING</span>
<a name="l03375"></a>03375    <span class="keywordflow">for</span> (i = map-&gt;coupling_steps-1; i &gt;= 0; --i) {
<a name="l03376"></a>03376       <span class="keywordtype">int</span> n2 = n &gt;&gt; 1;
<a name="l03377"></a>03377       <span class="keywordtype">float</span> *m = f-&gt;channel_buffers[map-&gt;chan[i].magnitude];
<a name="l03378"></a>03378       <span class="keywordtype">float</span> *a = f-&gt;channel_buffers[map-&gt;chan[i].angle    ];
<a name="l03379"></a>03379       <span class="keywordflow">for</span> (j=0; j &lt; n2; ++j) {
<a name="l03380"></a>03380          <span class="keywordtype">float</span> a2,m2;
<a name="l03381"></a>03381          <span class="keywordflow">if</span> (m[j] &gt; 0)
<a name="l03382"></a>03382             <span class="keywordflow">if</span> (a[j] &gt; 0)
<a name="l03383"></a>03383                m2 = m[j], a2 = m[j] - a[j];
<a name="l03384"></a>03384             <span class="keywordflow">else</span>
<a name="l03385"></a>03385                a2 = m[j], m2 = m[j] + a[j];
<a name="l03386"></a>03386          <span class="keywordflow">else</span>
<a name="l03387"></a>03387             <span class="keywordflow">if</span> (a[j] &gt; 0)
<a name="l03388"></a>03388                m2 = m[j], a2 = m[j] + a[j];
<a name="l03389"></a>03389             <span class="keywordflow">else</span>
<a name="l03390"></a>03390                a2 = m[j], m2 = m[j] - a[j];
<a name="l03391"></a>03391          m[j] = m2;
<a name="l03392"></a>03392          a[j] = a2;
<a name="l03393"></a>03393       }
<a name="l03394"></a>03394    }
<a name="l03395"></a>03395    CHECK(f);
<a name="l03396"></a>03396 
<a name="l03397"></a>03397    <span class="comment">// finish decoding the floors</span>
<a name="l03398"></a>03398 <span class="preprocessor">#ifndef STB_VORBIS_NO_DEFER_FLOOR</span>
<a name="l03399"></a>03399 <span class="preprocessor"></span>   <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;channels; ++i) {
<a name="l03400"></a>03400       <span class="keywordflow">if</span> (really_zero_channel[i]) {
<a name="l03401"></a>03401          memset(f-&gt;channel_buffers[i], 0, <span class="keyword">sizeof</span>(*f-&gt;channel_buffers[i]) * n2);
<a name="l03402"></a>03402       } <span class="keywordflow">else</span> {
<a name="l03403"></a>03403          do_floor(f, map, i, n, f-&gt;channel_buffers[i], f-&gt;finalY[i], NULL);
<a name="l03404"></a>03404       }
<a name="l03405"></a>03405    }
<a name="l03406"></a>03406 <span class="preprocessor">#else</span>
<a name="l03407"></a>03407 <span class="preprocessor"></span>   <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;channels; ++i) {
<a name="l03408"></a>03408       <span class="keywordflow">if</span> (really_zero_channel[i]) {
<a name="l03409"></a>03409          memset(f-&gt;channel_buffers[i], 0, <span class="keyword">sizeof</span>(*f-&gt;channel_buffers[i]) * n2);
<a name="l03410"></a>03410       } <span class="keywordflow">else</span> {
<a name="l03411"></a>03411          <span class="keywordflow">for</span> (j=0; j &lt; n2; ++j)
<a name="l03412"></a>03412             f-&gt;channel_buffers[i][j] *= f-&gt;floor_buffers[i][j];
<a name="l03413"></a>03413       }
<a name="l03414"></a>03414    }
<a name="l03415"></a>03415 <span class="preprocessor">#endif</span>
<a name="l03416"></a>03416 <span class="preprocessor"></span>
<a name="l03417"></a>03417 <span class="comment">// INVERSE MDCT</span>
<a name="l03418"></a>03418    CHECK(f);
<a name="l03419"></a>03419    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;channels; ++i)
<a name="l03420"></a>03420       inverse_mdct(f-&gt;channel_buffers[i], n, f, m-&gt;blockflag);
<a name="l03421"></a>03421    CHECK(f);
<a name="l03422"></a>03422 
<a name="l03423"></a>03423    <span class="comment">// this shouldn&#39;t be necessary, unless we exited on an error</span>
<a name="l03424"></a>03424    <span class="comment">// and want to flush to get to the next packet</span>
<a name="l03425"></a>03425    flush_packet(f);
<a name="l03426"></a>03426 
<a name="l03427"></a>03427    <span class="keywordflow">if</span> (f-&gt;first_decode) {
<a name="l03428"></a>03428       <span class="comment">// assume we start so first non-discarded sample is sample 0</span>
<a name="l03429"></a>03429       <span class="comment">// this isn&#39;t to spec, but spec would require us to read ahead</span>
<a name="l03430"></a>03430       <span class="comment">// and decode the size of all current frames--could be done,</span>
<a name="l03431"></a>03431       <span class="comment">// but presumably it&#39;s not a commonly used feature</span>
<a name="l03432"></a>03432       f-&gt;current_loc = -n2; <span class="comment">// start of first frame is positioned for discard</span>
<a name="l03433"></a>03433       <span class="comment">// we might have to discard samples &quot;from&quot; the next frame too,</span>
<a name="l03434"></a>03434       <span class="comment">// if we&#39;re lapping a large block then a small at the start?</span>
<a name="l03435"></a>03435       f-&gt;discard_samples_deferred = n - right_end;
<a name="l03436"></a>03436       f-&gt;current_loc_valid = TRUE;
<a name="l03437"></a>03437       f-&gt;first_decode = FALSE;
<a name="l03438"></a>03438    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (f-&gt;discard_samples_deferred) {
<a name="l03439"></a>03439       <span class="keywordflow">if</span> (f-&gt;discard_samples_deferred &gt;= right_start - left_start) {
<a name="l03440"></a>03440          f-&gt;discard_samples_deferred -= (right_start - left_start);
<a name="l03441"></a>03441          left_start = right_start;
<a name="l03442"></a>03442          *p_left = left_start;
<a name="l03443"></a>03443       } <span class="keywordflow">else</span> {
<a name="l03444"></a>03444          left_start += f-&gt;discard_samples_deferred;
<a name="l03445"></a>03445          *p_left = left_start;
<a name="l03446"></a>03446          f-&gt;discard_samples_deferred = 0;
<a name="l03447"></a>03447       }
<a name="l03448"></a>03448    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (f-&gt;previous_length == 0 &amp;&amp; f-&gt;current_loc_valid) {
<a name="l03449"></a>03449       <span class="comment">// we&#39;re recovering from a seek... that means we&#39;re going to discard</span>
<a name="l03450"></a>03450       <span class="comment">// the samples from this packet even though we know our position from</span>
<a name="l03451"></a>03451       <span class="comment">// the last page header, so we need to update the position based on</span>
<a name="l03452"></a>03452       <span class="comment">// the discarded samples here</span>
<a name="l03453"></a>03453       <span class="comment">// but wait, the code below is going to add this in itself even</span>
<a name="l03454"></a>03454       <span class="comment">// on a discard, so we don&#39;t need to do it here...</span>
<a name="l03455"></a>03455    }
<a name="l03456"></a>03456 
<a name="l03457"></a>03457    <span class="comment">// check if we have ogg information about the sample # for this packet</span>
<a name="l03458"></a>03458    <span class="keywordflow">if</span> (f-&gt;last_seg_which == f-&gt;end_seg_with_known_loc) {
<a name="l03459"></a>03459       <span class="comment">// if we have a valid current loc, and this is final:</span>
<a name="l03460"></a>03460       <span class="keywordflow">if</span> (f-&gt;current_loc_valid &amp;&amp; (f-&gt;page_flag &amp; PAGEFLAG_last_page)) {
<a name="l03461"></a>03461          uint32 current_end = f-&gt;known_loc_for_packet;
<a name="l03462"></a>03462          <span class="comment">// then let&#39;s infer the size of the (probably) short final frame</span>
<a name="l03463"></a>03463          <span class="keywordflow">if</span> (current_end &lt; f-&gt;current_loc + (right_end-left_start)) {
<a name="l03464"></a>03464             <span class="keywordflow">if</span> (current_end &lt; f-&gt;current_loc) {
<a name="l03465"></a>03465                <span class="comment">// negative truncation, that&#39;s impossible!</span>
<a name="l03466"></a>03466                *len = 0;
<a name="l03467"></a>03467             } <span class="keywordflow">else</span> {
<a name="l03468"></a>03468                *len = current_end - f-&gt;current_loc;
<a name="l03469"></a>03469             }
<a name="l03470"></a>03470             *len += left_start; <span class="comment">// this doesn&#39;t seem right, but has no ill effect on my test files</span>
<a name="l03471"></a>03471             <span class="keywordflow">if</span> (*len &gt; right_end) *len = right_end; <span class="comment">// this should never happen</span>
<a name="l03472"></a>03472             f-&gt;current_loc += *len;
<a name="l03473"></a>03473             <span class="keywordflow">return</span> TRUE;
<a name="l03474"></a>03474          }
<a name="l03475"></a>03475       }
<a name="l03476"></a>03476       <span class="comment">// otherwise, just set our sample loc</span>
<a name="l03477"></a>03477       <span class="comment">// guess that the ogg granule pos refers to the _middle_ of the</span>
<a name="l03478"></a>03478       <span class="comment">// last frame?</span>
<a name="l03479"></a>03479       <span class="comment">// set f-&gt;current_loc to the position of left_start</span>
<a name="l03480"></a>03480       f-&gt;current_loc = f-&gt;known_loc_for_packet - (n2-left_start);
<a name="l03481"></a>03481       f-&gt;current_loc_valid = TRUE;
<a name="l03482"></a>03482    }
<a name="l03483"></a>03483    <span class="keywordflow">if</span> (f-&gt;current_loc_valid)
<a name="l03484"></a>03484       f-&gt;current_loc += (right_start - left_start);
<a name="l03485"></a>03485 
<a name="l03486"></a>03486    <span class="keywordflow">if</span> (f-&gt;alloc.alloc_buffer)
<a name="l03487"></a>03487       assert(f-&gt;alloc.alloc_buffer_length_in_bytes == f-&gt;temp_offset);
<a name="l03488"></a>03488    *len = right_end;  <span class="comment">// ignore samples after the window goes to 0</span>
<a name="l03489"></a>03489    CHECK(f);
<a name="l03490"></a>03490 
<a name="l03491"></a>03491    <span class="keywordflow">return</span> TRUE;
<a name="l03492"></a>03492 }
<a name="l03493"></a>03493 
<a name="l03494"></a>03494 <span class="keyword">static</span> <span class="keywordtype">int</span> vorbis_decode_packet(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> *len, <span class="keywordtype">int</span> *p_left, <span class="keywordtype">int</span> *p_right)
<a name="l03495"></a>03495 {
<a name="l03496"></a>03496    <span class="keywordtype">int</span> mode, left_end, right_end;
<a name="l03497"></a>03497    <span class="keywordflow">if</span> (!vorbis_decode_initial(f, p_left, &amp;left_end, p_right, &amp;right_end, &amp;mode)) <span class="keywordflow">return</span> 0;
<a name="l03498"></a>03498    <span class="keywordflow">return</span> vorbis_decode_packet_rest(f, len, f-&gt;mode_config + mode, *p_left, left_end, *p_right, right_end, p_left);
<a name="l03499"></a>03499 }
<a name="l03500"></a>03500 
<a name="l03501"></a>03501 <span class="keyword">static</span> <span class="keywordtype">int</span> vorbis_finish_frame(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> len, <span class="keywordtype">int</span> left, <span class="keywordtype">int</span> right)
<a name="l03502"></a>03502 {
<a name="l03503"></a>03503    <span class="keywordtype">int</span> prev,i,j;
<a name="l03504"></a>03504    <span class="comment">// we use right&amp;left (the start of the right- and left-window sin()-regions)</span>
<a name="l03505"></a>03505    <span class="comment">// to determine how much to return, rather than inferring from the rules</span>
<a name="l03506"></a>03506    <span class="comment">// (same result, clearer code); &#39;left&#39; indicates where our sin() window</span>
<a name="l03507"></a>03507    <span class="comment">// starts, therefore where the previous window&#39;s right edge starts, and</span>
<a name="l03508"></a>03508    <span class="comment">// therefore where to start mixing from the previous buffer. &#39;right&#39;</span>
<a name="l03509"></a>03509    <span class="comment">// indicates where our sin() ending-window starts, therefore that&#39;s where</span>
<a name="l03510"></a>03510    <span class="comment">// we start saving, and where our returned-data ends.</span>
<a name="l03511"></a>03511 
<a name="l03512"></a>03512    <span class="comment">// mixin from previous window</span>
<a name="l03513"></a>03513    <span class="keywordflow">if</span> (f-&gt;previous_length) {
<a name="l03514"></a>03514       <span class="keywordtype">int</span> i,j, n = f-&gt;previous_length;
<a name="l03515"></a>03515       <span class="keywordtype">float</span> *w = get_window(f, n);
<a name="l03516"></a>03516       <span class="keywordflow">if</span> (w == NULL) <span class="keywordflow">return</span> 0;
<a name="l03517"></a>03517       <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;channels; ++i) {
<a name="l03518"></a>03518          <span class="keywordflow">for</span> (j=0; j &lt; n; ++j)
<a name="l03519"></a>03519             f-&gt;channel_buffers[i][left+j] =
<a name="l03520"></a>03520                f-&gt;channel_buffers[i][left+j]*w[    j] +
<a name="l03521"></a>03521                f-&gt;previous_window[i][     j]*w[n-1-j];
<a name="l03522"></a>03522       }
<a name="l03523"></a>03523    }
<a name="l03524"></a>03524 
<a name="l03525"></a>03525    prev = f-&gt;previous_length;
<a name="l03526"></a>03526 
<a name="l03527"></a>03527    <span class="comment">// last half of this data becomes previous window</span>
<a name="l03528"></a>03528    f-&gt;previous_length = len - right;
<a name="l03529"></a>03529 
<a name="l03530"></a>03530    <span class="comment">// @OPTIMIZE: could avoid this copy by double-buffering the</span>
<a name="l03531"></a>03531    <span class="comment">// output (flipping previous_window with channel_buffers), but</span>
<a name="l03532"></a>03532    <span class="comment">// then previous_window would have to be 2x as large, and</span>
<a name="l03533"></a>03533    <span class="comment">// channel_buffers couldn&#39;t be temp mem (although they&#39;re NOT</span>
<a name="l03534"></a>03534    <span class="comment">// currently temp mem, they could be (unless we want to level</span>
<a name="l03535"></a>03535    <span class="comment">// performance by spreading out the computation))</span>
<a name="l03536"></a>03536    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;channels; ++i)
<a name="l03537"></a>03537       <span class="keywordflow">for</span> (j=0; right+j &lt; len; ++j)
<a name="l03538"></a>03538          f-&gt;previous_window[i][j] = f-&gt;channel_buffers[i][right+j];
<a name="l03539"></a>03539 
<a name="l03540"></a>03540    if (!prev)
<a name="l03541"></a>03541       <span class="comment">// there was no previous packet, so this data isn&#39;t valid...</span>
<a name="l03542"></a>03542       <span class="comment">// this isn&#39;t entirely true, only the would-have-overlapped data</span>
<a name="l03543"></a>03543       <span class="comment">// isn&#39;t valid, but this seems to be what the spec requires</span>
<a name="l03544"></a>03544       <span class="keywordflow">return</span> 0;
<a name="l03545"></a>03545 
<a name="l03546"></a>03546    <span class="comment">// truncate a short frame</span>
<a name="l03547"></a>03547    <span class="keywordflow">if</span> (len &lt; right) right = len;
<a name="l03548"></a>03548 
<a name="l03549"></a>03549    f-&gt;samples_output += right-left;
<a name="l03550"></a>03550 
<a name="l03551"></a>03551    <span class="keywordflow">return</span> right - left;
<a name="l03552"></a>03552 }
<a name="l03553"></a>03553 
<a name="l03554"></a>03554 <span class="keyword">static</span> <span class="keywordtype">int</span> vorbis_pump_first_frame(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f)
<a name="l03555"></a>03555 {
<a name="l03556"></a>03556    <span class="keywordtype">int</span> len, right, left, res;
<a name="l03557"></a>03557    res = vorbis_decode_packet(f, &amp;len, &amp;left, &amp;right);
<a name="l03558"></a>03558    <span class="keywordflow">if</span> (res)
<a name="l03559"></a>03559       vorbis_finish_frame(f, len, left, right);
<a name="l03560"></a>03560    <span class="keywordflow">return</span> res;
<a name="l03561"></a>03561 }
<a name="l03562"></a>03562 
<a name="l03563"></a>03563 <span class="preprocessor">#ifndef STB_VORBIS_NO_PUSHDATA_API</span>
<a name="l03564"></a>03564 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> is_whole_packet_present(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f)
<a name="l03565"></a>03565 {
<a name="l03566"></a>03566    <span class="comment">// make sure that we have the packet available before continuing...</span>
<a name="l03567"></a>03567    <span class="comment">// this requires a full ogg parse, but we know we can fetch from f-&gt;stream</span>
<a name="l03568"></a>03568 
<a name="l03569"></a>03569    <span class="comment">// instead of coding this out explicitly, we could save the current read state,</span>
<a name="l03570"></a>03570    <span class="comment">// read the next packet with get8() until end-of-packet, check f-&gt;eof, then</span>
<a name="l03571"></a>03571    <span class="comment">// reset the state? but that would be slower, esp. since we&#39;d have over 256 bytes</span>
<a name="l03572"></a>03572    <span class="comment">// of state to restore (primarily the page segment table)</span>
<a name="l03573"></a>03573 
<a name="l03574"></a>03574    <span class="keywordtype">int</span> s = f-&gt;next_seg, first = TRUE;
<a name="l03575"></a>03575    uint8 *p = f-&gt;stream;
<a name="l03576"></a>03576 
<a name="l03577"></a>03577    <span class="keywordflow">if</span> (s != -1) { <span class="comment">// if we&#39;re not starting the packet with a &#39;continue on next page&#39; flag</span>
<a name="l03578"></a>03578       <span class="keywordflow">for</span> (; s &lt; f-&gt;segment_count; ++s) {
<a name="l03579"></a>03579          p += f-&gt;segments[s];
<a name="l03580"></a>03580          <span class="keywordflow">if</span> (f-&gt;segments[s] &lt; 255)               <span class="comment">// stop at first short segment</span>
<a name="l03581"></a>03581             <span class="keywordflow">break</span>;
<a name="l03582"></a>03582       }
<a name="l03583"></a>03583       <span class="comment">// either this continues, or it ends it...</span>
<a name="l03584"></a>03584       <span class="keywordflow">if</span> (s == f-&gt;segment_count)
<a name="l03585"></a>03585          s = -1; <span class="comment">// set &#39;crosses page&#39; flag</span>
<a name="l03586"></a>03586       <span class="keywordflow">if</span> (p &gt; f-&gt;stream_end)                     <span class="keywordflow">return</span> error(f, VORBIS_need_more_data);
<a name="l03587"></a>03587       first = FALSE;
<a name="l03588"></a>03588    }
<a name="l03589"></a>03589    <span class="keywordflow">for</span> (; s == -1;) {
<a name="l03590"></a>03590       uint8 *q;
<a name="l03591"></a>03591       <span class="keywordtype">int</span> n;
<a name="l03592"></a>03592 
<a name="l03593"></a>03593       <span class="comment">// check that we have the page header ready</span>
<a name="l03594"></a>03594       <span class="keywordflow">if</span> (p + 26 &gt;= f-&gt;stream_end)               <span class="keywordflow">return</span> error(f, VORBIS_need_more_data);
<a name="l03595"></a>03595       <span class="comment">// validate the page</span>
<a name="l03596"></a>03596       <span class="keywordflow">if</span> (memcmp(p, ogg_page_header, 4))         <span class="keywordflow">return</span> error(f, VORBIS_invalid_stream);
<a name="l03597"></a>03597       <span class="keywordflow">if</span> (p[4] != 0)                             <span class="keywordflow">return</span> error(f, VORBIS_invalid_stream);
<a name="l03598"></a>03598       <span class="keywordflow">if</span> (first) { <span class="comment">// the first segment must NOT have &#39;continued_packet&#39;, later ones MUST</span>
<a name="l03599"></a>03599          <span class="keywordflow">if</span> (f-&gt;previous_length)
<a name="l03600"></a>03600             <span class="keywordflow">if</span> ((p[5] &amp; PAGEFLAG_continued_packet))  <span class="keywordflow">return</span> error(f, VORBIS_invalid_stream);
<a name="l03601"></a>03601          <span class="comment">// if no previous length, we&#39;re resynching, so we can come in on a continued-packet,</span>
<a name="l03602"></a>03602          <span class="comment">// which we&#39;ll just drop</span>
<a name="l03603"></a>03603       } <span class="keywordflow">else</span> {
<a name="l03604"></a>03604          <span class="keywordflow">if</span> (!(p[5] &amp; PAGEFLAG_continued_packet)) <span class="keywordflow">return</span> error(f, VORBIS_invalid_stream);
<a name="l03605"></a>03605       }
<a name="l03606"></a>03606       n = p[26]; <span class="comment">// segment counts</span>
<a name="l03607"></a>03607       q = p+27;  <span class="comment">// q points to segment table</span>
<a name="l03608"></a>03608       p = q + n; <span class="comment">// advance past header</span>
<a name="l03609"></a>03609       <span class="comment">// make sure we&#39;ve read the segment table</span>
<a name="l03610"></a>03610       <span class="keywordflow">if</span> (p &gt; f-&gt;stream_end)                     <span class="keywordflow">return</span> error(f, VORBIS_need_more_data);
<a name="l03611"></a>03611       <span class="keywordflow">for</span> (s=0; s &lt; n; ++s) {
<a name="l03612"></a>03612          p += q[s];
<a name="l03613"></a>03613          <span class="keywordflow">if</span> (q[s] &lt; 255)
<a name="l03614"></a>03614             <span class="keywordflow">break</span>;
<a name="l03615"></a>03615       }
<a name="l03616"></a>03616       <span class="keywordflow">if</span> (s == n)
<a name="l03617"></a>03617          s = -1; <span class="comment">// set &#39;crosses page&#39; flag</span>
<a name="l03618"></a>03618       <span class="keywordflow">if</span> (p &gt; f-&gt;stream_end)                     <span class="keywordflow">return</span> error(f, VORBIS_need_more_data);
<a name="l03619"></a>03619       first = FALSE;
<a name="l03620"></a>03620    }
<a name="l03621"></a>03621    <span class="keywordflow">return</span> TRUE;
<a name="l03622"></a>03622 }
<a name="l03623"></a>03623 <span class="preprocessor">#endif // !STB_VORBIS_NO_PUSHDATA_API</span>
<a name="l03624"></a>03624 <span class="preprocessor"></span>
<a name="l03625"></a>03625 <span class="keyword">static</span> <span class="keywordtype">int</span> start_decoder(<a class="code" href="structstb__vorbis.html">vorb</a> *f)
<a name="l03626"></a>03626 {
<a name="l03627"></a>03627    uint8 header[6], x,y;
<a name="l03628"></a>03628    <span class="keywordtype">int</span> len,i,j,k, max_submaps = 0;
<a name="l03629"></a>03629    <span class="keywordtype">int</span> longest_floorlist=0;
<a name="l03630"></a>03630 
<a name="l03631"></a>03631    <span class="comment">// first page, first packet</span>
<a name="l03632"></a>03632    f-&gt;first_decode = TRUE;
<a name="l03633"></a>03633 
<a name="l03634"></a>03634    <span class="keywordflow">if</span> (!start_page(f))                              <span class="keywordflow">return</span> FALSE;
<a name="l03635"></a>03635    <span class="comment">// validate page flag</span>
<a name="l03636"></a>03636    <span class="keywordflow">if</span> (!(f-&gt;page_flag &amp; PAGEFLAG_first_page))       <span class="keywordflow">return</span> error(f, VORBIS_invalid_first_page);
<a name="l03637"></a>03637    <span class="keywordflow">if</span> (f-&gt;page_flag &amp; PAGEFLAG_last_page)           <span class="keywordflow">return</span> error(f, VORBIS_invalid_first_page);
<a name="l03638"></a>03638    <span class="keywordflow">if</span> (f-&gt;page_flag &amp; PAGEFLAG_continued_packet)    <span class="keywordflow">return</span> error(f, VORBIS_invalid_first_page);
<a name="l03639"></a>03639    <span class="comment">// check for expected packet length</span>
<a name="l03640"></a>03640    <span class="keywordflow">if</span> (f-&gt;segment_count != 1)                       <span class="keywordflow">return</span> error(f, VORBIS_invalid_first_page);
<a name="l03641"></a>03641    <span class="keywordflow">if</span> (f-&gt;segments[0] != 30) {
<a name="l03642"></a>03642       <span class="comment">// check for the Ogg skeleton fishead identifying header to refine our error</span>
<a name="l03643"></a>03643       <span class="keywordflow">if</span> (f-&gt;segments[0] == 64 &amp;&amp;
<a name="l03644"></a>03644           getn(f, header, 6) &amp;&amp;
<a name="l03645"></a>03645           header[0] == <span class="charliteral">&#39;f&#39;</span> &amp;&amp;
<a name="l03646"></a>03646           header[1] == <span class="charliteral">&#39;i&#39;</span> &amp;&amp;
<a name="l03647"></a>03647           header[2] == <span class="charliteral">&#39;s&#39;</span> &amp;&amp;
<a name="l03648"></a>03648           header[3] == <span class="charliteral">&#39;h&#39;</span> &amp;&amp;
<a name="l03649"></a>03649           header[4] == <span class="charliteral">&#39;e&#39;</span> &amp;&amp;
<a name="l03650"></a>03650           header[5] == <span class="charliteral">&#39;a&#39;</span> &amp;&amp;
<a name="l03651"></a>03651           get8(f)   == <span class="charliteral">&#39;d&#39;</span> &amp;&amp;
<a name="l03652"></a>03652           get8(f)   == <span class="charliteral">&#39;\0&#39;</span>)                        <span class="keywordflow">return</span> error(f, VORBIS_ogg_skeleton_not_supported);
<a name="l03653"></a>03653       <span class="keywordflow">else</span>
<a name="l03654"></a>03654                                                     <span class="keywordflow">return</span> error(f, VORBIS_invalid_first_page);
<a name="l03655"></a>03655    }
<a name="l03656"></a>03656 
<a name="l03657"></a>03657    <span class="comment">// read packet</span>
<a name="l03658"></a>03658    <span class="comment">// check packet header</span>
<a name="l03659"></a>03659    <span class="keywordflow">if</span> (get8(f) != VORBIS_packet_id)                 <span class="keywordflow">return</span> error(f, VORBIS_invalid_first_page);
<a name="l03660"></a>03660    <span class="keywordflow">if</span> (!getn(f, header, 6))                         <span class="keywordflow">return</span> error(f, VORBIS_unexpected_eof);
<a name="l03661"></a>03661    <span class="keywordflow">if</span> (!vorbis_validate(header))                    <span class="keywordflow">return</span> error(f, VORBIS_invalid_first_page);
<a name="l03662"></a>03662    <span class="comment">// vorbis_version</span>
<a name="l03663"></a>03663    <span class="keywordflow">if</span> (get32(f) != 0)                               <span class="keywordflow">return</span> error(f, VORBIS_invalid_first_page);
<a name="l03664"></a>03664    f-&gt;channels = get8(f); <span class="keywordflow">if</span> (!f-&gt;channels)         <span class="keywordflow">return</span> error(f, VORBIS_invalid_first_page);
<a name="l03665"></a>03665    <span class="keywordflow">if</span> (f-&gt;channels &gt; STB_VORBIS_MAX_CHANNELS)       <span class="keywordflow">return</span> error(f, VORBIS_too_many_channels);
<a name="l03666"></a>03666    f-&gt;sample_rate = get32(f); <span class="keywordflow">if</span> (!f-&gt;sample_rate)  <span class="keywordflow">return</span> error(f, VORBIS_invalid_first_page);
<a name="l03667"></a>03667    get32(f); <span class="comment">// bitrate_maximum</span>
<a name="l03668"></a>03668    get32(f); <span class="comment">// bitrate_nominal</span>
<a name="l03669"></a>03669    get32(f); <span class="comment">// bitrate_minimum</span>
<a name="l03670"></a>03670    x = get8(f);
<a name="l03671"></a>03671    {
<a name="l03672"></a>03672       <span class="keywordtype">int</span> log0,log1;
<a name="l03673"></a>03673       log0 = x &amp; 15;
<a name="l03674"></a>03674       log1 = x &gt;&gt; 4;
<a name="l03675"></a>03675       f-&gt;blocksize_0 = 1 &lt;&lt; log0;
<a name="l03676"></a>03676       f-&gt;blocksize_1 = 1 &lt;&lt; log1;
<a name="l03677"></a>03677       <span class="keywordflow">if</span> (log0 &lt; 6 || log0 &gt; 13)                       <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03678"></a>03678       <span class="keywordflow">if</span> (log1 &lt; 6 || log1 &gt; 13)                       <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03679"></a>03679       <span class="keywordflow">if</span> (log0 &gt; log1)                                 <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03680"></a>03680    }
<a name="l03681"></a>03681 
<a name="l03682"></a>03682    <span class="comment">// framing_flag</span>
<a name="l03683"></a>03683    x = get8(f);
<a name="l03684"></a>03684    <span class="keywordflow">if</span> (!(x &amp; 1))                                    <span class="keywordflow">return</span> error(f, VORBIS_invalid_first_page);
<a name="l03685"></a>03685 
<a name="l03686"></a>03686    <span class="comment">// second packet!</span>
<a name="l03687"></a>03687    <span class="keywordflow">if</span> (!start_page(f))                              <span class="keywordflow">return</span> FALSE;
<a name="l03688"></a>03688 
<a name="l03689"></a>03689    <span class="keywordflow">if</span> (!start_packet(f))                            <span class="keywordflow">return</span> FALSE;
<a name="l03690"></a>03690 
<a name="l03691"></a>03691    <span class="keywordflow">if</span> (!next_segment(f))                            <span class="keywordflow">return</span> FALSE;
<a name="l03692"></a>03692 
<a name="l03693"></a>03693    <span class="keywordflow">if</span> (get8_packet(f) != VORBIS_packet_comment)            <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03694"></a>03694    <span class="keywordflow">for</span> (i=0; i &lt; 6; ++i) header[i] = get8_packet(f);
<a name="l03695"></a>03695    <span class="keywordflow">if</span> (!vorbis_validate(header))                    <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03696"></a>03696    <span class="comment">//file vendor</span>
<a name="l03697"></a>03697    len = get32_packet(f);
<a name="l03698"></a>03698    f-&gt;vendor = (<span class="keywordtype">char</span>*)setup_malloc(f, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>) * (len+1));
<a name="l03699"></a>03699    <span class="keywordflow">for</span>(i=0; i &lt; len; ++i) {
<a name="l03700"></a>03700       f-&gt;vendor[i] = get8_packet(f);
<a name="l03701"></a>03701    }
<a name="l03702"></a>03702    f-&gt;vendor[len] = (char)<span class="charliteral">&#39;\0&#39;</span>;
<a name="l03703"></a>03703    <span class="comment">//user comments</span>
<a name="l03704"></a>03704    f-&gt;comment_list_length = get32_packet(f);
<a name="l03705"></a>03705    f-&gt;comment_list = (<span class="keywordtype">char</span>**)setup_malloc(f, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*) * (f-&gt;comment_list_length));
<a name="l03706"></a>03706 
<a name="l03707"></a>03707    <span class="keywordflow">for</span>(i=0; i &lt; f-&gt;comment_list_length; ++i) {
<a name="l03708"></a>03708       len = get32_packet(f);
<a name="l03709"></a>03709       f-&gt;comment_list[i] = (<span class="keywordtype">char</span>*)setup_malloc(f, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>) * (len+1));
<a name="l03710"></a>03710 
<a name="l03711"></a>03711       <span class="keywordflow">for</span>(j=0; j &lt; len; ++j) {
<a name="l03712"></a>03712          f-&gt;comment_list[i][j] = get8_packet(f);
<a name="l03713"></a>03713       }
<a name="l03714"></a>03714       f-&gt;comment_list[i][len] = (char)<span class="charliteral">&#39;\0&#39;</span>;
<a name="l03715"></a>03715    }
<a name="l03716"></a>03716 
<a name="l03717"></a>03717    <span class="comment">// framing_flag</span>
<a name="l03718"></a>03718    x = get8_packet(f);
<a name="l03719"></a>03719    <span class="keywordflow">if</span> (!(x &amp; 1))                                    <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03720"></a>03720 
<a name="l03721"></a>03721 
<a name="l03722"></a>03722    skip(f, f-&gt;bytes_in_seg);
<a name="l03723"></a>03723    f-&gt;bytes_in_seg = 0;
<a name="l03724"></a>03724 
<a name="l03725"></a>03725    <span class="keywordflow">do</span> {
<a name="l03726"></a>03726       len = next_segment(f);
<a name="l03727"></a>03727       skip(f, len);
<a name="l03728"></a>03728       f-&gt;bytes_in_seg = 0;
<a name="l03729"></a>03729    } <span class="keywordflow">while</span> (len);
<a name="l03730"></a>03730 
<a name="l03731"></a>03731    <span class="comment">// third packet!</span>
<a name="l03732"></a>03732    <span class="keywordflow">if</span> (!start_packet(f))                            <span class="keywordflow">return</span> FALSE;
<a name="l03733"></a>03733 
<a name="l03734"></a>03734 <span class="preprocessor">   #ifndef STB_VORBIS_NO_PUSHDATA_API</span>
<a name="l03735"></a>03735 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (IS_PUSH_MODE(f)) {
<a name="l03736"></a>03736       <span class="keywordflow">if</span> (!is_whole_packet_present(f)) {
<a name="l03737"></a>03737          <span class="comment">// convert error in ogg header to write type</span>
<a name="l03738"></a>03738          <span class="keywordflow">if</span> (f-&gt;error == VORBIS_invalid_stream)
<a name="l03739"></a>03739             f-&gt;error = VORBIS_invalid_setup;
<a name="l03740"></a>03740          <span class="keywordflow">return</span> FALSE;
<a name="l03741"></a>03741       }
<a name="l03742"></a>03742    }
<a name="l03743"></a>03743 <span class="preprocessor">   #endif</span>
<a name="l03744"></a>03744 <span class="preprocessor"></span>
<a name="l03745"></a>03745    crc32_init(); <span class="comment">// always init it, to avoid multithread race conditions</span>
<a name="l03746"></a>03746 
<a name="l03747"></a>03747    <span class="keywordflow">if</span> (get8_packet(f) != VORBIS_packet_setup)       <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03748"></a>03748    <span class="keywordflow">for</span> (i=0; i &lt; 6; ++i) header[i] = get8_packet(f);
<a name="l03749"></a>03749    <span class="keywordflow">if</span> (!vorbis_validate(header))                    <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03750"></a>03750 
<a name="l03751"></a>03751    <span class="comment">// codebooks</span>
<a name="l03752"></a>03752 
<a name="l03753"></a>03753    f-&gt;codebook_count = get_bits(f,8) + 1;
<a name="l03754"></a>03754    f-&gt;codebooks = (<a class="code" href="structCodebook.html">Codebook</a> *) setup_malloc(f, <span class="keyword">sizeof</span>(*f-&gt;codebooks) * f-&gt;codebook_count);
<a name="l03755"></a>03755    <span class="keywordflow">if</span> (f-&gt;codebooks == NULL)                        <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l03756"></a>03756    memset(f-&gt;codebooks, 0, <span class="keyword">sizeof</span>(*f-&gt;codebooks) * f-&gt;codebook_count);
<a name="l03757"></a>03757    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;codebook_count; ++i) {
<a name="l03758"></a>03758       uint32 *values;
<a name="l03759"></a>03759       <span class="keywordtype">int</span> ordered, sorted_count;
<a name="l03760"></a>03760       <span class="keywordtype">int</span> total=0;
<a name="l03761"></a>03761       uint8 *lengths;
<a name="l03762"></a>03762       <a class="code" href="structCodebook.html">Codebook</a> *c = f-&gt;codebooks+i;
<a name="l03763"></a>03763       CHECK(f);
<a name="l03764"></a>03764       x = get_bits(f, 8); <span class="keywordflow">if</span> (x != 0x42)            <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03765"></a>03765       x = get_bits(f, 8); <span class="keywordflow">if</span> (x != 0x43)            <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03766"></a>03766       x = get_bits(f, 8); <span class="keywordflow">if</span> (x != 0x56)            <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03767"></a>03767       x = get_bits(f, 8);
<a name="l03768"></a>03768       c-&gt;dimensions = (get_bits(f, 8)&lt;&lt;8) + x;
<a name="l03769"></a>03769       x = get_bits(f, 8);
<a name="l03770"></a>03770       y = get_bits(f, 8);
<a name="l03771"></a>03771       c-&gt;entries = (get_bits(f, 8)&lt;&lt;16) + (y&lt;&lt;8) + x;
<a name="l03772"></a>03772       ordered = get_bits(f,1);
<a name="l03773"></a>03773       c-&gt;sparse = ordered ? 0 : get_bits(f,1);
<a name="l03774"></a>03774 
<a name="l03775"></a>03775       <span class="keywordflow">if</span> (c-&gt;dimensions == 0 &amp;&amp; c-&gt;entries != 0)    <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03776"></a>03776 
<a name="l03777"></a>03777       <span class="keywordflow">if</span> (c-&gt;sparse)
<a name="l03778"></a>03778          lengths = (uint8 *) setup_temp_malloc(f, c-&gt;entries);
<a name="l03779"></a>03779       <span class="keywordflow">else</span>
<a name="l03780"></a>03780          lengths = c-&gt;codeword_lengths = (uint8 *) setup_malloc(f, c-&gt;entries);
<a name="l03781"></a>03781 
<a name="l03782"></a>03782       <span class="keywordflow">if</span> (!lengths) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l03783"></a>03783 
<a name="l03784"></a>03784       <span class="keywordflow">if</span> (ordered) {
<a name="l03785"></a>03785          <span class="keywordtype">int</span> current_entry = 0;
<a name="l03786"></a>03786          <span class="keywordtype">int</span> current_length = get_bits(f,5) + 1;
<a name="l03787"></a>03787          <span class="keywordflow">while</span> (current_entry &lt; c-&gt;entries) {
<a name="l03788"></a>03788             <span class="keywordtype">int</span> limit = c-&gt;entries - current_entry;
<a name="l03789"></a>03789             <span class="keywordtype">int</span> n = get_bits(f, ilog(limit));
<a name="l03790"></a>03790             <span class="keywordflow">if</span> (current_length &gt;= 32) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03791"></a>03791             <span class="keywordflow">if</span> (current_entry + n &gt; (<span class="keywordtype">int</span>) c-&gt;entries) { <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup); }
<a name="l03792"></a>03792             memset(lengths + current_entry, current_length, n);
<a name="l03793"></a>03793             current_entry += n;
<a name="l03794"></a>03794             ++current_length;
<a name="l03795"></a>03795          }
<a name="l03796"></a>03796       } <span class="keywordflow">else</span> {
<a name="l03797"></a>03797          <span class="keywordflow">for</span> (j=0; j &lt; c-&gt;entries; ++j) {
<a name="l03798"></a>03798             <span class="keywordtype">int</span> present = c-&gt;sparse ? get_bits(f,1) : 1;
<a name="l03799"></a>03799             <span class="keywordflow">if</span> (present) {
<a name="l03800"></a>03800                lengths[j] = get_bits(f, 5) + 1;
<a name="l03801"></a>03801                ++total;
<a name="l03802"></a>03802                <span class="keywordflow">if</span> (lengths[j] == 32)
<a name="l03803"></a>03803                   <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03804"></a>03804             } <span class="keywordflow">else</span> {
<a name="l03805"></a>03805                lengths[j] = NO_CODE;
<a name="l03806"></a>03806             }
<a name="l03807"></a>03807          }
<a name="l03808"></a>03808       }
<a name="l03809"></a>03809 
<a name="l03810"></a>03810       <span class="keywordflow">if</span> (c-&gt;sparse &amp;&amp; total &gt;= c-&gt;entries &gt;&gt; 2) {
<a name="l03811"></a>03811          <span class="comment">// convert sparse items to non-sparse!</span>
<a name="l03812"></a>03812          <span class="keywordflow">if</span> (c-&gt;entries &gt; (<span class="keywordtype">int</span>) f-&gt;setup_temp_memory_required)
<a name="l03813"></a>03813             f-&gt;setup_temp_memory_required = c-&gt;entries;
<a name="l03814"></a>03814 
<a name="l03815"></a>03815          c-&gt;codeword_lengths = (uint8 *) setup_malloc(f, c-&gt;entries);
<a name="l03816"></a>03816          <span class="keywordflow">if</span> (c-&gt;codeword_lengths == NULL) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l03817"></a>03817          memcpy(c-&gt;codeword_lengths, lengths, c-&gt;entries);
<a name="l03818"></a>03818          setup_temp_free(f, lengths, c-&gt;entries); <span class="comment">// note this is only safe if there have been no intervening temp mallocs!</span>
<a name="l03819"></a>03819          lengths = c-&gt;codeword_lengths;
<a name="l03820"></a>03820          c-&gt;sparse = 0;
<a name="l03821"></a>03821       }
<a name="l03822"></a>03822 
<a name="l03823"></a>03823       <span class="comment">// compute the size of the sorted tables</span>
<a name="l03824"></a>03824       <span class="keywordflow">if</span> (c-&gt;sparse) {
<a name="l03825"></a>03825          sorted_count = total;
<a name="l03826"></a>03826       } <span class="keywordflow">else</span> {
<a name="l03827"></a>03827          sorted_count = 0;
<a name="l03828"></a>03828 <span class="preprocessor">         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH</span>
<a name="l03829"></a>03829 <span class="preprocessor"></span>         <span class="keywordflow">for</span> (j=0; j &lt; c-&gt;entries; ++j)
<a name="l03830"></a>03830             <span class="keywordflow">if</span> (lengths[j] &gt; STB_VORBIS_FAST_HUFFMAN_LENGTH &amp;&amp; lengths[j] != NO_CODE)
<a name="l03831"></a>03831                ++sorted_count;
<a name="l03832"></a>03832 <span class="preprocessor">         #endif</span>
<a name="l03833"></a>03833 <span class="preprocessor"></span>      }
<a name="l03834"></a>03834 
<a name="l03835"></a>03835       c-&gt;sorted_entries = sorted_count;
<a name="l03836"></a>03836       values = NULL;
<a name="l03837"></a>03837 
<a name="l03838"></a>03838       CHECK(f);
<a name="l03839"></a>03839       <span class="keywordflow">if</span> (!c-&gt;sparse) {
<a name="l03840"></a>03840          c-&gt;codewords = (uint32 *) setup_malloc(f, <span class="keyword">sizeof</span>(c-&gt;codewords[0]) * c-&gt;entries);
<a name="l03841"></a>03841          <span class="keywordflow">if</span> (!c-&gt;codewords)                  <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l03842"></a>03842       } <span class="keywordflow">else</span> {
<a name="l03843"></a>03843          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size;
<a name="l03844"></a>03844          <span class="keywordflow">if</span> (c-&gt;sorted_entries) {
<a name="l03845"></a>03845             c-&gt;codeword_lengths = (uint8 *) setup_malloc(f, c-&gt;sorted_entries);
<a name="l03846"></a>03846             <span class="keywordflow">if</span> (!c-&gt;codeword_lengths)           <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l03847"></a>03847             c-&gt;codewords = (uint32 *) setup_temp_malloc(f, <span class="keyword">sizeof</span>(*c-&gt;codewords) * c-&gt;sorted_entries);
<a name="l03848"></a>03848             <span class="keywordflow">if</span> (!c-&gt;codewords)                  <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l03849"></a>03849             values = (uint32 *) setup_temp_malloc(f, <span class="keyword">sizeof</span>(*values) * c-&gt;sorted_entries);
<a name="l03850"></a>03850             <span class="keywordflow">if</span> (!values)                        <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l03851"></a>03851          }
<a name="l03852"></a>03852          size = c-&gt;entries + (<span class="keyword">sizeof</span>(*c-&gt;codewords) + <span class="keyword">sizeof</span>(*values)) * c-&gt;sorted_entries;
<a name="l03853"></a>03853          if (size &gt; f-&gt;setup_temp_memory_required)
<a name="l03854"></a>03854             f-&gt;setup_temp_memory_required = size;
<a name="l03855"></a>03855       }
<a name="l03856"></a>03856 
<a name="l03857"></a>03857       <span class="keywordflow">if</span> (!compute_codewords(c, lengths, c-&gt;entries, values)) {
<a name="l03858"></a>03858          <span class="keywordflow">if</span> (c-&gt;sparse) setup_temp_free(f, values, 0);
<a name="l03859"></a>03859          <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03860"></a>03860       }
<a name="l03861"></a>03861 
<a name="l03862"></a>03862       <span class="keywordflow">if</span> (c-&gt;sorted_entries) {
<a name="l03863"></a>03863          <span class="comment">// allocate an extra slot for sentinels</span>
<a name="l03864"></a>03864          c-&gt;sorted_codewords = (uint32 *) setup_malloc(f, <span class="keyword">sizeof</span>(*c-&gt;sorted_codewords) * (c-&gt;sorted_entries+1));
<a name="l03865"></a>03865          <span class="keywordflow">if</span> (c-&gt;sorted_codewords == NULL) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l03866"></a>03866          <span class="comment">// allocate an extra slot at the front so that c-&gt;sorted_values[-1] is defined</span>
<a name="l03867"></a>03867          <span class="comment">// so that we can catch that case without an extra if</span>
<a name="l03868"></a>03868          c-&gt;sorted_values    = ( <span class="keywordtype">int</span>   *) setup_malloc(f, <span class="keyword">sizeof</span>(*c-&gt;sorted_values   ) * (c-&gt;sorted_entries+1));
<a name="l03869"></a>03869          <span class="keywordflow">if</span> (c-&gt;sorted_values == NULL) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l03870"></a>03870          ++c-&gt;sorted_values;
<a name="l03871"></a>03871          c-&gt;sorted_values[-1] = -1;
<a name="l03872"></a>03872          compute_sorted_huffman(c, lengths, values);
<a name="l03873"></a>03873       }
<a name="l03874"></a>03874 
<a name="l03875"></a>03875       <span class="keywordflow">if</span> (c-&gt;sparse) {
<a name="l03876"></a>03876          setup_temp_free(f, values, <span class="keyword">sizeof</span>(*values)*c-&gt;sorted_entries);
<a name="l03877"></a>03877          setup_temp_free(f, c-&gt;codewords, <span class="keyword">sizeof</span>(*c-&gt;codewords)*c-&gt;sorted_entries);
<a name="l03878"></a>03878          setup_temp_free(f, lengths, c-&gt;entries);
<a name="l03879"></a>03879          c-&gt;codewords = NULL;
<a name="l03880"></a>03880       }
<a name="l03881"></a>03881 
<a name="l03882"></a>03882       compute_accelerated_huffman(c);
<a name="l03883"></a>03883 
<a name="l03884"></a>03884       CHECK(f);
<a name="l03885"></a>03885       c-&gt;lookup_type = get_bits(f, 4);
<a name="l03886"></a>03886       <span class="keywordflow">if</span> (c-&gt;lookup_type &gt; 2) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03887"></a>03887       <span class="keywordflow">if</span> (c-&gt;lookup_type &gt; 0) {
<a name="l03888"></a>03888          uint16 *mults;
<a name="l03889"></a>03889          c-&gt;minimum_value = float32_unpack(get_bits(f, 32));
<a name="l03890"></a>03890          c-&gt;delta_value = float32_unpack(get_bits(f, 32));
<a name="l03891"></a>03891          c-&gt;value_bits = get_bits(f, 4)+1;
<a name="l03892"></a>03892          c-&gt;sequence_p = get_bits(f,1);
<a name="l03893"></a>03893          <span class="keywordflow">if</span> (c-&gt;lookup_type == 1) {
<a name="l03894"></a>03894             <span class="keywordtype">int</span> values = lookup1_values(c-&gt;entries, c-&gt;dimensions);
<a name="l03895"></a>03895             <span class="keywordflow">if</span> (values &lt; 0) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03896"></a>03896             c-&gt;lookup_values = (uint32) values;
<a name="l03897"></a>03897          } <span class="keywordflow">else</span> {
<a name="l03898"></a>03898             c-&gt;lookup_values = c-&gt;entries * c-&gt;dimensions;
<a name="l03899"></a>03899          }
<a name="l03900"></a>03900          <span class="keywordflow">if</span> (c-&gt;lookup_values == 0) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03901"></a>03901          mults = (uint16 *) setup_temp_malloc(f, <span class="keyword">sizeof</span>(mults[0]) * c-&gt;lookup_values);
<a name="l03902"></a>03902          <span class="keywordflow">if</span> (mults == NULL) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l03903"></a>03903          <span class="keywordflow">for</span> (j=0; j &lt; (int) c-&gt;lookup_values; ++j) {
<a name="l03904"></a>03904             <span class="keywordtype">int</span> q = get_bits(f, c-&gt;value_bits);
<a name="l03905"></a>03905             <span class="keywordflow">if</span> (q == EOP) { setup_temp_free(f,mults,<span class="keyword">sizeof</span>(mults[0])*c-&gt;lookup_values); <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup); }
<a name="l03906"></a>03906             mults[j] = q;
<a name="l03907"></a>03907          }
<a name="l03908"></a>03908 
<a name="l03909"></a>03909 <span class="preprocessor">#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK</span>
<a name="l03910"></a>03910 <span class="preprocessor"></span>         <span class="keywordflow">if</span> (c-&gt;lookup_type == 1) {
<a name="l03911"></a>03911             <span class="keywordtype">int</span> len, sparse = c-&gt;sparse;
<a name="l03912"></a>03912             <span class="keywordtype">float</span> last=0;
<a name="l03913"></a>03913             <span class="comment">// pre-expand the lookup1-style multiplicands, to avoid a divide in the inner loop</span>
<a name="l03914"></a>03914             <span class="keywordflow">if</span> (sparse) {
<a name="l03915"></a>03915                <span class="keywordflow">if</span> (c-&gt;sorted_entries == 0) <span class="keywordflow">goto</span> skip;
<a name="l03916"></a>03916                c-&gt;multiplicands = (codetype *) setup_malloc(f, <span class="keyword">sizeof</span>(c-&gt;multiplicands[0]) * c-&gt;sorted_entries * c-&gt;dimensions);
<a name="l03917"></a>03917             } <span class="keywordflow">else</span>
<a name="l03918"></a>03918                c-&gt;multiplicands = (codetype *) setup_malloc(f, <span class="keyword">sizeof</span>(c-&gt;multiplicands[0]) * c-&gt;entries        * c-&gt;dimensions);
<a name="l03919"></a>03919             <span class="keywordflow">if</span> (c-&gt;multiplicands == NULL) { setup_temp_free(f,mults,<span class="keyword">sizeof</span>(mults[0])*c-&gt;lookup_values); <span class="keywordflow">return</span> error(f, VORBIS_outofmem); }
<a name="l03920"></a>03920             len = sparse ? c-&gt;sorted_entries : c-&gt;entries;
<a name="l03921"></a>03921             <span class="keywordflow">for</span> (j=0; j &lt; len; ++j) {
<a name="l03922"></a>03922                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = sparse ? c-&gt;sorted_values[j] : j;
<a name="l03923"></a>03923                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> div=1;
<a name="l03924"></a>03924                <span class="keywordflow">for</span> (k=0; k &lt; c-&gt;dimensions; ++k) {
<a name="l03925"></a>03925                   <span class="keywordtype">int</span> off = (z / div) % c-&gt;lookup_values;
<a name="l03926"></a>03926                   <span class="keyword">const</span> <span class="keywordtype">float</span> val = mults[off]*c-&gt;delta_value + c-&gt;minimum_value + last;
<a name="l03927"></a>03927                   c-&gt;multiplicands[j*c-&gt;dimensions + k] = val;
<a name="l03928"></a>03928                   if (c-&gt;sequence_p)
<a name="l03929"></a>03929                      last = val;
<a name="l03930"></a>03930                   <span class="keywordflow">if</span> (k+1 &lt; c-&gt;dimensions) {
<a name="l03931"></a>03931                      <span class="keywordflow">if</span> (div &gt; UINT_MAX / (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) c-&gt;lookup_values) {
<a name="l03932"></a>03932                         setup_temp_free(f, mults,<span class="keyword">sizeof</span>(mults[0])*c-&gt;lookup_values);
<a name="l03933"></a>03933                         <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03934"></a>03934                      }
<a name="l03935"></a>03935                      div *= c-&gt;lookup_values;
<a name="l03936"></a>03936                   }
<a name="l03937"></a>03937                }
<a name="l03938"></a>03938             }
<a name="l03939"></a>03939             c-&gt;lookup_type = 2;
<a name="l03940"></a>03940          }
<a name="l03941"></a>03941          <span class="keywordflow">else</span>
<a name="l03942"></a>03942 <span class="preprocessor">#endif</span>
<a name="l03943"></a>03943 <span class="preprocessor"></span>         {
<a name="l03944"></a>03944             <span class="keywordtype">float</span> last=0;
<a name="l03945"></a>03945             CHECK(f);
<a name="l03946"></a>03946             c-&gt;multiplicands = (codetype *) setup_malloc(f, <span class="keyword">sizeof</span>(c-&gt;multiplicands[0]) * c-&gt;lookup_values);
<a name="l03947"></a>03947             <span class="keywordflow">if</span> (c-&gt;multiplicands == NULL) { setup_temp_free(f, mults,<span class="keyword">sizeof</span>(mults[0])*c-&gt;lookup_values); <span class="keywordflow">return</span> error(f, VORBIS_outofmem); }
<a name="l03948"></a>03948             <span class="keywordflow">for</span> (j=0; j &lt; (int) c-&gt;lookup_values; ++j) {
<a name="l03949"></a>03949                <span class="keywordtype">float</span> val = mults[j] * c-&gt;delta_value + c-&gt;minimum_value + last;
<a name="l03950"></a>03950                c-&gt;multiplicands[j] = val;
<a name="l03951"></a>03951                <span class="keywordflow">if</span> (c-&gt;sequence_p)
<a name="l03952"></a>03952                   last = val;
<a name="l03953"></a>03953             }
<a name="l03954"></a>03954          }
<a name="l03955"></a>03955 <span class="preprocessor">#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK</span>
<a name="l03956"></a>03956 <span class="preprocessor"></span>        skip:;
<a name="l03957"></a>03957 <span class="preprocessor">#endif</span>
<a name="l03958"></a>03958 <span class="preprocessor"></span>         setup_temp_free(f, mults, <span class="keyword">sizeof</span>(mults[0])*c-&gt;lookup_values);
<a name="l03959"></a>03959 
<a name="l03960"></a>03960          CHECK(f);
<a name="l03961"></a>03961       }
<a name="l03962"></a>03962       CHECK(f);
<a name="l03963"></a>03963    }
<a name="l03964"></a>03964 
<a name="l03965"></a>03965    <span class="comment">// time domain transfers (notused)</span>
<a name="l03966"></a>03966 
<a name="l03967"></a>03967    x = get_bits(f, 6) + 1;
<a name="l03968"></a>03968    <span class="keywordflow">for</span> (i=0; i &lt; x; ++i) {
<a name="l03969"></a>03969       uint32 z = get_bits(f, 16);
<a name="l03970"></a>03970       <span class="keywordflow">if</span> (z != 0) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03971"></a>03971    }
<a name="l03972"></a>03972 
<a name="l03973"></a>03973    <span class="comment">// Floors</span>
<a name="l03974"></a>03974    f-&gt;floor_count = get_bits(f, 6)+1;
<a name="l03975"></a>03975    f-&gt;floor_config = (<a class="code" href="unionFloor.html">Floor</a> *)  setup_malloc(f, f-&gt;floor_count * <span class="keyword">sizeof</span>(*f-&gt;floor_config));
<a name="l03976"></a>03976    <span class="keywordflow">if</span> (f-&gt;floor_config == NULL) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l03977"></a>03977    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;floor_count; ++i) {
<a name="l03978"></a>03978       f-&gt;floor_types[i] = get_bits(f, 16);
<a name="l03979"></a>03979       <span class="keywordflow">if</span> (f-&gt;floor_types[i] &gt; 1) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l03980"></a>03980       <span class="keywordflow">if</span> (f-&gt;floor_types[i] == 0) {
<a name="l03981"></a>03981          <a class="code" href="structFloor0.html">Floor0</a> *g = &amp;f-&gt;floor_config[i].floor0;
<a name="l03982"></a>03982          g-&gt;order = get_bits(f,8);
<a name="l03983"></a>03983          g-&gt;rate = get_bits(f,16);
<a name="l03984"></a>03984          g-&gt;bark_map_size = get_bits(f,16);
<a name="l03985"></a>03985          g-&gt;amplitude_bits = get_bits(f,6);
<a name="l03986"></a>03986          g-&gt;amplitude_offset = get_bits(f,8);
<a name="l03987"></a>03987          g-&gt;number_of_books = get_bits(f,4) + 1;
<a name="l03988"></a>03988          <span class="keywordflow">for</span> (j=0; j &lt; g-&gt;number_of_books; ++j)
<a name="l03989"></a>03989             g-&gt;book_list[j] = get_bits(f,8);
<a name="l03990"></a>03990          <span class="keywordflow">return</span> error(f, VORBIS_feature_not_supported);
<a name="l03991"></a>03991       } <span class="keywordflow">else</span> {
<a name="l03992"></a>03992          <a class="code" href="structstbv____floor__ordering.html">stbv__floor_ordering</a> p[31*8+2];
<a name="l03993"></a>03993          <a class="code" href="structFloor1.html">Floor1</a> *g = &amp;f-&gt;floor_config[i].floor1;
<a name="l03994"></a>03994          <span class="keywordtype">int</span> max_class = -1;
<a name="l03995"></a>03995          g-&gt;partitions = get_bits(f, 5);
<a name="l03996"></a>03996          <span class="keywordflow">for</span> (j=0; j &lt; g-&gt;partitions; ++j) {
<a name="l03997"></a>03997             g-&gt;partition_class_list[j] = get_bits(f, 4);
<a name="l03998"></a>03998             <span class="keywordflow">if</span> (g-&gt;partition_class_list[j] &gt; max_class)
<a name="l03999"></a>03999                max_class = g-&gt;partition_class_list[j];
<a name="l04000"></a>04000          }
<a name="l04001"></a>04001          <span class="keywordflow">for</span> (j=0; j &lt;= max_class; ++j) {
<a name="l04002"></a>04002             g-&gt;class_dimensions[j] = get_bits(f, 3)+1;
<a name="l04003"></a>04003             g-&gt;class_subclasses[j] = get_bits(f, 2);
<a name="l04004"></a>04004             <span class="keywordflow">if</span> (g-&gt;class_subclasses[j]) {
<a name="l04005"></a>04005                g-&gt;class_masterbooks[j] = get_bits(f, 8);
<a name="l04006"></a>04006                <span class="keywordflow">if</span> (g-&gt;class_masterbooks[j] &gt;= f-&gt;codebook_count) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04007"></a>04007             }
<a name="l04008"></a>04008             <span class="keywordflow">for</span> (k=0; k &lt; 1 &lt;&lt; g-&gt;class_subclasses[j]; ++k) {
<a name="l04009"></a>04009                g-&gt;subclass_books[j][k] = get_bits(f,8)-1;
<a name="l04010"></a>04010                <span class="keywordflow">if</span> (g-&gt;subclass_books[j][k] &gt;= f-&gt;codebook_count) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04011"></a>04011             }
<a name="l04012"></a>04012          }
<a name="l04013"></a>04013          g-&gt;floor1_multiplier = get_bits(f,2)+1;
<a name="l04014"></a>04014          g-&gt;rangebits = get_bits(f,4);
<a name="l04015"></a>04015          g-&gt;Xlist[0] = 0;
<a name="l04016"></a>04016          g-&gt;Xlist[1] = 1 &lt;&lt; g-&gt;rangebits;
<a name="l04017"></a>04017          g-&gt;values = 2;
<a name="l04018"></a>04018          <span class="keywordflow">for</span> (j=0; j &lt; g-&gt;partitions; ++j) {
<a name="l04019"></a>04019             <span class="keywordtype">int</span> c = g-&gt;partition_class_list[j];
<a name="l04020"></a>04020             <span class="keywordflow">for</span> (k=0; k &lt; g-&gt;class_dimensions[c]; ++k) {
<a name="l04021"></a>04021                g-&gt;Xlist[g-&gt;values] = get_bits(f, g-&gt;rangebits);
<a name="l04022"></a>04022                ++g-&gt;values;
<a name="l04023"></a>04023             }
<a name="l04024"></a>04024          }
<a name="l04025"></a>04025          <span class="comment">// precompute the sorting</span>
<a name="l04026"></a>04026          <span class="keywordflow">for</span> (j=0; j &lt; g-&gt;values; ++j) {
<a name="l04027"></a>04027             p[j].x = g-&gt;Xlist[j];
<a name="l04028"></a>04028             p[j].id = j;
<a name="l04029"></a>04029          }
<a name="l04030"></a>04030          qsort(p, g-&gt;values, <span class="keyword">sizeof</span>(p[0]), point_compare);
<a name="l04031"></a>04031          <span class="keywordflow">for</span> (j=0; j &lt; g-&gt;values-1; ++j)
<a name="l04032"></a>04032             <span class="keywordflow">if</span> (p[j].x == p[j+1].x)
<a name="l04033"></a>04033                <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04034"></a>04034          <span class="keywordflow">for</span> (j=0; j &lt; g-&gt;values; ++j)
<a name="l04035"></a>04035             g-&gt;sorted_order[j] = (uint8) p[j].id;
<a name="l04036"></a>04036          <span class="comment">// precompute the neighbors</span>
<a name="l04037"></a>04037          <span class="keywordflow">for</span> (j=2; j &lt; g-&gt;values; ++j) {
<a name="l04038"></a>04038             <span class="keywordtype">int</span> low = 0,hi = 0;
<a name="l04039"></a>04039             neighbors(g-&gt;Xlist, j, &amp;low,&amp;hi);
<a name="l04040"></a>04040             g-&gt;neighbors[j][0] = low;
<a name="l04041"></a>04041             g-&gt;neighbors[j][1] = hi;
<a name="l04042"></a>04042          }
<a name="l04043"></a>04043 
<a name="l04044"></a>04044          <span class="keywordflow">if</span> (g-&gt;values &gt; longest_floorlist)
<a name="l04045"></a>04045             longest_floorlist = g-&gt;values;
<a name="l04046"></a>04046       }
<a name="l04047"></a>04047    }
<a name="l04048"></a>04048 
<a name="l04049"></a>04049    <span class="comment">// Residue</span>
<a name="l04050"></a>04050    f-&gt;residue_count = get_bits(f, 6)+1;
<a name="l04051"></a>04051    f-&gt;residue_config = (<a class="code" href="structResidue.html">Residue</a> *) setup_malloc(f, f-&gt;residue_count * <span class="keyword">sizeof</span>(f-&gt;residue_config[0]));
<a name="l04052"></a>04052    <span class="keywordflow">if</span> (f-&gt;residue_config == NULL) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l04053"></a>04053    memset(f-&gt;residue_config, 0, f-&gt;residue_count * <span class="keyword">sizeof</span>(f-&gt;residue_config[0]));
<a name="l04054"></a>04054    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;residue_count; ++i) {
<a name="l04055"></a>04055       uint8 residue_cascade[64];
<a name="l04056"></a>04056       <a class="code" href="structResidue.html">Residue</a> *r = f-&gt;residue_config+i;
<a name="l04057"></a>04057       f-&gt;residue_types[i] = get_bits(f, 16);
<a name="l04058"></a>04058       <span class="keywordflow">if</span> (f-&gt;residue_types[i] &gt; 2) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04059"></a>04059       r-&gt;begin = get_bits(f, 24);
<a name="l04060"></a>04060       r-&gt;end = get_bits(f, 24);
<a name="l04061"></a>04061       <span class="keywordflow">if</span> (r-&gt;end &lt; r-&gt;begin) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04062"></a>04062       r-&gt;part_size = get_bits(f,24)+1;
<a name="l04063"></a>04063       r-&gt;classifications = get_bits(f,6)+1;
<a name="l04064"></a>04064       r-&gt;classbook = get_bits(f,8);
<a name="l04065"></a>04065       <span class="keywordflow">if</span> (r-&gt;classbook &gt;= f-&gt;codebook_count) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04066"></a>04066       <span class="keywordflow">for</span> (j=0; j &lt; r-&gt;classifications; ++j) {
<a name="l04067"></a>04067          uint8 high_bits=0;
<a name="l04068"></a>04068          uint8 low_bits=get_bits(f,3);
<a name="l04069"></a>04069          <span class="keywordflow">if</span> (get_bits(f,1))
<a name="l04070"></a>04070             high_bits = get_bits(f,5);
<a name="l04071"></a>04071          residue_cascade[j] = high_bits*8 + low_bits;
<a name="l04072"></a>04072       }
<a name="l04073"></a>04073       r-&gt;residue_books = (short (*)[8]) setup_malloc(f, <span class="keyword">sizeof</span>(r-&gt;residue_books[0]) * r-&gt;classifications);
<a name="l04074"></a>04074       <span class="keywordflow">if</span> (r-&gt;residue_books == NULL) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l04075"></a>04075       <span class="keywordflow">for</span> (j=0; j &lt; r-&gt;classifications; ++j) {
<a name="l04076"></a>04076          <span class="keywordflow">for</span> (k=0; k &lt; 8; ++k) {
<a name="l04077"></a>04077             <span class="keywordflow">if</span> (residue_cascade[j] &amp; (1 &lt;&lt; k)) {
<a name="l04078"></a>04078                r-&gt;residue_books[j][k] = get_bits(f, 8);
<a name="l04079"></a>04079                <span class="keywordflow">if</span> (r-&gt;residue_books[j][k] &gt;= f-&gt;codebook_count) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04080"></a>04080             } <span class="keywordflow">else</span> {
<a name="l04081"></a>04081                r-&gt;residue_books[j][k] = -1;
<a name="l04082"></a>04082             }
<a name="l04083"></a>04083          }
<a name="l04084"></a>04084       }
<a name="l04085"></a>04085       <span class="comment">// precompute the classifications[] array to avoid inner-loop mod/divide</span>
<a name="l04086"></a>04086       <span class="comment">// call it &#39;classdata&#39; since we already have r-&gt;classifications</span>
<a name="l04087"></a>04087       r-&gt;classdata = (uint8 **) setup_malloc(f, <span class="keyword">sizeof</span>(*r-&gt;classdata) * f-&gt;codebooks[r-&gt;classbook].entries);
<a name="l04088"></a>04088       <span class="keywordflow">if</span> (!r-&gt;classdata) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l04089"></a>04089       memset(r-&gt;classdata, 0, <span class="keyword">sizeof</span>(*r-&gt;classdata) * f-&gt;codebooks[r-&gt;classbook].entries);
<a name="l04090"></a>04090       <span class="keywordflow">for</span> (j=0; j &lt; f-&gt;codebooks[r-&gt;classbook].entries; ++j) {
<a name="l04091"></a>04091          <span class="keywordtype">int</span> classwords = f-&gt;codebooks[r-&gt;classbook].dimensions;
<a name="l04092"></a>04092          <span class="keywordtype">int</span> temp = j;
<a name="l04093"></a>04093          r-&gt;classdata[j] = (uint8 *) setup_malloc(f, <span class="keyword">sizeof</span>(r-&gt;classdata[j][0]) * classwords);
<a name="l04094"></a>04094          <span class="keywordflow">if</span> (r-&gt;classdata[j] == NULL) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l04095"></a>04095          <span class="keywordflow">for</span> (k=classwords-1; k &gt;= 0; --k) {
<a name="l04096"></a>04096             r-&gt;classdata[j][k] = temp % r-&gt;classifications;
<a name="l04097"></a>04097             temp /= r-&gt;classifications;
<a name="l04098"></a>04098          }
<a name="l04099"></a>04099       }
<a name="l04100"></a>04100    }
<a name="l04101"></a>04101 
<a name="l04102"></a>04102    f-&gt;mapping_count = get_bits(f,6)+1;
<a name="l04103"></a>04103    f-&gt;mapping = (<a class="code" href="structMapping.html">Mapping</a> *) setup_malloc(f, f-&gt;mapping_count * <span class="keyword">sizeof</span>(*f-&gt;mapping));
<a name="l04104"></a>04104    <span class="keywordflow">if</span> (f-&gt;mapping == NULL) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l04105"></a>04105    memset(f-&gt;mapping, 0, f-&gt;mapping_count * <span class="keyword">sizeof</span>(*f-&gt;mapping));
<a name="l04106"></a>04106    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;mapping_count; ++i) {
<a name="l04107"></a>04107       <a class="code" href="structMapping.html">Mapping</a> *m = f-&gt;mapping + i;
<a name="l04108"></a>04108       <span class="keywordtype">int</span> mapping_type = get_bits(f,16);
<a name="l04109"></a>04109       <span class="keywordflow">if</span> (mapping_type != 0) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04110"></a>04110       m-&gt;chan = (<a class="code" href="structMappingChannel.html">MappingChannel</a> *) setup_malloc(f, f-&gt;channels * <span class="keyword">sizeof</span>(*m-&gt;chan));
<a name="l04111"></a>04111       <span class="keywordflow">if</span> (m-&gt;chan == NULL) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l04112"></a>04112       <span class="keywordflow">if</span> (get_bits(f,1))
<a name="l04113"></a>04113          m-&gt;submaps = get_bits(f,4)+1;
<a name="l04114"></a>04114       <span class="keywordflow">else</span>
<a name="l04115"></a>04115          m-&gt;submaps = 1;
<a name="l04116"></a>04116       <span class="keywordflow">if</span> (m-&gt;submaps &gt; max_submaps)
<a name="l04117"></a>04117          max_submaps = m-&gt;submaps;
<a name="l04118"></a>04118       <span class="keywordflow">if</span> (get_bits(f,1)) {
<a name="l04119"></a>04119          m-&gt;coupling_steps = get_bits(f,8)+1;
<a name="l04120"></a>04120          <span class="keywordflow">if</span> (m-&gt;coupling_steps &gt; f-&gt;channels) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04121"></a>04121          <span class="keywordflow">for</span> (k=0; k &lt; m-&gt;coupling_steps; ++k) {
<a name="l04122"></a>04122             m-&gt;chan[k].magnitude = get_bits(f, ilog(f-&gt;channels-1));
<a name="l04123"></a>04123             m-&gt;chan[k].angle = get_bits(f, ilog(f-&gt;channels-1));
<a name="l04124"></a>04124             <span class="keywordflow">if</span> (m-&gt;chan[k].magnitude &gt;= f-&gt;channels)        <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04125"></a>04125             <span class="keywordflow">if</span> (m-&gt;chan[k].angle     &gt;= f-&gt;channels)        <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04126"></a>04126             <span class="keywordflow">if</span> (m-&gt;chan[k].magnitude == m-&gt;chan[k].angle)   <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04127"></a>04127          }
<a name="l04128"></a>04128       } <span class="keywordflow">else</span>
<a name="l04129"></a>04129          m-&gt;coupling_steps = 0;
<a name="l04130"></a>04130 
<a name="l04131"></a>04131       <span class="comment">// reserved field</span>
<a name="l04132"></a>04132       <span class="keywordflow">if</span> (get_bits(f,2)) <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04133"></a>04133       <span class="keywordflow">if</span> (m-&gt;submaps &gt; 1) {
<a name="l04134"></a>04134          <span class="keywordflow">for</span> (j=0; j &lt; f-&gt;channels; ++j) {
<a name="l04135"></a>04135             m-&gt;chan[j].mux = get_bits(f, 4);
<a name="l04136"></a>04136             <span class="keywordflow">if</span> (m-&gt;chan[j].mux &gt;= m-&gt;submaps)                <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04137"></a>04137          }
<a name="l04138"></a>04138       } <span class="keywordflow">else</span>
<a name="l04139"></a>04139          <span class="comment">// @SPECIFICATION: this case is missing from the spec</span>
<a name="l04140"></a>04140          <span class="keywordflow">for</span> (j=0; j &lt; f-&gt;channels; ++j)
<a name="l04141"></a>04141             m-&gt;chan[j].mux = 0;
<a name="l04142"></a>04142 
<a name="l04143"></a>04143       for (j=0; j &lt; m-&gt;submaps; ++j) {
<a name="l04144"></a>04144          get_bits(f,8); <span class="comment">// discard</span>
<a name="l04145"></a>04145          m-&gt;submap_floor[j] = get_bits(f,8);
<a name="l04146"></a>04146          m-&gt;submap_residue[j] = get_bits(f,8);
<a name="l04147"></a>04147          <span class="keywordflow">if</span> (m-&gt;submap_floor[j] &gt;= f-&gt;floor_count)      <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04148"></a>04148          <span class="keywordflow">if</span> (m-&gt;submap_residue[j] &gt;= f-&gt;residue_count)  <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04149"></a>04149       }
<a name="l04150"></a>04150    }
<a name="l04151"></a>04151 
<a name="l04152"></a>04152    <span class="comment">// Modes</span>
<a name="l04153"></a>04153    f-&gt;mode_count = get_bits(f, 6)+1;
<a name="l04154"></a>04154    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;mode_count; ++i) {
<a name="l04155"></a>04155       <a class="code" href="structMode.html">Mode</a> *m = f-&gt;mode_config+i;
<a name="l04156"></a>04156       m-&gt;blockflag = get_bits(f,1);
<a name="l04157"></a>04157       m-&gt;windowtype = get_bits(f,16);
<a name="l04158"></a>04158       m-&gt;transformtype = get_bits(f,16);
<a name="l04159"></a>04159       m-&gt;mapping = get_bits(f,8);
<a name="l04160"></a>04160       <span class="keywordflow">if</span> (m-&gt;windowtype != 0)                 <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04161"></a>04161       <span class="keywordflow">if</span> (m-&gt;transformtype != 0)              <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04162"></a>04162       <span class="keywordflow">if</span> (m-&gt;mapping &gt;= f-&gt;mapping_count)     <span class="keywordflow">return</span> error(f, VORBIS_invalid_setup);
<a name="l04163"></a>04163    }
<a name="l04164"></a>04164 
<a name="l04165"></a>04165    flush_packet(f);
<a name="l04166"></a>04166 
<a name="l04167"></a>04167    f-&gt;previous_length = 0;
<a name="l04168"></a>04168 
<a name="l04169"></a>04169    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;channels; ++i) {
<a name="l04170"></a>04170       f-&gt;channel_buffers[i] = (<span class="keywordtype">float</span> *) setup_malloc(f, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * f-&gt;blocksize_1);
<a name="l04171"></a>04171       f-&gt;previous_window[i] = (<span class="keywordtype">float</span> *) setup_malloc(f, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * f-&gt;blocksize_1/2);
<a name="l04172"></a>04172       f-&gt;finalY[i]          = (int16 *) setup_malloc(f, <span class="keyword">sizeof</span>(int16) * longest_floorlist);
<a name="l04173"></a>04173       <span class="keywordflow">if</span> (f-&gt;channel_buffers[i] == NULL || f-&gt;previous_window[i] == NULL || f-&gt;finalY[i] == NULL) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l04174"></a>04174       memset(f-&gt;channel_buffers[i], 0, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * f-&gt;blocksize_1);
<a name="l04175"></a>04175 <span class="preprocessor">      #ifdef STB_VORBIS_NO_DEFER_FLOOR</span>
<a name="l04176"></a>04176 <span class="preprocessor"></span>      f-&gt;floor_buffers[i]   = (<span class="keywordtype">float</span> *) setup_malloc(f, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * f-&gt;blocksize_1/2);
<a name="l04177"></a>04177       <span class="keywordflow">if</span> (f-&gt;floor_buffers[i] == NULL) <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l04178"></a>04178 <span class="preprocessor">      #endif</span>
<a name="l04179"></a>04179 <span class="preprocessor"></span>   }
<a name="l04180"></a>04180 
<a name="l04181"></a>04181    <span class="keywordflow">if</span> (!init_blocksize(f, 0, f-&gt;blocksize_0)) <span class="keywordflow">return</span> FALSE;
<a name="l04182"></a>04182    <span class="keywordflow">if</span> (!init_blocksize(f, 1, f-&gt;blocksize_1)) <span class="keywordflow">return</span> FALSE;
<a name="l04183"></a>04183    f-&gt;blocksize[0] = f-&gt;blocksize_0;
<a name="l04184"></a>04184    f-&gt;blocksize[1] = f-&gt;blocksize_1;
<a name="l04185"></a>04185 
<a name="l04186"></a>04186 <span class="preprocessor">#ifdef STB_VORBIS_DIVIDE_TABLE</span>
<a name="l04187"></a>04187 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (integer_divide_table[1][1]==0)
<a name="l04188"></a>04188       <span class="keywordflow">for</span> (i=0; i &lt; DIVTAB_NUMER; ++i)
<a name="l04189"></a>04189          <span class="keywordflow">for</span> (j=1; j &lt; DIVTAB_DENOM; ++j)
<a name="l04190"></a>04190             integer_divide_table[i][j] = i / j;
<a name="l04191"></a>04191 <span class="preprocessor">#endif</span>
<a name="l04192"></a>04192 <span class="preprocessor"></span>
<a name="l04193"></a>04193    <span class="comment">// compute how much temporary memory is needed</span>
<a name="l04194"></a>04194 
<a name="l04195"></a>04195    <span class="comment">// 1.</span>
<a name="l04196"></a>04196    {
<a name="l04197"></a>04197       uint32 imdct_mem = (f-&gt;blocksize_1 * <span class="keyword">sizeof</span>(float) &gt;&gt; 1);
<a name="l04198"></a>04198       uint32 classify_mem;
<a name="l04199"></a>04199       <span class="keywordtype">int</span> i,max_part_read=0;
<a name="l04200"></a>04200       <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;residue_count; ++i) {
<a name="l04201"></a>04201          <a class="code" href="structResidue.html">Residue</a> *r = f-&gt;residue_config + i;
<a name="l04202"></a>04202          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> actual_size = f-&gt;blocksize_1 / 2;
<a name="l04203"></a>04203          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> limit_r_begin = r-&gt;begin &lt; actual_size ? r-&gt;begin : actual_size;
<a name="l04204"></a>04204          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> limit_r_end   = r-&gt;end   &lt; actual_size ? r-&gt;end   : actual_size;
<a name="l04205"></a>04205          <span class="keywordtype">int</span> n_read = limit_r_end - limit_r_begin;
<a name="l04206"></a>04206          <span class="keywordtype">int</span> part_read = n_read / r-&gt;part_size;
<a name="l04207"></a>04207          <span class="keywordflow">if</span> (part_read &gt; max_part_read)
<a name="l04208"></a>04208             max_part_read = part_read;
<a name="l04209"></a>04209       }
<a name="l04210"></a>04210 <span class="preprocessor">      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE</span>
<a name="l04211"></a>04211 <span class="preprocessor"></span>      classify_mem = f-&gt;channels * (<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) + max_part_read * <span class="keyword">sizeof</span>(uint8 *));
<a name="l04212"></a>04212 <span class="preprocessor">      #else</span>
<a name="l04213"></a>04213 <span class="preprocessor"></span>      classify_mem = f-&gt;channels * (<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) + max_part_read * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span> *));
<a name="l04214"></a>04214 <span class="preprocessor">      #endif</span>
<a name="l04215"></a>04215 <span class="preprocessor"></span>
<a name="l04216"></a>04216       <span class="comment">// maximum reasonable partition size is f-&gt;blocksize_1</span>
<a name="l04217"></a>04217 
<a name="l04218"></a>04218       f-&gt;temp_memory_required = classify_mem;
<a name="l04219"></a>04219       <span class="keywordflow">if</span> (imdct_mem &gt; f-&gt;temp_memory_required)
<a name="l04220"></a>04220          f-&gt;temp_memory_required = imdct_mem;
<a name="l04221"></a>04221    }
<a name="l04222"></a>04222 
<a name="l04223"></a>04223 
<a name="l04224"></a>04224    <span class="keywordflow">if</span> (f-&gt;alloc.alloc_buffer) {
<a name="l04225"></a>04225       assert(f-&gt;temp_offset == f-&gt;alloc.alloc_buffer_length_in_bytes);
<a name="l04226"></a>04226       <span class="comment">// check if there&#39;s enough temp memory so we don&#39;t error later</span>
<a name="l04227"></a>04227       <span class="keywordflow">if</span> (f-&gt;setup_offset + <span class="keyword">sizeof</span>(*f) + f-&gt;temp_memory_required &gt; (<span class="keywordtype">unsigned</span>) f-&gt;temp_offset)
<a name="l04228"></a>04228          <span class="keywordflow">return</span> error(f, VORBIS_outofmem);
<a name="l04229"></a>04229    }
<a name="l04230"></a>04230 
<a name="l04231"></a>04231    <span class="comment">// @TODO: stb_vorbis_seek_start expects first_audio_page_offset to point to a page</span>
<a name="l04232"></a>04232    <span class="comment">// without PAGEFLAG_continued_packet, so this either points to the first page, or</span>
<a name="l04233"></a>04233    <span class="comment">// the page after the end of the headers. It might be cleaner to point to a page</span>
<a name="l04234"></a>04234    <span class="comment">// in the middle of the headers, when that&#39;s the page where the first audio packet</span>
<a name="l04235"></a>04235    <span class="comment">// starts, but we&#39;d have to also correctly skip the end of any continued packet in</span>
<a name="l04236"></a>04236    <span class="comment">// stb_vorbis_seek_start.</span>
<a name="l04237"></a>04237    <span class="keywordflow">if</span> (f-&gt;next_seg == -1) {
<a name="l04238"></a>04238       f-&gt;first_audio_page_offset = stb_vorbis_get_file_offset(f);
<a name="l04239"></a>04239    } <span class="keywordflow">else</span> {
<a name="l04240"></a>04240       f-&gt;first_audio_page_offset = 0;
<a name="l04241"></a>04241    }
<a name="l04242"></a>04242 
<a name="l04243"></a>04243    <span class="keywordflow">return</span> TRUE;
<a name="l04244"></a>04244 }
<a name="l04245"></a>04245 
<a name="l04246"></a>04246 <span class="keyword">static</span> <span class="keywordtype">void</span> vorbis_deinit(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *p)
<a name="l04247"></a>04247 {
<a name="l04248"></a>04248    <span class="keywordtype">int</span> i,j;
<a name="l04249"></a>04249 
<a name="l04250"></a>04250    setup_free(p, p-&gt;vendor);
<a name="l04251"></a>04251    <span class="keywordflow">for</span> (i=0; i &lt; p-&gt;comment_list_length; ++i) {
<a name="l04252"></a>04252       setup_free(p, p-&gt;comment_list[i]);
<a name="l04253"></a>04253    }
<a name="l04254"></a>04254    setup_free(p, p-&gt;comment_list);
<a name="l04255"></a>04255 
<a name="l04256"></a>04256    <span class="keywordflow">if</span> (p-&gt;residue_config) {
<a name="l04257"></a>04257       <span class="keywordflow">for</span> (i=0; i &lt; p-&gt;residue_count; ++i) {
<a name="l04258"></a>04258          <a class="code" href="structResidue.html">Residue</a> *r = p-&gt;residue_config+i;
<a name="l04259"></a>04259          <span class="keywordflow">if</span> (r-&gt;classdata) {
<a name="l04260"></a>04260             <span class="keywordflow">for</span> (j=0; j &lt; p-&gt;codebooks[r-&gt;classbook].entries; ++j)
<a name="l04261"></a>04261                setup_free(p, r-&gt;classdata[j]);
<a name="l04262"></a>04262             setup_free(p, r-&gt;classdata);
<a name="l04263"></a>04263          }
<a name="l04264"></a>04264          setup_free(p, r-&gt;residue_books);
<a name="l04265"></a>04265       }
<a name="l04266"></a>04266    }
<a name="l04267"></a>04267 
<a name="l04268"></a>04268    <span class="keywordflow">if</span> (p-&gt;codebooks) {
<a name="l04269"></a>04269       CHECK(p);
<a name="l04270"></a>04270       <span class="keywordflow">for</span> (i=0; i &lt; p-&gt;codebook_count; ++i) {
<a name="l04271"></a>04271          <a class="code" href="structCodebook.html">Codebook</a> *c = p-&gt;codebooks + i;
<a name="l04272"></a>04272          setup_free(p, c-&gt;codeword_lengths);
<a name="l04273"></a>04273          setup_free(p, c-&gt;multiplicands);
<a name="l04274"></a>04274          setup_free(p, c-&gt;codewords);
<a name="l04275"></a>04275          setup_free(p, c-&gt;sorted_codewords);
<a name="l04276"></a>04276          <span class="comment">// c-&gt;sorted_values[-1] is the first entry in the array</span>
<a name="l04277"></a>04277          setup_free(p, c-&gt;sorted_values ? c-&gt;sorted_values-1 : NULL);
<a name="l04278"></a>04278       }
<a name="l04279"></a>04279       setup_free(p, p-&gt;codebooks);
<a name="l04280"></a>04280    }
<a name="l04281"></a>04281    setup_free(p, p-&gt;floor_config);
<a name="l04282"></a>04282    setup_free(p, p-&gt;residue_config);
<a name="l04283"></a>04283    <span class="keywordflow">if</span> (p-&gt;mapping) {
<a name="l04284"></a>04284       <span class="keywordflow">for</span> (i=0; i &lt; p-&gt;mapping_count; ++i)
<a name="l04285"></a>04285          setup_free(p, p-&gt;mapping[i].chan);
<a name="l04286"></a>04286       setup_free(p, p-&gt;mapping);
<a name="l04287"></a>04287    }
<a name="l04288"></a>04288    CHECK(p);
<a name="l04289"></a>04289    <span class="keywordflow">for</span> (i=0; i &lt; p-&gt;channels &amp;&amp; i &lt; STB_VORBIS_MAX_CHANNELS; ++i) {
<a name="l04290"></a>04290       setup_free(p, p-&gt;channel_buffers[i]);
<a name="l04291"></a>04291       setup_free(p, p-&gt;previous_window[i]);
<a name="l04292"></a>04292 <span class="preprocessor">      #ifdef STB_VORBIS_NO_DEFER_FLOOR</span>
<a name="l04293"></a>04293 <span class="preprocessor"></span>      setup_free(p, p-&gt;floor_buffers[i]);
<a name="l04294"></a>04294 <span class="preprocessor">      #endif</span>
<a name="l04295"></a>04295 <span class="preprocessor"></span>      setup_free(p, p-&gt;finalY[i]);
<a name="l04296"></a>04296    }
<a name="l04297"></a>04297    <span class="keywordflow">for</span> (i=0; i &lt; 2; ++i) {
<a name="l04298"></a>04298       setup_free(p, p-&gt;A[i]);
<a name="l04299"></a>04299       setup_free(p, p-&gt;B[i]);
<a name="l04300"></a>04300       setup_free(p, p-&gt;C[i]);
<a name="l04301"></a>04301       setup_free(p, p-&gt;window[i]);
<a name="l04302"></a>04302       setup_free(p, p-&gt;bit_reverse[i]);
<a name="l04303"></a>04303    }
<a name="l04304"></a>04304 <span class="preprocessor">   #ifdef __SDL_SOUND_INTERNAL__</span>
<a name="l04305"></a>04305 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (p-&gt;close_on_free) SDL_RWclose(p-&gt;rwops);
<a name="l04306"></a>04306 <span class="preprocessor">   #endif</span>
<a name="l04307"></a>04307 <span class="preprocessor"></span><span class="preprocessor">   #ifndef STB_VORBIS_NO_STDIO</span>
<a name="l04308"></a>04308 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (p-&gt;close_on_free) fclose(p-&gt;f);
<a name="l04309"></a>04309 <span class="preprocessor">   #endif</span>
<a name="l04310"></a>04310 <span class="preprocessor"></span>}
<a name="l04311"></a>04311 
<a name="l04312"></a>04312 <span class="keywordtype">void</span> stb_vorbis_close(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *p)
<a name="l04313"></a>04313 {
<a name="l04314"></a>04314    <span class="keywordflow">if</span> (p == NULL) <span class="keywordflow">return</span>;
<a name="l04315"></a>04315    vorbis_deinit(p);
<a name="l04316"></a>04316    setup_free(p,p);
<a name="l04317"></a>04317 }
<a name="l04318"></a>04318 
<a name="l04319"></a>04319 <span class="keyword">static</span> <span class="keywordtype">void</span> vorbis_init(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *p, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *z)
<a name="l04320"></a>04320 {
<a name="l04321"></a>04321    memset(p, 0, <span class="keyword">sizeof</span>(*p)); <span class="comment">// NULL out all malloc&#39;d pointers to start</span>
<a name="l04322"></a>04322    <span class="keywordflow">if</span> (z) {
<a name="l04323"></a>04323       p-&gt;alloc = *z;
<a name="l04324"></a>04324       p-&gt;alloc.alloc_buffer_length_in_bytes = (p-&gt;alloc.alloc_buffer_length_in_bytes+3) &amp; ~3;
<a name="l04325"></a>04325       p-&gt;temp_offset = p-&gt;alloc.alloc_buffer_length_in_bytes;
<a name="l04326"></a>04326    }
<a name="l04327"></a>04327    p-&gt;eof = 0;
<a name="l04328"></a>04328    p-&gt;error = VORBIS__no_error;
<a name="l04329"></a>04329    p-&gt;stream = NULL;
<a name="l04330"></a>04330    p-&gt;codebooks = NULL;
<a name="l04331"></a>04331    p-&gt;page_crc_tests = -1;
<a name="l04332"></a>04332 <span class="preprocessor">   #ifdef __SDL_SOUND_INTERNAL__</span>
<a name="l04333"></a>04333 <span class="preprocessor"></span>   p-&gt;close_on_free = FALSE;
<a name="l04334"></a>04334    p-&gt;rwops = NULL;
<a name="l04335"></a>04335 <span class="preprocessor">   #endif</span>
<a name="l04336"></a>04336 <span class="preprocessor"></span><span class="preprocessor">   #ifndef STB_VORBIS_NO_STDIO</span>
<a name="l04337"></a>04337 <span class="preprocessor"></span>   p-&gt;close_on_free = FALSE;
<a name="l04338"></a>04338    p-&gt;f = NULL;
<a name="l04339"></a>04339 <span class="preprocessor">   #endif</span>
<a name="l04340"></a>04340 <span class="preprocessor"></span>}
<a name="l04341"></a>04341 
<a name="l04342"></a>04342 <span class="keywordtype">int</span> stb_vorbis_get_sample_offset(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f)
<a name="l04343"></a>04343 {
<a name="l04344"></a>04344    <span class="keywordflow">if</span> (f-&gt;current_loc_valid)
<a name="l04345"></a>04345       <span class="keywordflow">return</span> f-&gt;current_loc;
<a name="l04346"></a>04346    <span class="keywordflow">else</span>
<a name="l04347"></a>04347       <span class="keywordflow">return</span> -1;
<a name="l04348"></a>04348 }
<a name="l04349"></a>04349 
<a name="l04350"></a>04350 <a class="code" href="structstb__vorbis__info.html">stb_vorbis_info</a> stb_vorbis_get_info(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f)
<a name="l04351"></a>04351 {
<a name="l04352"></a>04352    <a class="code" href="structstb__vorbis__info.html">stb_vorbis_info</a> d;
<a name="l04353"></a>04353    d.channels = f-&gt;channels;
<a name="l04354"></a>04354    d.sample_rate = f-&gt;sample_rate;
<a name="l04355"></a>04355    d.setup_memory_required = f-&gt;setup_memory_required;
<a name="l04356"></a>04356    d.setup_temp_memory_required = f-&gt;setup_temp_memory_required;
<a name="l04357"></a>04357    d.temp_memory_required = f-&gt;temp_memory_required;
<a name="l04358"></a>04358    d.max_frame_size = f-&gt;blocksize_1 &gt;&gt; 1;
<a name="l04359"></a>04359    <span class="keywordflow">return</span> d;
<a name="l04360"></a>04360 }
<a name="l04361"></a>04361 
<a name="l04362"></a>04362 <a class="code" href="structstb__vorbis__comment.html">stb_vorbis_comment</a> stb_vorbis_get_comment(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f)
<a name="l04363"></a>04363 {
<a name="l04364"></a>04364    <a class="code" href="structstb__vorbis__comment.html">stb_vorbis_comment</a> d;
<a name="l04365"></a>04365    d.vendor = f-&gt;vendor;
<a name="l04366"></a>04366    d.comment_list_length = f-&gt;comment_list_length;
<a name="l04367"></a>04367    d.comment_list = f-&gt;comment_list;
<a name="l04368"></a>04368    <span class="keywordflow">return</span> d;
<a name="l04369"></a>04369 }
<a name="l04370"></a>04370 
<a name="l04371"></a>04371 <span class="keywordtype">int</span> stb_vorbis_get_error(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f)
<a name="l04372"></a>04372 {
<a name="l04373"></a>04373    <span class="keywordtype">int</span> e = (int)(f-&gt;error);
<a name="l04374"></a>04374    f-&gt;error = VORBIS__no_error;
<a name="l04375"></a>04375    <span class="keywordflow">return</span> e;
<a name="l04376"></a>04376 }
<a name="l04377"></a>04377 
<a name="l04378"></a>04378 <span class="keyword">static</span> <a class="code" href="structstb__vorbis.html">stb_vorbis</a> * vorbis_alloc(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f)
<a name="l04379"></a>04379 {
<a name="l04380"></a>04380    <a class="code" href="structstb__vorbis.html">stb_vorbis</a> *p = (<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *) setup_malloc(f, <span class="keyword">sizeof</span>(*p));
<a name="l04381"></a>04381    <span class="keywordflow">return</span> p;
<a name="l04382"></a>04382 }
<a name="l04383"></a>04383 
<a name="l04384"></a>04384 <span class="preprocessor">#ifndef STB_VORBIS_NO_PUSHDATA_API</span>
<a name="l04385"></a>04385 <span class="preprocessor"></span>
<a name="l04386"></a>04386 <span class="keywordtype">void</span> stb_vorbis_flush_pushdata(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f)
<a name="l04387"></a>04387 {
<a name="l04388"></a>04388    f-&gt;previous_length = 0;
<a name="l04389"></a>04389    f-&gt;page_crc_tests  = 0;
<a name="l04390"></a>04390    f-&gt;discard_samples_deferred = 0;
<a name="l04391"></a>04391    f-&gt;current_loc_valid = FALSE;
<a name="l04392"></a>04392    f-&gt;first_decode = FALSE;
<a name="l04393"></a>04393    f-&gt;samples_output = 0;
<a name="l04394"></a>04394    f-&gt;channel_buffer_start = 0;
<a name="l04395"></a>04395    f-&gt;channel_buffer_end = 0;
<a name="l04396"></a>04396 }
<a name="l04397"></a>04397 
<a name="l04398"></a>04398 <span class="keyword">static</span> <span class="keywordtype">int</span> vorbis_search_for_page_pushdata(<a class="code" href="structstb__vorbis.html">vorb</a> *f, uint8 *data, <span class="keywordtype">int</span> data_len)
<a name="l04399"></a>04399 {
<a name="l04400"></a>04400    <span class="keywordtype">int</span> i,n;
<a name="l04401"></a>04401    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;page_crc_tests; ++i)
<a name="l04402"></a>04402       f-&gt;scan[i].bytes_done = 0;
<a name="l04403"></a>04403 
<a name="l04404"></a>04404    <span class="comment">// if we have room for more scans, search for them first, because</span>
<a name="l04405"></a>04405    <span class="comment">// they may cause us to stop early if their header is incomplete</span>
<a name="l04406"></a>04406    if (f-&gt;page_crc_tests &lt; STB_VORBIS_PUSHDATA_CRC_COUNT) {
<a name="l04407"></a>04407       <span class="keywordflow">if</span> (data_len &lt; 4) <span class="keywordflow">return</span> 0;
<a name="l04408"></a>04408       data_len -= 3; <span class="comment">// need to look for 4-byte sequence, so don&#39;t miss</span>
<a name="l04409"></a>04409                      <span class="comment">// one that straddles a boundary</span>
<a name="l04410"></a>04410       <span class="keywordflow">for</span> (i=0; i &lt; data_len; ++i) {
<a name="l04411"></a>04411          <span class="keywordflow">if</span> (data[i] == 0x4f) {
<a name="l04412"></a>04412             <span class="keywordflow">if</span> (0==memcmp(data+i, ogg_page_header, 4)) {
<a name="l04413"></a>04413                <span class="keywordtype">int</span> j,len;
<a name="l04414"></a>04414                uint32 crc;
<a name="l04415"></a>04415                <span class="comment">// make sure we have the whole page header</span>
<a name="l04416"></a>04416                <span class="keywordflow">if</span> (i+26 &gt;= data_len || i+27+data[i+26] &gt;= data_len) {
<a name="l04417"></a>04417                   <span class="comment">// only read up to this page start, so hopefully we&#39;ll</span>
<a name="l04418"></a>04418                   <span class="comment">// have the whole page header start next time</span>
<a name="l04419"></a>04419                   data_len = i;
<a name="l04420"></a>04420                   <span class="keywordflow">break</span>;
<a name="l04421"></a>04421                }
<a name="l04422"></a>04422                <span class="comment">// ok, we have it all; compute the length of the page</span>
<a name="l04423"></a>04423                len = 27 + data[i+26];
<a name="l04424"></a>04424                <span class="keywordflow">for</span> (j=0; j &lt; data[i+26]; ++j)
<a name="l04425"></a>04425                   len += data[i+27+j];
<a name="l04426"></a>04426                <span class="comment">// scan everything up to the embedded crc (which we must 0)</span>
<a name="l04427"></a>04427                crc = 0;
<a name="l04428"></a>04428                <span class="keywordflow">for</span> (j=0; j &lt; 22; ++j)
<a name="l04429"></a>04429                   crc = crc32_update(crc, data[i+j]);
<a name="l04430"></a>04430                <span class="comment">// now process 4 0-bytes</span>
<a name="l04431"></a>04431                <span class="keywordflow">for</span> (   ; j &lt; 26; ++j)
<a name="l04432"></a>04432                   crc = crc32_update(crc, 0);
<a name="l04433"></a>04433                <span class="comment">// len is the total number of bytes we need to scan</span>
<a name="l04434"></a>04434                n = f-&gt;page_crc_tests++;
<a name="l04435"></a>04435                f-&gt;scan[n].bytes_left = len-j;
<a name="l04436"></a>04436                f-&gt;scan[n].crc_so_far = crc;
<a name="l04437"></a>04437                f-&gt;scan[n].goal_crc = data[i+22] + (data[i+23] &lt;&lt; 8) + (data[i+24]&lt;&lt;16) + (data[i+25]&lt;&lt;24);
<a name="l04438"></a>04438                <span class="comment">// if the last frame on a page is continued to the next, then</span>
<a name="l04439"></a>04439                <span class="comment">// we can&#39;t recover the sample_loc immediately</span>
<a name="l04440"></a>04440                <span class="keywordflow">if</span> (data[i+27+data[i+26]-1] == 255)
<a name="l04441"></a>04441                   f-&gt;scan[n].sample_loc = ~0;
<a name="l04442"></a>04442                <span class="keywordflow">else</span>
<a name="l04443"></a>04443                   f-&gt;scan[n].sample_loc = data[i+6] + (data[i+7] &lt;&lt; 8) + (data[i+ 8]&lt;&lt;16) + (data[i+ 9]&lt;&lt;24);
<a name="l04444"></a>04444                f-&gt;scan[n].bytes_done = i+j;
<a name="l04445"></a>04445                <span class="keywordflow">if</span> (f-&gt;page_crc_tests == STB_VORBIS_PUSHDATA_CRC_COUNT)
<a name="l04446"></a>04446                   <span class="keywordflow">break</span>;
<a name="l04447"></a>04447                <span class="comment">// keep going if we still have room for more</span>
<a name="l04448"></a>04448             }
<a name="l04449"></a>04449          }
<a name="l04450"></a>04450       }
<a name="l04451"></a>04451    }
<a name="l04452"></a>04452 
<a name="l04453"></a>04453    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;page_crc_tests;) {
<a name="l04454"></a>04454       uint32 crc;
<a name="l04455"></a>04455       <span class="keywordtype">int</span> j;
<a name="l04456"></a>04456       <span class="keywordtype">int</span> n = f-&gt;scan[i].bytes_done;
<a name="l04457"></a>04457       <span class="keywordtype">int</span> m = f-&gt;scan[i].bytes_left;
<a name="l04458"></a>04458       <span class="keywordflow">if</span> (m &gt; data_len - n) m = data_len - n;
<a name="l04459"></a>04459       <span class="comment">// m is the bytes to scan in the current chunk</span>
<a name="l04460"></a>04460       crc = f-&gt;scan[i].crc_so_far;
<a name="l04461"></a>04461       <span class="keywordflow">for</span> (j=0; j &lt; m; ++j)
<a name="l04462"></a>04462          crc = crc32_update(crc, data[n+j]);
<a name="l04463"></a>04463       f-&gt;scan[i].bytes_left -= m;
<a name="l04464"></a>04464       f-&gt;scan[i].crc_so_far = crc;
<a name="l04465"></a>04465       <span class="keywordflow">if</span> (f-&gt;scan[i].bytes_left == 0) {
<a name="l04466"></a>04466          <span class="comment">// does it match?</span>
<a name="l04467"></a>04467          <span class="keywordflow">if</span> (f-&gt;scan[i].crc_so_far == f-&gt;scan[i].goal_crc) {
<a name="l04468"></a>04468             <span class="comment">// Houston, we have page</span>
<a name="l04469"></a>04469             data_len = n+m; <span class="comment">// consumption amount is wherever that scan ended</span>
<a name="l04470"></a>04470             f-&gt;page_crc_tests = -1; <span class="comment">// drop out of page scan mode</span>
<a name="l04471"></a>04471             f-&gt;previous_length = 0; <span class="comment">// decode-but-don&#39;t-output one frame</span>
<a name="l04472"></a>04472             f-&gt;next_seg = -1;       <span class="comment">// start a new page</span>
<a name="l04473"></a>04473             f-&gt;current_loc = f-&gt;scan[i].sample_loc; <span class="comment">// set the current sample location</span>
<a name="l04474"></a>04474                                     <span class="comment">// to the amount we&#39;d have decoded had we decoded this page</span>
<a name="l04475"></a>04475             f-&gt;current_loc_valid = f-&gt;current_loc != ~0U;
<a name="l04476"></a>04476             <span class="keywordflow">return</span> data_len;
<a name="l04477"></a>04477          }
<a name="l04478"></a>04478          <span class="comment">// delete entry</span>
<a name="l04479"></a>04479          f-&gt;scan[i] = f-&gt;scan[--f-&gt;page_crc_tests];
<a name="l04480"></a>04480       } <span class="keywordflow">else</span> {
<a name="l04481"></a>04481          ++i;
<a name="l04482"></a>04482       }
<a name="l04483"></a>04483    }
<a name="l04484"></a>04484 
<a name="l04485"></a>04485    <span class="keywordflow">return</span> data_len;
<a name="l04486"></a>04486 }
<a name="l04487"></a>04487 
<a name="l04488"></a>04488 <span class="comment">// return value: number of bytes we used</span>
<a name="l04489"></a>04489 <span class="keywordtype">int</span> stb_vorbis_decode_frame_pushdata(
<a name="l04490"></a>04490          <a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f,                   <span class="comment">// the file we&#39;re decoding</span>
<a name="l04491"></a>04491          <span class="keyword">const</span> uint8 *data, <span class="keywordtype">int</span> data_len, <span class="comment">// the memory available for decoding</span>
<a name="l04492"></a>04492          <span class="keywordtype">int</span> *channels,                   <span class="comment">// place to write number of float * buffers</span>
<a name="l04493"></a>04493          <span class="keywordtype">float</span> ***output,                 <span class="comment">// place to write float ** array of float * buffers</span>
<a name="l04494"></a>04494          <span class="keywordtype">int</span> *samples                     <span class="comment">// place to write number of output samples</span>
<a name="l04495"></a>04495      )
<a name="l04496"></a>04496 {
<a name="l04497"></a>04497    <span class="keywordtype">int</span> i;
<a name="l04498"></a>04498    <span class="keywordtype">int</span> len,right,left;
<a name="l04499"></a>04499 
<a name="l04500"></a>04500    <span class="keywordflow">if</span> (!IS_PUSH_MODE(f)) <span class="keywordflow">return</span> error(f, VORBIS_invalid_api_mixing);
<a name="l04501"></a>04501 
<a name="l04502"></a>04502    <span class="keywordflow">if</span> (f-&gt;page_crc_tests &gt;= 0) {
<a name="l04503"></a>04503       *samples = 0;
<a name="l04504"></a>04504       <span class="keywordflow">return</span> vorbis_search_for_page_pushdata(f, (uint8 *) data, data_len);
<a name="l04505"></a>04505    }
<a name="l04506"></a>04506 
<a name="l04507"></a>04507    f-&gt;stream     = (uint8 *) data;
<a name="l04508"></a>04508    f-&gt;stream_end = (uint8 *) data + data_len;
<a name="l04509"></a>04509    f-&gt;error      = VORBIS__no_error;
<a name="l04510"></a>04510 
<a name="l04511"></a>04511    <span class="comment">// check that we have the entire packet in memory</span>
<a name="l04512"></a>04512    <span class="keywordflow">if</span> (!is_whole_packet_present(f)) {
<a name="l04513"></a>04513       *samples = 0;
<a name="l04514"></a>04514       <span class="keywordflow">return</span> 0;
<a name="l04515"></a>04515    }
<a name="l04516"></a>04516 
<a name="l04517"></a>04517    <span class="keywordflow">if</span> (!vorbis_decode_packet(f, &amp;len, &amp;left, &amp;right)) {
<a name="l04518"></a>04518       <span class="comment">// save the actual error we encountered</span>
<a name="l04519"></a>04519       <span class="keyword">enum</span> STBVorbisError error = f-&gt;error;
<a name="l04520"></a>04520       <span class="keywordflow">if</span> (error == VORBIS_bad_packet_type) {
<a name="l04521"></a>04521          <span class="comment">// flush and resynch</span>
<a name="l04522"></a>04522          f-&gt;error = VORBIS__no_error;
<a name="l04523"></a>04523          <span class="keywordflow">while</span> (get8_packet(f) != EOP)
<a name="l04524"></a>04524             <span class="keywordflow">if</span> (f-&gt;eof) <span class="keywordflow">break</span>;
<a name="l04525"></a>04525          *samples = 0;
<a name="l04526"></a>04526          <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) (f-&gt;stream - data);
<a name="l04527"></a>04527       }
<a name="l04528"></a>04528       <span class="keywordflow">if</span> (error == VORBIS_continued_packet_flag_invalid) {
<a name="l04529"></a>04529          <span class="keywordflow">if</span> (f-&gt;previous_length == 0) {
<a name="l04530"></a>04530             <span class="comment">// we may be resynching, in which case it&#39;s ok to hit one</span>
<a name="l04531"></a>04531             <span class="comment">// of these; just discard the packet</span>
<a name="l04532"></a>04532             f-&gt;error = VORBIS__no_error;
<a name="l04533"></a>04533             <span class="keywordflow">while</span> (get8_packet(f) != EOP)
<a name="l04534"></a>04534                <span class="keywordflow">if</span> (f-&gt;eof) <span class="keywordflow">break</span>;
<a name="l04535"></a>04535             *samples = 0;
<a name="l04536"></a>04536             <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) (f-&gt;stream - data);
<a name="l04537"></a>04537          }
<a name="l04538"></a>04538       }
<a name="l04539"></a>04539       <span class="comment">// if we get an error while parsing, what to do?</span>
<a name="l04540"></a>04540       <span class="comment">// well, it DEFINITELY won&#39;t work to continue from where we are!</span>
<a name="l04541"></a>04541       stb_vorbis_flush_pushdata(f);
<a name="l04542"></a>04542       <span class="comment">// restore the error that actually made us bail</span>
<a name="l04543"></a>04543       f-&gt;error = error;
<a name="l04544"></a>04544       *samples = 0;
<a name="l04545"></a>04545       <span class="keywordflow">return</span> 1;
<a name="l04546"></a>04546    }
<a name="l04547"></a>04547 
<a name="l04548"></a>04548    <span class="comment">// success!</span>
<a name="l04549"></a>04549    len = vorbis_finish_frame(f, len, left, right);
<a name="l04550"></a>04550    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;channels; ++i)
<a name="l04551"></a>04551       f-&gt;outputs[i] = f-&gt;channel_buffers[i] + left;
<a name="l04552"></a>04552 
<a name="l04553"></a>04553    if (channels) *channels = f-&gt;channels;
<a name="l04554"></a>04554    *samples = len;
<a name="l04555"></a>04555    *output = f-&gt;outputs;
<a name="l04556"></a>04556    <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) (f-&gt;stream - data);
<a name="l04557"></a>04557 }
<a name="l04558"></a>04558 
<a name="l04559"></a>04559 <a class="code" href="structstb__vorbis.html">stb_vorbis</a> *stb_vorbis_open_pushdata(
<a name="l04560"></a>04560          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">int</span> data_len, <span class="comment">// the memory available for decoding</span>
<a name="l04561"></a>04561          <span class="keywordtype">int</span> *data_used,              <span class="comment">// only defined if result is not NULL</span>
<a name="l04562"></a>04562          <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc)
<a name="l04563"></a>04563 {
<a name="l04564"></a>04564    <a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, p;
<a name="l04565"></a>04565    vorbis_init(&amp;p, alloc);
<a name="l04566"></a>04566    p.stream     = (uint8 *) data;
<a name="l04567"></a>04567    p.stream_end = (uint8 *) data + data_len;
<a name="l04568"></a>04568    p.push_mode  = TRUE;
<a name="l04569"></a>04569    <span class="keywordflow">if</span> (!start_decoder(&amp;p)) {
<a name="l04570"></a>04570       <span class="keywordflow">if</span> (p.eof)
<a name="l04571"></a>04571          *error = VORBIS_need_more_data;
<a name="l04572"></a>04572       <span class="keywordflow">else</span>
<a name="l04573"></a>04573          *error = p.error;
<a name="l04574"></a>04574       <span class="keywordflow">return</span> NULL;
<a name="l04575"></a>04575    }
<a name="l04576"></a>04576    f = vorbis_alloc(&amp;p);
<a name="l04577"></a>04577    <span class="keywordflow">if</span> (f) {
<a name="l04578"></a>04578       *f = p;
<a name="l04579"></a>04579       *data_used = (int) (f-&gt;stream - data);
<a name="l04580"></a>04580       *error = 0;
<a name="l04581"></a>04581       <span class="keywordflow">return</span> f;
<a name="l04582"></a>04582    } <span class="keywordflow">else</span> {
<a name="l04583"></a>04583       vorbis_deinit(&amp;p);
<a name="l04584"></a>04584       <span class="keywordflow">return</span> NULL;
<a name="l04585"></a>04585    }
<a name="l04586"></a>04586 }
<a name="l04587"></a>04587 <span class="preprocessor">#endif // STB_VORBIS_NO_PUSHDATA_API</span>
<a name="l04588"></a>04588 <span class="preprocessor"></span>
<a name="l04589"></a>04589 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stb_vorbis_get_file_offset(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f)
<a name="l04590"></a>04590 {
<a name="l04591"></a>04591 <span class="preprocessor">   #ifndef STB_VORBIS_NO_PUSHDATA_API</span>
<a name="l04592"></a>04592 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (f-&gt;push_mode) <span class="keywordflow">return</span> 0;
<a name="l04593"></a>04593 <span class="preprocessor">   #endif</span>
<a name="l04594"></a>04594 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (USE_MEMORY(f)) <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (f-&gt;stream - f-&gt;stream_start);
<a name="l04595"></a>04595 <span class="preprocessor">   #ifdef __SDL_SOUND_INTERNAL__</span>
<a name="l04596"></a>04596 <span class="preprocessor"></span>   <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (SDL_RWtell(f-&gt;rwops) - f-&gt;rwops_start);
<a name="l04597"></a>04597 <span class="preprocessor">   #endif</span>
<a name="l04598"></a>04598 <span class="preprocessor"></span><span class="preprocessor">   #ifndef STB_VORBIS_NO_STDIO</span>
<a name="l04599"></a>04599 <span class="preprocessor"></span>   <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (ftell(f-&gt;f) - f-&gt;f_start);
<a name="l04600"></a>04600 <span class="preprocessor">   #endif</span>
<a name="l04601"></a>04601 <span class="preprocessor"></span>}
<a name="l04602"></a>04602 
<a name="l04603"></a>04603 <span class="preprocessor">#ifndef STB_VORBIS_NO_PULLDATA_API</span>
<a name="l04604"></a>04604 <span class="preprocessor"></span><span class="comment">//</span>
<a name="l04605"></a>04605 <span class="comment">// DATA-PULLING API</span>
<a name="l04606"></a>04606 <span class="comment">//</span>
<a name="l04607"></a>04607 
<a name="l04608"></a>04608 <span class="keyword">static</span> uint32 vorbis_find_page(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, uint32 *end, uint32 *last)
<a name="l04609"></a>04609 {
<a name="l04610"></a>04610    <span class="keywordflow">for</span>(;;) {
<a name="l04611"></a>04611       <span class="keywordtype">int</span> n;
<a name="l04612"></a>04612       <span class="keywordflow">if</span> (f-&gt;eof) <span class="keywordflow">return</span> 0;
<a name="l04613"></a>04613       n = get8(f);
<a name="l04614"></a>04614       <span class="keywordflow">if</span> (n == 0x4f) { <span class="comment">// page header candidate</span>
<a name="l04615"></a>04615          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> retry_loc = stb_vorbis_get_file_offset(f);
<a name="l04616"></a>04616          <span class="keywordtype">int</span> i;
<a name="l04617"></a>04617          <span class="comment">// check if we&#39;re off the end of a file_section stream</span>
<a name="l04618"></a>04618          <span class="keywordflow">if</span> (retry_loc - 25 &gt; f-&gt;stream_len)
<a name="l04619"></a>04619             <span class="keywordflow">return</span> 0;
<a name="l04620"></a>04620          <span class="comment">// check the rest of the header</span>
<a name="l04621"></a>04621          <span class="keywordflow">for</span> (i=1; i &lt; 4; ++i)
<a name="l04622"></a>04622             <span class="keywordflow">if</span> (get8(f) != ogg_page_header[i])
<a name="l04623"></a>04623                <span class="keywordflow">break</span>;
<a name="l04624"></a>04624          <span class="keywordflow">if</span> (f-&gt;eof) <span class="keywordflow">return</span> 0;
<a name="l04625"></a>04625          <span class="keywordflow">if</span> (i == 4) {
<a name="l04626"></a>04626             uint8 header[27];
<a name="l04627"></a>04627             uint32 i, crc, goal, len;
<a name="l04628"></a>04628             <span class="keywordflow">for</span> (i=0; i &lt; 4; ++i)
<a name="l04629"></a>04629                header[i] = ogg_page_header[i];
<a name="l04630"></a>04630             <span class="keywordflow">for</span> (; i &lt; 27; ++i)
<a name="l04631"></a>04631                header[i] = get8(f);
<a name="l04632"></a>04632             <span class="keywordflow">if</span> (f-&gt;eof) <span class="keywordflow">return</span> 0;
<a name="l04633"></a>04633             <span class="keywordflow">if</span> (header[4] != 0) <span class="keywordflow">goto</span> invalid;
<a name="l04634"></a>04634             goal = header[22] + (header[23] &lt;&lt; 8) + (header[24]&lt;&lt;16) + (header[25]&lt;&lt;24);
<a name="l04635"></a>04635             <span class="keywordflow">for</span> (i=22; i &lt; 26; ++i)
<a name="l04636"></a>04636                header[i] = 0;
<a name="l04637"></a>04637             crc = 0;
<a name="l04638"></a>04638             <span class="keywordflow">for</span> (i=0; i &lt; 27; ++i)
<a name="l04639"></a>04639                crc = crc32_update(crc, header[i]);
<a name="l04640"></a>04640             len = 0;
<a name="l04641"></a>04641             <span class="keywordflow">for</span> (i=0; i &lt; header[26]; ++i) {
<a name="l04642"></a>04642                <span class="keywordtype">int</span> s = get8(f);
<a name="l04643"></a>04643                crc = crc32_update(crc, s);
<a name="l04644"></a>04644                len += s;
<a name="l04645"></a>04645             }
<a name="l04646"></a>04646             <span class="keywordflow">if</span> (len &amp;&amp; f-&gt;eof) <span class="keywordflow">return</span> 0;
<a name="l04647"></a>04647             <span class="keywordflow">for</span> (i=0; i &lt; len; ++i)
<a name="l04648"></a>04648                crc = crc32_update(crc, get8(f));
<a name="l04649"></a>04649             <span class="comment">// finished parsing probable page</span>
<a name="l04650"></a>04650             <span class="keywordflow">if</span> (crc == goal) {
<a name="l04651"></a>04651                <span class="comment">// we could now check that it&#39;s either got the last</span>
<a name="l04652"></a>04652                <span class="comment">// page flag set, OR it&#39;s followed by the capture</span>
<a name="l04653"></a>04653                <span class="comment">// pattern, but I guess TECHNICALLY you could have</span>
<a name="l04654"></a>04654                <span class="comment">// a file with garbage between each ogg page and recover</span>
<a name="l04655"></a>04655                <span class="comment">// from it automatically? So even though that paranoia</span>
<a name="l04656"></a>04656                <span class="comment">// might decrease the chance of an invalid decode by</span>
<a name="l04657"></a>04657                <span class="comment">// another 2^32, not worth it since it would hose those</span>
<a name="l04658"></a>04658                <span class="comment">// invalid-but-useful files?</span>
<a name="l04659"></a>04659                <span class="keywordflow">if</span> (end)
<a name="l04660"></a>04660                   *end = stb_vorbis_get_file_offset(f);
<a name="l04661"></a>04661                <span class="keywordflow">if</span> (last) {
<a name="l04662"></a>04662                   <span class="keywordflow">if</span> (header[5] &amp; 0x04)
<a name="l04663"></a>04663                      *last = 1;
<a name="l04664"></a>04664                   <span class="keywordflow">else</span>
<a name="l04665"></a>04665                      *last = 0;
<a name="l04666"></a>04666                }
<a name="l04667"></a>04667                set_file_offset(f, retry_loc-1);
<a name="l04668"></a>04668                <span class="keywordflow">return</span> 1;
<a name="l04669"></a>04669             }
<a name="l04670"></a>04670          }
<a name="l04671"></a>04671         invalid:
<a name="l04672"></a>04672          <span class="comment">// not a valid page, so rewind and look for next one</span>
<a name="l04673"></a>04673          set_file_offset(f, retry_loc);
<a name="l04674"></a>04674       }
<a name="l04675"></a>04675    }
<a name="l04676"></a>04676 }
<a name="l04677"></a>04677 
<a name="l04678"></a>04678 
<a name="l04679"></a>04679 <span class="preprocessor">#define SAMPLE_unknown  0xffffffff</span>
<a name="l04680"></a>04680 <span class="preprocessor"></span>
<a name="l04681"></a>04681 <span class="comment">// seeking is implemented with a binary search, which narrows down the range to</span>
<a name="l04682"></a>04682 <span class="comment">// 64K, before using a linear search (because finding the synchronization</span>
<a name="l04683"></a>04683 <span class="comment">// pattern can be expensive, and the chance we&#39;d find the end page again is</span>
<a name="l04684"></a>04684 <span class="comment">// relatively high for small ranges)</span>
<a name="l04685"></a>04685 <span class="comment">//</span>
<a name="l04686"></a>04686 <span class="comment">// two initial interpolation-style probes are used at the start of the search</span>
<a name="l04687"></a>04687 <span class="comment">// to try to bound either side of the binary search sensibly, while still</span>
<a name="l04688"></a>04688 <span class="comment">// working in O(log n) time if they fail.</span>
<a name="l04689"></a>04689 
<a name="l04690"></a>04690 <span class="keyword">static</span> <span class="keywordtype">int</span> get_seek_page_info(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <a class="code" href="structProbedPage.html">ProbedPage</a> *z)
<a name="l04691"></a>04691 {
<a name="l04692"></a>04692    uint8 header[27], lacing[255];
<a name="l04693"></a>04693    <span class="keywordtype">int</span> i,len;
<a name="l04694"></a>04694 
<a name="l04695"></a>04695    <span class="comment">// record where the page starts</span>
<a name="l04696"></a>04696    z-&gt;page_start = stb_vorbis_get_file_offset(f);
<a name="l04697"></a>04697 
<a name="l04698"></a>04698    <span class="comment">// parse the header</span>
<a name="l04699"></a>04699    getn(f, header, 27);
<a name="l04700"></a>04700    <span class="keywordflow">if</span> (header[0] != <span class="charliteral">&#39;O&#39;</span> || header[1] != <span class="charliteral">&#39;g&#39;</span> || header[2] != <span class="charliteral">&#39;g&#39;</span> || header[3] != <span class="charliteral">&#39;S&#39;</span>)
<a name="l04701"></a>04701       <span class="keywordflow">return</span> 0;
<a name="l04702"></a>04702    getn(f, lacing, header[26]);
<a name="l04703"></a>04703 
<a name="l04704"></a>04704    <span class="comment">// determine the length of the payload</span>
<a name="l04705"></a>04705    len = 0;
<a name="l04706"></a>04706    <span class="keywordflow">for</span> (i=0; i &lt; header[26]; ++i)
<a name="l04707"></a>04707       len += lacing[i];
<a name="l04708"></a>04708 
<a name="l04709"></a>04709    <span class="comment">// this implies where the page ends</span>
<a name="l04710"></a>04710    z-&gt;page_end = z-&gt;page_start + 27 + header[26] + len;
<a name="l04711"></a>04711 
<a name="l04712"></a>04712    <span class="comment">// read the last-decoded sample out of the data</span>
<a name="l04713"></a>04713    z-&gt;last_decoded_sample = header[6] + (header[7] &lt;&lt; 8) + (header[8] &lt;&lt; 16) + (header[9] &lt;&lt; 24);
<a name="l04714"></a>04714 
<a name="l04715"></a>04715    <span class="comment">// restore file state to where we were</span>
<a name="l04716"></a>04716    set_file_offset(f, z-&gt;page_start);
<a name="l04717"></a>04717    <span class="keywordflow">return</span> 1;
<a name="l04718"></a>04718 }
<a name="l04719"></a>04719 
<a name="l04720"></a>04720 <span class="comment">// rarely used function to seek back to the preceding page while finding the</span>
<a name="l04721"></a>04721 <span class="comment">// start of a packet</span>
<a name="l04722"></a>04722 <span class="keyword">static</span> <span class="keywordtype">int</span> go_to_page_before(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> limit_offset)
<a name="l04723"></a>04723 {
<a name="l04724"></a>04724    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> previous_safe, end;
<a name="l04725"></a>04725 
<a name="l04726"></a>04726    <span class="comment">// now we want to seek back 64K from the limit</span>
<a name="l04727"></a>04727    <span class="keywordflow">if</span> (limit_offset &gt;= 65536 &amp;&amp; limit_offset-65536 &gt;= f-&gt;first_audio_page_offset)
<a name="l04728"></a>04728       previous_safe = limit_offset - 65536;
<a name="l04729"></a>04729    <span class="keywordflow">else</span>
<a name="l04730"></a>04730       previous_safe = f-&gt;first_audio_page_offset;
<a name="l04731"></a>04731 
<a name="l04732"></a>04732    set_file_offset(f, previous_safe);
<a name="l04733"></a>04733 
<a name="l04734"></a>04734    <span class="keywordflow">while</span> (vorbis_find_page(f, &amp;end, NULL)) {
<a name="l04735"></a>04735       <span class="keywordflow">if</span> (end &gt;= limit_offset &amp;&amp; stb_vorbis_get_file_offset(f) &lt; limit_offset)
<a name="l04736"></a>04736          <span class="keywordflow">return</span> 1;
<a name="l04737"></a>04737       set_file_offset(f, end);
<a name="l04738"></a>04738    }
<a name="l04739"></a>04739 
<a name="l04740"></a>04740    <span class="keywordflow">return</span> 0;
<a name="l04741"></a>04741 }
<a name="l04742"></a>04742 
<a name="l04743"></a>04743 <span class="comment">// implements the search logic for finding a page and starting decoding. if</span>
<a name="l04744"></a>04744 <span class="comment">// the function succeeds, current_loc_valid will be true and current_loc will</span>
<a name="l04745"></a>04745 <span class="comment">// be less than or equal to the provided sample number (the closer the</span>
<a name="l04746"></a>04746 <span class="comment">// better).</span>
<a name="l04747"></a>04747 <span class="keyword">static</span> <span class="keywordtype">int</span> seek_to_sample_coarse(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, uint32 sample_number)
<a name="l04748"></a>04748 {
<a name="l04749"></a>04749    <a class="code" href="structProbedPage.html">ProbedPage</a> left, right, mid;
<a name="l04750"></a>04750    <span class="keywordtype">int</span> i, start_seg_with_known_loc, end_pos, page_start;
<a name="l04751"></a>04751    uint32 delta, stream_length, padding, last_sample_limit;
<a name="l04752"></a>04752    <span class="keywordtype">double</span> offset = 0.0, bytes_per_sample = 0.0;
<a name="l04753"></a>04753    <span class="keywordtype">int</span> probe = 0;
<a name="l04754"></a>04754 
<a name="l04755"></a>04755    <span class="comment">// find the last page and validate the target sample</span>
<a name="l04756"></a>04756    stream_length = stb_vorbis_stream_length_in_samples(f);
<a name="l04757"></a>04757    <span class="keywordflow">if</span> (stream_length == 0)            <span class="keywordflow">return</span> error(f, VORBIS_seek_without_length);
<a name="l04758"></a>04758    <span class="keywordflow">if</span> (sample_number &gt; stream_length) <span class="keywordflow">return</span> error(f, VORBIS_seek_invalid);
<a name="l04759"></a>04759 
<a name="l04760"></a>04760    <span class="comment">// this is the maximum difference between the window-center (which is the</span>
<a name="l04761"></a>04761    <span class="comment">// actual granule position value), and the right-start (which the spec</span>
<a name="l04762"></a>04762    <span class="comment">// indicates should be the granule position (give or take one)).</span>
<a name="l04763"></a>04763    padding = ((f-&gt;blocksize_1 - f-&gt;blocksize_0) &gt;&gt; 2);
<a name="l04764"></a>04764    <span class="keywordflow">if</span> (sample_number &lt; padding)
<a name="l04765"></a>04765       last_sample_limit = 0;
<a name="l04766"></a>04766    <span class="keywordflow">else</span>
<a name="l04767"></a>04767       last_sample_limit = sample_number - padding;
<a name="l04768"></a>04768 
<a name="l04769"></a>04769    left = f-&gt;p_first;
<a name="l04770"></a>04770    <span class="keywordflow">while</span> (left.last_decoded_sample == ~0U) {
<a name="l04771"></a>04771       <span class="comment">// (untested) the first page does not have a &#39;last_decoded_sample&#39;</span>
<a name="l04772"></a>04772       set_file_offset(f, left.page_end);
<a name="l04773"></a>04773       <span class="keywordflow">if</span> (!get_seek_page_info(f, &amp;left)) <span class="keywordflow">goto</span> error;
<a name="l04774"></a>04774    }
<a name="l04775"></a>04775 
<a name="l04776"></a>04776    right = f-&gt;p_last;
<a name="l04777"></a>04777    assert(right.last_decoded_sample != ~0U);
<a name="l04778"></a>04778 
<a name="l04779"></a>04779    <span class="comment">// starting from the start is handled differently</span>
<a name="l04780"></a>04780    <span class="keywordflow">if</span> (last_sample_limit &lt;= left.last_decoded_sample) {
<a name="l04781"></a>04781       <span class="keywordflow">if</span> (stb_vorbis_seek_start(f)) {
<a name="l04782"></a>04782          <span class="keywordflow">if</span> (f-&gt;current_loc &gt; sample_number)
<a name="l04783"></a>04783             <span class="keywordflow">return</span> error(f, VORBIS_seek_failed);
<a name="l04784"></a>04784          <span class="keywordflow">return</span> 1;
<a name="l04785"></a>04785       }
<a name="l04786"></a>04786       <span class="keywordflow">return</span> 0;
<a name="l04787"></a>04787    }
<a name="l04788"></a>04788 
<a name="l04789"></a>04789    <span class="keywordflow">while</span> (left.page_end != right.page_start) {
<a name="l04790"></a>04790       assert(left.page_end &lt; right.page_start);
<a name="l04791"></a>04791       <span class="comment">// search range in bytes</span>
<a name="l04792"></a>04792       delta = right.page_start - left.page_end;
<a name="l04793"></a>04793       <span class="keywordflow">if</span> (delta &lt;= 65536) {
<a name="l04794"></a>04794          <span class="comment">// there&#39;s only 64K left to search - handle it linearly</span>
<a name="l04795"></a>04795          set_file_offset(f, left.page_end);
<a name="l04796"></a>04796       } <span class="keywordflow">else</span> {
<a name="l04797"></a>04797          <span class="keywordflow">if</span> (probe &lt; 2) {
<a name="l04798"></a>04798             <span class="keywordflow">if</span> (probe == 0) {
<a name="l04799"></a>04799                <span class="comment">// first probe (interpolate)</span>
<a name="l04800"></a>04800                <span class="keywordtype">double</span> data_bytes = right.page_end - left.page_start;
<a name="l04801"></a>04801                bytes_per_sample = data_bytes / right.last_decoded_sample;
<a name="l04802"></a>04802                offset = left.page_start + bytes_per_sample * (last_sample_limit - left.last_decoded_sample);
<a name="l04803"></a>04803             } <span class="keywordflow">else</span> {
<a name="l04804"></a>04804                <span class="comment">// second probe (try to bound the other side)</span>
<a name="l04805"></a>04805                <span class="keywordtype">double</span> error = ((double) last_sample_limit - mid.last_decoded_sample) * bytes_per_sample;
<a name="l04806"></a>04806                <span class="keywordflow">if</span> (error &gt;= 0 &amp;&amp; error &lt;  8000) error =  8000;
<a name="l04807"></a>04807                <span class="keywordflow">if</span> (error &lt;  0 &amp;&amp; error &gt; -8000) error = -8000;
<a name="l04808"></a>04808                offset += error * 2;
<a name="l04809"></a>04809             }
<a name="l04810"></a>04810 
<a name="l04811"></a>04811             <span class="comment">// ensure the offset is valid</span>
<a name="l04812"></a>04812             <span class="keywordflow">if</span> (offset &lt; left.page_end)
<a name="l04813"></a>04813                offset = left.page_end;
<a name="l04814"></a>04814             <span class="keywordflow">if</span> (offset &gt; right.page_start - 65536)
<a name="l04815"></a>04815                offset = right.page_start - 65536;
<a name="l04816"></a>04816 
<a name="l04817"></a>04817             set_file_offset(f, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) offset);
<a name="l04818"></a>04818          } <span class="keywordflow">else</span> {
<a name="l04819"></a>04819             <span class="comment">// binary search for large ranges (offset by 32K to ensure</span>
<a name="l04820"></a>04820             <span class="comment">// we don&#39;t hit the right page)</span>
<a name="l04821"></a>04821             set_file_offset(f, left.page_end + (delta / 2) - 32768);
<a name="l04822"></a>04822          }
<a name="l04823"></a>04823 
<a name="l04824"></a>04824          <span class="keywordflow">if</span> (!vorbis_find_page(f, NULL, NULL)) <span class="keywordflow">goto</span> error;
<a name="l04825"></a>04825       }
<a name="l04826"></a>04826 
<a name="l04827"></a>04827       <span class="keywordflow">for</span> (;;) {
<a name="l04828"></a>04828          <span class="keywordflow">if</span> (!get_seek_page_info(f, &amp;mid)) <span class="keywordflow">goto</span> error;
<a name="l04829"></a>04829          <span class="keywordflow">if</span> (mid.last_decoded_sample != ~0U) <span class="keywordflow">break</span>;
<a name="l04830"></a>04830          <span class="comment">// (untested) no frames end on this page</span>
<a name="l04831"></a>04831          set_file_offset(f, mid.page_end);
<a name="l04832"></a>04832          assert(mid.page_start &lt; right.page_start);
<a name="l04833"></a>04833       }
<a name="l04834"></a>04834 
<a name="l04835"></a>04835       <span class="comment">// if we&#39;ve just found the last page again then we&#39;re in a tricky file,</span>
<a name="l04836"></a>04836       <span class="comment">// and we&#39;re close enough (if it wasn&#39;t an interpolation probe).</span>
<a name="l04837"></a>04837       <span class="keywordflow">if</span> (mid.page_start == right.page_start) {
<a name="l04838"></a>04838          <span class="keywordflow">if</span> (probe &gt;= 2 || delta &lt;= 65536)
<a name="l04839"></a>04839             <span class="keywordflow">break</span>;
<a name="l04840"></a>04840       } <span class="keywordflow">else</span> {
<a name="l04841"></a>04841          <span class="keywordflow">if</span> (last_sample_limit &lt; mid.last_decoded_sample)
<a name="l04842"></a>04842             right = mid;
<a name="l04843"></a>04843          <span class="keywordflow">else</span>
<a name="l04844"></a>04844             left = mid;
<a name="l04845"></a>04845       }
<a name="l04846"></a>04846 
<a name="l04847"></a>04847       ++probe;
<a name="l04848"></a>04848    }
<a name="l04849"></a>04849 
<a name="l04850"></a>04850    <span class="comment">// seek back to start of the last packet</span>
<a name="l04851"></a>04851    page_start = left.page_start;
<a name="l04852"></a>04852    set_file_offset(f, page_start);
<a name="l04853"></a>04853    <span class="keywordflow">if</span> (!start_page(f)) <span class="keywordflow">return</span> error(f, VORBIS_seek_failed);
<a name="l04854"></a>04854    end_pos = f-&gt;end_seg_with_known_loc;
<a name="l04855"></a>04855    assert(end_pos &gt;= 0);
<a name="l04856"></a>04856 
<a name="l04857"></a>04857    <span class="keywordflow">for</span> (;;) {
<a name="l04858"></a>04858       <span class="keywordflow">for</span> (i = end_pos; i &gt; 0; --i)
<a name="l04859"></a>04859          <span class="keywordflow">if</span> (f-&gt;segments[i-1] != 255)
<a name="l04860"></a>04860             <span class="keywordflow">break</span>;
<a name="l04861"></a>04861 
<a name="l04862"></a>04862       start_seg_with_known_loc = i;
<a name="l04863"></a>04863 
<a name="l04864"></a>04864       <span class="keywordflow">if</span> (start_seg_with_known_loc &gt; 0 || !(f-&gt;page_flag &amp; PAGEFLAG_continued_packet))
<a name="l04865"></a>04865          <span class="keywordflow">break</span>;
<a name="l04866"></a>04866 
<a name="l04867"></a>04867       <span class="comment">// (untested) the final packet begins on an earlier page</span>
<a name="l04868"></a>04868       <span class="keywordflow">if</span> (!go_to_page_before(f, page_start))
<a name="l04869"></a>04869          <span class="keywordflow">goto</span> error;
<a name="l04870"></a>04870 
<a name="l04871"></a>04871       page_start = stb_vorbis_get_file_offset(f);
<a name="l04872"></a>04872       <span class="keywordflow">if</span> (!start_page(f)) <span class="keywordflow">goto</span> error;
<a name="l04873"></a>04873       end_pos = f-&gt;segment_count - 1;
<a name="l04874"></a>04874    }
<a name="l04875"></a>04875 
<a name="l04876"></a>04876    <span class="comment">// prepare to start decoding</span>
<a name="l04877"></a>04877    f-&gt;current_loc_valid = FALSE;
<a name="l04878"></a>04878    f-&gt;last_seg = FALSE;
<a name="l04879"></a>04879    f-&gt;valid_bits = 0;
<a name="l04880"></a>04880    f-&gt;packet_bytes = 0;
<a name="l04881"></a>04881    f-&gt;bytes_in_seg = 0;
<a name="l04882"></a>04882    f-&gt;previous_length = 0;
<a name="l04883"></a>04883    f-&gt;next_seg = start_seg_with_known_loc;
<a name="l04884"></a>04884 
<a name="l04885"></a>04885    <span class="keywordflow">for</span> (i = 0; i &lt; start_seg_with_known_loc; i++)
<a name="l04886"></a>04886       skip(f, f-&gt;segments[i]);
<a name="l04887"></a>04887 
<a name="l04888"></a>04888    <span class="comment">// start decoding (optimizable - this frame is generally discarded)</span>
<a name="l04889"></a>04889    <span class="keywordflow">if</span> (!vorbis_pump_first_frame(f))
<a name="l04890"></a>04890       <span class="keywordflow">return</span> 0;
<a name="l04891"></a>04891    <span class="keywordflow">if</span> (f-&gt;current_loc &gt; sample_number)
<a name="l04892"></a>04892       <span class="keywordflow">return</span> error(f, VORBIS_seek_failed);
<a name="l04893"></a>04893    <span class="keywordflow">return</span> 1;
<a name="l04894"></a>04894 
<a name="l04895"></a>04895 error:
<a name="l04896"></a>04896    <span class="comment">// try to restore the file to a valid state</span>
<a name="l04897"></a>04897    stb_vorbis_seek_start(f);
<a name="l04898"></a>04898    <span class="keywordflow">return</span> error(f, VORBIS_seek_failed);
<a name="l04899"></a>04899 }
<a name="l04900"></a>04900 
<a name="l04901"></a>04901 <span class="comment">// the same as vorbis_decode_initial, but without advancing</span>
<a name="l04902"></a>04902 <span class="keyword">static</span> <span class="keywordtype">int</span> peek_decode_initial(<a class="code" href="structstb__vorbis.html">vorb</a> *f, <span class="keywordtype">int</span> *p_left_start, <span class="keywordtype">int</span> *p_left_end, <span class="keywordtype">int</span> *p_right_start, <span class="keywordtype">int</span> *p_right_end, <span class="keywordtype">int</span> *mode)
<a name="l04903"></a>04903 {
<a name="l04904"></a>04904    <span class="keywordtype">int</span> bits_read, bytes_read;
<a name="l04905"></a>04905 
<a name="l04906"></a>04906    <span class="keywordflow">if</span> (!vorbis_decode_initial(f, p_left_start, p_left_end, p_right_start, p_right_end, mode))
<a name="l04907"></a>04907       <span class="keywordflow">return</span> 0;
<a name="l04908"></a>04908 
<a name="l04909"></a>04909    <span class="comment">// either 1 or 2 bytes were read, figure out which so we can rewind</span>
<a name="l04910"></a>04910    bits_read = 1 + ilog(f-&gt;mode_count-1);
<a name="l04911"></a>04911    <span class="keywordflow">if</span> (f-&gt;mode_config[*mode].blockflag)
<a name="l04912"></a>04912       bits_read += 2;
<a name="l04913"></a>04913    bytes_read = (bits_read + 7) / 8;
<a name="l04914"></a>04914 
<a name="l04915"></a>04915    f-&gt;bytes_in_seg += bytes_read;
<a name="l04916"></a>04916    f-&gt;packet_bytes -= bytes_read;
<a name="l04917"></a>04917    skip(f, -bytes_read);
<a name="l04918"></a>04918    <span class="keywordflow">if</span> (f-&gt;next_seg == -1)
<a name="l04919"></a>04919       f-&gt;next_seg = f-&gt;segment_count - 1;
<a name="l04920"></a>04920    <span class="keywordflow">else</span>
<a name="l04921"></a>04921       f-&gt;next_seg--;
<a name="l04922"></a>04922    f-&gt;valid_bits = 0;
<a name="l04923"></a>04923 
<a name="l04924"></a>04924    <span class="keywordflow">return</span> 1;
<a name="l04925"></a>04925 }
<a name="l04926"></a>04926 
<a name="l04927"></a>04927 <span class="keywordtype">int</span> stb_vorbis_seek_frame(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sample_number)
<a name="l04928"></a>04928 {
<a name="l04929"></a>04929    uint32 max_frame_samples;
<a name="l04930"></a>04930 
<a name="l04931"></a>04931    <span class="keywordflow">if</span> (IS_PUSH_MODE(f)) <span class="keywordflow">return</span> error(f, VORBIS_invalid_api_mixing);
<a name="l04932"></a>04932 
<a name="l04933"></a>04933    <span class="comment">// fast page-level search</span>
<a name="l04934"></a>04934    <span class="keywordflow">if</span> (!seek_to_sample_coarse(f, sample_number))
<a name="l04935"></a>04935       <span class="keywordflow">return</span> 0;
<a name="l04936"></a>04936 
<a name="l04937"></a>04937    assert(f-&gt;current_loc_valid);
<a name="l04938"></a>04938    assert(f-&gt;current_loc &lt;= sample_number);
<a name="l04939"></a>04939 
<a name="l04940"></a>04940    <span class="comment">// linear search for the relevant packet</span>
<a name="l04941"></a>04941    max_frame_samples = (f-&gt;blocksize_1*3 - f-&gt;blocksize_0) &gt;&gt; 2;
<a name="l04942"></a>04942    <span class="keywordflow">while</span> (f-&gt;current_loc &lt; sample_number) {
<a name="l04943"></a>04943       <span class="keywordtype">int</span> left_start, left_end, right_start, right_end, mode, frame_samples;
<a name="l04944"></a>04944       <span class="keywordflow">if</span> (!peek_decode_initial(f, &amp;left_start, &amp;left_end, &amp;right_start, &amp;right_end, &amp;mode))
<a name="l04945"></a>04945          <span class="keywordflow">return</span> error(f, VORBIS_seek_failed);
<a name="l04946"></a>04946       <span class="comment">// calculate the number of samples returned by the next frame</span>
<a name="l04947"></a>04947       frame_samples = right_start - left_start;
<a name="l04948"></a>04948       <span class="keywordflow">if</span> (f-&gt;current_loc + frame_samples &gt; sample_number) {
<a name="l04949"></a>04949          <span class="keywordflow">return</span> 1; <span class="comment">// the next frame will contain the sample</span>
<a name="l04950"></a>04950       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (f-&gt;current_loc + frame_samples + max_frame_samples &gt; sample_number) {
<a name="l04951"></a>04951          <span class="comment">// there&#39;s a chance the frame after this could contain the sample</span>
<a name="l04952"></a>04952          vorbis_pump_first_frame(f);
<a name="l04953"></a>04953       } <span class="keywordflow">else</span> {
<a name="l04954"></a>04954          <span class="comment">// this frame is too early to be relevant</span>
<a name="l04955"></a>04955          f-&gt;current_loc += frame_samples;
<a name="l04956"></a>04956          f-&gt;previous_length = 0;
<a name="l04957"></a>04957          maybe_start_packet(f);
<a name="l04958"></a>04958          flush_packet(f);
<a name="l04959"></a>04959       }
<a name="l04960"></a>04960    }
<a name="l04961"></a>04961    <span class="comment">// the next frame should start with the sample</span>
<a name="l04962"></a>04962    <span class="keywordflow">if</span> (f-&gt;current_loc != sample_number) <span class="keywordflow">return</span> error(f, VORBIS_seek_failed);
<a name="l04963"></a>04963    <span class="keywordflow">return</span> 1;
<a name="l04964"></a>04964 }
<a name="l04965"></a>04965 
<a name="l04966"></a>04966 <span class="keywordtype">int</span> stb_vorbis_seek(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sample_number)
<a name="l04967"></a>04967 {
<a name="l04968"></a>04968    <span class="keywordflow">if</span> (!stb_vorbis_seek_frame(f, sample_number))
<a name="l04969"></a>04969       <span class="keywordflow">return</span> 0;
<a name="l04970"></a>04970 
<a name="l04971"></a>04971    <span class="keywordflow">if</span> (sample_number != f-&gt;current_loc) {
<a name="l04972"></a>04972       <span class="keywordtype">int</span> n;
<a name="l04973"></a>04973       uint32 frame_start = f-&gt;current_loc;
<a name="l04974"></a>04974       stb_vorbis_get_frame_float(f, &amp;n, NULL);
<a name="l04975"></a>04975       assert(sample_number &gt; frame_start);
<a name="l04976"></a>04976       assert(f-&gt;channel_buffer_start + (<span class="keywordtype">int</span>) (sample_number-frame_start) &lt;= f-&gt;channel_buffer_end);
<a name="l04977"></a>04977       f-&gt;channel_buffer_start += (sample_number - frame_start);
<a name="l04978"></a>04978    }
<a name="l04979"></a>04979 
<a name="l04980"></a>04980    <span class="keywordflow">return</span> 1;
<a name="l04981"></a>04981 }
<a name="l04982"></a>04982 
<a name="l04983"></a>04983 <span class="keywordtype">int</span> stb_vorbis_seek_start(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f)
<a name="l04984"></a>04984 {
<a name="l04985"></a>04985    <span class="keywordflow">if</span> (IS_PUSH_MODE(f)) { <span class="keywordflow">return</span> error(f, VORBIS_invalid_api_mixing); }
<a name="l04986"></a>04986    set_file_offset(f, f-&gt;first_audio_page_offset);
<a name="l04987"></a>04987    f-&gt;previous_length = 0;
<a name="l04988"></a>04988    f-&gt;first_decode = TRUE;
<a name="l04989"></a>04989    f-&gt;next_seg = -1;
<a name="l04990"></a>04990    <span class="keywordflow">return</span> vorbis_pump_first_frame(f);
<a name="l04991"></a>04991 }
<a name="l04992"></a>04992 
<a name="l04993"></a>04993 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stb_vorbis_stream_length_in_samples(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f)
<a name="l04994"></a>04994 {
<a name="l04995"></a>04995    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> restore_offset, previous_safe;
<a name="l04996"></a>04996    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> end, last_page_loc;
<a name="l04997"></a>04997 
<a name="l04998"></a>04998    <span class="keywordflow">if</span> (IS_PUSH_MODE(f)) <span class="keywordflow">return</span> error(f, VORBIS_invalid_api_mixing);
<a name="l04999"></a>04999    <span class="keywordflow">if</span> (!f-&gt;total_samples) {
<a name="l05000"></a>05000       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> last;
<a name="l05001"></a>05001       uint32 lo,hi;
<a name="l05002"></a>05002       <span class="keywordtype">char</span> header[6];
<a name="l05003"></a>05003 
<a name="l05004"></a>05004       <span class="comment">// first, store the current decode position so we can restore it</span>
<a name="l05005"></a>05005       restore_offset = stb_vorbis_get_file_offset(f);
<a name="l05006"></a>05006 
<a name="l05007"></a>05007       <span class="comment">// now we want to seek back 64K from the end (the last page must</span>
<a name="l05008"></a>05008       <span class="comment">// be at most a little less than 64K, but let&#39;s allow a little slop)</span>
<a name="l05009"></a>05009       <span class="keywordflow">if</span> (f-&gt;stream_len &gt;= 65536 &amp;&amp; f-&gt;stream_len-65536 &gt;= f-&gt;first_audio_page_offset)
<a name="l05010"></a>05010          previous_safe = f-&gt;stream_len - 65536;
<a name="l05011"></a>05011       <span class="keywordflow">else</span>
<a name="l05012"></a>05012          previous_safe = f-&gt;first_audio_page_offset;
<a name="l05013"></a>05013 
<a name="l05014"></a>05014       set_file_offset(f, previous_safe);
<a name="l05015"></a>05015       <span class="comment">// previous_safe is now our candidate &#39;earliest known place that seeking</span>
<a name="l05016"></a>05016       <span class="comment">// to will lead to the final page&#39;</span>
<a name="l05017"></a>05017 
<a name="l05018"></a>05018       <span class="keywordflow">if</span> (!vorbis_find_page(f, &amp;end, &amp;last)) {
<a name="l05019"></a>05019          <span class="comment">// if we can&#39;t find a page, we&#39;re hosed!</span>
<a name="l05020"></a>05020          f-&gt;error = VORBIS_cant_find_last_page;
<a name="l05021"></a>05021          f-&gt;total_samples = 0xffffffff;
<a name="l05022"></a>05022          <span class="keywordflow">goto</span> done;
<a name="l05023"></a>05023       }
<a name="l05024"></a>05024 
<a name="l05025"></a>05025       <span class="comment">// check if there are more pages</span>
<a name="l05026"></a>05026       last_page_loc = stb_vorbis_get_file_offset(f);
<a name="l05027"></a>05027 
<a name="l05028"></a>05028       <span class="comment">// stop when the last_page flag is set, not when we reach eof;</span>
<a name="l05029"></a>05029       <span class="comment">// this allows us to stop short of a &#39;file_section&#39; end without</span>
<a name="l05030"></a>05030       <span class="comment">// explicitly checking the length of the section</span>
<a name="l05031"></a>05031       <span class="keywordflow">while</span> (!last) {
<a name="l05032"></a>05032          set_file_offset(f, end);
<a name="l05033"></a>05033          <span class="keywordflow">if</span> (!vorbis_find_page(f, &amp;end, &amp;last)) {
<a name="l05034"></a>05034             <span class="comment">// the last page we found didn&#39;t have the &#39;last page&#39; flag</span>
<a name="l05035"></a>05035             <span class="comment">// set. whoops!</span>
<a name="l05036"></a>05036             <span class="keywordflow">break</span>;
<a name="l05037"></a>05037          }
<a name="l05038"></a>05038          last_page_loc = stb_vorbis_get_file_offset(f);
<a name="l05039"></a>05039       }
<a name="l05040"></a>05040 
<a name="l05041"></a>05041       set_file_offset(f, last_page_loc);
<a name="l05042"></a>05042 
<a name="l05043"></a>05043       <span class="comment">// parse the header</span>
<a name="l05044"></a>05044       getn(f, (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)header, 6);
<a name="l05045"></a>05045       <span class="comment">// extract the absolute granule position</span>
<a name="l05046"></a>05046       lo = get32(f);
<a name="l05047"></a>05047       hi = get32(f);
<a name="l05048"></a>05048       <span class="keywordflow">if</span> (lo == 0xffffffff &amp;&amp; hi == 0xffffffff) {
<a name="l05049"></a>05049          f-&gt;error = VORBIS_cant_find_last_page;
<a name="l05050"></a>05050          f-&gt;total_samples = SAMPLE_unknown;
<a name="l05051"></a>05051          <span class="keywordflow">goto</span> done;
<a name="l05052"></a>05052       }
<a name="l05053"></a>05053       <span class="keywordflow">if</span> (hi)
<a name="l05054"></a>05054          lo = 0xfffffffe; <span class="comment">// saturate</span>
<a name="l05055"></a>05055       f-&gt;total_samples = lo;
<a name="l05056"></a>05056 
<a name="l05057"></a>05057       f-&gt;p_last.page_start = last_page_loc;
<a name="l05058"></a>05058       f-&gt;p_last.page_end   = end;
<a name="l05059"></a>05059       f-&gt;p_last.last_decoded_sample = lo;
<a name="l05060"></a>05060 
<a name="l05061"></a>05061      done:
<a name="l05062"></a>05062       set_file_offset(f, restore_offset);
<a name="l05063"></a>05063    }
<a name="l05064"></a>05064    <span class="keywordflow">return</span> f-&gt;total_samples == SAMPLE_unknown ? 0 : f-&gt;total_samples;
<a name="l05065"></a>05065 }
<a name="l05066"></a>05066 
<a name="l05067"></a>05067 <span class="keywordtype">float</span> stb_vorbis_stream_length_in_seconds(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f)
<a name="l05068"></a>05068 {
<a name="l05069"></a>05069    <span class="keywordflow">return</span> stb_vorbis_stream_length_in_samples(f) / (float) f-&gt;sample_rate;
<a name="l05070"></a>05070 }
<a name="l05071"></a>05071 
<a name="l05072"></a>05072 
<a name="l05073"></a>05073 
<a name="l05074"></a>05074 <span class="keywordtype">int</span> stb_vorbis_get_frame_float(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> *channels, <span class="keywordtype">float</span> ***output)
<a name="l05075"></a>05075 {
<a name="l05076"></a>05076    <span class="keywordtype">int</span> len, right,left,i;
<a name="l05077"></a>05077    <span class="keywordflow">if</span> (IS_PUSH_MODE(f)) <span class="keywordflow">return</span> error(f, VORBIS_invalid_api_mixing);
<a name="l05078"></a>05078 
<a name="l05079"></a>05079    <span class="keywordflow">if</span> (!vorbis_decode_packet(f, &amp;len, &amp;left, &amp;right)) {
<a name="l05080"></a>05080       f-&gt;channel_buffer_start = f-&gt;channel_buffer_end = 0;
<a name="l05081"></a>05081       <span class="keywordflow">return</span> 0;
<a name="l05082"></a>05082    }
<a name="l05083"></a>05083 
<a name="l05084"></a>05084    len = vorbis_finish_frame(f, len, left, right);
<a name="l05085"></a>05085    <span class="keywordflow">for</span> (i=0; i &lt; f-&gt;channels; ++i)
<a name="l05086"></a>05086       f-&gt;outputs[i] = f-&gt;channel_buffers[i] + left;
<a name="l05087"></a>05087 
<a name="l05088"></a>05088    f-&gt;channel_buffer_start = left;
<a name="l05089"></a>05089    f-&gt;channel_buffer_end   = left+len;
<a name="l05090"></a>05090 
<a name="l05091"></a>05091    if (channels) *channels = f-&gt;channels;
<a name="l05092"></a>05092    <span class="keywordflow">if</span> (output)   *output = f-&gt;outputs;
<a name="l05093"></a>05093    <span class="keywordflow">return</span> len;
<a name="l05094"></a>05094 }
<a name="l05095"></a>05095 
<a name="l05096"></a>05096 <span class="preprocessor">#ifndef STB_VORBIS_NO_STDIO</span>
<a name="l05097"></a>05097 <span class="preprocessor"></span>
<a name="l05098"></a>05098 <a class="code" href="structstb__vorbis.html">stb_vorbis</a> * stb_vorbis_open_file_section(FILE *file, <span class="keywordtype">int</span> close_on_free, <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
<a name="l05099"></a>05099 {
<a name="l05100"></a>05100    <a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, p;
<a name="l05101"></a>05101    vorbis_init(&amp;p, alloc);
<a name="l05102"></a>05102    p.f = file;
<a name="l05103"></a>05103    p.f_start = (uint32) ftell(file);
<a name="l05104"></a>05104    p.stream_len   = length;
<a name="l05105"></a>05105    p.close_on_free = close_on_free;
<a name="l05106"></a>05106    <span class="keywordflow">if</span> (start_decoder(&amp;p)) {
<a name="l05107"></a>05107       f = vorbis_alloc(&amp;p);
<a name="l05108"></a>05108       <span class="keywordflow">if</span> (f) {
<a name="l05109"></a>05109          *f = p;
<a name="l05110"></a>05110          vorbis_pump_first_frame(f);
<a name="l05111"></a>05111          <span class="keywordflow">return</span> f;
<a name="l05112"></a>05112       }
<a name="l05113"></a>05113    }
<a name="l05114"></a>05114    <span class="keywordflow">if</span> (error) *error = p.error;
<a name="l05115"></a>05115    vorbis_deinit(&amp;p);
<a name="l05116"></a>05116    <span class="keywordflow">return</span> NULL;
<a name="l05117"></a>05117 }
<a name="l05118"></a>05118 
<a name="l05119"></a>05119 <a class="code" href="structstb__vorbis.html">stb_vorbis</a> * stb_vorbis_open_file(FILE *file, <span class="keywordtype">int</span> close_on_free, <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc)
<a name="l05120"></a>05120 {
<a name="l05121"></a>05121    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len, start;
<a name="l05122"></a>05122    start = (<span class="keywordtype">unsigned</span> int) ftell(file);
<a name="l05123"></a>05123    fseek(file, 0, SEEK_END);
<a name="l05124"></a>05124    len = (<span class="keywordtype">unsigned</span> int) (ftell(file) - start);
<a name="l05125"></a>05125    fseek(file, start, SEEK_SET);
<a name="l05126"></a>05126    <span class="keywordflow">return</span> stb_vorbis_open_file_section(file, close_on_free, error, alloc, len);
<a name="l05127"></a>05127 }
<a name="l05128"></a>05128 
<a name="l05129"></a>05129 <a class="code" href="structstb__vorbis.html">stb_vorbis</a> * stb_vorbis_open_filename(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc)
<a name="l05130"></a>05130 {
<a name="l05131"></a>05131    FILE *f;
<a name="l05132"></a>05132 <span class="preprocessor">#if defined(_WIN32) &amp;&amp; defined(__STDC_WANT_SECURE_LIB__)</span>
<a name="l05133"></a>05133 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (0 != fopen_s(&amp;f, filename, <span class="stringliteral">&quot;rb&quot;</span>))
<a name="l05134"></a>05134       f = NULL;
<a name="l05135"></a>05135 <span class="preprocessor">#else</span>
<a name="l05136"></a>05136 <span class="preprocessor"></span>   f = fopen(filename, <span class="stringliteral">&quot;rb&quot;</span>);
<a name="l05137"></a>05137 <span class="preprocessor">#endif</span>
<a name="l05138"></a>05138 <span class="preprocessor"></span>   <span class="keywordflow">if</span> (f)
<a name="l05139"></a>05139       <span class="keywordflow">return</span> stb_vorbis_open_file(f, TRUE, error, alloc);
<a name="l05140"></a>05140    <span class="keywordflow">if</span> (error) *error = VORBIS_file_open_failure;
<a name="l05141"></a>05141    <span class="keywordflow">return</span> NULL;
<a name="l05142"></a>05142 }
<a name="l05143"></a>05143 <span class="preprocessor">#endif // STB_VORBIS_NO_STDIO</span>
<a name="l05144"></a>05144 <span class="preprocessor"></span>
<a name="l05145"></a>05145 <span class="preprocessor">#ifdef __SDL_SOUND_INTERNAL__</span>
<a name="l05146"></a>05146 <span class="preprocessor"></span><a class="code" href="structstb__vorbis.html">stb_vorbis</a> * stb_vorbis_open_rwops_section(SDL_RWops *rwops, <span class="keywordtype">int</span> close_on_free, <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length)
<a name="l05147"></a>05147 {
<a name="l05148"></a>05148    <a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, p;
<a name="l05149"></a>05149    vorbis_init(&amp;p, alloc);
<a name="l05150"></a>05150    p.rwops = rwops;
<a name="l05151"></a>05151    p.rwops_start = (uint32) SDL_RWtell(rwops);
<a name="l05152"></a>05152    p.stream_len   = length;
<a name="l05153"></a>05153    p.close_on_free = close_on_free;
<a name="l05154"></a>05154    <span class="keywordflow">if</span> (start_decoder(&amp;p)) {
<a name="l05155"></a>05155       f = vorbis_alloc(&amp;p);
<a name="l05156"></a>05156       <span class="keywordflow">if</span> (f) {
<a name="l05157"></a>05157          memcpy(f, &amp;p, <span class="keyword">sizeof</span> (<a class="code" href="structstb__vorbis.html">stb_vorbis</a>));
<a name="l05158"></a>05158          vorbis_pump_first_frame(f);
<a name="l05159"></a>05159          <span class="keywordflow">return</span> f;
<a name="l05160"></a>05160       }
<a name="l05161"></a>05161    }
<a name="l05162"></a>05162    <span class="keywordflow">if</span> (error) *error = p.error;
<a name="l05163"></a>05163    vorbis_deinit(&amp;p);
<a name="l05164"></a>05164    <span class="keywordflow">return</span> NULL;
<a name="l05165"></a>05165 }
<a name="l05166"></a>05166 
<a name="l05167"></a>05167 <a class="code" href="structstb__vorbis.html">stb_vorbis</a> * stb_vorbis_open_rwops(SDL_RWops *rwops, <span class="keywordtype">int</span> close_on_free, <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc)
<a name="l05168"></a>05168 {
<a name="l05169"></a>05169    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start = (<span class="keywordtype">unsigned</span> int) SDL_RWtell(rwops);
<a name="l05170"></a>05170    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = (<span class="keywordtype">unsigned</span> int) (SDL_RWseek(rwops, 0, RW_SEEK_END) - start);
<a name="l05171"></a>05171    SDL_RWseek(rwops, start, RW_SEEK_SET);
<a name="l05172"></a>05172    <span class="keywordflow">return</span> stb_vorbis_open_rwops_section(rwops, close_on_free, error, alloc, len);
<a name="l05173"></a>05173 }
<a name="l05174"></a>05174 <span class="preprocessor">#endif</span>
<a name="l05175"></a>05175 <span class="preprocessor"></span>
<a name="l05176"></a>05176 <a class="code" href="structstb__vorbis.html">stb_vorbis</a> * stb_vorbis_open_memory(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">int</span> len, <span class="keywordtype">int</span> *error, <span class="keyword">const</span> <a class="code" href="structstb__vorbis__alloc.html">stb_vorbis_alloc</a> *alloc)
<a name="l05177"></a>05177 {
<a name="l05178"></a>05178    <a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, p;
<a name="l05179"></a>05179    <span class="keywordflow">if</span> (data == NULL) <span class="keywordflow">return</span> NULL;
<a name="l05180"></a>05180    vorbis_init(&amp;p, alloc);
<a name="l05181"></a>05181    p.stream = (uint8 *) data;
<a name="l05182"></a>05182    p.stream_end = (uint8 *) data + len;
<a name="l05183"></a>05183    p.stream_start = (uint8 *) p.stream;
<a name="l05184"></a>05184    p.stream_len = len;
<a name="l05185"></a>05185    p.push_mode = FALSE;
<a name="l05186"></a>05186    if (start_decoder(&amp;p)) {
<a name="l05187"></a>05187       f = vorbis_alloc(&amp;p);
<a name="l05188"></a>05188       <span class="keywordflow">if</span> (f) {
<a name="l05189"></a>05189          *f = p;
<a name="l05190"></a>05190          vorbis_pump_first_frame(f);
<a name="l05191"></a>05191          <span class="keywordflow">if</span> (error) *error = VORBIS__no_error;
<a name="l05192"></a>05192          <span class="keywordflow">return</span> f;
<a name="l05193"></a>05193       }
<a name="l05194"></a>05194    }
<a name="l05195"></a>05195    <span class="keywordflow">if</span> (error) *error = (int)(p.error);
<a name="l05196"></a>05196    vorbis_deinit(&amp;p);
<a name="l05197"></a>05197    <span class="keywordflow">return</span> NULL;
<a name="l05198"></a>05198 }
<a name="l05199"></a>05199 
<a name="l05200"></a>05200 <span class="preprocessor">#ifndef STB_VORBIS_NO_INTEGER_CONVERSION</span>
<a name="l05201"></a>05201 <span class="preprocessor"></span><span class="preprocessor">#define PLAYBACK_MONO     1</span>
<a name="l05202"></a>05202 <span class="preprocessor"></span><span class="preprocessor">#define PLAYBACK_LEFT     2</span>
<a name="l05203"></a>05203 <span class="preprocessor"></span><span class="preprocessor">#define PLAYBACK_RIGHT    4</span>
<a name="l05204"></a>05204 <span class="preprocessor"></span>
<a name="l05205"></a>05205 <span class="preprocessor">#define L  (PLAYBACK_LEFT  | PLAYBACK_MONO)</span>
<a name="l05206"></a>05206 <span class="preprocessor"></span><span class="preprocessor">#define C  (PLAYBACK_LEFT  | PLAYBACK_RIGHT | PLAYBACK_MONO)</span>
<a name="l05207"></a>05207 <span class="preprocessor"></span><span class="preprocessor">#define R  (PLAYBACK_RIGHT | PLAYBACK_MONO)</span>
<a name="l05208"></a>05208 <span class="preprocessor"></span>
<a name="l05209"></a>05209 <span class="keyword">static</span> int8 channel_position[7][6] =
<a name="l05210"></a>05210 {
<a name="l05211"></a>05211    { 0 },
<a name="l05212"></a>05212    { C },
<a name="l05213"></a>05213    { L, R },
<a name="l05214"></a>05214    { L, C, R },
<a name="l05215"></a>05215    { L, R, L, R },
<a name="l05216"></a>05216    { L, C, R, L, R },
<a name="l05217"></a>05217    { L, C, R, L, R, C },
<a name="l05218"></a>05218 };
<a name="l05219"></a>05219 
<a name="l05220"></a>05220 
<a name="l05221"></a>05221 <span class="preprocessor">#ifndef STB_VORBIS_NO_FAST_SCALED_FLOAT</span>
<a name="l05222"></a><a class="code" href="unionfloat__conv.html">05222</a> <span class="preprocessor"></span>   <span class="keyword">typedef</span> <span class="keyword">union </span>{
<a name="l05223"></a>05223       <span class="keywordtype">float</span> f;
<a name="l05224"></a>05224       <span class="keywordtype">int</span> i;
<a name="l05225"></a>05225    } <a class="code" href="unionfloat__conv.html">float_conv</a>;
<a name="l05226"></a>05226    <span class="keyword">typedef</span> <span class="keywordtype">char</span> stb_vorbis_float_size_test[<span class="keyword">sizeof</span>(float)==4 &amp;&amp; <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) == 4];
<a name="l05227"></a>05227 <span class="preprocessor">   #define FASTDEF(x) float_conv x</span>
<a name="l05228"></a>05228 <span class="preprocessor"></span>   <span class="comment">// add (1&lt;&lt;23) to convert to int, then divide by 2^SHIFT, then add 0.5/2^SHIFT to round</span>
<a name="l05229"></a>05229 <span class="preprocessor">   #define MAGIC(SHIFT) (1.5f * (1 &lt;&lt; (23-SHIFT)) + 0.5f/(1 &lt;&lt; SHIFT))</span>
<a name="l05230"></a>05230 <span class="preprocessor"></span><span class="preprocessor">   #define ADDEND(SHIFT) (((150-SHIFT) &lt;&lt; 23) + (1 &lt;&lt; 22))</span>
<a name="l05231"></a>05231 <span class="preprocessor"></span><span class="preprocessor">   #define FAST_SCALED_FLOAT_TO_INT(temp,x,s) (temp.f = (x) + MAGIC(s), temp.i - ADDEND(s))</span>
<a name="l05232"></a>05232 <span class="preprocessor"></span><span class="preprocessor">   #define check_endianness()</span>
<a name="l05233"></a>05233 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l05234"></a>05234 <span class="preprocessor"></span><span class="preprocessor">   #define FAST_SCALED_FLOAT_TO_INT(temp,x,s) ((int) ((x) * (1 &lt;&lt; (s))))</span>
<a name="l05235"></a>05235 <span class="preprocessor"></span><span class="preprocessor">   #define check_endianness()</span>
<a name="l05236"></a>05236 <span class="preprocessor"></span><span class="preprocessor">   #define FASTDEF(x)</span>
<a name="l05237"></a>05237 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l05238"></a>05238 <span class="preprocessor"></span>
<a name="l05239"></a>05239 <span class="keyword">static</span> <span class="keywordtype">void</span> copy_samples(<span class="keywordtype">short</span> *dest, <span class="keywordtype">float</span> *src, <span class="keywordtype">int</span> len)
<a name="l05240"></a>05240 {
<a name="l05241"></a>05241    <span class="keywordtype">int</span> i;
<a name="l05242"></a>05242    check_endianness();
<a name="l05243"></a>05243    <span class="keywordflow">for</span> (i=0; i &lt; len; ++i) {
<a name="l05244"></a>05244       FASTDEF(temp);
<a name="l05245"></a>05245       <span class="keywordtype">int</span> v = FAST_SCALED_FLOAT_TO_INT(temp, src[i],15);
<a name="l05246"></a>05246       <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (v + 32768) &gt; 65535)
<a name="l05247"></a>05247          v = v &lt; 0 ? -32768 : 32767;
<a name="l05248"></a>05248       dest[i] = v;
<a name="l05249"></a>05249    }
<a name="l05250"></a>05250 }
<a name="l05251"></a>05251 
<a name="l05252"></a>05252 <span class="keyword">static</span> <span class="keywordtype">void</span> compute_samples(<span class="keywordtype">int</span> mask, <span class="keywordtype">short</span> *output, <span class="keywordtype">int</span> num_c, <span class="keywordtype">float</span> **data, <span class="keywordtype">int</span> d_offset, <span class="keywordtype">int</span> len)
<a name="l05253"></a>05253 {
<a name="l05254"></a>05254 <span class="preprocessor">   #define BUFFER_SIZE  32</span>
<a name="l05255"></a>05255 <span class="preprocessor"></span>   <span class="keywordtype">float</span> buffer[BUFFER_SIZE];
<a name="l05256"></a>05256    <span class="keywordtype">int</span> i,j,o,n = BUFFER_SIZE;
<a name="l05257"></a>05257    check_endianness();
<a name="l05258"></a>05258    <span class="keywordflow">for</span> (o = 0; o &lt; len; o += BUFFER_SIZE) {
<a name="l05259"></a>05259       memset(buffer, 0, <span class="keyword">sizeof</span>(buffer));
<a name="l05260"></a>05260       <span class="keywordflow">if</span> (o + n &gt; len) n = len - o;
<a name="l05261"></a>05261       <span class="keywordflow">for</span> (j=0; j &lt; num_c; ++j) {
<a name="l05262"></a>05262          <span class="keywordflow">if</span> (channel_position[num_c][j] &amp; mask) {
<a name="l05263"></a>05263             <span class="keywordflow">for</span> (i=0; i &lt; n; ++i)
<a name="l05264"></a>05264                buffer[i] += data[j][d_offset+o+i];
<a name="l05265"></a>05265          }
<a name="l05266"></a>05266       }
<a name="l05267"></a>05267       <span class="keywordflow">for</span> (i=0; i &lt; n; ++i) {
<a name="l05268"></a>05268          FASTDEF(temp);
<a name="l05269"></a>05269          <span class="keywordtype">int</span> v = FAST_SCALED_FLOAT_TO_INT(temp,buffer[i],15);
<a name="l05270"></a>05270          <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (v + 32768) &gt; 65535)
<a name="l05271"></a>05271             v = v &lt; 0 ? -32768 : 32767;
<a name="l05272"></a>05272          output[o+i] = v;
<a name="l05273"></a>05273       }
<a name="l05274"></a>05274    }
<a name="l05275"></a>05275 }
<a name="l05276"></a>05276 
<a name="l05277"></a>05277 <span class="keyword">static</span> <span class="keywordtype">void</span> compute_stereo_samples(<span class="keywordtype">short</span> *output, <span class="keywordtype">int</span> num_c, <span class="keywordtype">float</span> **data, <span class="keywordtype">int</span> d_offset, <span class="keywordtype">int</span> len)
<a name="l05278"></a>05278 {
<a name="l05279"></a>05279 <span class="preprocessor">   #define BUFFER_SIZE  32</span>
<a name="l05280"></a>05280 <span class="preprocessor"></span>   <span class="keywordtype">float</span> buffer[BUFFER_SIZE];
<a name="l05281"></a>05281    <span class="keywordtype">int</span> i,j,o,n = BUFFER_SIZE &gt;&gt; 1;
<a name="l05282"></a>05282    <span class="comment">// o is the offset in the source data</span>
<a name="l05283"></a>05283    check_endianness();
<a name="l05284"></a>05284    <span class="keywordflow">for</span> (o = 0; o &lt; len; o += BUFFER_SIZE &gt;&gt; 1) {
<a name="l05285"></a>05285       <span class="comment">// o2 is the offset in the output data</span>
<a name="l05286"></a>05286       <span class="keywordtype">int</span> o2 = o &lt;&lt; 1;
<a name="l05287"></a>05287       memset(buffer, 0, <span class="keyword">sizeof</span>(buffer));
<a name="l05288"></a>05288       <span class="keywordflow">if</span> (o + n &gt; len) n = len - o;
<a name="l05289"></a>05289       <span class="keywordflow">for</span> (j=0; j &lt; num_c; ++j) {
<a name="l05290"></a>05290          <span class="keywordtype">int</span> m = channel_position[num_c][j] &amp; (PLAYBACK_LEFT | PLAYBACK_RIGHT);
<a name="l05291"></a>05291          <span class="keywordflow">if</span> (m == (PLAYBACK_LEFT | PLAYBACK_RIGHT)) {
<a name="l05292"></a>05292             <span class="keywordflow">for</span> (i=0; i &lt; n; ++i) {
<a name="l05293"></a>05293                buffer[i*2+0] += data[j][d_offset+o+i];
<a name="l05294"></a>05294                buffer[i*2+1] += data[j][d_offset+o+i];
<a name="l05295"></a>05295             }
<a name="l05296"></a>05296          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m == PLAYBACK_LEFT) {
<a name="l05297"></a>05297             <span class="keywordflow">for</span> (i=0; i &lt; n; ++i) {
<a name="l05298"></a>05298                buffer[i*2+0] += data[j][d_offset+o+i];
<a name="l05299"></a>05299             }
<a name="l05300"></a>05300          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m == PLAYBACK_RIGHT) {
<a name="l05301"></a>05301             <span class="keywordflow">for</span> (i=0; i &lt; n; ++i) {
<a name="l05302"></a>05302                buffer[i*2+1] += data[j][d_offset+o+i];
<a name="l05303"></a>05303             }
<a name="l05304"></a>05304          }
<a name="l05305"></a>05305       }
<a name="l05306"></a>05306       <span class="keywordflow">for</span> (i=0; i &lt; (n&lt;&lt;1); ++i) {
<a name="l05307"></a>05307          FASTDEF(temp);
<a name="l05308"></a>05308          <span class="keywordtype">int</span> v = FAST_SCALED_FLOAT_TO_INT(temp,buffer[i],15);
<a name="l05309"></a>05309          <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (v + 32768) &gt; 65535)
<a name="l05310"></a>05310             v = v &lt; 0 ? -32768 : 32767;
<a name="l05311"></a>05311          output[o2+i] = v;
<a name="l05312"></a>05312       }
<a name="l05313"></a>05313    }
<a name="l05314"></a>05314 }
<a name="l05315"></a>05315 
<a name="l05316"></a>05316 <span class="keyword">static</span> <span class="keywordtype">void</span> convert_samples_short(<span class="keywordtype">int</span> buf_c, <span class="keywordtype">short</span> **buffer, <span class="keywordtype">int</span> b_offset, <span class="keywordtype">int</span> data_c, <span class="keywordtype">float</span> **data, <span class="keywordtype">int</span> d_offset, <span class="keywordtype">int</span> samples)
<a name="l05317"></a>05317 {
<a name="l05318"></a>05318    <span class="keywordtype">int</span> i;
<a name="l05319"></a>05319    <span class="keywordflow">if</span> (buf_c != data_c &amp;&amp; buf_c &lt;= 2 &amp;&amp; data_c &lt;= 6) {
<a name="l05320"></a>05320       <span class="keyword">static</span> <span class="keywordtype">int</span> channel_selector[3][2] = { {0}, {PLAYBACK_MONO}, {PLAYBACK_LEFT, PLAYBACK_RIGHT} };
<a name="l05321"></a>05321       <span class="keywordflow">for</span> (i=0; i &lt; buf_c; ++i)
<a name="l05322"></a>05322          compute_samples(channel_selector[buf_c][i], buffer[i]+b_offset, data_c, data, d_offset, samples);
<a name="l05323"></a>05323    } <span class="keywordflow">else</span> {
<a name="l05324"></a>05324       <span class="keywordtype">int</span> limit = buf_c &lt; data_c ? buf_c : data_c;
<a name="l05325"></a>05325       <span class="keywordflow">for</span> (i=0; i &lt; limit; ++i)
<a name="l05326"></a>05326          copy_samples(buffer[i]+b_offset, data[i]+d_offset, samples);
<a name="l05327"></a>05327       <span class="keywordflow">for</span> (   ; i &lt; buf_c; ++i)
<a name="l05328"></a>05328          memset(buffer[i]+b_offset, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>) * samples);
<a name="l05329"></a>05329    }
<a name="l05330"></a>05330 }
<a name="l05331"></a>05331 
<a name="l05332"></a>05332 <span class="keywordtype">int</span> stb_vorbis_get_frame_short(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> num_c, <span class="keywordtype">short</span> **buffer, <span class="keywordtype">int</span> num_samples)
<a name="l05333"></a>05333 {
<a name="l05334"></a>05334    <span class="keywordtype">float</span> **output = NULL;
<a name="l05335"></a>05335    <span class="keywordtype">int</span> len = stb_vorbis_get_frame_float(f, NULL, &amp;output);
<a name="l05336"></a>05336    <span class="keywordflow">if</span> (len &gt; num_samples) len = num_samples;
<a name="l05337"></a>05337    <span class="keywordflow">if</span> (len)
<a name="l05338"></a>05338       convert_samples_short(num_c, buffer, 0, f-&gt;channels, output, 0, len);
<a name="l05339"></a>05339    <span class="keywordflow">return</span> len;
<a name="l05340"></a>05340 }
<a name="l05341"></a>05341 
<a name="l05342"></a>05342 <span class="keyword">static</span> <span class="keywordtype">void</span> convert_channels_short_interleaved(<span class="keywordtype">int</span> buf_c, <span class="keywordtype">short</span> *buffer, <span class="keywordtype">int</span> data_c, <span class="keywordtype">float</span> **data, <span class="keywordtype">int</span> d_offset, <span class="keywordtype">int</span> len)
<a name="l05343"></a>05343 {
<a name="l05344"></a>05344    <span class="keywordtype">int</span> i;
<a name="l05345"></a>05345    check_endianness();
<a name="l05346"></a>05346    <span class="keywordflow">if</span> (buf_c != data_c &amp;&amp; buf_c &lt;= 2 &amp;&amp; data_c &lt;= 6) {
<a name="l05347"></a>05347       assert(buf_c == 2);
<a name="l05348"></a>05348       <span class="keywordflow">for</span> (i=0; i &lt; buf_c; ++i)
<a name="l05349"></a>05349          compute_stereo_samples(buffer, data_c, data, d_offset, len);
<a name="l05350"></a>05350    } <span class="keywordflow">else</span> {
<a name="l05351"></a>05351       <span class="keywordtype">int</span> limit = buf_c &lt; data_c ? buf_c : data_c;
<a name="l05352"></a>05352       <span class="keywordtype">int</span> j;
<a name="l05353"></a>05353       <span class="keywordflow">for</span> (j=0; j &lt; len; ++j) {
<a name="l05354"></a>05354          <span class="keywordflow">for</span> (i=0; i &lt; limit; ++i) {
<a name="l05355"></a>05355             FASTDEF(temp);
<a name="l05356"></a>05356             <span class="keywordtype">float</span> f = data[i][d_offset+j];
<a name="l05357"></a>05357             <span class="keywordtype">int</span> v = FAST_SCALED_FLOAT_TO_INT(temp, f,15);<span class="comment">//data[i][d_offset+j],15);</span>
<a name="l05358"></a>05358             <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) (v + 32768) &gt; 65535)
<a name="l05359"></a>05359                v = v &lt; 0 ? -32768 : 32767;
<a name="l05360"></a>05360             *buffer++ = v;
<a name="l05361"></a>05361          }
<a name="l05362"></a>05362          <span class="keywordflow">for</span> (   ; i &lt; buf_c; ++i)
<a name="l05363"></a>05363             *buffer++ = 0;
<a name="l05364"></a>05364       }
<a name="l05365"></a>05365    }
<a name="l05366"></a>05366 }
<a name="l05367"></a>05367 
<a name="l05368"></a>05368 <span class="keywordtype">int</span> stb_vorbis_get_frame_short_interleaved(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> num_c, <span class="keywordtype">short</span> *buffer, <span class="keywordtype">int</span> num_shorts)
<a name="l05369"></a>05369 {
<a name="l05370"></a>05370    <span class="keywordtype">float</span> **output;
<a name="l05371"></a>05371    <span class="keywordtype">int</span> len;
<a name="l05372"></a>05372    <span class="keywordflow">if</span> (num_c == 1) <span class="keywordflow">return</span> stb_vorbis_get_frame_short(f,num_c,&amp;buffer, num_shorts);
<a name="l05373"></a>05373    len = stb_vorbis_get_frame_float(f, NULL, &amp;output);
<a name="l05374"></a>05374    <span class="keywordflow">if</span> (len) {
<a name="l05375"></a>05375       <span class="keywordflow">if</span> (len*num_c &gt; num_shorts) len = num_shorts / num_c;
<a name="l05376"></a>05376       convert_channels_short_interleaved(num_c, buffer, f-&gt;channels, output, 0, len);
<a name="l05377"></a>05377    }
<a name="l05378"></a>05378    <span class="keywordflow">return</span> len;
<a name="l05379"></a>05379 }
<a name="l05380"></a>05380 
<a name="l05381"></a>05381 <span class="keywordtype">int</span> stb_vorbis_get_samples_short_interleaved(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> channels, <span class="keywordtype">short</span> *buffer, <span class="keywordtype">int</span> num_shorts)
<a name="l05382"></a>05382 {
<a name="l05383"></a>05383    <span class="keywordtype">float</span> **outputs;
<a name="l05384"></a>05384    <span class="keywordtype">int</span> len = num_shorts / channels;
<a name="l05385"></a>05385    <span class="keywordtype">int</span> n=0;
<a name="l05386"></a>05386    <span class="keywordflow">while</span> (n &lt; len) {
<a name="l05387"></a>05387       <span class="keywordtype">int</span> k = f-&gt;channel_buffer_end - f-&gt;channel_buffer_start;
<a name="l05388"></a>05388       <span class="keywordflow">if</span> (n+k &gt;= len) k = len - n;
<a name="l05389"></a>05389       <span class="keywordflow">if</span> (k)
<a name="l05390"></a>05390          convert_channels_short_interleaved(channels, buffer, f-&gt;channels, f-&gt;channel_buffers, f-&gt;channel_buffer_start, k);
<a name="l05391"></a>05391       buffer += k*channels;
<a name="l05392"></a>05392       n += k;
<a name="l05393"></a>05393       f-&gt;channel_buffer_start += k;
<a name="l05394"></a>05394       <span class="keywordflow">if</span> (n == len) <span class="keywordflow">break</span>;
<a name="l05395"></a>05395       <span class="keywordflow">if</span> (!stb_vorbis_get_frame_float(f, NULL, &amp;outputs)) <span class="keywordflow">break</span>;
<a name="l05396"></a>05396    }
<a name="l05397"></a>05397    <span class="keywordflow">return</span> n;
<a name="l05398"></a>05398 }
<a name="l05399"></a>05399 
<a name="l05400"></a>05400 <span class="keywordtype">int</span> stb_vorbis_get_samples_short(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> channels, <span class="keywordtype">short</span> **buffer, <span class="keywordtype">int</span> len)
<a name="l05401"></a>05401 {
<a name="l05402"></a>05402    <span class="keywordtype">float</span> **outputs;
<a name="l05403"></a>05403    <span class="keywordtype">int</span> n=0;
<a name="l05404"></a>05404    <span class="keywordflow">while</span> (n &lt; len) {
<a name="l05405"></a>05405       <span class="keywordtype">int</span> k = f-&gt;channel_buffer_end - f-&gt;channel_buffer_start;
<a name="l05406"></a>05406       <span class="keywordflow">if</span> (n+k &gt;= len) k = len - n;
<a name="l05407"></a>05407       <span class="keywordflow">if</span> (k)
<a name="l05408"></a>05408          convert_samples_short(channels, buffer, n, f-&gt;channels, f-&gt;channel_buffers, f-&gt;channel_buffer_start, k);
<a name="l05409"></a>05409       n += k;
<a name="l05410"></a>05410       f-&gt;channel_buffer_start += k;
<a name="l05411"></a>05411       <span class="keywordflow">if</span> (n == len) <span class="keywordflow">break</span>;
<a name="l05412"></a>05412       <span class="keywordflow">if</span> (!stb_vorbis_get_frame_float(f, NULL, &amp;outputs)) <span class="keywordflow">break</span>;
<a name="l05413"></a>05413    }
<a name="l05414"></a>05414    <span class="keywordflow">return</span> n;
<a name="l05415"></a>05415 }
<a name="l05416"></a>05416 
<a name="l05417"></a>05417 <span class="preprocessor">#ifndef STB_VORBIS_NO_STDIO</span>
<a name="l05418"></a>05418 <span class="preprocessor"></span><span class="keywordtype">int</span> stb_vorbis_decode_filename(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> *channels, <span class="keywordtype">int</span> *sample_rate, <span class="keywordtype">short</span> **output)
<a name="l05419"></a>05419 {
<a name="l05420"></a>05420    <span class="keywordtype">int</span> data_len, offset, total, limit, error;
<a name="l05421"></a>05421    <span class="keywordtype">short</span> *data;
<a name="l05422"></a>05422    <a class="code" href="structstb__vorbis.html">stb_vorbis</a> *v = stb_vorbis_open_filename(filename, &amp;error, NULL);
<a name="l05423"></a>05423    <span class="keywordflow">if</span> (v == NULL) <span class="keywordflow">return</span> -1;
<a name="l05424"></a>05424    limit = v-&gt;channels * 4096;
<a name="l05425"></a>05425    *channels = v-&gt;channels;
<a name="l05426"></a>05426    <span class="keywordflow">if</span> (sample_rate)
<a name="l05427"></a>05427       *sample_rate = v-&gt;sample_rate;
<a name="l05428"></a>05428    offset = data_len = 0;
<a name="l05429"></a>05429    total = limit;
<a name="l05430"></a>05430    data = (<span class="keywordtype">short</span> *) malloc(total * <span class="keyword">sizeof</span>(*data));
<a name="l05431"></a>05431    <span class="keywordflow">if</span> (data == NULL) {
<a name="l05432"></a>05432       stb_vorbis_close(v);
<a name="l05433"></a>05433       <span class="keywordflow">return</span> -2;
<a name="l05434"></a>05434    }
<a name="l05435"></a>05435    <span class="keywordflow">for</span> (;;) {
<a name="l05436"></a>05436       <span class="keywordtype">int</span> n = stb_vorbis_get_frame_short_interleaved(v, v-&gt;channels, data+offset, total-offset);
<a name="l05437"></a>05437       <span class="keywordflow">if</span> (n == 0) <span class="keywordflow">break</span>;
<a name="l05438"></a>05438       data_len += n;
<a name="l05439"></a>05439       offset += n * v-&gt;channels;
<a name="l05440"></a>05440       <span class="keywordflow">if</span> (offset + limit &gt; total) {
<a name="l05441"></a>05441          <span class="keywordtype">short</span> *data2;
<a name="l05442"></a>05442          total *= 2;
<a name="l05443"></a>05443          data2 = (<span class="keywordtype">short</span> *) realloc(data, total * <span class="keyword">sizeof</span>(*data));
<a name="l05444"></a>05444          <span class="keywordflow">if</span> (data2 == NULL) {
<a name="l05445"></a>05445             free(data);
<a name="l05446"></a>05446             stb_vorbis_close(v);
<a name="l05447"></a>05447             <span class="keywordflow">return</span> -2;
<a name="l05448"></a>05448          }
<a name="l05449"></a>05449          data = data2;
<a name="l05450"></a>05450       }
<a name="l05451"></a>05451    }
<a name="l05452"></a>05452    *output = data;
<a name="l05453"></a>05453    stb_vorbis_close(v);
<a name="l05454"></a>05454    <span class="keywordflow">return</span> data_len;
<a name="l05455"></a>05455 }
<a name="l05456"></a>05456 <span class="preprocessor">#endif // NO_STDIO</span>
<a name="l05457"></a>05457 <span class="preprocessor"></span>
<a name="l05458"></a>05458 <span class="keywordtype">int</span> stb_vorbis_decode_memory(<span class="keyword">const</span> uint8 *mem, <span class="keywordtype">int</span> len, <span class="keywordtype">int</span> *channels, <span class="keywordtype">int</span> *sample_rate, <span class="keywordtype">short</span> **output)
<a name="l05459"></a>05459 {
<a name="l05460"></a>05460    <span class="keywordtype">int</span> data_len, offset, total, limit, error;
<a name="l05461"></a>05461    <span class="keywordtype">short</span> *data;
<a name="l05462"></a>05462    <a class="code" href="structstb__vorbis.html">stb_vorbis</a> *v = stb_vorbis_open_memory(mem, len, &amp;error, NULL);
<a name="l05463"></a>05463    <span class="keywordflow">if</span> (v == NULL) <span class="keywordflow">return</span> -1;
<a name="l05464"></a>05464    limit = v-&gt;channels * 4096;
<a name="l05465"></a>05465    *channels = v-&gt;channels;
<a name="l05466"></a>05466    <span class="keywordflow">if</span> (sample_rate)
<a name="l05467"></a>05467       *sample_rate = v-&gt;sample_rate;
<a name="l05468"></a>05468    offset = data_len = 0;
<a name="l05469"></a>05469    total = limit;
<a name="l05470"></a>05470    data = (<span class="keywordtype">short</span> *) malloc(total * <span class="keyword">sizeof</span>(*data));
<a name="l05471"></a>05471    <span class="keywordflow">if</span> (data == NULL) {
<a name="l05472"></a>05472       stb_vorbis_close(v);
<a name="l05473"></a>05473       <span class="keywordflow">return</span> -2;
<a name="l05474"></a>05474    }
<a name="l05475"></a>05475    <span class="keywordflow">for</span> (;;) {
<a name="l05476"></a>05476       <span class="keywordtype">int</span> n = stb_vorbis_get_frame_short_interleaved(v, v-&gt;channels, data+offset, total-offset);
<a name="l05477"></a>05477       <span class="keywordflow">if</span> (n == 0) <span class="keywordflow">break</span>;
<a name="l05478"></a>05478       data_len += n;
<a name="l05479"></a>05479       offset += n * v-&gt;channels;
<a name="l05480"></a>05480       <span class="keywordflow">if</span> (offset + limit &gt; total) {
<a name="l05481"></a>05481          <span class="keywordtype">short</span> *data2;
<a name="l05482"></a>05482          total *= 2;
<a name="l05483"></a>05483          data2 = (<span class="keywordtype">short</span> *) realloc(data, total * <span class="keyword">sizeof</span>(*data));
<a name="l05484"></a>05484          <span class="keywordflow">if</span> (data2 == NULL) {
<a name="l05485"></a>05485             free(data);
<a name="l05486"></a>05486             stb_vorbis_close(v);
<a name="l05487"></a>05487             <span class="keywordflow">return</span> -2;
<a name="l05488"></a>05488          }
<a name="l05489"></a>05489          data = data2;
<a name="l05490"></a>05490       }
<a name="l05491"></a>05491    }
<a name="l05492"></a>05492    *output = data;
<a name="l05493"></a>05493    stb_vorbis_close(v);
<a name="l05494"></a>05494    <span class="keywordflow">return</span> data_len;
<a name="l05495"></a>05495 }
<a name="l05496"></a>05496 <span class="preprocessor">#endif // STB_VORBIS_NO_INTEGER_CONVERSION</span>
<a name="l05497"></a>05497 <span class="preprocessor"></span>
<a name="l05498"></a>05498 <span class="keywordtype">int</span> stb_vorbis_get_samples_float_interleaved(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> channels, <span class="keywordtype">float</span> *buffer, <span class="keywordtype">int</span> num_floats)
<a name="l05499"></a>05499 {
<a name="l05500"></a>05500    <span class="keywordtype">float</span> **outputs;
<a name="l05501"></a>05501    <span class="keywordtype">int</span> len = num_floats / channels;
<a name="l05502"></a>05502    <span class="keywordtype">int</span> n=0;
<a name="l05503"></a>05503    <span class="keywordtype">int</span> z = f-&gt;channels;
<a name="l05504"></a>05504    <span class="keywordflow">if</span> (z &gt; channels) z = channels;
<a name="l05505"></a>05505    <span class="keywordflow">while</span> (n &lt; len) {
<a name="l05506"></a>05506       <span class="keywordtype">int</span> i,j;
<a name="l05507"></a>05507       <span class="keywordtype">int</span> k = f-&gt;channel_buffer_end - f-&gt;channel_buffer_start;
<a name="l05508"></a>05508       <span class="keywordflow">if</span> (n+k &gt;= len) k = len - n;
<a name="l05509"></a>05509       <span class="keywordflow">for</span> (j=0; j &lt; k; ++j) {
<a name="l05510"></a>05510          <span class="keywordflow">for</span> (i=0; i &lt; z; ++i)
<a name="l05511"></a>05511             *buffer++ = f-&gt;channel_buffers[i][f-&gt;channel_buffer_start+j];
<a name="l05512"></a>05512          for (   ; i &lt; channels; ++i)
<a name="l05513"></a>05513             *buffer++ = 0;
<a name="l05514"></a>05514       }
<a name="l05515"></a>05515       n += k;
<a name="l05516"></a>05516       f-&gt;channel_buffer_start += k;
<a name="l05517"></a>05517       <span class="keywordflow">if</span> (n == len)
<a name="l05518"></a>05518          <span class="keywordflow">break</span>;
<a name="l05519"></a>05519       <span class="keywordflow">if</span> (!stb_vorbis_get_frame_float(f, NULL, &amp;outputs))
<a name="l05520"></a>05520          <span class="keywordflow">break</span>;
<a name="l05521"></a>05521    }
<a name="l05522"></a>05522    <span class="keywordflow">return</span> n;
<a name="l05523"></a>05523 }
<a name="l05524"></a>05524 
<a name="l05525"></a>05525 <span class="keywordtype">int</span> stb_vorbis_get_samples_float(<a class="code" href="structstb__vorbis.html">stb_vorbis</a> *f, <span class="keywordtype">int</span> channels, <span class="keywordtype">float</span> **buffer, <span class="keywordtype">int</span> num_samples)
<a name="l05526"></a>05526 {
<a name="l05527"></a>05527    <span class="keywordtype">float</span> **outputs;
<a name="l05528"></a>05528    <span class="keywordtype">int</span> n=0;
<a name="l05529"></a>05529    <span class="keywordtype">int</span> z = f-&gt;channels;
<a name="l05530"></a>05530    <span class="keywordflow">if</span> (z &gt; channels) z = channels;
<a name="l05531"></a>05531    <span class="keywordflow">while</span> (n &lt; num_samples) {
<a name="l05532"></a>05532       <span class="keywordtype">int</span> i;
<a name="l05533"></a>05533       <span class="keywordtype">int</span> k = f-&gt;channel_buffer_end - f-&gt;channel_buffer_start;
<a name="l05534"></a>05534       <span class="keywordflow">if</span> (n+k &gt;= num_samples) k = num_samples - n;
<a name="l05535"></a>05535       <span class="keywordflow">if</span> (k) {
<a name="l05536"></a>05536          <span class="keywordflow">for</span> (i=0; i &lt; z; ++i)
<a name="l05537"></a>05537             memcpy(buffer[i]+n, f-&gt;channel_buffers[i]+f-&gt;channel_buffer_start, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)*k);
<a name="l05538"></a>05538          <span class="keywordflow">for</span> (   ; i &lt; channels; ++i)
<a name="l05539"></a>05539             memset(buffer[i]+n, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * k);
<a name="l05540"></a>05540       }
<a name="l05541"></a>05541       n += k;
<a name="l05542"></a>05542       f-&gt;channel_buffer_start += k;
<a name="l05543"></a>05543       <span class="keywordflow">if</span> (n == num_samples)
<a name="l05544"></a>05544          <span class="keywordflow">break</span>;
<a name="l05545"></a>05545       <span class="keywordflow">if</span> (!stb_vorbis_get_frame_float(f, NULL, &amp;outputs))
<a name="l05546"></a>05546          <span class="keywordflow">break</span>;
<a name="l05547"></a>05547    }
<a name="l05548"></a>05548    <span class="keywordflow">return</span> n;
<a name="l05549"></a>05549 }
<a name="l05550"></a>05550 <span class="preprocessor">#endif // STB_VORBIS_NO_PULLDATA_API</span>
<a name="l05551"></a>05551 <span class="preprocessor"></span>
<a name="l05552"></a>05552 <span class="comment">/* Version history</span>
<a name="l05553"></a>05553 <span class="comment">    1.17    - 2019-07-08 - fix CVE-2019-13217, -13218, -13219, -13220, -13221, -13222, -13223</span>
<a name="l05554"></a>05554 <span class="comment">                           found with Mayhem by ForAllSecure</span>
<a name="l05555"></a>05555 <span class="comment">    1.16    - 2019-03-04 - fix warnings</span>
<a name="l05556"></a>05556 <span class="comment">    1.15    - 2019-02-07 - explicit failure if Ogg Skeleton data is found</span>
<a name="l05557"></a>05557 <span class="comment">    1.14    - 2018-02-11 - delete bogus dealloca usage</span>
<a name="l05558"></a>05558 <span class="comment">    1.13    - 2018-01-29 - fix truncation of last frame (hopefully)</span>
<a name="l05559"></a>05559 <span class="comment">    1.12    - 2017-11-21 - limit residue begin/end to blocksize/2 to avoid large temp allocs in bad/corrupt files</span>
<a name="l05560"></a>05560 <span class="comment">    1.11    - 2017-07-23 - fix MinGW compilation</span>
<a name="l05561"></a>05561 <span class="comment">    1.10    - 2017-03-03 - more robust seeking; fix negative ilog(); clear error in open_memory</span>
<a name="l05562"></a>05562 <span class="comment">    1.09    - 2016-04-04 - back out &#39;avoid discarding last frame&#39; fix from previous version</span>
<a name="l05563"></a>05563 <span class="comment">    1.08    - 2016-04-02 - fixed multiple warnings; fix setup memory leaks;</span>
<a name="l05564"></a>05564 <span class="comment">                           avoid discarding last frame of audio data</span>
<a name="l05565"></a>05565 <span class="comment">    1.07    - 2015-01-16 - fixed some warnings, fix mingw, const-correct API</span>
<a name="l05566"></a>05566 <span class="comment">                           some more crash fixes when out of memory or with corrupt files</span>
<a name="l05567"></a>05567 <span class="comment">    1.06    - 2015-08-31 - full, correct support for seeking API (Dougall Johnson)</span>
<a name="l05568"></a>05568 <span class="comment">                           some crash fixes when out of memory or with corrupt files</span>
<a name="l05569"></a>05569 <span class="comment">    1.05    - 2015-04-19 - don&#39;t define __forceinline if it&#39;s redundant</span>
<a name="l05570"></a>05570 <span class="comment">    1.04    - 2014-08-27 - fix missing const-correct case in API</span>
<a name="l05571"></a>05571 <span class="comment">    1.03    - 2014-08-07 - Warning fixes</span>
<a name="l05572"></a>05572 <span class="comment">    1.02    - 2014-07-09 - Declare qsort compare function _cdecl on windows</span>
<a name="l05573"></a>05573 <span class="comment">    1.01    - 2014-06-18 - fix stb_vorbis_get_samples_float</span>
<a name="l05574"></a>05574 <span class="comment">    1.0     - 2014-05-26 - fix memory leaks; fix warnings; fix bugs in multichannel</span>
<a name="l05575"></a>05575 <span class="comment">                           (API change) report sample rate for decode-full-file funcs</span>
<a name="l05576"></a>05576 <span class="comment">    0.99996 - bracket #include &lt;malloc.h&gt; for macintosh compilation by Laurent Gomila</span>
<a name="l05577"></a>05577 <span class="comment">    0.99995 - use union instead of pointer-cast for fast-float-to-int to avoid alias-optimization problem</span>
<a name="l05578"></a>05578 <span class="comment">    0.99994 - change fast-float-to-int to work in single-precision FPU mode, remove endian-dependence</span>
<a name="l05579"></a>05579 <span class="comment">    0.99993 - remove assert that fired on legal files with empty tables</span>
<a name="l05580"></a>05580 <span class="comment">    0.99992 - rewind-to-start</span>
<a name="l05581"></a>05581 <span class="comment">    0.99991 - bugfix to stb_vorbis_get_samples_short by Bernhard Wodo</span>
<a name="l05582"></a>05582 <span class="comment">    0.9999 - (should have been 0.99990) fix no-CRT support, compiling as C++</span>
<a name="l05583"></a>05583 <span class="comment">    0.9998 - add a full-decode function with a memory source</span>
<a name="l05584"></a>05584 <span class="comment">    0.9997 - fix a bug in the read-from-FILE case in 0.9996 addition</span>
<a name="l05585"></a>05585 <span class="comment">    0.9996 - query length of vorbis stream in samples/seconds</span>
<a name="l05586"></a>05586 <span class="comment">    0.9995 - bugfix to another optimization that only happened in certain files</span>
<a name="l05587"></a>05587 <span class="comment">    0.9994 - bugfix to one of the optimizations that caused significant (but inaudible?) errors</span>
<a name="l05588"></a>05588 <span class="comment">    0.9993 - performance improvements; runs in 99% to 104% of time of reference implementation</span>
<a name="l05589"></a>05589 <span class="comment">    0.9992 - performance improvement of IMDCT; now performs close to reference implementation</span>
<a name="l05590"></a>05590 <span class="comment">    0.9991 - performance improvement of IMDCT</span>
<a name="l05591"></a>05591 <span class="comment">    0.999 - (should have been 0.9990) performance improvement of IMDCT</span>
<a name="l05592"></a>05592 <span class="comment">    0.998 - no-CRT support from Casey Muratori</span>
<a name="l05593"></a>05593 <span class="comment">    0.997 - bugfixes for bugs found by Terje Mathisen</span>
<a name="l05594"></a>05594 <span class="comment">    0.996 - bugfix: fast-huffman decode initialized incorrectly for sparse codebooks; fixing gives 10% speedup - found by Terje Mathisen</span>
<a name="l05595"></a>05595 <span class="comment">    0.995 - bugfix: fix to &#39;effective&#39; overrun detection - found by Terje Mathisen</span>
<a name="l05596"></a>05596 <span class="comment">    0.994 - bugfix: garbage decode on final VQ symbol of a non-multiple - found by Terje Mathisen</span>
<a name="l05597"></a>05597 <span class="comment">    0.993 - bugfix: pushdata API required 1 extra byte for empty page (failed to consume final page if empty) - found by Terje Mathisen</span>
<a name="l05598"></a>05598 <span class="comment">    0.992 - fixes for MinGW warning</span>
<a name="l05599"></a>05599 <span class="comment">    0.991 - turn fast-float-conversion on by default</span>
<a name="l05600"></a>05600 <span class="comment">    0.990 - fix push-mode seek recovery if you seek into the headers</span>
<a name="l05601"></a>05601 <span class="comment">    0.98b - fix to bad release of 0.98</span>
<a name="l05602"></a>05602 <span class="comment">    0.98 - fix push-mode seek recovery; robustify float-to-int and support non-fast mode</span>
<a name="l05603"></a>05603 <span class="comment">    0.97 - builds under c++ (typecasting, don&#39;t use &#39;class&#39; keyword)</span>
<a name="l05604"></a>05604 <span class="comment">    0.96 - somehow MY 0.95 was right, but the web one was wrong, so here&#39;s my 0.95 rereleased as 0.96, fixes a typo in the clamping code</span>
<a name="l05605"></a>05605 <span class="comment">    0.95 - clamping code for 16-bit functions</span>
<a name="l05606"></a>05606 <span class="comment">    0.94 - not publically released</span>
<a name="l05607"></a>05607 <span class="comment">    0.93 - fixed all-zero-floor case (was decoding garbage)</span>
<a name="l05608"></a>05608 <span class="comment">    0.92 - fixed a memory leak</span>
<a name="l05609"></a>05609 <span class="comment">    0.91 - conditional compiles to omit parts of the API and the infrastructure to support them: STB_VORBIS_NO_PULLDATA_API, STB_VORBIS_NO_PUSHDATA_API, STB_VORBIS_NO_STDIO, STB_VORBIS_NO_INTEGER_CONVERSION</span>
<a name="l05610"></a>05610 <span class="comment">    0.90 - first public release</span>
<a name="l05611"></a>05611 <span class="comment">*/</span>
<a name="l05612"></a>05612 
<a name="l05613"></a>05613 <span class="preprocessor">#endif // STB_VORBIS_HEADER_ONLY</span>
<a name="l05614"></a>05614 <span class="preprocessor"></span>
<a name="l05615"></a>05615 
<a name="l05616"></a>05616 <span class="comment">/*</span>
<a name="l05617"></a>05617 <span class="comment">------------------------------------------------------------------------------</span>
<a name="l05618"></a>05618 <span class="comment">This software is available under 2 licenses -- choose whichever you prefer.</span>
<a name="l05619"></a>05619 <span class="comment">------------------------------------------------------------------------------</span>
<a name="l05620"></a>05620 <span class="comment">ALTERNATIVE A - MIT License</span>
<a name="l05621"></a>05621 <span class="comment">Copyright (c) 2017 Sean Barrett</span>
<a name="l05622"></a>05622 <span class="comment">Permission is hereby granted, free of charge, to any person obtaining a copy of</span>
<a name="l05623"></a>05623 <span class="comment">this software and associated documentation files (the &quot;Software&quot;), to deal in</span>
<a name="l05624"></a>05624 <span class="comment">the Software without restriction, including without limitation the rights to</span>
<a name="l05625"></a>05625 <span class="comment">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</span>
<a name="l05626"></a>05626 <span class="comment">of the Software, and to permit persons to whom the Software is furnished to do</span>
<a name="l05627"></a>05627 <span class="comment">so, subject to the following conditions:</span>
<a name="l05628"></a>05628 <span class="comment">The above copyright notice and this permission notice shall be included in all</span>
<a name="l05629"></a>05629 <span class="comment">copies or substantial portions of the Software.</span>
<a name="l05630"></a>05630 <span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<a name="l05631"></a>05631 <span class="comment">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<a name="l05632"></a>05632 <span class="comment">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<a name="l05633"></a>05633 <span class="comment">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<a name="l05634"></a>05634 <span class="comment">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<a name="l05635"></a>05635 <span class="comment">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<a name="l05636"></a>05636 <span class="comment">SOFTWARE.</span>
<a name="l05637"></a>05637 <span class="comment">------------------------------------------------------------------------------</span>
<a name="l05638"></a>05638 <span class="comment">ALTERNATIVE B - Public Domain (www.unlicense.org)</span>
<a name="l05639"></a>05639 <span class="comment">This is free and unencumbered software released into the public domain.</span>
<a name="l05640"></a>05640 <span class="comment">Anyone is free to copy, modify, publish, use, compile, sell, or distribute this</span>
<a name="l05641"></a>05641 <span class="comment">software, either in source code form or as a compiled binary, for any purpose,</span>
<a name="l05642"></a>05642 <span class="comment">commercial or non-commercial, and by any means.</span>
<a name="l05643"></a>05643 <span class="comment">In jurisdictions that recognize copyright laws, the author or authors of this</span>
<a name="l05644"></a>05644 <span class="comment">software dedicate any and all copyright interest in the software to the public</span>
<a name="l05645"></a>05645 <span class="comment">domain. We make this dedication for the benefit of the public at large and to</span>
<a name="l05646"></a>05646 <span class="comment">the detriment of our heirs and successors. We intend this dedication to be an</span>
<a name="l05647"></a>05647 <span class="comment">overt act of relinquishment in perpetuity of all present and future rights to</span>
<a name="l05648"></a>05648 <span class="comment">this software under copyright law.</span>
<a name="l05649"></a>05649 <span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<a name="l05650"></a>05650 <span class="comment">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<a name="l05651"></a>05651 <span class="comment">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<a name="l05652"></a>05652 <span class="comment">AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<a name="l05653"></a>05653 <span class="comment">ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</span>
<a name="l05654"></a>05654 <span class="comment">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<a name="l05655"></a>05655 <span class="comment">------------------------------------------------------------------------------</span>
<a name="l05656"></a>05656 <span class="comment">*/</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 5 2020 13:11:39 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
