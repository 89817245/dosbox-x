<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/hardware/pic.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/hardware/pic.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  Copyright (C) 2002-2012  The DOSBox Team</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  This program is free software; you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment"> *  (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *  This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment"> *  GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment"> *  along with this program; if not, write to the Free Software</span>
<a name="l00016"></a>00016 <span class="comment"> *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;dosbox.h&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;inout.h&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;callback.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;pic.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;timer.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;setup.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;control.h&quot;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#define PIC_QUEUESIZE 512</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a>00030 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> PIC_irq_delay_ns = 0;
<a name="l00031"></a>00031 
<a name="l00032"></a><a class="code" href="structPIC__Controller.html">00032</a> <span class="keyword">struct </span><a class="code" href="structPIC__Controller.html">PIC_Controller</a> {
<a name="l00033"></a>00033         Bitu icw_words;
<a name="l00034"></a>00034         Bitu icw_index;
<a name="l00035"></a>00035         <span class="keywordtype">bool</span> special;
<a name="l00036"></a>00036         <span class="keywordtype">bool</span> auto_eoi;
<a name="l00037"></a>00037         <span class="keywordtype">bool</span> rotate_on_auto_eoi;
<a name="l00038"></a>00038         <span class="keywordtype">bool</span> single;
<a name="l00039"></a>00039         <span class="keywordtype">bool</span> request_issr;
<a name="l00040"></a>00040         Bit8u vector_base;
<a name="l00041"></a>00041 
<a name="l00042"></a>00042         Bit8u irr;        <span class="comment">// request register</span>
<a name="l00043"></a>00043         Bit8u imr;        <span class="comment">// mask register</span>
<a name="l00044"></a>00044         Bit8u imrr;       <span class="comment">// mask register reversed (makes bit tests simpler)</span>
<a name="l00045"></a>00045         Bit8u isr;        <span class="comment">// in service register</span>
<a name="l00046"></a>00046         Bit8u isrr;       <span class="comment">// in service register reversed (makes bit tests simpler)</span>
<a name="l00047"></a>00047         Bit8u active_irq; <span class="comment">//currently active irq</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 
<a name="l00050"></a>00050         <span class="keywordtype">void</span> set_imr(Bit8u val);
<a name="l00051"></a>00051 
<a name="l00052"></a>00052         <span class="keywordtype">void</span> check_after_EOI(){
<a name="l00053"></a>00053                 <span class="comment">//Update the active_irq as an EOI is likely to change that.</span>
<a name="l00054"></a>00054                 update_active_irq();
<a name="l00055"></a>00055                 <span class="keywordflow">if</span>((irr&amp;imrr)&amp;isrr) check_for_irq();
<a name="l00056"></a>00056         }
<a name="l00057"></a>00057 
<a name="l00058"></a>00058         <span class="keywordtype">void</span> update_active_irq() {
<a name="l00059"></a>00059                 <span class="keywordflow">if</span>(isr == 0) {active_irq = 8; <span class="keywordflow">return</span>;}
<a name="l00060"></a>00060                 <span class="keywordflow">for</span>(Bit8u i = 0, s = 1; i &lt; 8;i++, s&lt;&lt;=1){
<a name="l00061"></a>00061                         <span class="keywordflow">if</span>( isr &amp; s){
<a name="l00062"></a>00062                                 active_irq = i;
<a name="l00063"></a>00063                                 <span class="keywordflow">return</span>;
<a name="l00064"></a>00064                         }
<a name="l00065"></a>00065                 }
<a name="l00066"></a>00066         }
<a name="l00067"></a>00067 
<a name="l00068"></a>00068         <span class="keywordtype">void</span> check_for_irq(){
<a name="l00069"></a>00069                 <span class="keyword">const</span> Bit8u possible_irq = (irr&amp;imrr)&amp;isrr;
<a name="l00070"></a>00070                 <span class="keywordflow">if</span> (possible_irq) {
<a name="l00071"></a>00071                         <span class="keyword">const</span> Bit8u a_irq = special?8:active_irq;
<a name="l00072"></a>00072                         <span class="keywordflow">for</span>(Bit8u i = 0, s = 1; i &lt; a_irq;i++, s&lt;&lt;=1){
<a name="l00073"></a>00073                                 <span class="keywordflow">if</span> ( possible_irq &amp; s ) {
<a name="l00074"></a>00074                                         <span class="comment">//There is an irq ready to be served =&gt; signal master and/or cpu</span>
<a name="l00075"></a>00075                                         activate();
<a name="l00076"></a>00076                                         <span class="keywordflow">return</span>;
<a name="l00077"></a>00077                                 }
<a name="l00078"></a>00078                         }
<a name="l00079"></a>00079                 }
<a name="l00080"></a>00080                 deactivate(); <span class="comment">//No irq, remove signal to master and/or cpu</span>
<a name="l00081"></a>00081         }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083         <span class="comment">//Signals master/cpu that there is an irq ready.</span>
<a name="l00084"></a>00084         <span class="keywordtype">void</span> activate();
<a name="l00085"></a>00085 
<a name="l00086"></a>00086         <span class="comment">//Removes signal to master/cpu that there is an irq ready.</span>
<a name="l00087"></a>00087         <span class="keywordtype">void</span> deactivate();
<a name="l00088"></a>00088 
<a name="l00089"></a>00089         <span class="keywordtype">void</span> raise_irq(Bit8u val){
<a name="l00090"></a>00090                 Bit8u bit = 1 &lt;&lt; (val);
<a name="l00091"></a>00091                 <span class="keywordflow">if</span>((irr &amp; bit)==0) { <span class="comment">//value changed (as it is currently not active)</span>
<a name="l00092"></a>00092                         irr|=bit;
<a name="l00093"></a>00093                         <span class="keywordflow">if</span>((bit&amp;imrr)&amp;isrr) { <span class="comment">//not masked and not in service</span>
<a name="l00094"></a>00094                                 <span class="keywordflow">if</span>(special || val &lt; active_irq) activate();
<a name="l00095"></a>00095                         }
<a name="l00096"></a>00096                 }
<a name="l00097"></a>00097         }
<a name="l00098"></a>00098 
<a name="l00099"></a>00099         <span class="keywordtype">void</span> lower_irq(Bit8u val){
<a name="l00100"></a>00100                 Bit8u bit = 1 &lt;&lt; ( val);
<a name="l00101"></a>00101                 <span class="keywordflow">if</span>(irr &amp; bit) { <span class="comment">//value will change (as it is currently active)</span>
<a name="l00102"></a>00102                         irr&amp;=~bit;
<a name="l00103"></a>00103                         <span class="keywordflow">if</span>((bit&amp;imrr)&amp;isrr) { <span class="comment">//not masked and not in service</span>
<a name="l00104"></a>00104                                 <span class="comment">//This irq might have toggled PIC_IRQCheck/caused irq 2 on master, when it was raised.</span>
<a name="l00105"></a>00105                                 <span class="comment">//If it is active, then recheck it, we can&#39;t just deactivate as there might be more IRQS raised.</span>
<a name="l00106"></a>00106                                 <span class="keywordflow">if</span>(special || val &lt; active_irq) check_for_irq();
<a name="l00107"></a>00107                         }
<a name="l00108"></a>00108                 }
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111         <span class="comment">//handles all bits and logic related to starting this IRQ, it does NOT start the interrupt on the CPU.</span>
<a name="l00112"></a>00112         <span class="keywordtype">void</span> start_irq(Bit8u val);
<a name="l00113"></a>00113 };
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="keywordtype">int</span> master_cascade_irq = -1;
<a name="l00116"></a>00116 <span class="keyword">static</span> <a class="code" href="structPIC__Controller.html">PIC_Controller</a> pics[2];
<a name="l00117"></a>00117 <span class="keyword">static</span> <a class="code" href="structPIC__Controller.html">PIC_Controller</a>&amp; master = pics[0];
<a name="l00118"></a>00118 <span class="keyword">static</span> <a class="code" href="structPIC__Controller.html">PIC_Controller</a>&amp; slave  = pics[1];
<a name="l00119"></a>00119 Bitu PIC_Ticks = 0;
<a name="l00120"></a>00120 Bitu PIC_IRQCheck = 0; <span class="comment">//Maybe make it a bool and/or ensure 32bit size (x86 dynamic core seems to assume 32 bit variable size)</span>
<a name="l00121"></a>00121 Bitu PIC_IRQCheckPending = 0; <span class="comment">//Maybe make it a bool and/or ensure 32bit size (x86 dynamic core seems to assume 32 bit variable size)</span>
<a name="l00122"></a>00122 <span class="keywordtype">bool</span> enable_slave_pic = <span class="keyword">true</span>; <span class="comment">/* if set, emulate slave with cascade to master. if clear, emulate only master, and no cascade (IRQ 2 is open) */</span>
<a name="l00123"></a>00123 <span class="keywordtype">bool</span> enable_pc_xt_nmi_mask = <span class="keyword">false</span>;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="keywordtype">void</span> PIC_IRQCheckDelayed(Bitu val) {
<a name="l00126"></a>00126     PIC_IRQCheck = 1;
<a name="l00127"></a>00127     PIC_IRQCheckPending = 0;
<a name="l00128"></a>00128 }
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="keywordtype">void</span> PIC_Controller::set_imr(Bit8u val) {
<a name="l00131"></a>00131         Bit8u change = (imr) ^ (val); <span class="comment">//Bits that have changed become 1.</span>
<a name="l00132"></a>00132         imr  =  val;
<a name="l00133"></a>00133         imrr = ~val;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135         <span class="comment">//Test if changed bits are set in irr and are not being served at the moment</span>
<a name="l00136"></a>00136         <span class="comment">//Those bits have impact on whether the cpu emulation should be paused or not.</span>
<a name="l00137"></a>00137         <span class="keywordflow">if</span>((irr &amp; change)&amp;isrr) check_for_irq();
<a name="l00138"></a>00138 }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="keywordtype">void</span> PIC_Controller::activate() { 
<a name="l00141"></a>00141         <span class="comment">//Stops CPU if master, signals master if slave</span>
<a name="l00142"></a>00142         <span class="keywordflow">if</span>(<span class="keyword">this</span> == &amp;master) {
<a name="l00143"></a>00143                 <span class="comment">//cycles 0, take care of the port IO stuff added in raise_irq base caller.</span>
<a name="l00144"></a>00144         <span class="keywordflow">if</span> (!PIC_IRQCheckPending) {
<a name="l00145"></a>00145             <span class="comment">/* NTS: PIC_AddEvent by design caps CPU_Cycles to make the event happen on time */</span>
<a name="l00146"></a>00146             PIC_AddEvent(PIC_IRQCheckDelayed,(<span class="keywordtype">double</span>)PIC_irq_delay_ns / 1000000,0);
<a name="l00147"></a>00147             PIC_IRQCheckPending = 1;
<a name="l00148"></a>00148         }
<a name="l00149"></a>00149         } <span class="keywordflow">else</span> {
<a name="l00150"></a>00150                 master.raise_irq(master_cascade_irq);
<a name="l00151"></a>00151         }
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keywordtype">void</span> PIC_Controller::deactivate() { 
<a name="l00155"></a>00155         <span class="comment">//removes irq check value if master, signals master if slave</span>
<a name="l00156"></a>00156         <span class="keywordflow">if</span>(<span class="keyword">this</span> == &amp;master) {
<a name="l00157"></a>00157                 <span class="comment">/* NTS: DOSBox code used to set PIC_IRQCheck = 0 here.</span>
<a name="l00158"></a>00158 <span class="comment">                 *</span>
<a name="l00159"></a>00159 <span class="comment">                 *      That&#39;s actually not the way to handle it. Here&#39;s why:</span>
<a name="l00160"></a>00160 <span class="comment">                 *</span>
<a name="l00161"></a>00161 <span class="comment">                 *      What would happen if one device raised an IRQ (setting PIC_IRQCheck=1)</span>
<a name="l00162"></a>00162 <span class="comment">                 *      then before dispatching IRQs, another device lowered an IRQ (setting PIC_IRQCheck=0).</span>
<a name="l00163"></a>00163 <span class="comment">                 *</span>
<a name="l00164"></a>00164 <span class="comment">                 *      Lowering the IRQ would reset the flag, and PIC_runIRQs() would never process</span>
<a name="l00165"></a>00165 <span class="comment">                 *      any pending IRQs even though some are waiting.</span>
<a name="l00166"></a>00166 <span class="comment">                 *</span>
<a name="l00167"></a>00167 <span class="comment">                 *      It&#39;s better if we set the flag when raising an IRQ, and leave the flag set until</span>
<a name="l00168"></a>00168 <span class="comment">                 *      PIC_runIRQs() determines there are no more IRQs to dispatch. Then and only then</span>
<a name="l00169"></a>00169 <span class="comment">                 *      will PIC_runIRQs() clear the flag. */</span>
<a name="l00170"></a>00170         } <span class="keywordflow">else</span> {
<a name="l00171"></a>00171                 <span class="comment">/* just because ONE IRQ on the slave finished doesn&#39;t mean there aren&#39;t any others needing service! */</span>
<a name="l00172"></a>00172                 <span class="keywordflow">if</span> ((irr&amp;imrr) == 0)
<a name="l00173"></a>00173                         master.lower_irq(master_cascade_irq);
<a name="l00174"></a>00174                 <span class="keywordflow">else</span>
<a name="l00175"></a>00175                         LOG_MSG(<span class="stringliteral">&quot;Slave PIC: still to handle irr=%02x imrr=%02x isrr=%02x&quot;</span>,irr,imrr,isrr);
<a name="l00176"></a>00176         }
<a name="l00177"></a>00177 }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="keywordtype">void</span> PIC_Controller::start_irq(Bit8u val){
<a name="l00180"></a>00180         irr&amp;=~(1&lt;&lt;(val));
<a name="l00181"></a>00181         <span class="keywordflow">if</span> (!auto_eoi) {
<a name="l00182"></a>00182                 active_irq = val;
<a name="l00183"></a>00183                 isr |= 1&lt;&lt;(val);
<a name="l00184"></a>00184                 isrr = ~isr;
<a name="l00185"></a>00185         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (GCC_UNLIKELY(rotate_on_auto_eoi)) {
<a name="l00186"></a>00186                 LOG_MSG(<span class="stringliteral">&quot;rotate on auto EOI not handled&quot;</span>);
<a name="l00187"></a>00187         }
<a name="l00188"></a>00188 }
<a name="l00189"></a>00189 
<a name="l00190"></a><a class="code" href="structPICEntry.html">00190</a> <span class="keyword">struct </span><a class="code" href="structPICEntry.html">PICEntry</a> {
<a name="l00191"></a>00191         <span class="keywordtype">float</span> index;
<a name="l00192"></a>00192         Bitu value;
<a name="l00193"></a>00193         PIC_EventHandler pic_event;
<a name="l00194"></a>00194         <a class="code" href="structPICEntry.html">PICEntry</a> * next;
<a name="l00195"></a>00195 };
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="keyword">static</span> <span class="keyword">struct </span>{
<a name="l00198"></a>00198         <a class="code" href="structPICEntry.html">PICEntry</a> <a class="code" href="structentries.html">entries</a>[PIC_QUEUESIZE];
<a name="l00199"></a>00199         <a class="code" href="structPICEntry.html">PICEntry</a> * free_entry;
<a name="l00200"></a>00200         <a class="code" href="structPICEntry.html">PICEntry</a> * next_entry;
<a name="l00201"></a>00201 } pic_queue;
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 <span class="keyword">static</span> <span class="keywordtype">void</span> write_command(Bitu port,Bitu val,Bitu iolen) {
<a name="l00204"></a>00204         <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[(port==0x20<span class="comment">/*IBM*/</span> || port==0x00<span class="comment">/*PC-98*/</span>) ? 0 : 1];
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         <span class="keywordflow">if</span> (GCC_UNLIKELY(val&amp;0x10)) {           <span class="comment">// ICW1 issued</span>
<a name="l00207"></a>00207                 <span class="keywordflow">if</span> (val&amp;0x04) LOG_MSG(<span class="stringliteral">&quot;PIC: 4 byte interval not handled&quot;</span>);
<a name="l00208"></a>00208                 <span class="keywordflow">if</span> (val&amp;0x08) LOG_MSG(<span class="stringliteral">&quot;PIC: level triggered mode not handled&quot;</span>);
<a name="l00209"></a>00209                 <span class="keywordflow">if</span> (val&amp;0xe0) LOG_MSG(<span class="stringliteral">&quot;PIC: 8080/8085 mode not handled&quot;</span>);
<a name="l00210"></a>00210                 pic-&gt;single=(val&amp;0x02)==0x02;
<a name="l00211"></a>00211                 pic-&gt;icw_index=1;                       <span class="comment">// next is ICW2</span>
<a name="l00212"></a>00212                 pic-&gt;icw_words=2 + (val&amp;0x01);  <span class="comment">// =3 if ICW4 needed</span>
<a name="l00213"></a>00213         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (GCC_UNLIKELY(val&amp;0x08)) {    <span class="comment">// OCW3 issued</span>
<a name="l00214"></a>00214                 <span class="keywordflow">if</span> (val&amp;0x04) LOG_MSG(<span class="stringliteral">&quot;PIC: poll command not handled&quot;</span>);
<a name="l00215"></a>00215                 <span class="keywordflow">if</span> (val&amp;0x02) {         <span class="comment">// function select</span>
<a name="l00216"></a>00216                         <span class="keywordflow">if</span> (val&amp;0x01) pic-&gt;request_issr=<span class="keyword">true</span>;   <span class="comment">/* select read interrupt in-service register */</span>
<a name="l00217"></a>00217                         <span class="keywordflow">else</span> pic-&gt;request_issr=<span class="keyword">false</span>;                   <span class="comment">/* select read interrupt request register */</span>
<a name="l00218"></a>00218                 }
<a name="l00219"></a>00219                 <span class="keywordflow">if</span> (val&amp;0x40) {         <span class="comment">// special mask select</span>
<a name="l00220"></a>00220                         <span class="keywordflow">if</span> (val&amp;0x20) pic-&gt;special = <span class="keyword">true</span>;
<a name="l00221"></a>00221                         <span class="keywordflow">else</span> pic-&gt;special = <span class="keyword">false</span>;
<a name="l00222"></a>00222                         <span class="comment">//Check if there are irqs ready to run, as the priority system has possibly been changed.</span>
<a name="l00223"></a>00223                         pic-&gt;check_for_irq();
<a name="l00224"></a>00224                         <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_NORMAL)(<span class="stringliteral">&quot;port %X : special mask %s&quot;</span>,(int)port,(pic-&gt;special)?<span class="stringliteral">&quot;ON&quot;</span>:<span class="stringliteral">&quot;OFF&quot;</span>);
<a name="l00225"></a>00225                 }
<a name="l00226"></a>00226         } <span class="keywordflow">else</span> {        <span class="comment">// OCW2 issued</span>
<a name="l00227"></a>00227                 <span class="keywordflow">if</span> (val&amp;0x20) {         <span class="comment">// EOI commands</span>
<a name="l00228"></a>00228                         <span class="keywordflow">if</span> (GCC_UNLIKELY(val&amp;0x80)) LOG_MSG(<span class="stringliteral">&quot;rotate mode not supported&quot;</span>);
<a name="l00229"></a>00229                         <span class="keywordflow">if</span> (val&amp;0x40) {         <span class="comment">// specific EOI</span>
<a name="l00230"></a>00230                                 pic-&gt;isr &amp;= ~(1&lt;&lt; ((val-0x60)));
<a name="l00231"></a>00231                                 pic-&gt;isrr = ~pic-&gt;isr;
<a name="l00232"></a>00232                                 pic-&gt;check_after_EOI();
<a name="l00233"></a>00233 <span class="comment">//                              if (val&amp;0x80);  // perform rotation</span>
<a name="l00234"></a>00234                         } <span class="keywordflow">else</span> {                <span class="comment">// nonspecific EOI</span>
<a name="l00235"></a>00235                                 <span class="keywordflow">if</span> (pic-&gt;active_irq != 8) { 
<a name="l00236"></a>00236                                         <span class="comment">//If there is no irq in service, ignore the call, some games send an eoi to both pics when a sound irq happens (regardless of the irq).</span>
<a name="l00237"></a>00237                                         pic-&gt;isr &amp;= ~(1 &lt;&lt; (pic-&gt;active_irq));
<a name="l00238"></a>00238                                         pic-&gt;isrr = ~pic-&gt;isr;
<a name="l00239"></a>00239                                         pic-&gt;check_after_EOI();
<a name="l00240"></a>00240                                 }
<a name="l00241"></a>00241 <span class="comment">//                              if (val&amp;0x80);  // perform rotation</span>
<a name="l00242"></a>00242                         }
<a name="l00243"></a>00243                 } <span class="keywordflow">else</span> {
<a name="l00244"></a>00244                         <span class="keywordflow">if</span> ((val&amp;0x40)==0) {            <span class="comment">// rotate in auto EOI mode</span>
<a name="l00245"></a>00245                                 <span class="keywordflow">if</span> (val&amp;0x80) pic-&gt;rotate_on_auto_eoi=<span class="keyword">true</span>;
<a name="l00246"></a>00246                                 <span class="keywordflow">else</span> pic-&gt;rotate_on_auto_eoi=<span class="keyword">false</span>;
<a name="l00247"></a>00247                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val&amp;0x80) {
<a name="l00248"></a>00248                                 <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_NORMAL)(<span class="stringliteral">&quot;set priority command not handled&quot;</span>);
<a name="l00249"></a>00249                         }       <span class="comment">// else NOP command</span>
<a name="l00250"></a>00250                 }
<a name="l00251"></a>00251         }       <span class="comment">// end OCW2</span>
<a name="l00252"></a>00252 }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="keyword">static</span> <span class="keywordtype">void</span> write_data(Bitu port,Bitu val,Bitu iolen) {
<a name="l00255"></a>00255         <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[(port==0x21<span class="comment">/*IBM*/</span> || port==0x02<span class="comment">/*PC-98*/</span>) ? 0 : 1];
<a name="l00256"></a>00256 
<a name="l00257"></a>00257         <span class="keywordflow">switch</span>(pic-&gt;icw_index) {
<a name="l00258"></a>00258         <span class="keywordflow">case</span> 0:                        <span class="comment">/* mask register */</span>
<a name="l00259"></a>00259                 pic-&gt;set_imr(val);
<a name="l00260"></a>00260                 <span class="keywordflow">break</span>;
<a name="l00261"></a>00261         <span class="keywordflow">case</span> 1:                        <span class="comment">/* icw2          */</span>
<a name="l00262"></a>00262                 <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_NORMAL)(<span class="stringliteral">&quot;%d:Base vector %X&quot;</span>,port==0x21 ? 0 : 1,(int)val);
<a name="l00263"></a>00263                 pic-&gt;vector_base = val&amp;0xf8;
<a name="l00264"></a>00264                 <span class="keywordflow">if</span>(pic-&gt;icw_index++ &gt;= pic-&gt;icw_words) pic-&gt;icw_index=0;
<a name="l00265"></a>00265                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pic-&gt;single) pic-&gt;icw_index=3;          <span class="comment">/* skip ICW3 in single mode */</span>
<a name="l00266"></a>00266                 <span class="keywordflow">break</span>;
<a name="l00267"></a>00267         <span class="keywordflow">case</span> 2:                                                 <span class="comment">/* icw 3 */</span>
<a name="l00268"></a>00268                 <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_NORMAL)(<span class="stringliteral">&quot;%d:ICW 3 %X&quot;</span>,port==0x21 ? 0 : 1,(int)val);
<a name="l00269"></a>00269                 <span class="keywordflow">if</span>(pic-&gt;icw_index++ &gt;= pic-&gt;icw_words) pic-&gt;icw_index=0;
<a name="l00270"></a>00270                 <span class="keywordflow">break</span>;
<a name="l00271"></a>00271         <span class="keywordflow">case</span> 3:                                                 <span class="comment">/* icw 4 */</span>
<a name="l00272"></a>00272                 <span class="comment">/*</span>
<a name="l00273"></a>00273 <span class="comment">                        0           1 8086/8080  0 mcs-8085 mode</span>
<a name="l00274"></a>00274 <span class="comment">                        1           1 Auto EOI   0 Normal EOI</span>
<a name="l00275"></a>00275 <span class="comment">                        2-3        0x Non buffer Mode </span>
<a name="l00276"></a>00276 <span class="comment">                                   10 Buffer Mode Slave </span>
<a name="l00277"></a>00277 <span class="comment">                                   11 Buffer mode Master        </span>
<a name="l00278"></a>00278 <span class="comment">                        4               Special/Not Special nested mode </span>
<a name="l00279"></a>00279 <span class="comment">                */</span>
<a name="l00280"></a>00280                 pic-&gt;auto_eoi=(val &amp; 0x2)&gt;0;
<a name="l00281"></a>00281                 
<a name="l00282"></a>00282                 <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_NORMAL)(<span class="stringliteral">&quot;%d:ICW 4 %X&quot;</span>,port==0x21 ? 0 : 1,(int)val);
<a name="l00283"></a>00283 
<a name="l00284"></a>00284                 <span class="keywordflow">if</span> ((val&amp;0x01)==0) LOG_MSG(<span class="stringliteral">&quot;PIC:ICW4: %x, 8085 mode not handled&quot;</span>,(<span class="keywordtype">int</span>)val);
<a name="l00285"></a>00285                 <span class="keywordflow">if</span> ((val&amp;0x10)!=0) LOG_MSG(<span class="stringliteral">&quot;PIC:ICW4: %x, special fully-nested mode not handled&quot;</span>,(<span class="keywordtype">int</span>)val);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287                 <span class="keywordflow">if</span>(pic-&gt;icw_index++ &gt;= pic-&gt;icw_words) pic-&gt;icw_index=0;
<a name="l00288"></a>00288                 <span class="keywordflow">break</span>;
<a name="l00289"></a>00289         <span class="keywordflow">default</span>:
<a name="l00290"></a>00290                 <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_NORMAL)(<span class="stringliteral">&quot;ICW HUH? %X&quot;</span>,(int)val);
<a name="l00291"></a>00291                 <span class="keywordflow">break</span>;
<a name="l00292"></a>00292         }
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="keyword">static</span> Bitu read_command(Bitu port,Bitu iolen) {
<a name="l00297"></a>00297         <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[(port==0x20<span class="comment">/*IBM*/</span> || port==0x00<span class="comment">/*PC-98*/</span>) ? 0 : 1];
<a name="l00298"></a>00298         <span class="keywordflow">if</span> (pic-&gt;request_issr){
<a name="l00299"></a>00299                 <span class="keywordflow">return</span> pic-&gt;isr;
<a name="l00300"></a>00300         } <span class="keywordflow">else</span> { 
<a name="l00301"></a>00301                 <span class="keywordflow">return</span> pic-&gt;irr;
<a name="l00302"></a>00302         }
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 <span class="keyword">static</span> Bitu read_data(Bitu port,Bitu iolen) {
<a name="l00307"></a>00307         <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[(port==0x21<span class="comment">/*IBM*/</span> || port==0x02<span class="comment">/*PC-98*/</span>) ? 0 : 1];
<a name="l00308"></a>00308         <span class="keywordflow">return</span> pic-&gt;imr;
<a name="l00309"></a>00309 }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="comment">/* PC/XT NMI mask register 0xA0. Documentation on the other bits</span>
<a name="l00312"></a>00312 <span class="comment"> * is sparse and spread across the internet, but many seem to</span>
<a name="l00313"></a>00313 <span class="comment"> * agree that bit 7 is used to enable/disable the NMI (1=enable,</span>
<a name="l00314"></a>00314 <span class="comment"> * 0=disable) */</span>
<a name="l00315"></a>00315 <span class="keyword">static</span> <span class="keywordtype">void</span> pc_xt_nmi_write(Bitu port,Bitu val,Bitu iolen) {
<a name="l00316"></a>00316         CPU_NMI_gate = (val &amp; 0x80) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00317"></a>00317 }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="comment">/* FIXME: This should be called something else that&#39;s true to the ISA bus, like PIC_PulseIRQ, not Activate IRQ.</span>
<a name="l00320"></a>00320 <span class="comment"> *        ISA interrupts are edge triggered, not level triggered. */</span>
<a name="l00321"></a>00321 <span class="keywordtype">void</span> PIC_ActivateIRQ(Bitu irq) {
<a name="l00322"></a>00322         <span class="comment">/* Remember what was once IRQ 2 on PC/XT is IRQ 9 on PC/AT */</span>
<a name="l00323"></a>00323     <span class="keywordflow">if</span> (IS_PC98_ARCH) {
<a name="l00324"></a>00324         <span class="keywordflow">if</span> (irq == 7) {
<a name="l00325"></a>00325             <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_ERROR)(<span class="stringliteral">&quot;Attempted to raise IRQ %u, which is cascade IRQ&quot;</span>,(int)irq);
<a name="l00326"></a>00326             <span class="keywordflow">return</span>; <span class="comment">/* don&#39;t raise cascade IRQ */</span>
<a name="l00327"></a>00327         }
<a name="l00328"></a>00328     }
<a name="l00329"></a>00329     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (enable_slave_pic) { <span class="comment">/* PC/AT emulation with slave PIC cascade to master */</span>
<a name="l00330"></a>00330                 <span class="keywordflow">if</span> (irq == 2) irq = 9;
<a name="l00331"></a>00331         }
<a name="l00332"></a>00332         <span class="keywordflow">else</span> { <span class="comment">/* PC/XT emulation with only master PIC */</span>
<a name="l00333"></a>00333                 <span class="keywordflow">if</span> (irq == 9) irq = 2;
<a name="l00334"></a>00334                 <span class="keywordflow">if</span> (irq &gt;= 8) {
<a name="l00335"></a>00335                         <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_ERROR)(<span class="stringliteral">&quot;Attempted to raise IRQ %u when slave PIC does not exist&quot;</span>,(int)irq);
<a name="l00336"></a>00336                         <span class="keywordflow">return</span>;
<a name="l00337"></a>00337                 }
<a name="l00338"></a>00338         }
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         Bitu t = irq&gt;7 ? (irq - 8): irq;
<a name="l00341"></a>00341         <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[irq&gt;7 ? 1 : 0];
<a name="l00342"></a>00342 
<a name="l00343"></a>00343         pic-&gt;raise_irq(t);
<a name="l00344"></a>00344 }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 <span class="keywordtype">void</span> PIC_DeActivateIRQ(Bitu irq) {
<a name="l00347"></a>00347         <span class="comment">/* Remember what was once IRQ 2 on PC/XT is IRQ 9 on PC/AT */</span>
<a name="l00348"></a>00348     <span class="keywordflow">if</span> (IS_PC98_ARCH) {
<a name="l00349"></a>00349         <span class="keywordflow">if</span> (irq == 7) <span class="keywordflow">return</span>;
<a name="l00350"></a>00350     }
<a name="l00351"></a>00351     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (enable_slave_pic) { <span class="comment">/* PC/AT emulation with slave PIC cascade to master */</span>
<a name="l00352"></a>00352                 <span class="keywordflow">if</span> (irq == 2) irq = 9;
<a name="l00353"></a>00353         }
<a name="l00354"></a>00354         <span class="keywordflow">else</span> { <span class="comment">/* PC/XT emulation with only master PIC */</span>
<a name="l00355"></a>00355                 <span class="keywordflow">if</span> (irq == 9) irq = 2;
<a name="l00356"></a>00356                 <span class="keywordflow">if</span> (irq &gt;= 8) {
<a name="l00357"></a>00357                         <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_ERROR)(<span class="stringliteral">&quot;Attempted to lower IRQ %u when slave PIC does not exist&quot;</span>,(int)irq);
<a name="l00358"></a>00358                         <span class="keywordflow">return</span>;
<a name="l00359"></a>00359                 }
<a name="l00360"></a>00360         }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362         Bitu t = irq&gt;7 ? (irq - 8): irq;
<a name="l00363"></a>00363         <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[irq&gt;7 ? 1 : 0];
<a name="l00364"></a>00364         pic-&gt;lower_irq(t);
<a name="l00365"></a>00365 }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 <span class="keyword">enum</span> PIC_irq_hacks PIC_IRQ_hax[16] = { PIC_irq_hack_none };
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 <span class="keywordtype">void</span> PIC_Set_IRQ_hack(<span class="keywordtype">int</span> IRQ,<span class="keyword">enum</span> PIC_irq_hacks hack) {
<a name="l00370"></a>00370         <span class="keywordflow">if</span> (IRQ &lt; 0 || IRQ &gt;= 16) <span class="keywordflow">return</span>;
<a name="l00371"></a>00371         PIC_IRQ_hax[IRQ] = hack;
<a name="l00372"></a>00372 }
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="keyword">enum</span> PIC_irq_hacks PIC_parse_IRQ_hack_string(<span class="keyword">const</span> <span class="keywordtype">char</span> *str) {
<a name="l00375"></a>00375         <span class="keywordflow">if</span> (!strcmp(str,<span class="stringliteral">&quot;none&quot;</span>))
<a name="l00376"></a>00376                 <span class="keywordflow">return</span> PIC_irq_hack_none;
<a name="l00377"></a>00377         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(str,<span class="stringliteral">&quot;cs_equ_ds&quot;</span>))
<a name="l00378"></a>00378                 <span class="keywordflow">return</span> PIC_irq_hack_cs_equ_ds;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380         <span class="keywordflow">return</span> PIC_irq_hack_none;
<a name="l00381"></a>00381 }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 <span class="keyword">static</span> <span class="keywordtype">bool</span> IRQ_hack_check_cs_equ_ds(<span class="keyword">const</span> <span class="keywordtype">int</span> IRQ) {
<a name="l00384"></a>00384         uint16_t s_cs = SegValue(cs);
<a name="l00385"></a>00385         uint16_t s_ds = SegValue(ds);
<a name="l00386"></a>00386 
<a name="l00387"></a>00387         <span class="keywordflow">if</span> (s_cs &gt;= 0xA000)
<a name="l00388"></a>00388                 <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// don&#39;t complain about the BIOS ISR</span>
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         <span class="keywordflow">if</span> (s_cs != s_ds) {
<a name="l00391"></a>00391                 <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_DEBUG)(<span class="stringliteral">&quot;Not dispatching IRQ %d according to IRQ hack. CS != DS&quot;</span>,IRQ);
<a name="l00392"></a>00392                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00393"></a>00393         }
<a name="l00394"></a>00394 
<a name="l00395"></a>00395         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00396"></a>00396 }
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 <span class="keyword">static</span> <span class="keywordtype">void</span> slave_startIRQ(){
<a name="l00399"></a>00399         Bit8u pic1_irq = 8;
<a name="l00400"></a>00400         <span class="keyword">const</span> Bit8u p = (slave.irr &amp; slave.imrr)&amp;slave.isrr;
<a name="l00401"></a>00401         <span class="keyword">const</span> Bit8u max = slave.special?8:slave.active_irq;
<a name="l00402"></a>00402         <span class="keywordflow">for</span>(Bit8u i = 0,s = 1;i &lt; max;i++, s&lt;&lt;=1) {
<a name="l00403"></a>00403                 <span class="keywordflow">if</span> (p&amp;s) {
<a name="l00404"></a>00404                         <span class="keywordflow">if</span> (PIC_IRQ_hax[i+8] == PIC_irq_hack_cs_equ_ds)
<a name="l00405"></a>00405                                 <span class="keywordflow">if</span> (!IRQ_hack_check_cs_equ_ds(i+8))
<a name="l00406"></a>00406                                         <span class="keywordflow">continue</span>; <span class="comment">// skip IRQ</span>
<a name="l00407"></a>00407 
<a name="l00408"></a>00408                         pic1_irq = i;
<a name="l00409"></a>00409                         <span class="keywordflow">break</span>;
<a name="l00410"></a>00410                 }
<a name="l00411"></a>00411         }
<a name="l00412"></a>00412 
<a name="l00413"></a>00413         <span class="keywordflow">if</span> (GCC_UNLIKELY(pic1_irq == 8)) {
<a name="l00414"></a>00414                 <span class="comment">/* we have an IRQ routing problem. this code is supposed to emulate the fact that</span>
<a name="l00415"></a>00415 <span class="comment">                 * what was once IRQ 2 on PC/XT is routed to IRQ 9 on AT systems, because IRQ 8-15</span>
<a name="l00416"></a>00416 <span class="comment">                 * cascade to IRQ 2 on such systems. but it&#39;s nothing to E_Exit() over. */</span>
<a name="l00417"></a>00417                 <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_ERROR)(<span class="stringliteral">&quot;ISA PIC problem: IRQ %d (cascade) is active on master PIC without active IRQ 8-15 on slave PIC.&quot;</span>,master_cascade_irq);
<a name="l00418"></a>00418                 slave.lower_irq(master_cascade_irq); <span class="comment">/* clear it */</span>
<a name="l00419"></a>00419                 <span class="keywordflow">return</span>;
<a name="l00420"></a>00420         }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422         slave.start_irq(pic1_irq);
<a name="l00423"></a>00423         master.start_irq(master_cascade_irq);
<a name="l00424"></a>00424         CPU_HW_Interrupt(slave.vector_base + pic1_irq);
<a name="l00425"></a>00425 }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">inline</span> master_startIRQ(Bitu i){
<a name="l00428"></a>00428         master.start_irq(i);
<a name="l00429"></a>00429         CPU_HW_Interrupt(master.vector_base + i);
<a name="l00430"></a>00430 }
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 <span class="keywordtype">void</span> PIC_runIRQs(<span class="keywordtype">void</span>) {
<a name="l00433"></a>00433         <span class="keywordflow">if</span> (!GETFLAG(IF)) <span class="keywordflow">return</span>;
<a name="l00434"></a>00434         <span class="keywordflow">if</span> (GCC_UNLIKELY(!PIC_IRQCheck)) <span class="keywordflow">return</span>;
<a name="l00435"></a>00435         <span class="keywordflow">if</span> (GCC_UNLIKELY(cpudecoder==CPU_Core_Normal_Trap_Run)) <span class="keywordflow">return</span>; <span class="comment">// FIXME: Why?</span>
<a name="l00436"></a>00436         <span class="keywordflow">if</span> (GCC_UNLIKELY(CPU_NMI_active) || GCC_UNLIKELY(CPU_NMI_pending)) <span class="keywordflow">return</span>; <span class="comment">/* NMI has higher priority than PIC */</span>
<a name="l00437"></a>00437 
<a name="l00438"></a>00438         <span class="keyword">const</span> Bit8u p = (master.irr &amp; master.imrr)&amp;master.isrr;
<a name="l00439"></a>00439         <span class="keyword">const</span> Bit8u max = master.special?8:master.active_irq;
<a name="l00440"></a>00440         Bit8u i,s;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442         for (i = 0,s = 1;i &lt; max;i++, s&lt;&lt;=1){
<a name="l00443"></a>00443                 <span class="keywordflow">if</span> (p&amp;s) {
<a name="l00444"></a>00444                         <span class="keywordflow">if</span> (PIC_IRQ_hax[i] == PIC_irq_hack_cs_equ_ds)
<a name="l00445"></a>00445                                 <span class="keywordflow">if</span> (!IRQ_hack_check_cs_equ_ds(i))
<a name="l00446"></a>00446                                         <span class="keywordflow">continue</span>; <span class="comment">// skip IRQ</span>
<a name="l00447"></a>00447 
<a name="l00448"></a>00448                         <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)i == master_cascade_irq) { <span class="comment">//second pic, or will not match if master_cascade_irq == -1</span>
<a name="l00449"></a>00449                                 slave_startIRQ();
<a name="l00450"></a>00450                         } <span class="keywordflow">else</span> {
<a name="l00451"></a>00451                                 master_startIRQ(i);
<a name="l00452"></a>00452                         }
<a name="l00453"></a>00453                         <span class="keywordflow">break</span>;
<a name="l00454"></a>00454                 }
<a name="l00455"></a>00455         }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457         <span class="comment">/* if we cleared all IRQs, then stop checking.</span>
<a name="l00458"></a>00458 <span class="comment">         * otherwise, keep the flag set for the next IRQ to process. */</span>
<a name="l00459"></a>00459         <span class="keywordflow">if</span> (i == max &amp;&amp; (master.irr&amp;master.imrr) == 0) {
<a name="l00460"></a>00460         PIC_IRQCheckPending = 0;
<a name="l00461"></a>00461         PIC_IRQCheck = 0;
<a name="l00462"></a>00462     }
<a name="l00463"></a>00463     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PIC_IRQCheck) {
<a name="l00464"></a>00464         PIC_AddEvent(PIC_IRQCheckDelayed,(<span class="keywordtype">double</span>)PIC_irq_delay_ns / 1000000,0);
<a name="l00465"></a>00465         PIC_IRQCheckPending = 1;
<a name="l00466"></a>00466         PIC_IRQCheck = 0;
<a name="l00467"></a>00467     }
<a name="l00468"></a>00468 }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 <span class="keywordtype">void</span> PIC_SetIRQMask(Bitu irq, <span class="keywordtype">bool</span> masked) {
<a name="l00471"></a>00471         Bitu t = irq&gt;7 ? (irq - 8): irq;
<a name="l00472"></a>00472         <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[irq&gt;7 ? 1 : 0];
<a name="l00473"></a>00473         <span class="comment">//clear bit</span>
<a name="l00474"></a>00474         Bit8u bit = 1 &lt;&lt;(t);
<a name="l00475"></a>00475         Bit8u newmask = pic-&gt;imr;
<a name="l00476"></a>00476         newmask &amp;= ~bit;
<a name="l00477"></a>00477         <span class="keywordflow">if</span> (masked) newmask |= bit;
<a name="l00478"></a>00478         pic-&gt;set_imr(newmask);
<a name="l00479"></a>00479 }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="keywordtype">void</span> DEBUG_PICSignal(<span class="keywordtype">int</span> irq,<span class="keywordtype">bool</span> <span class="keyword">raise</span>) {
<a name="l00482"></a>00482     <span class="keywordflow">if</span> (irq &gt;= 0 &amp;&amp; irq &lt;= 15) {
<a name="l00483"></a>00483         <span class="keywordflow">if</span> (<span class="keyword">raise</span>)
<a name="l00484"></a>00484             PIC_ActivateIRQ(irq);
<a name="l00485"></a>00485         <span class="keywordflow">else</span>
<a name="l00486"></a>00486             PIC_DeActivateIRQ(irq);
<a name="l00487"></a>00487     }
<a name="l00488"></a>00488 }
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 <span class="keywordtype">void</span> DEBUG_PICAck(<span class="keywordtype">int</span> irq) {
<a name="l00491"></a>00491     <span class="keywordflow">if</span> (irq &gt;= 0 &amp;&amp; irq &lt;= 15) {
<a name="l00492"></a>00492         <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[irq&gt;7 ? 1 : 0];
<a name="l00493"></a>00493 
<a name="l00494"></a>00494         pic-&gt;isr &amp;= ~(1 &lt;&lt; (irq &amp; 7U));
<a name="l00495"></a>00495         pic-&gt;isrr = ~pic-&gt;isr;
<a name="l00496"></a>00496         pic-&gt;check_after_EOI();
<a name="l00497"></a>00497     }
<a name="l00498"></a>00498 }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 <span class="keywordtype">void</span> DEBUG_PICMask(<span class="keywordtype">int</span> irq,<span class="keywordtype">bool</span> mask) {
<a name="l00501"></a>00501     <span class="keywordflow">if</span> (irq &gt;= 0 &amp;&amp; irq &lt;= 15)
<a name="l00502"></a>00502         PIC_SetIRQMask(irq,mask);
<a name="l00503"></a>00503 }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505 <span class="keyword">static</span> <span class="keywordtype">void</span> AddEntry(<a class="code" href="structPICEntry.html">PICEntry</a> * entry) {
<a name="l00506"></a>00506         <a class="code" href="structPICEntry.html">PICEntry</a> * find_entry=pic_queue.next_entry;
<a name="l00507"></a>00507         <span class="keywordflow">if</span> (GCC_UNLIKELY(find_entry ==0)) {
<a name="l00508"></a>00508                 entry-&gt;next=0;
<a name="l00509"></a>00509                 pic_queue.next_entry=entry;
<a name="l00510"></a>00510         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (find_entry-&gt;index&gt;entry-&gt;index) {
<a name="l00511"></a>00511                 pic_queue.next_entry=entry;
<a name="l00512"></a>00512                 entry-&gt;next=find_entry;
<a name="l00513"></a>00513         } <span class="keywordflow">else</span> <span class="keywordflow">while</span> (find_entry) {
<a name="l00514"></a>00514                 <span class="keywordflow">if</span> (find_entry-&gt;next) {
<a name="l00515"></a>00515                         <span class="comment">/* See if the next index comes later than this one */</span>
<a name="l00516"></a>00516                         <span class="keywordflow">if</span> (find_entry-&gt;next-&gt;index &gt; entry-&gt;index) {
<a name="l00517"></a>00517                                 entry-&gt;next=find_entry-&gt;next;
<a name="l00518"></a>00518                                 find_entry-&gt;next=entry;
<a name="l00519"></a>00519                                 <span class="keywordflow">break</span>;
<a name="l00520"></a>00520                         } <span class="keywordflow">else</span> {
<a name="l00521"></a>00521                                 find_entry=find_entry-&gt;next;
<a name="l00522"></a>00522                         }
<a name="l00523"></a>00523                 } <span class="keywordflow">else</span> {
<a name="l00524"></a>00524                         entry-&gt;next=find_entry-&gt;next;
<a name="l00525"></a>00525                         find_entry-&gt;next=entry;
<a name="l00526"></a>00526                         <span class="keywordflow">break</span>;
<a name="l00527"></a>00527                 }
<a name="l00528"></a>00528         }
<a name="l00529"></a>00529         Bits cycles=PIC_MakeCycles(pic_queue.next_entry-&gt;index-PIC_TickIndex());
<a name="l00530"></a>00530         <span class="keywordflow">if</span> (cycles&lt;CPU_Cycles) {
<a name="l00531"></a>00531                 CPU_CycleLeft+=CPU_Cycles;
<a name="l00532"></a>00532                 CPU_Cycles=0;
<a name="l00533"></a>00533         }
<a name="l00534"></a>00534 }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536 <span class="keyword">static</span> <span class="keywordtype">bool</span> InEventService = <span class="keyword">false</span>;
<a name="l00537"></a>00537 <span class="keyword">static</span> <span class="keywordtype">float</span> srv_lag = 0;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 <span class="keywordtype">void</span> PIC_AddEvent(PIC_EventHandler handler,<span class="keywordtype">float</span> delay,Bitu val) {
<a name="l00540"></a>00540         <span class="keywordflow">if</span> (GCC_UNLIKELY(!pic_queue.free_entry)) {
<a name="l00541"></a>00541                 <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_ERROR)(<span class="stringliteral">&quot;Event queue full&quot;</span>);
<a name="l00542"></a>00542                 <span class="keywordflow">return</span>;
<a name="l00543"></a>00543         }
<a name="l00544"></a>00544         <a class="code" href="structPICEntry.html">PICEntry</a> * entry=pic_queue.free_entry;
<a name="l00545"></a>00545         <span class="keywordflow">if</span>(InEventService) entry-&gt;index = delay + srv_lag;
<a name="l00546"></a>00546         <span class="keywordflow">else</span> entry-&gt;index = delay + PIC_TickIndex();
<a name="l00547"></a>00547 
<a name="l00548"></a>00548         entry-&gt;pic_event=handler;
<a name="l00549"></a>00549         entry-&gt;value=val;
<a name="l00550"></a>00550         pic_queue.free_entry=pic_queue.free_entry-&gt;next;
<a name="l00551"></a>00551         AddEntry(entry);
<a name="l00552"></a>00552 }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="keywordtype">void</span> PIC_RemoveSpecificEvents(PIC_EventHandler handler, Bitu val) {
<a name="l00555"></a>00555         <a class="code" href="structPICEntry.html">PICEntry</a> * entry=pic_queue.next_entry;
<a name="l00556"></a>00556         <a class="code" href="structPICEntry.html">PICEntry</a> * prev_entry;
<a name="l00557"></a>00557         prev_entry = 0;
<a name="l00558"></a>00558         <span class="keywordflow">while</span> (entry) {
<a name="l00559"></a>00559                 <span class="keywordflow">if</span> (GCC_UNLIKELY((entry-&gt;pic_event == handler)) &amp;&amp; (entry-&gt;value == val)) {
<a name="l00560"></a>00560                         <span class="keywordflow">if</span> (prev_entry) {
<a name="l00561"></a>00561                                 prev_entry-&gt;next=entry-&gt;next;
<a name="l00562"></a>00562                                 entry-&gt;next=pic_queue.free_entry;
<a name="l00563"></a>00563                                 pic_queue.free_entry=entry;
<a name="l00564"></a>00564                                 entry=prev_entry-&gt;next;
<a name="l00565"></a>00565                                 <span class="keywordflow">continue</span>;
<a name="l00566"></a>00566                         } <span class="keywordflow">else</span> {
<a name="l00567"></a>00567                                 pic_queue.next_entry=entry-&gt;next;
<a name="l00568"></a>00568                                 entry-&gt;next=pic_queue.free_entry;
<a name="l00569"></a>00569                                 pic_queue.free_entry=entry;
<a name="l00570"></a>00570                                 entry=pic_queue.next_entry;
<a name="l00571"></a>00571                                 <span class="keywordflow">continue</span>;
<a name="l00572"></a>00572                         }
<a name="l00573"></a>00573                 }
<a name="l00574"></a>00574                 prev_entry=entry;
<a name="l00575"></a>00575                 entry=entry-&gt;next;
<a name="l00576"></a>00576         }       
<a name="l00577"></a>00577 }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579 <span class="keywordtype">void</span> PIC_RemoveEvents(PIC_EventHandler handler) {
<a name="l00580"></a>00580         <a class="code" href="structPICEntry.html">PICEntry</a> * entry=pic_queue.next_entry;
<a name="l00581"></a>00581         <a class="code" href="structPICEntry.html">PICEntry</a> * prev_entry;
<a name="l00582"></a>00582         prev_entry=0;
<a name="l00583"></a>00583         <span class="keywordflow">while</span> (entry) {
<a name="l00584"></a>00584                 <span class="keywordflow">if</span> (GCC_UNLIKELY(entry-&gt;pic_event==handler)) {
<a name="l00585"></a>00585                         <span class="keywordflow">if</span> (prev_entry) {
<a name="l00586"></a>00586                                 prev_entry-&gt;next=entry-&gt;next;
<a name="l00587"></a>00587                                 entry-&gt;next=pic_queue.free_entry;
<a name="l00588"></a>00588                                 pic_queue.free_entry=entry;
<a name="l00589"></a>00589                                 entry=prev_entry-&gt;next;
<a name="l00590"></a>00590                                 <span class="keywordflow">continue</span>;
<a name="l00591"></a>00591                         } <span class="keywordflow">else</span> {
<a name="l00592"></a>00592                                 pic_queue.next_entry=entry-&gt;next;
<a name="l00593"></a>00593                                 entry-&gt;next=pic_queue.free_entry;
<a name="l00594"></a>00594                                 pic_queue.free_entry=entry;
<a name="l00595"></a>00595                                 entry=pic_queue.next_entry;
<a name="l00596"></a>00596                                 <span class="keywordflow">continue</span>;
<a name="l00597"></a>00597                         }
<a name="l00598"></a>00598                 }
<a name="l00599"></a>00599                 prev_entry=entry;
<a name="l00600"></a>00600                 entry=entry-&gt;next;
<a name="l00601"></a>00601         }       
<a name="l00602"></a>00602 }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604 <span class="keyword">extern</span> <a class="code" href="classClockDomain.html">ClockDomain</a> clockdom_DOSBox_cycles;
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 <span class="keywordtype">bool</span> PIC_RunQueue(<span class="keywordtype">void</span>) {
<a name="l00607"></a>00607         <span class="comment">/* Check to see if a new millisecond needs to be started */</span>
<a name="l00608"></a>00608         CPU_CycleLeft += CPU_Cycles;
<a name="l00609"></a>00609         CPU_Cycles = 0;
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         <span class="keywordflow">if</span> (CPU_CycleLeft &gt; 0) {
<a name="l00612"></a>00612                 <span class="keywordflow">if</span> (PIC_IRQCheck)
<a name="l00613"></a>00613                         PIC_runIRQs();
<a name="l00614"></a>00614 
<a name="l00615"></a>00615                 <span class="comment">/* Check the queue for an entry */</span>
<a name="l00616"></a>00616                 Bits index_nd=PIC_TickIndexND();
<a name="l00617"></a>00617                 InEventService = <span class="keyword">true</span>;
<a name="l00618"></a>00618                 <span class="keywordflow">while</span> (pic_queue.next_entry &amp;&amp; (pic_queue.next_entry-&gt;index*CPU_CycleMax&lt;=index_nd)) {
<a name="l00619"></a>00619                         <a class="code" href="structPICEntry.html">PICEntry</a> * entry=pic_queue.next_entry;
<a name="l00620"></a>00620                         pic_queue.next_entry=entry-&gt;next;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622                         srv_lag = entry-&gt;index;
<a name="l00623"></a>00623                         (entry-&gt;pic_event)(entry-&gt;value); <span class="comment">// call the event handler</span>
<a name="l00624"></a>00624 
<a name="l00625"></a>00625                         <span class="comment">/* Put the entry in the free list */</span>
<a name="l00626"></a>00626                         entry-&gt;next=pic_queue.free_entry;
<a name="l00627"></a>00627                         pic_queue.free_entry=entry;
<a name="l00628"></a>00628                 }
<a name="l00629"></a>00629                 InEventService = <span class="keyword">false</span>;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631                 <span class="comment">/* Check when to set the new cycle end */</span>
<a name="l00632"></a>00632                 <span class="keywordflow">if</span> (pic_queue.next_entry) {
<a name="l00633"></a>00633                         Bits cycles=(Bits)(pic_queue.next_entry-&gt;index*CPU_CycleMax-index_nd);
<a name="l00634"></a>00634                         <span class="keywordflow">if</span> (GCC_UNLIKELY(!cycles)) cycles=1;
<a name="l00635"></a>00635                         <span class="keywordflow">if</span> (cycles&lt;CPU_CycleLeft) {
<a name="l00636"></a>00636                                 CPU_Cycles=cycles;
<a name="l00637"></a>00637                         } <span class="keywordflow">else</span> {
<a name="l00638"></a>00638                                 CPU_Cycles=CPU_CycleLeft;
<a name="l00639"></a>00639                         }
<a name="l00640"></a>00640                 } <span class="keywordflow">else</span> CPU_Cycles=CPU_CycleLeft;
<a name="l00641"></a>00641                 CPU_CycleLeft-=CPU_Cycles;
<a name="l00642"></a>00642 
<a name="l00643"></a>00643         <span class="keywordflow">if</span> (PIC_IRQCheck)
<a name="l00644"></a>00644             PIC_runIRQs();
<a name="l00645"></a>00645     }
<a name="l00646"></a>00646 
<a name="l00647"></a>00647         <span class="comment">/* if we&#39;re out of cycles, then return false. don&#39;t execute any more instructions */</span>
<a name="l00648"></a>00648         <span class="keywordflow">if</span> ((CPU_CycleLeft+CPU_Cycles) &lt;= 0)
<a name="l00649"></a>00649                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00650"></a>00650 
<a name="l00651"></a>00651         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00652"></a>00652 }
<a name="l00653"></a>00653 
<a name="l00654"></a>00654 <span class="comment">/* The TIMER Part */</span>
<a name="l00655"></a><a class="code" href="structTickerBlock.html">00655</a> <span class="keyword">struct </span><a class="code" href="structTickerBlock.html">TickerBlock</a> {
<a name="l00656"></a>00656         <span class="comment">/* TODO: carry const char * field for name! */</span>
<a name="l00657"></a>00657         TIMER_TickHandler handler;
<a name="l00658"></a>00658         <a class="code" href="structTickerBlock.html">TickerBlock</a> * next;
<a name="l00659"></a>00659 };
<a name="l00660"></a>00660 
<a name="l00661"></a>00661 <span class="keyword">static</span> <a class="code" href="structTickerBlock.html">TickerBlock</a> * firstticker=0;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663 <span class="keywordtype">void</span> TIMER_ShutdownTickHandlers() {
<a name="l00664"></a>00664         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> leftovers = 0;
<a name="l00665"></a>00665 
<a name="l00666"></a>00666         <span class="comment">/* pull in the singly linked list from the front, hand over hand */</span>
<a name="l00667"></a>00667         <span class="keywordflow">while</span> (firstticker != NULL) {
<a name="l00668"></a>00668                 <a class="code" href="structTickerBlock.html">TickerBlock</a> *n = firstticker-&gt;next;
<a name="l00669"></a>00669                 <span class="keyword">delete</span> firstticker;
<a name="l00670"></a>00670                 firstticker = n;
<a name="l00671"></a>00671                 leftovers++;
<a name="l00672"></a>00672         }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674         <span class="keywordflow">if</span> (leftovers != 0)
<a name="l00675"></a>00675                 <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;TIMER: %u leftover handlers (clean up!).&quot;</span>,leftovers);
<a name="l00676"></a>00676 }
<a name="l00677"></a>00677 
<a name="l00678"></a>00678 <span class="keywordtype">void</span> TIMER_DelTickHandler(TIMER_TickHandler handler) {
<a name="l00679"></a>00679         <a class="code" href="structTickerBlock.html">TickerBlock</a> * ticker=firstticker;
<a name="l00680"></a>00680         <a class="code" href="structTickerBlock.html">TickerBlock</a> * * tick_where=&amp;firstticker;
<a name="l00681"></a>00681         <span class="keywordflow">while</span> (ticker) {
<a name="l00682"></a>00682                 <span class="keywordflow">if</span> (ticker-&gt;handler==handler) {
<a name="l00683"></a>00683                         *tick_where=ticker-&gt;next;
<a name="l00684"></a>00684                         <span class="keyword">delete</span> ticker;
<a name="l00685"></a>00685                         <span class="keywordflow">return</span>;
<a name="l00686"></a>00686                 }
<a name="l00687"></a>00687                 tick_where=&amp;ticker-&gt;next;
<a name="l00688"></a>00688                 ticker=ticker-&gt;next;
<a name="l00689"></a>00689         }
<a name="l00690"></a>00690 }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692 <span class="keywordtype">void</span> TIMER_AddTickHandler(TIMER_TickHandler handler) {
<a name="l00693"></a>00693         <a class="code" href="structTickerBlock.html">TickerBlock</a> * newticker=<span class="keyword">new</span> <a class="code" href="structTickerBlock.html">TickerBlock</a>;
<a name="l00694"></a>00694         newticker-&gt;next=firstticker;
<a name="l00695"></a>00695         newticker-&gt;handler=handler;
<a name="l00696"></a>00696         firstticker=newticker;
<a name="l00697"></a>00697 }
<a name="l00698"></a>00698 
<a name="l00699"></a>00699 <span class="keyword">extern</span> Bitu time_limit_ms;
<a name="l00700"></a>00700 
<a name="l00701"></a>00701 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> PIC_benchstart = 0;
<a name="l00702"></a>00702 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> PIC_tickstart = 0;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 <span class="keyword">extern</span> <span class="keywordtype">void</span> GFX_SetTitle(Bit32s cycles, Bits frameskip, Bits timing, <span class="keywordtype">bool</span> paused);
<a name="l00705"></a>00705 <span class="keywordtype">void</span> TIMER_AddTick(<span class="keywordtype">void</span>) {
<a name="l00706"></a>00706         <span class="comment">/* Setup new amount of cycles for PIC */</span>
<a name="l00707"></a>00707         PIC_Ticks++;
<a name="l00708"></a>00708         <span class="keywordflow">if</span> ((PIC_Ticks&amp;0x3fff) == 0) {
<a name="l00709"></a>00709                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ticks = GetTicks();
<a name="l00710"></a>00710                 <span class="keywordtype">int</span> delta = (PIC_Ticks-PIC_tickstart)*10000/(ticks-PIC_benchstart)+5;
<a name="l00711"></a>00711                 GFX_SetTitle(-1,-1,delta,<span class="keyword">false</span>);
<a name="l00712"></a>00712                 PIC_benchstart = ticks;
<a name="l00713"></a>00713                 PIC_tickstart = PIC_Ticks;
<a name="l00714"></a>00714         }
<a name="l00715"></a>00715         CPU_CycleLeft += CPU_CycleMax + CPU_Cycles;
<a name="l00716"></a>00716         CPU_Cycles = 0;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     <span class="comment">/* timeout */</span>
<a name="l00719"></a>00719     <span class="keywordflow">if</span> (time_limit_ms != 0 &amp;&amp; PIC_Ticks &gt;= time_limit_ms)
<a name="l00720"></a>00720         <span class="keywordflow">throw</span> int(1);
<a name="l00721"></a>00721 
<a name="l00722"></a>00722         <span class="comment">/* Go through the list of scheduled events and lower their index with 1000 */</span>
<a name="l00723"></a>00723         <a class="code" href="structPICEntry.html">PICEntry</a> * entry=pic_queue.next_entry;
<a name="l00724"></a>00724         <span class="keywordflow">while</span> (entry) {
<a name="l00725"></a>00725                 entry-&gt;index -= 1.0;
<a name="l00726"></a>00726                 entry=entry-&gt;next;
<a name="l00727"></a>00727         }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729         <span class="comment">/* Call our list of ticker handlers */</span>
<a name="l00730"></a>00730         <a class="code" href="structTickerBlock.html">TickerBlock</a> * ticker=firstticker;
<a name="l00731"></a>00731         <span class="keywordflow">while</span> (ticker) {
<a name="l00732"></a>00732                 <a class="code" href="structTickerBlock.html">TickerBlock</a> * nextticker=ticker-&gt;next;
<a name="l00733"></a>00733                 ticker-&gt;handler();
<a name="l00734"></a>00734                 ticker=nextticker;
<a name="l00735"></a>00735         }
<a name="l00736"></a>00736 }
<a name="l00737"></a>00737 
<a name="l00738"></a>00738 <span class="keyword">static</span> <a class="code" href="classIO__WriteHandleObject.html">IO_WriteHandleObject</a> PCXT_NMI_WriteHandler;
<a name="l00739"></a>00739 
<a name="l00740"></a>00740 <span class="keyword">static</span> <a class="code" href="classIO__ReadHandleObject.html">IO_ReadHandleObject</a> ReadHandler[4];
<a name="l00741"></a>00741 <span class="keyword">static</span> <a class="code" href="classIO__WriteHandleObject.html">IO_WriteHandleObject</a> WriteHandler[4];
<a name="l00742"></a>00742 
<a name="l00743"></a>00743 <span class="keywordtype">void</span> PIC_Reset(<a class="code" href="classSection.html">Section</a> *sec) {
<a name="l00744"></a>00744         Bitu i;
<a name="l00745"></a>00745 
<a name="l00746"></a>00746         ReadHandler[0].Uninstall();
<a name="l00747"></a>00747         ReadHandler[1].Uninstall();
<a name="l00748"></a>00748         WriteHandler[0].Uninstall();
<a name="l00749"></a>00749         WriteHandler[1].Uninstall();
<a name="l00750"></a>00750         ReadHandler[2].Uninstall();
<a name="l00751"></a>00751         ReadHandler[3].Uninstall();
<a name="l00752"></a>00752         WriteHandler[2].Uninstall();
<a name="l00753"></a>00753         WriteHandler[3].Uninstall();
<a name="l00754"></a>00754         PCXT_NMI_WriteHandler.Uninstall();
<a name="l00755"></a>00755 
<a name="l00756"></a>00756         <span class="comment">/* NTS: Parsing this on reset allows PIC configuration changes on reboot instead of restarting the entire emulator */</span>
<a name="l00757"></a>00757         <a class="code" href="classSection__prop.html">Section_prop</a> * section=<span class="keyword">static_cast&lt;</span><a class="code" href="classSection__prop.html">Section_prop</a> *<span class="keyword">&gt;</span>(control-&gt;GetSection(<span class="stringliteral">&quot;dosbox&quot;</span>));
<a name="l00758"></a>00758         assert(section != NULL);
<a name="l00759"></a>00759 
<a name="l00760"></a>00760         enable_slave_pic = section-&gt;Get_bool(<span class="stringliteral">&quot;enable slave pic&quot;</span>);
<a name="l00761"></a>00761         enable_pc_xt_nmi_mask = section-&gt;Get_bool(<span class="stringliteral">&quot;enable pc nmi mask&quot;</span>);
<a name="l00762"></a>00762 
<a name="l00763"></a>00763     <span class="comment">/* NTS: This is a good guess. But the 8259 is static circuitry and not driven by a clock.</span>
<a name="l00764"></a>00764 <span class="comment">     *      But the ability to respond to interrupts is limited by the CPU, too. */</span>
<a name="l00765"></a>00765     PIC_irq_delay_ns = 1000000000UL / (<span class="keywordtype">unsigned</span> long)PIT_TICK_RATE;
<a name="l00766"></a>00766     {
<a name="l00767"></a>00767         <span class="keywordtype">int</span> x = section-&gt;Get_int(<span class="stringliteral">&quot;irq delay ns&quot;</span>);
<a name="l00768"></a>00768         <span class="keywordflow">if</span> (x &gt;= 0) PIC_irq_delay_ns = x;
<a name="l00769"></a>00769     }
<a name="l00770"></a>00770 
<a name="l00771"></a>00771     <span class="keywordflow">if</span> (enable_slave_pic)
<a name="l00772"></a>00772         master_cascade_irq = IS_PC98_ARCH ? 7 : 2;
<a name="l00773"></a>00773     <span class="keywordflow">else</span>
<a name="l00774"></a>00774         master_cascade_irq = -1;
<a name="l00775"></a>00775 
<a name="l00776"></a>00776         <span class="comment">// LOG</span>
<a name="l00777"></a>00777         <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;PIC_Reset(): reinitializing PIC controller (cascade=%d)&quot;</span>,master_cascade_irq);
<a name="l00778"></a>00778 
<a name="l00779"></a>00779         <span class="comment">/* Setup pic0 and pic1 with initial values like DOS has normally */</span>
<a name="l00780"></a>00780         PIC_Ticks=0;
<a name="l00781"></a>00781         PIC_IRQCheck=0;
<a name="l00782"></a>00782         <span class="keywordflow">for</span> (i=0;i&lt;2;i++) {
<a name="l00783"></a>00783                 pics[i].auto_eoi=<span class="keyword">false</span>;
<a name="l00784"></a>00784                 pics[i].rotate_on_auto_eoi=<span class="keyword">false</span>;
<a name="l00785"></a>00785                 pics[i].request_issr=<span class="keyword">false</span>;
<a name="l00786"></a>00786                 pics[i].special=<span class="keyword">false</span>;
<a name="l00787"></a>00787                 pics[i].single=<span class="keyword">false</span>;
<a name="l00788"></a>00788                 pics[i].icw_index=0;
<a name="l00789"></a>00789                 pics[i].icw_words=0;
<a name="l00790"></a>00790                 pics[i].irr = pics[i].isr = pics[i].imrr = 0;
<a name="l00791"></a>00791                 pics[i].isrr = pics[i].imr = 0xff;
<a name="l00792"></a>00792                 pics[i].active_irq = 8;
<a name="l00793"></a>00793         }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795     <span class="comment">/* IBM: IRQ 0-15 is INT 0x08-0x0F, 0x70-0x7F</span>
<a name="l00796"></a>00796 <span class="comment">     * PC-98: IRQ 0-15 is INT 0x08-0x17 */</span>
<a name="l00797"></a>00797         master.vector_base = 0x08;
<a name="l00798"></a>00798         slave.vector_base = IS_PC98_ARCH ? 0x10 : 0x70;
<a name="l00799"></a>00799 
<a name="l00800"></a>00800     <span class="keywordflow">for</span> (Bitu i=0;i &lt; 16;i++)
<a name="l00801"></a>00801         PIC_SetIRQMask(i,<span class="keyword">true</span>);
<a name="l00802"></a>00802 
<a name="l00803"></a>00803         PIC_SetIRQMask(0,<span class="keyword">false</span>);                                        <span class="comment">/* Enable system timer */</span>
<a name="l00804"></a>00804         PIC_SetIRQMask(1,<span class="keyword">false</span>);                                        <span class="comment">/* Enable system timer */</span>
<a name="l00805"></a>00805         PIC_SetIRQMask(8,<span class="keyword">false</span>);                                        <span class="comment">/* Enable RTC IRQ */</span>
<a name="l00806"></a>00806 
<a name="l00807"></a>00807     <span class="keywordflow">if</span> (master_cascade_irq &gt;= 0)
<a name="l00808"></a>00808         PIC_SetIRQMask(master_cascade_irq,<span class="keyword">false</span>);<span class="comment">/* Enable second pic */</span>
<a name="l00809"></a>00809 
<a name="l00810"></a>00810     <span class="comment">/* I/O port map</span>
<a name="l00811"></a>00811 <span class="comment">     *</span>
<a name="l00812"></a>00812 <span class="comment">     * IBM PC/XT/AT     NEC PC-98        A0</span>
<a name="l00813"></a>00813 <span class="comment">     * ---------------------------------------</span>
<a name="l00814"></a>00814 <span class="comment">     * 0x20             0x00             0</span>
<a name="l00815"></a>00815 <span class="comment">     * 0x21             0x02             1</span>
<a name="l00816"></a>00816 <span class="comment">     * 0xA0             0x08             0</span>
<a name="l00817"></a>00817 <span class="comment">     * 0xA1             0x0A             1</span>
<a name="l00818"></a>00818 <span class="comment">     */</span>
<a name="l00819"></a>00819 
<a name="l00820"></a>00820         ReadHandler[0].Install(IS_PC98_ARCH ? 0x00 : 0x20,read_command,IO_MB);
<a name="l00821"></a>00821         ReadHandler[1].Install(IS_PC98_ARCH ? 0x02 : 0x21,read_data,IO_MB);
<a name="l00822"></a>00822         WriteHandler[0].Install(IS_PC98_ARCH ? 0x00 : 0x20,write_command,IO_MB);
<a name="l00823"></a>00823         WriteHandler[1].Install(IS_PC98_ARCH ? 0x02 : 0x21,write_data,IO_MB);
<a name="l00824"></a>00824 
<a name="l00825"></a>00825         <span class="comment">/* the secondary slave PIC takes priority over PC/XT NMI mask emulation */</span>
<a name="l00826"></a>00826         <span class="keywordflow">if</span> (enable_slave_pic) {
<a name="l00827"></a>00827                 ReadHandler[2].Install(IS_PC98_ARCH ? 0x08 : 0xa0,read_command,IO_MB);
<a name="l00828"></a>00828                 ReadHandler[3].Install(IS_PC98_ARCH ? 0x0A : 0xa1,read_data,IO_MB);
<a name="l00829"></a>00829                 WriteHandler[2].Install(IS_PC98_ARCH ? 0x08 : 0xa0,write_command,IO_MB);
<a name="l00830"></a>00830                 WriteHandler[3].Install(IS_PC98_ARCH ? 0x0A : 0xa1,write_data,IO_MB);
<a name="l00831"></a>00831         }
<a name="l00832"></a>00832         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!IS_PC98_ARCH &amp;&amp; enable_pc_xt_nmi_mask) {
<a name="l00833"></a>00833                 PCXT_NMI_WriteHandler.Install(0xa0,pc_xt_nmi_write,IO_MB);
<a name="l00834"></a>00834         }
<a name="l00835"></a>00835 }
<a name="l00836"></a>00836 
<a name="l00837"></a>00837 <span class="keywordtype">void</span> PIC_Destroy(<a class="code" href="classSection.html">Section</a>* sec) {
<a name="l00838"></a>00838 }
<a name="l00839"></a>00839 
<a name="l00840"></a>00840 <span class="keywordtype">void</span> Init_PIC() {
<a name="l00841"></a>00841         Bitu i;
<a name="l00842"></a>00842 
<a name="l00843"></a>00843         <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;Init_PIC()&quot;</span>);
<a name="l00844"></a>00844 
<a name="l00845"></a>00845         <span class="comment">/* Initialize the pic queue */</span>
<a name="l00846"></a>00846         <span class="keywordflow">for</span> (i=0;i&lt;PIC_QUEUESIZE-1;i++) {
<a name="l00847"></a>00847                 pic_queue.entries[i].next=&amp;pic_queue.entries[i+1];
<a name="l00848"></a>00848 
<a name="l00849"></a>00849                 <span class="comment">// savestate compatibility</span>
<a name="l00850"></a>00850                 pic_queue.entries[i].pic_event = 0;
<a name="l00851"></a>00851         }
<a name="l00852"></a>00852         pic_queue.entries[PIC_QUEUESIZE-1].next=0;
<a name="l00853"></a>00853         pic_queue.free_entry=&amp;pic_queue.entries[0];
<a name="l00854"></a>00854         pic_queue.next_entry=0;
<a name="l00855"></a>00855 
<a name="l00856"></a>00856         AddExitFunction(AddExitFunctionFuncPair(PIC_Destroy));
<a name="l00857"></a>00857         AddVMEventFunction(VM_EVENT_RESET,AddVMEventFunctionFuncPair(PIC_Reset));
<a name="l00858"></a>00858 }
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 <span class="preprocessor">#if C_DEBUG</span>
<a name="l00861"></a>00861 <span class="preprocessor"></span><span class="keywordtype">void</span> DEBUG_LogPIC_C(<a class="code" href="structPIC__Controller.html">PIC_Controller</a> &amp;pic) {
<a name="l00862"></a>00862     LOG_MSG(<span class="stringliteral">&quot;%s interrupt controller state&quot;</span>,&amp;pic == &amp;master ? <span class="stringliteral">&quot;Master&quot;</span> : <span class="stringliteral">&quot;Slave&quot;</span>);
<a name="l00863"></a>00863     LOG_MSG(<span class="stringliteral">&quot;ICW %u/%u special=%u auto-eoi=%u rotate-eoi=%u single=%u request_issr=%u vectorbase=0x%02x active_irq=%u&quot;</span>,
<a name="l00864"></a>00864         pic.icw_index,
<a name="l00865"></a>00865         pic.icw_words,
<a name="l00866"></a>00866         pic.special?1:0,
<a name="l00867"></a>00867         pic.auto_eoi?1:0,
<a name="l00868"></a>00868         pic.rotate_on_auto_eoi?1:0,
<a name="l00869"></a>00869         pic.single?1:0,
<a name="l00870"></a>00870         pic.request_issr?1:0,
<a name="l00871"></a>00871         pic.vector_base,
<a name="l00872"></a>00872         pic.active_irq);
<a name="l00873"></a>00873 
<a name="l00874"></a>00874     LOG_MSG(<span class="stringliteral">&quot;IRQ INT#  Req /Mask/Serv&quot;</span>);
<a name="l00875"></a>00875     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> si=0;si &lt; 8;si++) {
<a name="l00876"></a>00876         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> IRQ = si + (&amp;pic == &amp;slave ? 8 : 0);
<a name="l00877"></a>00877         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> CPUINT = pic.vector_base + si;
<a name="l00878"></a>00878 
<a name="l00879"></a>00879         LOG_MSG(<span class="stringliteral">&quot;%3u 0x%02X   %c    %c    %c   %s&quot;</span>,
<a name="l00880"></a>00880             IRQ,
<a name="l00881"></a>00881             CPUINT,
<a name="l00882"></a>00882             (pic.irr &amp; (1U &lt;&lt; si))?<span class="charliteral">&#39;R&#39;</span>:<span class="charliteral">&#39; &#39;</span>,
<a name="l00883"></a>00883             (pic.imr &amp; (1U &lt;&lt; si))?<span class="charliteral">&#39;M&#39;</span>:<span class="charliteral">&#39; &#39;</span>,
<a name="l00884"></a>00884             (pic.isr &amp; (1U &lt;&lt; si))?<span class="charliteral">&#39;S&#39;</span>:<span class="charliteral">&#39; &#39;</span>,
<a name="l00885"></a>00885             (IRQ == master_cascade_irq) ? <span class="stringliteral">&quot;CASCADE&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l00886"></a>00886     }
<a name="l00887"></a>00887 }
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="keywordtype">void</span> DEBUG_LogPIC(<span class="keywordtype">void</span>) {
<a name="l00890"></a>00890     DEBUG_LogPIC_C(master);
<a name="l00891"></a>00891     <span class="keywordflow">if</span> (enable_slave_pic) DEBUG_LogPIC_C(slave);
<a name="l00892"></a>00892 }
<a name="l00893"></a>00893 <span class="preprocessor">#endif</span>
<a name="l00894"></a>00894 <span class="preprocessor"></span>
<a name="l00895"></a>00895 
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 20 2018 12:41:03 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
