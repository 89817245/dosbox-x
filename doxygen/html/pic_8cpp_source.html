<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/hardware/pic.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/hardware/pic.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  Copyright (C) 2002-2012  The DOSBox Team</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  This program is free software; you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment"> *  (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *  This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment"> *  GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment"> *  along with this program; if not, write to the Free Software</span>
<a name="l00016"></a>00016 <span class="comment"> *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;dosbox.h&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;inout.h&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;callback.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;pic.h&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;timer.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;setup.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;control.h&quot;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#if defined(_MSC_VER)</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor"># pragma warning(disable:4244) </span><span class="comment">/* const fmath::local::uint64_t to double possible loss of data */</span>
<a name="l00030"></a>00030 <span class="preprocessor">#endif</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span>
<a name="l00032"></a>00032 <span class="preprocessor">#define PIC_QUEUESIZE 512</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>
<a name="l00034"></a>00034 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> PIC_irq_delay_ns = 0;
<a name="l00035"></a>00035 
<a name="l00036"></a><a class="code" href="structPIC__Controller.html">00036</a> <span class="keyword">struct </span><a class="code" href="structPIC__Controller.html">PIC_Controller</a> {
<a name="l00037"></a>00037     Bitu icw_words;
<a name="l00038"></a>00038     Bitu icw_index;
<a name="l00039"></a>00039     <span class="keywordtype">bool</span> special;
<a name="l00040"></a>00040     <span class="keywordtype">bool</span> auto_eoi;
<a name="l00041"></a>00041     <span class="keywordtype">bool</span> rotate_on_auto_eoi;
<a name="l00042"></a>00042     <span class="keywordtype">bool</span> single;
<a name="l00043"></a>00043     <span class="keywordtype">bool</span> request_issr;
<a name="l00044"></a>00044     Bit8u vector_base;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     Bit8u irr;        <span class="comment">// request register</span>
<a name="l00047"></a>00047     Bit8u imr;        <span class="comment">// mask register</span>
<a name="l00048"></a>00048     Bit8u imrr;       <span class="comment">// mask register reversed (makes bit tests simpler)</span>
<a name="l00049"></a>00049     Bit8u isr;        <span class="comment">// in service register</span>
<a name="l00050"></a>00050     Bit8u isrr;       <span class="comment">// in service register reversed (makes bit tests simpler)</span>
<a name="l00051"></a>00051     Bit8u active_irq; <span class="comment">//currently active irq</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 
<a name="l00054"></a>00054     <span class="keywordtype">void</span> set_imr(Bit8u val);
<a name="l00055"></a>00055 
<a name="l00056"></a>00056     <span class="keywordtype">void</span> check_after_EOI(){
<a name="l00057"></a>00057         <span class="comment">//Update the active_irq as an EOI is likely to change that.</span>
<a name="l00058"></a>00058         update_active_irq();
<a name="l00059"></a>00059         <span class="keywordflow">if</span>((irr&amp;imrr)&amp;isrr) check_for_irq();
<a name="l00060"></a>00060     }
<a name="l00061"></a>00061 
<a name="l00062"></a>00062     <span class="keywordtype">void</span> update_active_irq() {
<a name="l00063"></a>00063         <span class="keywordflow">if</span>(isr == 0) {active_irq = 8; <span class="keywordflow">return</span>;}
<a name="l00064"></a>00064         <span class="keywordflow">for</span>(Bit8u i = 0, s = 1; i &lt; 8;i++, s&lt;&lt;=1){
<a name="l00065"></a>00065             <span class="keywordflow">if</span>( isr &amp; s){
<a name="l00066"></a>00066                 active_irq = i;
<a name="l00067"></a>00067                 <span class="keywordflow">return</span>;
<a name="l00068"></a>00068             }
<a name="l00069"></a>00069         }
<a name="l00070"></a>00070     }
<a name="l00071"></a>00071 
<a name="l00072"></a>00072     <span class="keywordtype">void</span> check_for_irq(){
<a name="l00073"></a>00073         <span class="keyword">const</span> Bit8u possible_irq = (irr&amp;imrr)&amp;isrr;
<a name="l00074"></a>00074         <span class="keywordflow">if</span> (possible_irq) {
<a name="l00075"></a>00075             <span class="keyword">const</span> Bit8u a_irq = special?8:active_irq;
<a name="l00076"></a>00076             <span class="keywordflow">for</span>(Bit8u i = 0, s = 1; i &lt; a_irq;i++, s&lt;&lt;=1){
<a name="l00077"></a>00077                 <span class="keywordflow">if</span> ( possible_irq &amp; s ) {
<a name="l00078"></a>00078                     <span class="comment">//There is an irq ready to be served =&gt; signal master and/or cpu</span>
<a name="l00079"></a>00079                     activate();
<a name="l00080"></a>00080                     <span class="keywordflow">return</span>;
<a name="l00081"></a>00081                 }
<a name="l00082"></a>00082             }
<a name="l00083"></a>00083         }
<a name="l00084"></a>00084         deactivate(); <span class="comment">//No irq, remove signal to master and/or cpu</span>
<a name="l00085"></a>00085     }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087     <span class="comment">//Signals master/cpu that there is an irq ready.</span>
<a name="l00088"></a>00088     <span class="keywordtype">void</span> activate();
<a name="l00089"></a>00089 
<a name="l00090"></a>00090     <span class="comment">//Removes signal to master/cpu that there is an irq ready.</span>
<a name="l00091"></a>00091     <span class="keywordtype">void</span> deactivate();
<a name="l00092"></a>00092 
<a name="l00093"></a>00093     <span class="keywordtype">void</span> raise_irq(Bit8u val){
<a name="l00094"></a>00094         Bit8u bit = 1 &lt;&lt; (val);
<a name="l00095"></a>00095         <span class="keywordflow">if</span>((irr &amp; bit)==0) { <span class="comment">//value changed (as it is currently not active)</span>
<a name="l00096"></a>00096             irr|=bit;
<a name="l00097"></a>00097             <span class="keywordflow">if</span>((bit&amp;imrr)&amp;isrr) { <span class="comment">//not masked and not in service</span>
<a name="l00098"></a>00098                 <span class="keywordflow">if</span>(special || val &lt; active_irq) activate();
<a name="l00099"></a>00099             }
<a name="l00100"></a>00100         }
<a name="l00101"></a>00101     }
<a name="l00102"></a>00102 
<a name="l00103"></a>00103     <span class="keywordtype">void</span> lower_irq(Bit8u val){
<a name="l00104"></a>00104         Bit8u bit = 1 &lt;&lt; ( val);
<a name="l00105"></a>00105         <span class="keywordflow">if</span>(irr &amp; bit) { <span class="comment">//value will change (as it is currently active)</span>
<a name="l00106"></a>00106             irr&amp;=~bit;
<a name="l00107"></a>00107             <span class="keywordflow">if</span>((bit&amp;imrr)&amp;isrr) { <span class="comment">//not masked and not in service</span>
<a name="l00108"></a>00108                 <span class="comment">//This irq might have toggled PIC_IRQCheck/caused irq 2 on master, when it was raised.</span>
<a name="l00109"></a>00109                 <span class="comment">//If it is active, then recheck it, we can&#39;t just deactivate as there might be more IRQS raised.</span>
<a name="l00110"></a>00110                 <span class="keywordflow">if</span>(special || val &lt; active_irq) check_for_irq();
<a name="l00111"></a>00111             }
<a name="l00112"></a>00112         }
<a name="l00113"></a>00113     }
<a name="l00114"></a>00114 
<a name="l00115"></a>00115     <span class="comment">//handles all bits and logic related to starting this IRQ, it does NOT start the interrupt on the CPU.</span>
<a name="l00116"></a>00116     <span class="keywordtype">void</span> start_irq(Bit8u val);
<a name="l00117"></a>00117 };
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="keywordtype">int</span> master_cascade_irq = -1;
<a name="l00120"></a>00120 <span class="keyword">static</span> <a class="code" href="structPIC__Controller.html">PIC_Controller</a> pics[2];
<a name="l00121"></a>00121 <span class="keyword">static</span> <a class="code" href="structPIC__Controller.html">PIC_Controller</a>&amp; master = pics[0];
<a name="l00122"></a>00122 <span class="keyword">static</span> <a class="code" href="structPIC__Controller.html">PIC_Controller</a>&amp; slave  = pics[1];
<a name="l00123"></a>00123 Bitu PIC_Ticks = 0;
<a name="l00124"></a>00124 Bitu PIC_IRQCheck = 0; <span class="comment">//Maybe make it a bool and/or ensure 32bit size (x86 dynamic core seems to assume 32 bit variable size)</span>
<a name="l00125"></a>00125 Bitu PIC_IRQCheckPending = 0; <span class="comment">//Maybe make it a bool and/or ensure 32bit size (x86 dynamic core seems to assume 32 bit variable size)</span>
<a name="l00126"></a>00126 <span class="keywordtype">bool</span> enable_slave_pic = <span class="keyword">true</span>; <span class="comment">/* if set, emulate slave with cascade to master. if clear, emulate only master, and no cascade (IRQ 2 is open) */</span>
<a name="l00127"></a>00127 <span class="keywordtype">bool</span> enable_pc_xt_nmi_mask = <span class="keyword">false</span>;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 <span class="keywordtype">void</span> PIC_IRQCheckDelayed(Bitu val) {
<a name="l00130"></a>00130     (void)val;<span class="comment">//UNUSED</span>
<a name="l00131"></a>00131     PIC_IRQCheck = 1;
<a name="l00132"></a>00132     PIC_IRQCheckPending = 0;
<a name="l00133"></a>00133 }
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 <span class="keywordtype">void</span> PIC_Controller::set_imr(Bit8u val) {
<a name="l00136"></a>00136     Bit8u change = (imr) ^ (val); <span class="comment">//Bits that have changed become 1.</span>
<a name="l00137"></a>00137     imr  =  val;
<a name="l00138"></a>00138     imrr = ~val;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140     <span class="comment">//Test if changed bits are set in irr and are not being served at the moment</span>
<a name="l00141"></a>00141     <span class="comment">//Those bits have impact on whether the cpu emulation should be paused or not.</span>
<a name="l00142"></a>00142     <span class="keywordflow">if</span>((irr &amp; change)&amp;isrr) check_for_irq();
<a name="l00143"></a>00143 }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="keywordtype">void</span> PIC_Controller::activate() { 
<a name="l00146"></a>00146     <span class="comment">//Stops CPU if master, signals master if slave</span>
<a name="l00147"></a>00147     <span class="keywordflow">if</span>(<span class="keyword">this</span> == &amp;master) {
<a name="l00148"></a>00148         <span class="comment">//cycles 0, take care of the port IO stuff added in raise_irq base caller.</span>
<a name="l00149"></a>00149         <span class="keywordflow">if</span> (!PIC_IRQCheckPending) {
<a name="l00150"></a>00150             <span class="comment">/* NTS: PIC_AddEvent by design caps CPU_Cycles to make the event happen on time */</span>
<a name="l00151"></a>00151             PIC_AddEvent(PIC_IRQCheckDelayed,(<span class="keywordtype">double</span>)PIC_irq_delay_ns / 1000000,0);
<a name="l00152"></a>00152             PIC_IRQCheckPending = 1;
<a name="l00153"></a>00153         }
<a name="l00154"></a>00154     } <span class="keywordflow">else</span> {
<a name="l00155"></a>00155         master.raise_irq(master_cascade_irq);
<a name="l00156"></a>00156     }
<a name="l00157"></a>00157 }
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="keywordtype">void</span> PIC_Controller::deactivate() { 
<a name="l00160"></a>00160     <span class="comment">//removes irq check value if master, signals master if slave</span>
<a name="l00161"></a>00161     <span class="keywordflow">if</span>(<span class="keyword">this</span> == &amp;master) {
<a name="l00162"></a>00162         <span class="comment">/* NTS: DOSBox code used to set PIC_IRQCheck = 0 here.</span>
<a name="l00163"></a>00163 <span class="comment">         *</span>
<a name="l00164"></a>00164 <span class="comment">         *      That&#39;s actually not the way to handle it. Here&#39;s why:</span>
<a name="l00165"></a>00165 <span class="comment">         *</span>
<a name="l00166"></a>00166 <span class="comment">         *      What would happen if one device raised an IRQ (setting PIC_IRQCheck=1)</span>
<a name="l00167"></a>00167 <span class="comment">         *      then before dispatching IRQs, another device lowered an IRQ (setting PIC_IRQCheck=0).</span>
<a name="l00168"></a>00168 <span class="comment">         *</span>
<a name="l00169"></a>00169 <span class="comment">         *      Lowering the IRQ would reset the flag, and PIC_runIRQs() would never process</span>
<a name="l00170"></a>00170 <span class="comment">         *      any pending IRQs even though some are waiting.</span>
<a name="l00171"></a>00171 <span class="comment">         *</span>
<a name="l00172"></a>00172 <span class="comment">         *      It&#39;s better if we set the flag when raising an IRQ, and leave the flag set until</span>
<a name="l00173"></a>00173 <span class="comment">         *      PIC_runIRQs() determines there are no more IRQs to dispatch. Then and only then</span>
<a name="l00174"></a>00174 <span class="comment">         *      will PIC_runIRQs() clear the flag. */</span>
<a name="l00175"></a>00175     } <span class="keywordflow">else</span> {
<a name="l00176"></a>00176         <span class="comment">/* just because ONE IRQ on the slave finished doesn&#39;t mean there aren&#39;t any others needing service! */</span>
<a name="l00177"></a>00177         <span class="keywordflow">if</span> ((irr&amp;imrr) == 0)
<a name="l00178"></a>00178             master.lower_irq(master_cascade_irq);
<a name="l00179"></a>00179         <span class="keywordflow">else</span>
<a name="l00180"></a>00180             LOG_MSG(<span class="stringliteral">&quot;Slave PIC: still to handle irr=%02x imrr=%02x isrr=%02x&quot;</span>,irr,imrr,isrr);
<a name="l00181"></a>00181     }
<a name="l00182"></a>00182 }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="keywordtype">void</span> PIC_Controller::start_irq(Bit8u val){
<a name="l00185"></a>00185     irr&amp;=~(1&lt;&lt;(val));
<a name="l00186"></a>00186     <span class="keywordflow">if</span> (!auto_eoi) {
<a name="l00187"></a>00187         active_irq = val;
<a name="l00188"></a>00188         isr |= 1&lt;&lt;(val);
<a name="l00189"></a>00189         isrr = ~isr;
<a name="l00190"></a>00190     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (GCC_UNLIKELY(rotate_on_auto_eoi)) {
<a name="l00191"></a>00191         LOG_MSG(<span class="stringliteral">&quot;rotate on auto EOI not handled&quot;</span>);
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193 }
<a name="l00194"></a>00194 
<a name="l00195"></a><a class="code" href="structPICEntry.html">00195</a> <span class="keyword">struct </span><a class="code" href="structPICEntry.html">PICEntry</a> {
<a name="l00196"></a>00196     pic_tickindex_t index;
<a name="l00197"></a>00197     Bitu value;
<a name="l00198"></a>00198     PIC_EventHandler pic_event;
<a name="l00199"></a>00199     <a class="code" href="structPICEntry.html">PICEntry</a> * next;
<a name="l00200"></a>00200 };
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="keyword">static</span> <span class="keyword">struct </span>{
<a name="l00203"></a>00203     <a class="code" href="structPICEntry.html">PICEntry</a> <a class="code" href="structentries.html">entries</a>[PIC_QUEUESIZE];
<a name="l00204"></a>00204     <a class="code" href="structPICEntry.html">PICEntry</a> * free_entry;
<a name="l00205"></a>00205     <a class="code" href="structPICEntry.html">PICEntry</a> * next_entry;
<a name="l00206"></a>00206 } pic_queue;
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 <span class="keyword">static</span> <span class="keywordtype">void</span> write_command(Bitu port,Bitu val,Bitu iolen) {
<a name="l00209"></a>00209     (void)iolen;<span class="comment">//UNUSED</span>
<a name="l00210"></a>00210     <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[(port==0x20<span class="comment">/*IBM*/</span> || port==0x00<span class="comment">/*PC-98*/</span>) ? 0 : 1];
<a name="l00211"></a>00211 
<a name="l00212"></a>00212     <span class="keywordflow">if</span> (GCC_UNLIKELY(val&amp;0x10)) {       <span class="comment">// ICW1 issued</span>
<a name="l00213"></a>00213         <span class="keywordflow">if</span> (val&amp;0x04) LOG_MSG(<span class="stringliteral">&quot;PIC: 4 byte interval not handled&quot;</span>);
<a name="l00214"></a>00214         <span class="keywordflow">if</span> (val&amp;0x08) LOG_MSG(<span class="stringliteral">&quot;PIC: level triggered mode not handled&quot;</span>);
<a name="l00215"></a>00215         <span class="keywordflow">if</span> (val&amp;0xe0) LOG_MSG(<span class="stringliteral">&quot;PIC: 8080/8085 mode not handled&quot;</span>);
<a name="l00216"></a>00216         pic-&gt;single=(val&amp;0x02)==0x02;
<a name="l00217"></a>00217         pic-&gt;icw_index=1;           <span class="comment">// next is ICW2</span>
<a name="l00218"></a>00218         pic-&gt;icw_words=2 + (val&amp;0x01);  <span class="comment">// =3 if ICW4 needed</span>
<a name="l00219"></a>00219     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (GCC_UNLIKELY(val&amp;0x08)) {    <span class="comment">// OCW3 issued</span>
<a name="l00220"></a>00220         <span class="keywordflow">if</span> (val&amp;0x04) LOG_MSG(<span class="stringliteral">&quot;PIC: poll command not handled&quot;</span>);
<a name="l00221"></a>00221         <span class="keywordflow">if</span> (val&amp;0x02) {     <span class="comment">// function select</span>
<a name="l00222"></a>00222             <span class="keywordflow">if</span> (val&amp;0x01) pic-&gt;request_issr=<span class="keyword">true</span>;   <span class="comment">/* select read interrupt in-service register */</span>
<a name="l00223"></a>00223             <span class="keywordflow">else</span> pic-&gt;request_issr=<span class="keyword">false</span>;           <span class="comment">/* select read interrupt request register */</span>
<a name="l00224"></a>00224         }
<a name="l00225"></a>00225         <span class="keywordflow">if</span> (val&amp;0x40) {     <span class="comment">// special mask select</span>
<a name="l00226"></a>00226             <span class="keywordflow">if</span> (val&amp;0x20) pic-&gt;special = <span class="keyword">true</span>;
<a name="l00227"></a>00227             <span class="keywordflow">else</span> pic-&gt;special = <span class="keyword">false</span>;
<a name="l00228"></a>00228             <span class="comment">//Check if there are irqs ready to run, as the priority system has possibly been changed.</span>
<a name="l00229"></a>00229             pic-&gt;check_for_irq();
<a name="l00230"></a>00230             <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_NORMAL)(<span class="stringliteral">&quot;port %X : special mask %s&quot;</span>,(int)port,(pic-&gt;special)?<span class="stringliteral">&quot;ON&quot;</span>:<span class="stringliteral">&quot;OFF&quot;</span>);
<a name="l00231"></a>00231         }
<a name="l00232"></a>00232     } <span class="keywordflow">else</span> {    <span class="comment">// OCW2 issued</span>
<a name="l00233"></a>00233         <span class="keywordflow">if</span> (val&amp;0x20) {     <span class="comment">// EOI commands</span>
<a name="l00234"></a>00234             <span class="keywordflow">if</span> (GCC_UNLIKELY(val&amp;0x80)) LOG_MSG(<span class="stringliteral">&quot;rotate mode not supported&quot;</span>);
<a name="l00235"></a>00235             <span class="keywordflow">if</span> (val&amp;0x40) {     <span class="comment">// specific EOI</span>
<a name="l00236"></a>00236                 pic-&gt;isr &amp;= ~(1&lt;&lt; ((val-0x60)));
<a name="l00237"></a>00237                 pic-&gt;isrr = ~pic-&gt;isr;
<a name="l00238"></a>00238                 pic-&gt;check_after_EOI();
<a name="l00239"></a>00239 <span class="comment">//              if (val&amp;0x80);  // perform rotation</span>
<a name="l00240"></a>00240             } <span class="keywordflow">else</span> {        <span class="comment">// nonspecific EOI</span>
<a name="l00241"></a>00241                 <span class="keywordflow">if</span> (pic-&gt;active_irq != 8) { 
<a name="l00242"></a>00242                     <span class="comment">//If there is no irq in service, ignore the call, some games send an eoi to both pics when a sound irq happens (regardless of the irq).</span>
<a name="l00243"></a>00243                     pic-&gt;isr &amp;= ~(1 &lt;&lt; (pic-&gt;active_irq));
<a name="l00244"></a>00244                     pic-&gt;isrr = ~pic-&gt;isr;
<a name="l00245"></a>00245                     pic-&gt;check_after_EOI();
<a name="l00246"></a>00246                 }
<a name="l00247"></a>00247 <span class="comment">//              if (val&amp;0x80);  // perform rotation</span>
<a name="l00248"></a>00248             }
<a name="l00249"></a>00249         } <span class="keywordflow">else</span> {
<a name="l00250"></a>00250             <span class="keywordflow">if</span> ((val&amp;0x40)==0) {        <span class="comment">// rotate in auto EOI mode</span>
<a name="l00251"></a>00251                 <span class="keywordflow">if</span> (val&amp;0x80) pic-&gt;rotate_on_auto_eoi=<span class="keyword">true</span>;
<a name="l00252"></a>00252                 <span class="keywordflow">else</span> pic-&gt;rotate_on_auto_eoi=<span class="keyword">false</span>;
<a name="l00253"></a>00253             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val&amp;0x80) {
<a name="l00254"></a>00254                 <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_NORMAL)(<span class="stringliteral">&quot;set priority command not handled&quot;</span>);
<a name="l00255"></a>00255             }   <span class="comment">// else NOP command</span>
<a name="l00256"></a>00256         }
<a name="l00257"></a>00257     }   <span class="comment">// end OCW2</span>
<a name="l00258"></a>00258 }
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 <span class="keyword">static</span> <span class="keywordtype">void</span> write_data(Bitu port,Bitu val,Bitu iolen) {
<a name="l00261"></a>00261     (void)iolen;<span class="comment">//UNUSED</span>
<a name="l00262"></a>00262     <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[(port==0x21<span class="comment">/*IBM*/</span> || port==0x02<span class="comment">/*PC-98*/</span>) ? 0 : 1];
<a name="l00263"></a>00263 
<a name="l00264"></a>00264     <span class="keywordflow">switch</span>(pic-&gt;icw_index) {
<a name="l00265"></a>00265     <span class="keywordflow">case</span> 0:                        <span class="comment">/* mask register */</span>
<a name="l00266"></a>00266         pic-&gt;set_imr(val);
<a name="l00267"></a>00267         <span class="keywordflow">break</span>;
<a name="l00268"></a>00268     <span class="keywordflow">case</span> 1:                        <span class="comment">/* icw2          */</span>
<a name="l00269"></a>00269         <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_NORMAL)(<span class="stringliteral">&quot;%d:Base vector %X&quot;</span>,port==0x21 ? 0 : 1,(int)val);
<a name="l00270"></a>00270         pic-&gt;vector_base = val&amp;0xf8;
<a name="l00271"></a>00271         <span class="keywordflow">if</span>(pic-&gt;icw_index++ &gt;= pic-&gt;icw_words) pic-&gt;icw_index=0;
<a name="l00272"></a>00272         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pic-&gt;single) pic-&gt;icw_index=3;      <span class="comment">/* skip ICW3 in single mode */</span>
<a name="l00273"></a>00273         <span class="keywordflow">break</span>;
<a name="l00274"></a>00274     <span class="keywordflow">case</span> 2:                         <span class="comment">/* icw 3 */</span>
<a name="l00275"></a>00275         <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_NORMAL)(<span class="stringliteral">&quot;%d:ICW 3 %X&quot;</span>,port==0x21 ? 0 : 1,(int)val);
<a name="l00276"></a>00276         <span class="keywordflow">if</span>(pic-&gt;icw_index++ &gt;= pic-&gt;icw_words) pic-&gt;icw_index=0;
<a name="l00277"></a>00277         <span class="keywordflow">break</span>;
<a name="l00278"></a>00278     <span class="keywordflow">case</span> 3:                         <span class="comment">/* icw 4 */</span>
<a name="l00279"></a>00279         <span class="comment">/*</span>
<a name="l00280"></a>00280 <span class="comment">            0       1 8086/8080  0 mcs-8085 mode</span>
<a name="l00281"></a>00281 <span class="comment">            1       1 Auto EOI   0 Normal EOI</span>
<a name="l00282"></a>00282 <span class="comment">            2-3    0x Non buffer Mode </span>
<a name="l00283"></a>00283 <span class="comment">                   10 Buffer Mode Slave </span>
<a name="l00284"></a>00284 <span class="comment">                   11 Buffer mode Master    </span>
<a name="l00285"></a>00285 <span class="comment">            4       Special/Not Special nested mode </span>
<a name="l00286"></a>00286 <span class="comment">        */</span>
<a name="l00287"></a>00287         pic-&gt;auto_eoi=(val &amp; 0x2)&gt;0;
<a name="l00288"></a>00288         
<a name="l00289"></a>00289         <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_NORMAL)(<span class="stringliteral">&quot;%d:ICW 4 %X&quot;</span>,port==0x21 ? 0 : 1,(int)val);
<a name="l00290"></a>00290 
<a name="l00291"></a>00291         <span class="keywordflow">if</span> ((val&amp;0x01)==0) LOG_MSG(<span class="stringliteral">&quot;PIC:ICW4: %x, 8085 mode not handled&quot;</span>,(<span class="keywordtype">int</span>)val);
<a name="l00292"></a>00292         <span class="keywordflow">if</span> ((val&amp;0x10)!=0) LOG_MSG(<span class="stringliteral">&quot;PIC:ICW4: %x, special fully-nested mode not handled&quot;</span>,(<span class="keywordtype">int</span>)val);
<a name="l00293"></a>00293 
<a name="l00294"></a>00294         <span class="keywordflow">if</span>(pic-&gt;icw_index++ &gt;= pic-&gt;icw_words) pic-&gt;icw_index=0;
<a name="l00295"></a>00295         <span class="keywordflow">break</span>;
<a name="l00296"></a>00296     <span class="keywordflow">default</span>:
<a name="l00297"></a>00297         <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_NORMAL)(<span class="stringliteral">&quot;ICW HUH? %X&quot;</span>,(int)val);
<a name="l00298"></a>00298         <span class="keywordflow">break</span>;
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300 }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="keyword">static</span> Bitu read_command(Bitu port,Bitu iolen) {
<a name="l00304"></a>00304     (void)iolen;<span class="comment">//UNUSED</span>
<a name="l00305"></a>00305     <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[(port==0x20<span class="comment">/*IBM*/</span> || port==0x00<span class="comment">/*PC-98*/</span>) ? 0 : 1];
<a name="l00306"></a>00306     <span class="keywordflow">if</span> (pic-&gt;request_issr){
<a name="l00307"></a>00307         <span class="keywordflow">return</span> pic-&gt;isr;
<a name="l00308"></a>00308     } <span class="keywordflow">else</span> { 
<a name="l00309"></a>00309         <span class="keywordflow">return</span> pic-&gt;irr;
<a name="l00310"></a>00310     }
<a name="l00311"></a>00311 }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="keyword">static</span> Bitu read_data(Bitu port,Bitu iolen) {
<a name="l00315"></a>00315     (void)iolen;<span class="comment">//UNUSED</span>
<a name="l00316"></a>00316     <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[(port==0x21<span class="comment">/*IBM*/</span> || port==0x02<span class="comment">/*PC-98*/</span>) ? 0 : 1];
<a name="l00317"></a>00317     <span class="keywordflow">return</span> pic-&gt;imr;
<a name="l00318"></a>00318 }
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 <span class="comment">/* PC/XT NMI mask register 0xA0. Documentation on the other bits</span>
<a name="l00321"></a>00321 <span class="comment"> * is sparse and spread across the internet, but many seem to</span>
<a name="l00322"></a>00322 <span class="comment"> * agree that bit 7 is used to enable/disable the NMI (1=enable,</span>
<a name="l00323"></a>00323 <span class="comment"> * 0=disable) */</span>
<a name="l00324"></a>00324 <span class="keyword">static</span> <span class="keywordtype">void</span> pc_xt_nmi_write(Bitu port,Bitu val,Bitu iolen) {
<a name="l00325"></a>00325     (void)iolen;<span class="comment">//UNUSED</span>
<a name="l00326"></a>00326     (void)port;<span class="comment">//UNUSED</span>
<a name="l00327"></a>00327     CPU_NMI_gate = (val &amp; 0x80) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00328"></a>00328 }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 <span class="comment">/* FIXME: This should be called something else that&#39;s true to the ISA bus, like PIC_PulseIRQ, not Activate IRQ.</span>
<a name="l00331"></a>00331 <span class="comment"> *        ISA interrupts are edge triggered, not level triggered. */</span>
<a name="l00332"></a>00332 <span class="keywordtype">void</span> PIC_ActivateIRQ(Bitu irq) {
<a name="l00333"></a>00333     <span class="comment">/* Remember what was once IRQ 2 on PC/XT is IRQ 9 on PC/AT */</span>
<a name="l00334"></a>00334     <span class="keywordflow">if</span> (IS_PC98_ARCH) {
<a name="l00335"></a>00335         <span class="keywordflow">if</span> (irq == 7) {
<a name="l00336"></a>00336             <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_ERROR)(<span class="stringliteral">&quot;Attempted to raise IRQ %u, which is cascade IRQ&quot;</span>,(int)irq);
<a name="l00337"></a>00337             <span class="keywordflow">return</span>; <span class="comment">/* don&#39;t raise cascade IRQ */</span>
<a name="l00338"></a>00338         }
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (enable_slave_pic) { <span class="comment">/* PC/AT emulation with slave PIC cascade to master */</span>
<a name="l00341"></a>00341         <span class="keywordflow">if</span> (irq == 2) irq = 9;
<a name="l00342"></a>00342     }
<a name="l00343"></a>00343     <span class="keywordflow">else</span> { <span class="comment">/* PC/XT emulation with only master PIC */</span>
<a name="l00344"></a>00344         <span class="keywordflow">if</span> (irq == 9) irq = 2;
<a name="l00345"></a>00345         <span class="keywordflow">if</span> (irq &gt;= 8) {
<a name="l00346"></a>00346             <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_ERROR)(<span class="stringliteral">&quot;Attempted to raise IRQ %u when slave PIC does not exist&quot;</span>,(int)irq);
<a name="l00347"></a>00347             <span class="keywordflow">return</span>;
<a name="l00348"></a>00348         }
<a name="l00349"></a>00349     }
<a name="l00350"></a>00350 
<a name="l00351"></a>00351     Bitu t = irq&gt;7 ? (irq - 8): irq;
<a name="l00352"></a>00352     <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[irq&gt;7 ? 1 : 0];
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     pic-&gt;raise_irq(t);
<a name="l00355"></a>00355 }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 <span class="keywordtype">void</span> PIC_DeActivateIRQ(Bitu irq) {
<a name="l00358"></a>00358     <span class="comment">/* Remember what was once IRQ 2 on PC/XT is IRQ 9 on PC/AT */</span>
<a name="l00359"></a>00359     <span class="keywordflow">if</span> (IS_PC98_ARCH) {
<a name="l00360"></a>00360         <span class="keywordflow">if</span> (irq == 7) <span class="keywordflow">return</span>;
<a name="l00361"></a>00361     }
<a name="l00362"></a>00362     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (enable_slave_pic) { <span class="comment">/* PC/AT emulation with slave PIC cascade to master */</span>
<a name="l00363"></a>00363         <span class="keywordflow">if</span> (irq == 2) irq = 9;
<a name="l00364"></a>00364     }
<a name="l00365"></a>00365     <span class="keywordflow">else</span> { <span class="comment">/* PC/XT emulation with only master PIC */</span>
<a name="l00366"></a>00366         <span class="keywordflow">if</span> (irq == 9) irq = 2;
<a name="l00367"></a>00367         <span class="keywordflow">if</span> (irq &gt;= 8) {
<a name="l00368"></a>00368             <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_ERROR)(<span class="stringliteral">&quot;Attempted to lower IRQ %u when slave PIC does not exist&quot;</span>,(int)irq);
<a name="l00369"></a>00369             <span class="keywordflow">return</span>;
<a name="l00370"></a>00370         }
<a name="l00371"></a>00371     }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373     Bitu t = irq&gt;7 ? (irq - 8): irq;
<a name="l00374"></a>00374     <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[irq&gt;7 ? 1 : 0];
<a name="l00375"></a>00375     pic-&gt;lower_irq(t);
<a name="l00376"></a>00376 }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="keyword">enum</span> PIC_irq_hacks PIC_IRQ_hax[16] = { PIC_irq_hack_none };
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 <span class="keywordtype">void</span> PIC_Set_IRQ_hack(<span class="keywordtype">int</span> IRQ,<span class="keyword">enum</span> PIC_irq_hacks hack) {
<a name="l00381"></a>00381     <span class="keywordflow">if</span> (IRQ &lt; 0 || IRQ &gt;= 16) <span class="keywordflow">return</span>;
<a name="l00382"></a>00382     PIC_IRQ_hax[IRQ] = hack;
<a name="l00383"></a>00383 }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 <span class="keyword">enum</span> PIC_irq_hacks PIC_parse_IRQ_hack_string(<span class="keyword">const</span> <span class="keywordtype">char</span> *str) {
<a name="l00386"></a>00386     <span class="keywordflow">if</span> (!strcmp(str,<span class="stringliteral">&quot;none&quot;</span>))
<a name="l00387"></a>00387         <span class="keywordflow">return</span> PIC_irq_hack_none;
<a name="l00388"></a>00388     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(str,<span class="stringliteral">&quot;cs_equ_ds&quot;</span>))
<a name="l00389"></a>00389         <span class="keywordflow">return</span> PIC_irq_hack_cs_equ_ds;
<a name="l00390"></a>00390 
<a name="l00391"></a>00391     <span class="keywordflow">return</span> PIC_irq_hack_none;
<a name="l00392"></a>00392 }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 <span class="keyword">static</span> <span class="keywordtype">bool</span> IRQ_hack_check_cs_equ_ds(<span class="keyword">const</span> <span class="keywordtype">int</span> IRQ) {
<a name="l00395"></a>00395     uint16_t s_cs = SegValue(cs);
<a name="l00396"></a>00396     uint16_t s_ds = SegValue(ds);
<a name="l00397"></a>00397 
<a name="l00398"></a>00398     <span class="keywordflow">if</span> (s_cs &gt;= 0xA000)
<a name="l00399"></a>00399         <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// don&#39;t complain about the BIOS ISR</span>
<a name="l00400"></a>00400 
<a name="l00401"></a>00401     <span class="keywordflow">if</span> (s_cs != s_ds) {
<a name="l00402"></a>00402         <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_DEBUG)(<span class="stringliteral">&quot;Not dispatching IRQ %d according to IRQ hack. CS != DS&quot;</span>,IRQ);
<a name="l00403"></a>00403         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00404"></a>00404     }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00407"></a>00407 }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 <span class="keyword">static</span> <span class="keywordtype">void</span> slave_startIRQ(){
<a name="l00410"></a>00410     Bit8u pic1_irq = 8;
<a name="l00411"></a>00411     <span class="keyword">const</span> Bit8u p = (slave.irr &amp; slave.imrr)&amp;slave.isrr;
<a name="l00412"></a>00412     <span class="keyword">const</span> Bit8u max = slave.special?8:slave.active_irq;
<a name="l00413"></a>00413     <span class="keywordflow">for</span>(Bit8u i = 0,s = 1;i &lt; max;i++, s&lt;&lt;=1) {
<a name="l00414"></a>00414         <span class="keywordflow">if</span> (p&amp;s) {
<a name="l00415"></a>00415             <span class="keywordflow">if</span> (PIC_IRQ_hax[i+8] == PIC_irq_hack_cs_equ_ds)
<a name="l00416"></a>00416                 <span class="keywordflow">if</span> (!IRQ_hack_check_cs_equ_ds(i+8))
<a name="l00417"></a>00417                     <span class="keywordflow">continue</span>; <span class="comment">// skip IRQ</span>
<a name="l00418"></a>00418 
<a name="l00419"></a>00419             pic1_irq = i;
<a name="l00420"></a>00420             <span class="keywordflow">break</span>;
<a name="l00421"></a>00421         }
<a name="l00422"></a>00422     }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424     <span class="keywordflow">if</span> (GCC_UNLIKELY(pic1_irq == 8)) {
<a name="l00425"></a>00425         <span class="comment">/* we have an IRQ routing problem. this code is supposed to emulate the fact that</span>
<a name="l00426"></a>00426 <span class="comment">         * what was once IRQ 2 on PC/XT is routed to IRQ 9 on AT systems, because IRQ 8-15</span>
<a name="l00427"></a>00427 <span class="comment">         * cascade to IRQ 2 on such systems. but it&#39;s nothing to E_Exit() over. */</span>
<a name="l00428"></a>00428         <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_ERROR)(<span class="stringliteral">&quot;ISA PIC problem: IRQ %d (cascade) is active on master PIC without active IRQ 8-15 on slave PIC.&quot;</span>,master_cascade_irq);
<a name="l00429"></a>00429         slave.lower_irq(master_cascade_irq); <span class="comment">/* clear it */</span>
<a name="l00430"></a>00430         <span class="keywordflow">return</span>;
<a name="l00431"></a>00431     }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433     slave.start_irq(pic1_irq);
<a name="l00434"></a>00434     master.start_irq(master_cascade_irq);
<a name="l00435"></a>00435     CPU_HW_Interrupt((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)slave.vector_base + (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)pic1_irq);
<a name="l00436"></a>00436 }
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">inline</span> master_startIRQ(Bitu i){
<a name="l00439"></a>00439     master.start_irq(i);
<a name="l00440"></a>00440     CPU_HW_Interrupt(master.vector_base + i);
<a name="l00441"></a>00441 }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 <span class="keywordtype">void</span> PIC_runIRQs(<span class="keywordtype">void</span>) {
<a name="l00444"></a>00444     <span class="keywordflow">if</span> (!GETFLAG(IF)) <span class="keywordflow">return</span>;
<a name="l00445"></a>00445     <span class="keywordflow">if</span> (GCC_UNLIKELY(!PIC_IRQCheck)) <span class="keywordflow">return</span>;
<a name="l00446"></a>00446     <span class="keywordflow">if</span> (GCC_UNLIKELY(cpudecoder==CPU_Core_Normal_Trap_Run)) <span class="keywordflow">return</span>; <span class="comment">// FIXME: Why?</span>
<a name="l00447"></a>00447     <span class="keywordflow">if</span> (GCC_UNLIKELY(CPU_NMI_active) || GCC_UNLIKELY(CPU_NMI_pending)) <span class="keywordflow">return</span>; <span class="comment">/* NMI has higher priority than PIC */</span>
<a name="l00448"></a>00448 
<a name="l00449"></a>00449     <span class="keyword">const</span> Bit8u p = (master.irr &amp; master.imrr)&amp;master.isrr;
<a name="l00450"></a>00450     <span class="keyword">const</span> Bit8u max = master.special?8:master.active_irq;
<a name="l00451"></a>00451     Bit8u i,s;
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     for (i = 0,s = 1;i &lt; max;i++, s&lt;&lt;=1){
<a name="l00454"></a>00454         <span class="keywordflow">if</span> (p&amp;s) {
<a name="l00455"></a>00455             <span class="keywordflow">if</span> (PIC_IRQ_hax[i] == PIC_irq_hack_cs_equ_ds)
<a name="l00456"></a>00456                 <span class="keywordflow">if</span> (!IRQ_hack_check_cs_equ_ds(i))
<a name="l00457"></a>00457                     <span class="keywordflow">continue</span>; <span class="comment">// skip IRQ</span>
<a name="l00458"></a>00458 
<a name="l00459"></a>00459             <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)i == master_cascade_irq) { <span class="comment">//second pic, or will not match if master_cascade_irq == -1</span>
<a name="l00460"></a>00460                 slave_startIRQ();
<a name="l00461"></a>00461             } <span class="keywordflow">else</span> {
<a name="l00462"></a>00462                 master_startIRQ(i);
<a name="l00463"></a>00463             }
<a name="l00464"></a>00464             <span class="keywordflow">break</span>;
<a name="l00465"></a>00465         }
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468     <span class="comment">/* if we cleared all IRQs, then stop checking.</span>
<a name="l00469"></a>00469 <span class="comment">     * otherwise, keep the flag set for the next IRQ to process. */</span>
<a name="l00470"></a>00470     <span class="keywordflow">if</span> (i == max &amp;&amp; (master.irr&amp;master.imrr) == 0) {
<a name="l00471"></a>00471         PIC_IRQCheckPending = 0;
<a name="l00472"></a>00472         PIC_IRQCheck = 0;
<a name="l00473"></a>00473     }
<a name="l00474"></a>00474     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PIC_IRQCheck) {
<a name="l00475"></a>00475         PIC_AddEvent(PIC_IRQCheckDelayed,(<span class="keywordtype">double</span>)PIC_irq_delay_ns / 1000000,0);
<a name="l00476"></a>00476         PIC_IRQCheckPending = 1;
<a name="l00477"></a>00477         PIC_IRQCheck = 0;
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479 }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="keywordtype">void</span> PIC_SetIRQMask(Bitu irq, <span class="keywordtype">bool</span> masked) {
<a name="l00482"></a>00482     Bitu t = irq&gt;7 ? (irq - 8): irq;
<a name="l00483"></a>00483     <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[irq&gt;7 ? 1 : 0];
<a name="l00484"></a>00484     <span class="comment">//clear bit</span>
<a name="l00485"></a>00485     Bit8u bit = 1 &lt;&lt;(t);
<a name="l00486"></a>00486     Bit8u newmask = pic-&gt;imr;
<a name="l00487"></a>00487     newmask &amp;= ~bit;
<a name="l00488"></a>00488     <span class="keywordflow">if</span> (masked) newmask |= bit;
<a name="l00489"></a>00489     pic-&gt;set_imr(newmask);
<a name="l00490"></a>00490 }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="keywordtype">void</span> DEBUG_PICSignal(<span class="keywordtype">int</span> irq,<span class="keywordtype">bool</span> <span class="keyword">raise</span>) {
<a name="l00493"></a>00493     <span class="keywordflow">if</span> (irq &gt;= 0 &amp;&amp; irq &lt;= 15) {
<a name="l00494"></a>00494         <span class="keywordflow">if</span> (<span class="keyword">raise</span>)
<a name="l00495"></a>00495             PIC_ActivateIRQ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)irq);
<a name="l00496"></a>00496         <span class="keywordflow">else</span>
<a name="l00497"></a>00497             PIC_DeActivateIRQ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)irq);
<a name="l00498"></a>00498     }
<a name="l00499"></a>00499 }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 <span class="keywordtype">void</span> DEBUG_PICAck(<span class="keywordtype">int</span> irq) {
<a name="l00502"></a>00502     <span class="keywordflow">if</span> (irq &gt;= 0 &amp;&amp; irq &lt;= 15) {
<a name="l00503"></a>00503         <a class="code" href="structPIC__Controller.html">PIC_Controller</a> * pic=&amp;pics[irq&gt;7 ? 1 : 0];
<a name="l00504"></a>00504 
<a name="l00505"></a>00505         pic-&gt;isr &amp;= ~(1u &lt;&lt; ((<span class="keywordtype">unsigned</span> int)irq &amp; 7U));
<a name="l00506"></a>00506         pic-&gt;isrr = ~pic-&gt;isr;
<a name="l00507"></a>00507         pic-&gt;check_after_EOI();
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509 }
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 <span class="keywordtype">void</span> DEBUG_PICMask(<span class="keywordtype">int</span> irq,<span class="keywordtype">bool</span> mask) {
<a name="l00512"></a>00512     <span class="keywordflow">if</span> (irq &gt;= 0 &amp;&amp; irq &lt;= 15)
<a name="l00513"></a>00513         PIC_SetIRQMask((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)irq,mask);
<a name="l00514"></a>00514 }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516 <span class="keyword">static</span> <span class="keywordtype">void</span> AddEntry(<a class="code" href="structPICEntry.html">PICEntry</a> * entry) {
<a name="l00517"></a>00517     <a class="code" href="structPICEntry.html">PICEntry</a> * find_entry=pic_queue.next_entry;
<a name="l00518"></a>00518     <span class="keywordflow">if</span> (GCC_UNLIKELY(find_entry ==0)) {
<a name="l00519"></a>00519         entry-&gt;next=0;
<a name="l00520"></a>00520         pic_queue.next_entry=entry;
<a name="l00521"></a>00521     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (find_entry-&gt;index&gt;entry-&gt;index) {
<a name="l00522"></a>00522         pic_queue.next_entry=entry;
<a name="l00523"></a>00523         entry-&gt;next=find_entry;
<a name="l00524"></a>00524     } <span class="keywordflow">else</span> <span class="keywordflow">while</span> (find_entry) {
<a name="l00525"></a>00525         <span class="keywordflow">if</span> (find_entry-&gt;next) {
<a name="l00526"></a>00526             <span class="comment">/* See if the next index comes later than this one */</span>
<a name="l00527"></a>00527             <span class="keywordflow">if</span> (find_entry-&gt;next-&gt;index &gt; entry-&gt;index) {
<a name="l00528"></a>00528                 entry-&gt;next=find_entry-&gt;next;
<a name="l00529"></a>00529                 find_entry-&gt;next=entry;
<a name="l00530"></a>00530                 <span class="keywordflow">break</span>;
<a name="l00531"></a>00531             } <span class="keywordflow">else</span> {
<a name="l00532"></a>00532                 find_entry=find_entry-&gt;next;
<a name="l00533"></a>00533             }
<a name="l00534"></a>00534         } <span class="keywordflow">else</span> {
<a name="l00535"></a>00535             entry-&gt;next=find_entry-&gt;next;
<a name="l00536"></a>00536             find_entry-&gt;next=entry;
<a name="l00537"></a>00537             <span class="keywordflow">break</span>;
<a name="l00538"></a>00538         }
<a name="l00539"></a>00539     }
<a name="l00540"></a>00540     Bits cycles=PIC_MakeCycles(pic_queue.next_entry-&gt;index-PIC_TickIndex());
<a name="l00541"></a>00541     <span class="keywordflow">if</span> (cycles&lt;CPU_Cycles) {
<a name="l00542"></a>00542         CPU_CycleLeft+=CPU_Cycles;
<a name="l00543"></a>00543         CPU_Cycles=0;
<a name="l00544"></a>00544     }
<a name="l00545"></a>00545 }
<a name="l00546"></a>00546 
<a name="l00547"></a>00547 <span class="keyword">static</span> <span class="keywordtype">bool</span> InEventService = <span class="keyword">false</span>;
<a name="l00548"></a>00548 <span class="keyword">static</span> pic_tickindex_t srv_lag = 0;
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="keywordtype">void</span> PIC_AddEvent(PIC_EventHandler handler,pic_tickindex_t delay,Bitu val) {
<a name="l00551"></a>00551     <span class="keywordflow">if</span> (GCC_UNLIKELY(!pic_queue.free_entry)) {
<a name="l00552"></a>00552         <a class="code" href="classLOG.html">LOG</a>(LOG_PIC,LOG_ERROR)(<span class="stringliteral">&quot;Event queue full&quot;</span>);
<a name="l00553"></a>00553         <span class="keywordflow">return</span>;
<a name="l00554"></a>00554     }
<a name="l00555"></a>00555     <a class="code" href="structPICEntry.html">PICEntry</a> * entry=pic_queue.free_entry;
<a name="l00556"></a>00556     <span class="keywordflow">if</span>(InEventService) entry-&gt;index = delay + srv_lag;
<a name="l00557"></a>00557     <span class="keywordflow">else</span> entry-&gt;index = delay + PIC_TickIndex();
<a name="l00558"></a>00558 
<a name="l00559"></a>00559     entry-&gt;pic_event=handler;
<a name="l00560"></a>00560     entry-&gt;value=val;
<a name="l00561"></a>00561     pic_queue.free_entry=pic_queue.free_entry-&gt;next;
<a name="l00562"></a>00562     AddEntry(entry);
<a name="l00563"></a>00563 }
<a name="l00564"></a>00564 
<a name="l00565"></a>00565 <span class="keywordtype">void</span> PIC_RemoveSpecificEvents(PIC_EventHandler handler, Bitu val) {
<a name="l00566"></a>00566     <a class="code" href="structPICEntry.html">PICEntry</a> * entry=pic_queue.next_entry;
<a name="l00567"></a>00567     <a class="code" href="structPICEntry.html">PICEntry</a> * prev_entry;
<a name="l00568"></a>00568     prev_entry = 0;
<a name="l00569"></a>00569     <span class="keywordflow">while</span> (entry) {
<a name="l00570"></a>00570         <span class="keywordflow">if</span> (GCC_UNLIKELY((entry-&gt;pic_event == handler)) &amp;&amp; (entry-&gt;value == val)) {
<a name="l00571"></a>00571             <span class="keywordflow">if</span> (prev_entry) {
<a name="l00572"></a>00572                 prev_entry-&gt;next=entry-&gt;next;
<a name="l00573"></a>00573                 entry-&gt;next=pic_queue.free_entry;
<a name="l00574"></a>00574                 pic_queue.free_entry=entry;
<a name="l00575"></a>00575                 entry=prev_entry-&gt;next;
<a name="l00576"></a>00576                 <span class="keywordflow">continue</span>;
<a name="l00577"></a>00577             } <span class="keywordflow">else</span> {
<a name="l00578"></a>00578                 pic_queue.next_entry=entry-&gt;next;
<a name="l00579"></a>00579                 entry-&gt;next=pic_queue.free_entry;
<a name="l00580"></a>00580                 pic_queue.free_entry=entry;
<a name="l00581"></a>00581                 entry=pic_queue.next_entry;
<a name="l00582"></a>00582                 <span class="keywordflow">continue</span>;
<a name="l00583"></a>00583             }
<a name="l00584"></a>00584         }
<a name="l00585"></a>00585         prev_entry=entry;
<a name="l00586"></a>00586         entry=entry-&gt;next;
<a name="l00587"></a>00587     }   
<a name="l00588"></a>00588 }
<a name="l00589"></a>00589 
<a name="l00590"></a>00590 <span class="keywordtype">void</span> PIC_RemoveEvents(PIC_EventHandler handler) {
<a name="l00591"></a>00591     <a class="code" href="structPICEntry.html">PICEntry</a> * entry=pic_queue.next_entry;
<a name="l00592"></a>00592     <a class="code" href="structPICEntry.html">PICEntry</a> * prev_entry;
<a name="l00593"></a>00593     prev_entry=0;
<a name="l00594"></a>00594     <span class="keywordflow">while</span> (entry) {
<a name="l00595"></a>00595         <span class="keywordflow">if</span> (GCC_UNLIKELY(entry-&gt;pic_event==handler)) {
<a name="l00596"></a>00596             <span class="keywordflow">if</span> (prev_entry) {
<a name="l00597"></a>00597                 prev_entry-&gt;next=entry-&gt;next;
<a name="l00598"></a>00598                 entry-&gt;next=pic_queue.free_entry;
<a name="l00599"></a>00599                 pic_queue.free_entry=entry;
<a name="l00600"></a>00600                 entry=prev_entry-&gt;next;
<a name="l00601"></a>00601                 <span class="keywordflow">continue</span>;
<a name="l00602"></a>00602             } <span class="keywordflow">else</span> {
<a name="l00603"></a>00603                 pic_queue.next_entry=entry-&gt;next;
<a name="l00604"></a>00604                 entry-&gt;next=pic_queue.free_entry;
<a name="l00605"></a>00605                 pic_queue.free_entry=entry;
<a name="l00606"></a>00606                 entry=pic_queue.next_entry;
<a name="l00607"></a>00607                 <span class="keywordflow">continue</span>;
<a name="l00608"></a>00608             }
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610         prev_entry=entry;
<a name="l00611"></a>00611         entry=entry-&gt;next;
<a name="l00612"></a>00612     }   
<a name="l00613"></a>00613 }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="keyword">extern</span> <a class="code" href="classClockDomain.html">ClockDomain</a> clockdom_DOSBox_cycles;
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 <span class="keywordtype">bool</span> PIC_RunQueue(<span class="keywordtype">void</span>) {
<a name="l00618"></a>00618     <span class="comment">/* Check to see if a new millisecond needs to be started */</span>
<a name="l00619"></a>00619     CPU_CycleLeft += CPU_Cycles;
<a name="l00620"></a>00620     CPU_Cycles = 0;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622     <span class="keywordflow">if</span> (CPU_CycleLeft &gt; 0) {
<a name="l00623"></a>00623         <span class="keywordflow">if</span> (PIC_IRQCheck)
<a name="l00624"></a>00624             PIC_runIRQs();
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="comment">/* Check the queue for an entry */</span>
<a name="l00627"></a>00627         Bits index_nd=PIC_TickIndexND();
<a name="l00628"></a>00628         InEventService = <span class="keyword">true</span>;
<a name="l00629"></a>00629         <span class="keywordflow">while</span> (pic_queue.next_entry &amp;&amp; (pic_queue.next_entry-&gt;index*CPU_CycleMax&lt;=index_nd)) {
<a name="l00630"></a>00630             <a class="code" href="structPICEntry.html">PICEntry</a> * entry=pic_queue.next_entry;
<a name="l00631"></a>00631             pic_queue.next_entry=entry-&gt;next;
<a name="l00632"></a>00632 
<a name="l00633"></a>00633             srv_lag = entry-&gt;index;
<a name="l00634"></a>00634             (entry-&gt;pic_event)(entry-&gt;value); <span class="comment">// call the event handler</span>
<a name="l00635"></a>00635 
<a name="l00636"></a>00636             <span class="comment">/* Put the entry in the free list */</span>
<a name="l00637"></a>00637             entry-&gt;next=pic_queue.free_entry;
<a name="l00638"></a>00638             pic_queue.free_entry=entry;
<a name="l00639"></a>00639         }
<a name="l00640"></a>00640         InEventService = <span class="keyword">false</span>;
<a name="l00641"></a>00641 
<a name="l00642"></a>00642         <span class="comment">/* Check when to set the new cycle end */</span>
<a name="l00643"></a>00643         <span class="keywordflow">if</span> (pic_queue.next_entry) {
<a name="l00644"></a>00644             Bits cycles=(Bits)(pic_queue.next_entry-&gt;index*CPU_CycleMax-index_nd);
<a name="l00645"></a>00645             <span class="keywordflow">if</span> (GCC_UNLIKELY(!cycles)) cycles=1;
<a name="l00646"></a>00646             <span class="keywordflow">if</span> (cycles&lt;CPU_CycleLeft) {
<a name="l00647"></a>00647                 CPU_Cycles=cycles;
<a name="l00648"></a>00648             } <span class="keywordflow">else</span> {
<a name="l00649"></a>00649                 CPU_Cycles=CPU_CycleLeft;
<a name="l00650"></a>00650             }
<a name="l00651"></a>00651         } <span class="keywordflow">else</span> CPU_Cycles=CPU_CycleLeft;
<a name="l00652"></a>00652         CPU_CycleLeft-=CPU_Cycles;
<a name="l00653"></a>00653 
<a name="l00654"></a>00654         <span class="keywordflow">if</span> (PIC_IRQCheck)
<a name="l00655"></a>00655             PIC_runIRQs();
<a name="l00656"></a>00656     }
<a name="l00657"></a>00657 
<a name="l00658"></a>00658     <span class="comment">/* if we&#39;re out of cycles, then return false. don&#39;t execute any more instructions */</span>
<a name="l00659"></a>00659     <span class="keywordflow">if</span> ((CPU_CycleLeft+CPU_Cycles) &lt;= 0)
<a name="l00660"></a>00660         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00663"></a>00663 }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 <span class="comment">/* The TIMER Part */</span>
<a name="l00666"></a><a class="code" href="structTickerBlock.html">00666</a> <span class="keyword">struct </span><a class="code" href="structTickerBlock.html">TickerBlock</a> {
<a name="l00667"></a>00667     <span class="comment">/* TODO: carry const char * field for name! */</span>
<a name="l00668"></a>00668     TIMER_TickHandler handler;
<a name="l00669"></a>00669     <a class="code" href="structTickerBlock.html">TickerBlock</a> * next;
<a name="l00670"></a>00670 };
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 <span class="keyword">static</span> <a class="code" href="structTickerBlock.html">TickerBlock</a> * firstticker=0;
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 <span class="keywordtype">void</span> TIMER_ShutdownTickHandlers() {
<a name="l00675"></a>00675     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> leftovers = 0;
<a name="l00676"></a>00676 
<a name="l00677"></a>00677     <span class="comment">/* pull in the singly linked list from the front, hand over hand */</span>
<a name="l00678"></a>00678     <span class="keywordflow">while</span> (firstticker != NULL) {
<a name="l00679"></a>00679         <a class="code" href="structTickerBlock.html">TickerBlock</a> *n = firstticker-&gt;next;
<a name="l00680"></a>00680         <span class="keyword">delete</span> firstticker;
<a name="l00681"></a>00681         firstticker = n;
<a name="l00682"></a>00682         leftovers++;
<a name="l00683"></a>00683     }
<a name="l00684"></a>00684 
<a name="l00685"></a>00685     <span class="keywordflow">if</span> (leftovers != 0)
<a name="l00686"></a>00686         <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;TIMER: %u leftover handlers (clean up!).&quot;</span>,leftovers);
<a name="l00687"></a>00687 }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 <span class="keywordtype">void</span> TIMER_DelTickHandler(TIMER_TickHandler handler) {
<a name="l00690"></a>00690     <a class="code" href="structTickerBlock.html">TickerBlock</a> * ticker=firstticker;
<a name="l00691"></a>00691     <a class="code" href="structTickerBlock.html">TickerBlock</a> * * tick_where=&amp;firstticker;
<a name="l00692"></a>00692     <span class="keywordflow">while</span> (ticker) {
<a name="l00693"></a>00693         <span class="keywordflow">if</span> (ticker-&gt;handler==handler) {
<a name="l00694"></a>00694             *tick_where=ticker-&gt;next;
<a name="l00695"></a>00695             <span class="keyword">delete</span> ticker;
<a name="l00696"></a>00696             <span class="keywordflow">return</span>;
<a name="l00697"></a>00697         }
<a name="l00698"></a>00698         tick_where=&amp;ticker-&gt;next;
<a name="l00699"></a>00699         ticker=ticker-&gt;next;
<a name="l00700"></a>00700     }
<a name="l00701"></a>00701 }
<a name="l00702"></a>00702 
<a name="l00703"></a>00703 <span class="keywordtype">void</span> TIMER_AddTickHandler(TIMER_TickHandler handler) {
<a name="l00704"></a>00704     <a class="code" href="structTickerBlock.html">TickerBlock</a> * newticker=<span class="keyword">new</span> <a class="code" href="structTickerBlock.html">TickerBlock</a>;
<a name="l00705"></a>00705     newticker-&gt;next=firstticker;
<a name="l00706"></a>00706     newticker-&gt;handler=handler;
<a name="l00707"></a>00707     firstticker=newticker;
<a name="l00708"></a>00708 }
<a name="l00709"></a>00709 
<a name="l00710"></a>00710 <span class="keyword">extern</span> Bitu time_limit_ms;
<a name="l00711"></a>00711 
<a name="l00712"></a>00712 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> PIC_benchstart = 0;
<a name="l00713"></a>00713 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> PIC_tickstart = 0;
<a name="l00714"></a>00714 
<a name="l00715"></a>00715 <span class="keyword">extern</span> <span class="keywordtype">void</span> GFX_SetTitle(Bit32s cycles, Bits frameskip, Bits timing, <span class="keywordtype">bool</span> paused);
<a name="l00716"></a>00716 <span class="keywordtype">void</span> TIMER_AddTick(<span class="keywordtype">void</span>) {
<a name="l00717"></a>00717     <span class="comment">/* Setup new amount of cycles for PIC */</span>
<a name="l00718"></a>00718     PIC_Ticks++;
<a name="l00719"></a>00719     <span class="keywordflow">if</span> ((PIC_Ticks&amp;0x3fff) == 0) {
<a name="l00720"></a>00720         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ticks = GetTicks();
<a name="l00721"></a>00721         <span class="keywordtype">int</span> delta = (PIC_Ticks-PIC_tickstart)*10000/(ticks-PIC_benchstart)+5;
<a name="l00722"></a>00722         GFX_SetTitle(-1,-1,delta,<span class="keyword">false</span>);
<a name="l00723"></a>00723         PIC_benchstart = ticks;
<a name="l00724"></a>00724         PIC_tickstart = PIC_Ticks;
<a name="l00725"></a>00725     }
<a name="l00726"></a>00726     CPU_CycleLeft += CPU_CycleMax + CPU_Cycles;
<a name="l00727"></a>00727     CPU_Cycles = 0;
<a name="l00728"></a>00728 
<a name="l00729"></a>00729     <span class="comment">/* timeout */</span>
<a name="l00730"></a>00730     <span class="keywordflow">if</span> (time_limit_ms != 0 &amp;&amp; PIC_Ticks &gt;= time_limit_ms)
<a name="l00731"></a>00731         <span class="keywordflow">throw</span> int(1);
<a name="l00732"></a>00732 
<a name="l00733"></a>00733     <span class="comment">/* Go through the list of scheduled events and lower their index with 1000 */</span>
<a name="l00734"></a>00734     <a class="code" href="structPICEntry.html">PICEntry</a> * entry=pic_queue.next_entry;
<a name="l00735"></a>00735     <span class="keywordflow">while</span> (entry) {
<a name="l00736"></a>00736         entry-&gt;index -= 1.0;
<a name="l00737"></a>00737         entry=entry-&gt;next;
<a name="l00738"></a>00738     }
<a name="l00739"></a>00739 
<a name="l00740"></a>00740     <span class="comment">/* Call our list of ticker handlers */</span>
<a name="l00741"></a>00741     <a class="code" href="structTickerBlock.html">TickerBlock</a> * ticker=firstticker;
<a name="l00742"></a>00742     <span class="keywordflow">while</span> (ticker) {
<a name="l00743"></a>00743         <a class="code" href="structTickerBlock.html">TickerBlock</a> * nextticker=ticker-&gt;next;
<a name="l00744"></a>00744         ticker-&gt;handler();
<a name="l00745"></a>00745         ticker=nextticker;
<a name="l00746"></a>00746     }
<a name="l00747"></a>00747 }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749 <span class="keyword">static</span> <a class="code" href="classIO__WriteHandleObject.html">IO_WriteHandleObject</a> PCXT_NMI_WriteHandler;
<a name="l00750"></a>00750 
<a name="l00751"></a>00751 <span class="keyword">static</span> <a class="code" href="classIO__ReadHandleObject.html">IO_ReadHandleObject</a> ReadHandler[4];
<a name="l00752"></a>00752 <span class="keyword">static</span> <a class="code" href="classIO__WriteHandleObject.html">IO_WriteHandleObject</a> WriteHandler[4];
<a name="l00753"></a>00753 
<a name="l00754"></a>00754 <span class="keywordtype">void</span> PIC_Reset(<a class="code" href="classSection.html">Section</a> *sec) {
<a name="l00755"></a>00755     (void)sec;<span class="comment">//UNUSED</span>
<a name="l00756"></a>00756     Bitu i;
<a name="l00757"></a>00757 
<a name="l00758"></a>00758     ReadHandler[0].Uninstall();
<a name="l00759"></a>00759     ReadHandler[1].Uninstall();
<a name="l00760"></a>00760     WriteHandler[0].Uninstall();
<a name="l00761"></a>00761     WriteHandler[1].Uninstall();
<a name="l00762"></a>00762     ReadHandler[2].Uninstall();
<a name="l00763"></a>00763     ReadHandler[3].Uninstall();
<a name="l00764"></a>00764     WriteHandler[2].Uninstall();
<a name="l00765"></a>00765     WriteHandler[3].Uninstall();
<a name="l00766"></a>00766     PCXT_NMI_WriteHandler.Uninstall();
<a name="l00767"></a>00767 
<a name="l00768"></a>00768     <span class="comment">/* NTS: Parsing this on reset allows PIC configuration changes on reboot instead of restarting the entire emulator */</span>
<a name="l00769"></a>00769     <a class="code" href="classSection__prop.html">Section_prop</a> * section=<span class="keyword">static_cast&lt;</span><a class="code" href="classSection__prop.html">Section_prop</a> *<span class="keyword">&gt;</span>(control-&gt;GetSection(<span class="stringliteral">&quot;dosbox&quot;</span>));
<a name="l00770"></a>00770     assert(section != NULL);
<a name="l00771"></a>00771 
<a name="l00772"></a>00772     enable_slave_pic = section-&gt;Get_bool(<span class="stringliteral">&quot;enable slave pic&quot;</span>);
<a name="l00773"></a>00773     enable_pc_xt_nmi_mask = section-&gt;Get_bool(<span class="stringliteral">&quot;enable pc nmi mask&quot;</span>);
<a name="l00774"></a>00774 
<a name="l00775"></a>00775     <span class="comment">/* NTS: This is a good guess. But the 8259 is static circuitry and not driven by a clock.</span>
<a name="l00776"></a>00776 <span class="comment">     *      But the ability to respond to interrupts is limited by the CPU, too. */</span>
<a name="l00777"></a>00777     PIC_irq_delay_ns = 1000000000UL / (<span class="keywordtype">unsigned</span> long)PIT_TICK_RATE;
<a name="l00778"></a>00778     {
<a name="l00779"></a>00779         <span class="keywordtype">int</span> x = section-&gt;Get_int(<span class="stringliteral">&quot;irq delay ns&quot;</span>);
<a name="l00780"></a>00780         <span class="keywordflow">if</span> (x &gt;= 0) PIC_irq_delay_ns = (<span class="keywordtype">unsigned</span> int)x;
<a name="l00781"></a>00781     }
<a name="l00782"></a>00782 
<a name="l00783"></a>00783     <span class="keywordflow">if</span> (enable_slave_pic)
<a name="l00784"></a>00784         master_cascade_irq = IS_PC98_ARCH ? 7 : 2;
<a name="l00785"></a>00785     <span class="keywordflow">else</span>
<a name="l00786"></a>00786         master_cascade_irq = -1;
<a name="l00787"></a>00787 
<a name="l00788"></a>00788     <span class="comment">// LOG</span>
<a name="l00789"></a>00789     <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;PIC_Reset(): reinitializing PIC controller (cascade=%d)&quot;</span>,master_cascade_irq);
<a name="l00790"></a>00790 
<a name="l00791"></a>00791     <span class="comment">/* Setup pic0 and pic1 with initial values like DOS has normally */</span>
<a name="l00792"></a>00792     PIC_Ticks=0;
<a name="l00793"></a>00793     PIC_IRQCheck=0;
<a name="l00794"></a>00794     <span class="keywordflow">for</span> (i=0;i&lt;2;i++) {
<a name="l00795"></a>00795         pics[i].auto_eoi=<span class="keyword">false</span>;
<a name="l00796"></a>00796         pics[i].rotate_on_auto_eoi=<span class="keyword">false</span>;
<a name="l00797"></a>00797         pics[i].request_issr=<span class="keyword">false</span>;
<a name="l00798"></a>00798         pics[i].special=<span class="keyword">false</span>;
<a name="l00799"></a>00799         pics[i].single=<span class="keyword">false</span>;
<a name="l00800"></a>00800         pics[i].icw_index=0;
<a name="l00801"></a>00801         pics[i].icw_words=0;
<a name="l00802"></a>00802         pics[i].irr = pics[i].isr = pics[i].imrr = 0;
<a name="l00803"></a>00803         pics[i].isrr = pics[i].imr = 0xff;
<a name="l00804"></a>00804         pics[i].active_irq = 8;
<a name="l00805"></a>00805     }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807     <span class="comment">/* IBM: IRQ 0-15 is INT 0x08-0x0F, 0x70-0x7F</span>
<a name="l00808"></a>00808 <span class="comment">     * PC-98: IRQ 0-15 is INT 0x08-0x17 */</span>
<a name="l00809"></a>00809     master.vector_base = 0x08;
<a name="l00810"></a>00810     slave.vector_base = IS_PC98_ARCH ? 0x10 : 0x70;
<a name="l00811"></a>00811 
<a name="l00812"></a>00812     <span class="keywordflow">for</span> (Bitu i=0;i &lt; 16;i++)
<a name="l00813"></a>00813         PIC_SetIRQMask(i,<span class="keyword">true</span>);
<a name="l00814"></a>00814 
<a name="l00815"></a>00815     PIC_SetIRQMask(0,<span class="keyword">false</span>);                    <span class="comment">/* Enable system timer */</span>
<a name="l00816"></a>00816     PIC_SetIRQMask(1,<span class="keyword">false</span>);                    <span class="comment">/* Enable system timer */</span>
<a name="l00817"></a>00817     PIC_SetIRQMask(8,<span class="keyword">false</span>);                    <span class="comment">/* Enable RTC IRQ */</span>
<a name="l00818"></a>00818 
<a name="l00819"></a>00819     <span class="keywordflow">if</span> (master_cascade_irq &gt;= 0)
<a name="l00820"></a>00820         PIC_SetIRQMask((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)master_cascade_irq,<span class="keyword">false</span>);<span class="comment">/* Enable second pic */</span>
<a name="l00821"></a>00821 
<a name="l00822"></a>00822     <span class="comment">/* I/O port map</span>
<a name="l00823"></a>00823 <span class="comment">     *</span>
<a name="l00824"></a>00824 <span class="comment">     * IBM PC/XT/AT     NEC PC-98        A0</span>
<a name="l00825"></a>00825 <span class="comment">     * ---------------------------------------</span>
<a name="l00826"></a>00826 <span class="comment">     * 0x20             0x00             0</span>
<a name="l00827"></a>00827 <span class="comment">     * 0x21             0x02             1</span>
<a name="l00828"></a>00828 <span class="comment">     * 0xA0             0x08             0</span>
<a name="l00829"></a>00829 <span class="comment">     * 0xA1             0x0A             1</span>
<a name="l00830"></a>00830 <span class="comment">     */</span>
<a name="l00831"></a>00831 
<a name="l00832"></a>00832     ReadHandler[0].Install(IS_PC98_ARCH ? 0x00 : 0x20,read_command,IO_MB);
<a name="l00833"></a>00833     ReadHandler[1].Install(IS_PC98_ARCH ? 0x02 : 0x21,read_data,IO_MB);
<a name="l00834"></a>00834     WriteHandler[0].Install(IS_PC98_ARCH ? 0x00 : 0x20,write_command,IO_MB);
<a name="l00835"></a>00835     WriteHandler[1].Install(IS_PC98_ARCH ? 0x02 : 0x21,write_data,IO_MB);
<a name="l00836"></a>00836 
<a name="l00837"></a>00837     <span class="comment">/* the secondary slave PIC takes priority over PC/XT NMI mask emulation */</span>
<a name="l00838"></a>00838     <span class="keywordflow">if</span> (enable_slave_pic) {
<a name="l00839"></a>00839         ReadHandler[2].Install(IS_PC98_ARCH ? 0x08 : 0xa0,read_command,IO_MB);
<a name="l00840"></a>00840         ReadHandler[3].Install(IS_PC98_ARCH ? 0x0A : 0xa1,read_data,IO_MB);
<a name="l00841"></a>00841         WriteHandler[2].Install(IS_PC98_ARCH ? 0x08 : 0xa0,write_command,IO_MB);
<a name="l00842"></a>00842         WriteHandler[3].Install(IS_PC98_ARCH ? 0x0A : 0xa1,write_data,IO_MB);
<a name="l00843"></a>00843     }
<a name="l00844"></a>00844     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!IS_PC98_ARCH &amp;&amp; enable_pc_xt_nmi_mask) {
<a name="l00845"></a>00845         PCXT_NMI_WriteHandler.Install(0xa0,pc_xt_nmi_write,IO_MB);
<a name="l00846"></a>00846     }
<a name="l00847"></a>00847 }
<a name="l00848"></a>00848 
<a name="l00849"></a>00849 <span class="keywordtype">void</span> PIC_Destroy(<a class="code" href="classSection.html">Section</a>* sec) {
<a name="l00850"></a>00850     (void)sec;<span class="comment">//UNUSED</span>
<a name="l00851"></a>00851 }
<a name="l00852"></a>00852 
<a name="l00853"></a>00853 <span class="keywordtype">void</span> Init_PIC() {
<a name="l00854"></a>00854     Bitu i;
<a name="l00855"></a>00855 
<a name="l00856"></a>00856     <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;Init_PIC()&quot;</span>);
<a name="l00857"></a>00857 
<a name="l00858"></a>00858     <span class="comment">/* Initialize the pic queue */</span>
<a name="l00859"></a>00859     <span class="keywordflow">for</span> (i=0;i&lt;PIC_QUEUESIZE-1;i++) {
<a name="l00860"></a>00860         pic_queue.entries[i].next=&amp;pic_queue.entries[i+1];
<a name="l00861"></a>00861 
<a name="l00862"></a>00862         <span class="comment">// savestate compatibility</span>
<a name="l00863"></a>00863         pic_queue.entries[i].pic_event = 0;
<a name="l00864"></a>00864     }
<a name="l00865"></a>00865     pic_queue.entries[PIC_QUEUESIZE-1].next=0;
<a name="l00866"></a>00866     pic_queue.free_entry=&amp;pic_queue.entries[0];
<a name="l00867"></a>00867     pic_queue.next_entry=0;
<a name="l00868"></a>00868 
<a name="l00869"></a>00869     AddExitFunction(AddExitFunctionFuncPair(PIC_Destroy));
<a name="l00870"></a>00870     AddVMEventFunction(VM_EVENT_RESET,AddVMEventFunctionFuncPair(PIC_Reset));
<a name="l00871"></a>00871 }
<a name="l00872"></a>00872 
<a name="l00873"></a>00873 <span class="preprocessor">#if C_DEBUG</span>
<a name="l00874"></a>00874 <span class="preprocessor"></span><span class="keywordtype">void</span> DEBUG_LogPIC_C(<a class="code" href="structPIC__Controller.html">PIC_Controller</a> &amp;pic) {
<a name="l00875"></a>00875     LOG_MSG(<span class="stringliteral">&quot;%s interrupt controller state&quot;</span>,&amp;pic == &amp;master ? <span class="stringliteral">&quot;Master&quot;</span> : <span class="stringliteral">&quot;Slave&quot;</span>);
<a name="l00876"></a>00876     LOG_MSG(<span class="stringliteral">&quot;ICW %u/%u special=%u auto-eoi=%u rotate-eoi=%u single=%u request_issr=%u vectorbase=0x%02x active_irq=%u&quot;</span>,
<a name="l00877"></a>00877         (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)pic.icw_index,
<a name="l00878"></a>00878         (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)pic.icw_words,
<a name="l00879"></a>00879         pic.special?1:0,
<a name="l00880"></a>00880         pic.auto_eoi?1:0,
<a name="l00881"></a>00881         pic.rotate_on_auto_eoi?1:0,
<a name="l00882"></a>00882         pic.single?1:0,
<a name="l00883"></a>00883         pic.request_issr?1:0,
<a name="l00884"></a>00884         pic.vector_base,
<a name="l00885"></a>00885         pic.active_irq);
<a name="l00886"></a>00886 
<a name="l00887"></a>00887     LOG_MSG(<span class="stringliteral">&quot;IRQ INT#  Req /Mask/Serv&quot;</span>);
<a name="l00888"></a>00888     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> si=0;si &lt; 8;si++) {
<a name="l00889"></a>00889         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> IRQ = si + (&amp;pic == &amp;slave ? 8 : 0);
<a name="l00890"></a>00890         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> CPUINT = pic.vector_base + si;
<a name="l00891"></a>00891 
<a name="l00892"></a>00892         LOG_MSG(<span class="stringliteral">&quot;%3u 0x%02X   %c    %c    %c   %s&quot;</span>,
<a name="l00893"></a>00893             IRQ,
<a name="l00894"></a>00894             CPUINT,
<a name="l00895"></a>00895             (pic.irr &amp; (1U &lt;&lt; si))?<span class="charliteral">&#39;R&#39;</span>:<span class="charliteral">&#39; &#39;</span>,
<a name="l00896"></a>00896             (pic.imr &amp; (1U &lt;&lt; si))?<span class="charliteral">&#39;M&#39;</span>:<span class="charliteral">&#39; &#39;</span>,
<a name="l00897"></a>00897             (pic.isr &amp; (1U &lt;&lt; si))?<span class="charliteral">&#39;S&#39;</span>:<span class="charliteral">&#39; &#39;</span>,
<a name="l00898"></a>00898             ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)IRQ == (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)master_cascade_irq) ? <span class="stringliteral">&quot;CASCADE&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);
<a name="l00899"></a>00899     }
<a name="l00900"></a>00900 }
<a name="l00901"></a>00901 
<a name="l00902"></a>00902 <span class="keywordtype">void</span> DEBUG_LogPIC(<span class="keywordtype">void</span>) {
<a name="l00903"></a>00903     DEBUG_LogPIC_C(master);
<a name="l00904"></a>00904     <span class="keywordflow">if</span> (enable_slave_pic) DEBUG_LogPIC_C(slave);
<a name="l00905"></a>00905 }
<a name="l00906"></a>00906 <span class="preprocessor">#endif</span>
<a name="l00907"></a>00907 <span class="preprocessor"></span>
<a name="l00908"></a>00908 
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 29 2018 08:09:02 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
