<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/dosbox.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/dosbox.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  Copyright (C) 2002-2019  The DOSBox Team</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  This program is free software; you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment"> *  (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *  This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment"> *  GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment"> *  along with this program; if not, write to the Free Software</span>
<a name="l00016"></a>00016 <span class="comment"> *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">/* NTS: Valgrind hunting shows memory leak from C++ new operator somewhere</span>
<a name="l00020"></a>00020 <span class="comment"> *      with the JACK library indirectly invoked by SDL audio. Can we resolve</span>
<a name="l00021"></a>00021 <span class="comment"> *      that too eventually? */</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/* NTS: Valgrind hunting also shows one of the section INIT functions (I can&#39;t</span>
<a name="l00024"></a>00024 <span class="comment"> *      yet tell which one because the stack trace doesn&#39;t show it) is allocating</span>
<a name="l00025"></a>00025 <span class="comment"> *      something and is not freeing it. */</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">/* NTS: Valgrind hunting has a moderate to high signal-to-noise ratio because</span>
<a name="l00028"></a>00028 <span class="comment"> *      of memory leaks (lazy memory allocation) from other libraries in the</span>
<a name="l00029"></a>00029 <span class="comment"> *      system, including:</span>
<a name="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031"></a>00031 <span class="comment"> *         ncurses</span>
<a name="l00032"></a>00032 <span class="comment"> *         libSDL</span>
<a name="l00033"></a>00033 <span class="comment"> *         libX11 and libXCB</span>
<a name="l00034"></a>00034 <span class="comment"> *         libasound (ALSA sound library)</span>
<a name="l00035"></a>00035 <span class="comment"> *         PulseAudio library calls</span>
<a name="l00036"></a>00036 <span class="comment"> *         JACK library calls</span>
<a name="l00037"></a>00037 <span class="comment"> *         libdl (the dlopen/dlclose functions allocate something and never free it)</span>
<a name="l00038"></a>00038 <span class="comment"> *         and a whole bunch of unidentified malloc calls without a matching free.</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> *      On my dev system, a reported leak of 450KB (77KB possibly lost + 384KB still reachable</span>
<a name="l00041"></a>00041 <span class="comment"> *      according to Valgrind) is normal.</span>
<a name="l00042"></a>00042 <span class="comment"> *</span>
<a name="l00043"></a>00043 <span class="comment"> *      Now you ask: why do I care so much about Valgrind, memory leaks, and cleaning</span>
<a name="l00044"></a>00044 <span class="comment"> *      up the code? The less spurious memory leaks, the easier it is to identify</span>
<a name="l00045"></a>00045 <span class="comment"> *      actual leaks among the noise and to patch them up. Thus, &quot;valgrind hunting&quot; --J.C. */</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;ctime&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;dosbox.h&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;debug.h&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;video.h&quot;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &quot;pic.h&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;ide.h&quot;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &quot;callback.h&quot;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &quot;inout.h&quot;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;mixer.h&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;timer.h&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;dos_inc.h&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &quot;setup.h&quot;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &quot;control.h&quot;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &quot;cross.h&quot;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &quot;programs.h&quot;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &quot;support.h&quot;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &quot;mapper.h&quot;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &quot;ints/int10.h&quot;</span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &quot;menu.h&quot;</span>
<a name="l00073"></a>00073 <span class="preprocessor">#include &quot;render.h&quot;</span>
<a name="l00074"></a>00074 <span class="preprocessor">#include &quot;pci_bus.h&quot;</span>
<a name="l00075"></a>00075 <span class="preprocessor">#include &quot;parport.h&quot;</span>
<a name="l00076"></a>00076 <span class="preprocessor">#include &quot;clockdomain.h&quot;</span>
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="preprocessor">#if C_EMSCRIPTEN</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor"># include &lt;emscripten.h&gt;</span>
<a name="l00080"></a>00080 <span class="preprocessor">#endif</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>
<a name="l00082"></a>00082 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#define WIN32_LEAN_AND_MEAN</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor">#include &lt;windows.h&gt;</span>
<a name="l00085"></a>00085 <span class="preprocessor">#endif</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>
<a name="l00087"></a>00087 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="comment">/*===================================TODO: Move to it&#39;s own file==============================*/</span>
<a name="l00090"></a>00090 <span class="preprocessor">#if defined(__SSE__) &amp;&amp; !defined(_M_AMD64)</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="keywordtype">bool</span> sse2_available = <span class="keyword">false</span>;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="preprocessor"># ifdef __GNUC__</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">#  define cpuid(func,ax,bx,cx,dx)\</span>
<a name="l00095"></a>00095 <span class="preprocessor">    __asm__ __volatile__ (&quot;cpuid&quot;:\</span>
<a name="l00096"></a>00096 <span class="preprocessor">    &quot;=a&quot; (ax), &quot;=b&quot; (bx), &quot;=c&quot; (cx), &quot;=d&quot; (dx) : &quot;a&quot; (func));</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor"># endif </span><span class="comment">/* __GNUC__ */</span>
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="preprocessor"># if defined(_MSC_VER)</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">#  define cpuid(func,a,b,c,d)\</span>
<a name="l00101"></a>00101 <span class="preprocessor">    __asm mov eax, func\</span>
<a name="l00102"></a>00102 <span class="preprocessor">    __asm cpuid\</span>
<a name="l00103"></a>00103 <span class="preprocessor">    __asm mov a, eax\</span>
<a name="l00104"></a>00104 <span class="preprocessor">    __asm mov b, ebx\</span>
<a name="l00105"></a>00105 <span class="preprocessor">    __asm mov c, ecx\</span>
<a name="l00106"></a>00106 <span class="preprocessor">    __asm mov d, edx</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor"># endif </span><span class="comment">/* _MSC_VER */</span>
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="keywordtype">void</span> CheckSSESupport()
<a name="l00110"></a>00110 {
<a name="l00111"></a>00111 <span class="preprocessor">#if (defined (__GNUC__) || (_MSC_VER)) &amp;&amp; !defined(EMSCRIPTEN)</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>    Bitu a, b, c, d;
<a name="l00113"></a>00113     cpuid(1, a, b, c, d);
<a name="l00114"></a>00114     sse2_available = ((d &gt;&gt; 26) &amp; 1)?<span class="keyword">true</span>:<span class="keyword">false</span>;
<a name="l00115"></a>00115 <span class="preprocessor">#endif</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span>}
<a name="l00117"></a>00117 <span class="preprocessor">#endif</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="comment">/*=============================================================================*/</span>
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="keyword">extern</span> <span class="keywordtype">void</span>         GFX_SetTitle(Bit32s cycles,Bits frameskip,Bits timing,<span class="keywordtype">bool</span> paused);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keyword">extern</span> Bitu         frames;
<a name="l00123"></a>00123 <span class="keyword">extern</span> Bitu         cycle_count;
<a name="l00124"></a>00124 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         sse2_available;
<a name="l00125"></a>00125 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         dynamic_dos_kernel_alloc;
<a name="l00126"></a>00126 <span class="keyword">extern</span> Bitu         DOS_PRIVATE_SEGMENT_Size;
<a name="l00127"></a>00127 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         VGA_BIOS_dont_duplicate_CGA_first_half;
<a name="l00128"></a>00128 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         VIDEO_BIOS_always_carry_14_high_font;
<a name="l00129"></a>00129 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         VIDEO_BIOS_always_carry_16_high_font;
<a name="l00130"></a>00130 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         VIDEO_BIOS_enable_CGA_8x8_second_half;
<a name="l00131"></a>00131 <span class="keyword">extern</span> <span class="keywordtype">bool</span>         allow_more_than_640kb;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 Bit32u              guest_msdos_LoL = 0;
<a name="l00134"></a>00134 Bit16u              guest_msdos_mcb_chain = 0;
<a name="l00135"></a>00135 <span class="keywordtype">int</span>                 boothax = BOOTHAX_NONE;
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <span class="keywordtype">bool</span>                want_fm_towns = <span class="keyword">false</span>;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="keywordtype">bool</span>                dos_con_use_int16_to_detect_input = <span class="keyword">true</span>;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="keywordtype">bool</span>                dbg_zero_on_dos_allocmem = <span class="keyword">true</span>;
<a name="l00142"></a>00142 <span class="keywordtype">bool</span>                dbg_zero_on_xms_allocmem = <span class="keyword">true</span>;
<a name="l00143"></a>00143 <span class="keywordtype">bool</span>                dbg_zero_on_ems_allocmem = <span class="keyword">true</span>;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="comment">/* the exact frequency of the NTSC color subcarrier ~3.579545454...MHz or 315/88 */</span>
<a name="l00146"></a>00146 <span class="comment">/* see: http://en.wikipedia.org/wiki/Colorburst */</span>
<a name="l00147"></a>00147 <span class="preprocessor">#define             NTSC_COLOR_SUBCARRIER_NUM       (315000000ULL)</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span><span class="preprocessor">#define             NTSC_COLOR_SUBCARRIER_DEN       (88ULL)</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span>
<a name="l00150"></a>00150 <span class="comment">/* PCI bus clock</span>
<a name="l00151"></a>00151 <span class="comment"> * Usual setting: 100MHz / 3 = 33.333MHz</span>
<a name="l00152"></a>00152 <span class="comment"> *                 90MHz / 3 = 30.000MHz */</span>
<a name="l00153"></a>00153 <a class="code" href="classClockDomain.html">ClockDomain</a>         clockdom_PCI_BCLK(100000000,3);     <span class="comment">/* MASTER 100MHz / 3 = 33.33333MHz */</span>
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="comment">/* ISA bus OSC clock (14.31818MHz), using a crystal that is 4x the NTSC subcarrier frequency 3.5795454..MHz */</span>
<a name="l00156"></a>00156 <a class="code" href="classClockDomain.html">ClockDomain</a>         clockdom_ISA_OSC(NTSC_COLOR_SUBCARRIER_NUM*4,NTSC_COLOR_SUBCARRIER_DEN);
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="comment">/* ISA bus clock (varies between 4.77MHz to 8.333MHz)</span>
<a name="l00159"></a>00159 <span class="comment"> * PC/XT: ISA oscillator clock (14.31818MHz / 3) = 4.77MHz</span>
<a name="l00160"></a>00160 <span class="comment"> * Some systems keep CPU synchronous to bus clock: 4.77MHz, 6MHz, 8MHz, 8.333MHz</span>
<a name="l00161"></a>00161 <span class="comment"> * Later systems: 25MHz / 3 = 8.333MHz</span>
<a name="l00162"></a>00162 <span class="comment"> *                33MHz / 4 = 8.333MHz</span>
<a name="l00163"></a>00163 <span class="comment"> * PCI bus systems: PCI bus clock 33MHz / 4 = 8.333MHz (especially Intel chipsets according to PIIX datasheets) */</span>
<a name="l00164"></a>00164 <a class="code" href="classClockDomain.html">ClockDomain</a>         clockdom_ISA_BCLK(25000000,3);      <span class="comment">/* MASTER 25000000Hz / 3 = 8.333333MHz */</span>
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 <a class="code" href="classConfig.html">Config</a>*             control;
<a name="l00167"></a>00167 MachineType         machine;
<a name="l00168"></a>00168 <span class="keywordtype">bool</span>                PS1AudioCard;       <span class="comment">// Perhaps have PS1 as a machine type...?</span>
<a name="l00169"></a>00169 SVGACards           svgaCard;
<a name="l00170"></a>00170 <span class="keywordtype">bool</span>                SDLNetInited;
<a name="l00171"></a>00171 Bit32s              ticksDone;
<a name="l00172"></a>00172 Bit32u              ticksScheduled;
<a name="l00173"></a>00173 <span class="keywordtype">bool</span>                ticksLocked;
<a name="l00174"></a>00174 <span class="keywordtype">bool</span>                mono_cga=<span class="keyword">false</span>;
<a name="l00175"></a>00175 <span class="keywordtype">bool</span>                ignore_opcode_63 = <span class="keyword">true</span>;
<a name="l00176"></a>00176 <span class="keywordtype">int</span>             dynamic_core_cache_block_size = 32;
<a name="l00177"></a>00177 Bitu                VGA_BIOS_Size_override = 0;
<a name="l00178"></a>00178 Bitu                VGA_BIOS_SEG = 0xC000;
<a name="l00179"></a>00179 Bitu                VGA_BIOS_SEG_END = 0xC800;
<a name="l00180"></a>00180 Bitu                VGA_BIOS_Size = 0x8000;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 Bit32u                  emulator_speed = 100;
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="keyword">static</span> Bit32u           ticksRemain;
<a name="l00185"></a>00185 <span class="keyword">static</span> Bit32u           ticksRemainSpeedFrac;
<a name="l00186"></a>00186 <span class="keyword">static</span> Bit32u           ticksLast;
<a name="l00187"></a>00187 <span class="keyword">static</span> Bit32u           ticksLastFramecounter;
<a name="l00188"></a>00188 <span class="keyword">static</span> Bit32u           ticksLastRTcounter;
<a name="l00189"></a>00189 <span class="keyword">static</span> <span class="keywordtype">double</span>           ticksLastRTtime;
<a name="l00190"></a>00190 <span class="keyword">static</span> Bit32u           ticksAdded;
<a name="l00191"></a>00191 <span class="keyword">static</span> Bit32u           <a class="code" href="namespaceGUI.html#af396fee5d5c26b98218f5803f85e3b65" title="A type which holds a number of timer ticks.">Ticks</a> = 0;
<a name="l00192"></a>00192 <span class="keyword">extern</span> <span class="keywordtype">double</span>           rtdelta;
<a name="l00193"></a>00193 <span class="keyword">static</span> LoopHandler*     loop;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 <span class="comment">/* The whole load of startups for all the subfunctions */</span>
<a name="l00196"></a>00196 <span class="keywordtype">void</span>                MEM_Init(<a class="code" href="classSection.html">Section</a> *);
<a name="l00197"></a>00197 <span class="keywordtype">void</span>                ISAPNP_Cfg_Init(<a class="code" href="classSection.html">Section</a> *);
<a name="l00198"></a>00198 <span class="keywordtype">void</span>                ROMBIOS_Init(<a class="code" href="classSection.html">Section</a> *);
<a name="l00199"></a>00199 <span class="keywordtype">void</span>                CALLBACK_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00200"></a>00200 <span class="keywordtype">void</span>                PROGRAMS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00201"></a>00201 <span class="keywordtype">void</span>                RENDER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00202"></a>00202 <span class="keywordtype">void</span>                VGA_VsyncInit(<a class="code" href="classSection.html">Section</a>*);
<a name="l00203"></a>00203 <span class="keywordtype">void</span>                VGA_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00204"></a>00204 <span class="keywordtype">void</span>                DOS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00205"></a>00205 <span class="keywordtype">void</span>                CPU_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00206"></a>00206 <span class="preprocessor">#if C_FPU</span>
<a name="l00207"></a>00207 <span class="preprocessor"></span><span class="keywordtype">void</span>                FPU_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00208"></a>00208 <span class="preprocessor">#endif</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span><span class="keywordtype">void</span>                DMA_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00210"></a>00210 <span class="keywordtype">void</span>                MIXER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00211"></a>00211 <span class="keywordtype">void</span>                MIDI_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00212"></a>00212 <span class="keywordtype">void</span>                HARDWARE_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00213"></a>00213 <span class="keywordtype">void</span>                PCIBUS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00214"></a>00214 <span class="keywordtype">void</span>                PCI_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00215"></a>00215 <span class="keywordtype">void</span>                VOODOO_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="keywordtype">void</span>                IDE_Primary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00218"></a>00218 <span class="keywordtype">void</span>                IDE_Secondary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00219"></a>00219 <span class="keywordtype">void</span>                IDE_Tertiary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00220"></a>00220 <span class="keywordtype">void</span>                IDE_Quaternary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00221"></a>00221 <span class="keywordtype">void</span>                IDE_Quinternary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00222"></a>00222 <span class="keywordtype">void</span>                IDE_Sexternary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00223"></a>00223 <span class="keywordtype">void</span>                IDE_Septernary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00224"></a>00224 <span class="keywordtype">void</span>                IDE_Octernary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 <span class="keywordtype">void</span>                FDC_Primary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="keywordtype">void</span>                KEYBOARD_Init(<a class="code" href="classSection.html">Section</a>*);    <span class="comment">//TODO This should setup INT 16 too but ok ;)</span>
<a name="l00229"></a>00229 <span class="keywordtype">void</span>                JOYSTICK_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00230"></a>00230 <span class="keywordtype">void</span>                MOUSE_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00231"></a>00231 <span class="keywordtype">void</span>                SBLASTER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00232"></a>00232 <span class="keywordtype">void</span>                GUS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00233"></a>00233 <span class="keywordtype">void</span>                MPU401_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00234"></a>00234 <span class="keywordtype">void</span>                PCSPEAKER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00235"></a>00235 <span class="keywordtype">void</span>                TANDYSOUND_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00236"></a>00236 <span class="keywordtype">void</span>                DISNEY_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00237"></a>00237 <span class="keywordtype">void</span>                PS1SOUND_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00238"></a>00238 <span class="keywordtype">void</span>                INNOVA_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00239"></a>00239 <span class="keywordtype">void</span>                SERIAL_Init(<a class="code" href="classSection.html">Section</a>*); 
<a name="l00240"></a>00240 <span class="keywordtype">void</span>                DONGLE_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00241"></a>00241 <span class="preprocessor">#if C_IPX</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span><span class="keywordtype">void</span>                IPX_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00243"></a>00243 <span class="preprocessor">#endif</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span><span class="keywordtype">void</span>                PIC_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00245"></a>00245 <span class="keywordtype">void</span>                TIMER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00246"></a>00246 <span class="keywordtype">void</span>                BIOS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00247"></a>00247 <span class="keywordtype">void</span>                DEBUG_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00248"></a>00248 <span class="keywordtype">void</span>                CMOS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00249"></a>00249 <span class="keywordtype">void</span>                MSCDEX_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00250"></a>00250 <span class="keywordtype">void</span>                DRIVES_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00251"></a>00251 <span class="keywordtype">void</span>                CDROM_Image_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00252"></a>00252 <span class="keywordtype">void</span>                EMS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00253"></a>00253 <span class="keywordtype">void</span>                XMS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00254"></a>00254 <span class="keywordtype">void</span>                DOS_KeyboardLayout_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00255"></a>00255 <span class="keywordtype">void</span>                AUTOEXEC_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00256"></a>00256 <span class="keywordtype">void</span>                INT10_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00257"></a>00257 <span class="preprocessor">#if C_PRINTER</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span><span class="keywordtype">void</span>                PRINTER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00259"></a>00259 <span class="preprocessor">#endif</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>
<a name="l00261"></a>00261 <span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> time_to_clockdom(<a class="code" href="classClockDomain.html">ClockDomain</a> &amp;src,<span class="keywordtype">double</span> t) {
<a name="l00262"></a>00262     <span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> lt = (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)t;
<a name="l00263"></a>00263 
<a name="l00264"></a>00264     lt *= (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)src.freq;
<a name="l00265"></a>00265     lt /= (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)src.freq_div;
<a name="l00266"></a>00266     <span class="keywordflow">return</span> lt;
<a name="l00267"></a>00267 }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> update_clockdom_from_now(<a class="code" href="classClockDomain.html">ClockDomain</a> &amp;dst) {
<a name="l00270"></a>00270     <span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> s;
<a name="l00271"></a>00271 
<a name="l00272"></a>00272     <span class="comment">/* PIC_Ticks (if I read the code correctly) is millisecond ticks, units of 1/1000 seconds.</span>
<a name="l00273"></a>00273 <span class="comment">     * PIC_TickIndexND() units of submillisecond time in units of 1/CPU_CycleMax. */</span>
<a name="l00274"></a>00274     s  = (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)PIC_Ticks * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)dst.freq);
<a name="l00275"></a>00275     s += (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)(((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)PIC_TickIndexND() * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)dst.freq) / (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)CPU_CycleMax);
<a name="l00276"></a>00276     <span class="comment">/* convert down to frequency counts, not freq x 1000 */</span>
<a name="l00277"></a>00277     s /= (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)(1000ULL * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)dst.freq_div);
<a name="l00278"></a>00278 
<a name="l00279"></a>00279     <span class="comment">/* guard against time going backwards slightly (as PIC_TickIndexND() will do sometimes by tiny amounts) */</span>
<a name="l00280"></a>00280     <span class="keywordflow">if</span> (dst.counter &lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)s) dst.counter = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)s;
<a name="l00281"></a>00281 
<a name="l00282"></a>00282     <span class="keywordflow">return</span> dst.counter;
<a name="l00283"></a>00283 }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 <span class="preprocessor">#include &quot;paging.h&quot;</span>
<a name="l00286"></a>00286 
<a name="l00287"></a>00287 <span class="keyword">extern</span> <span class="keywordtype">bool</span> rom_bios_vptable_enable;
<a name="l00288"></a>00288 <span class="keyword">extern</span> <span class="keywordtype">bool</span> rom_bios_8x8_cga_font;
<a name="l00289"></a>00289 <span class="keyword">extern</span> <span class="keywordtype">bool</span> allow_port_92_reset;
<a name="l00290"></a>00290 <span class="keyword">extern</span> <span class="keywordtype">bool</span> allow_keyb_reset;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="keyword">extern</span> <span class="keywordtype">bool</span> DOSBox_Paused();
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 <span class="comment">//#define DEBUG_CYCLE_OVERRUN_CALLBACK</span>
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="comment">//For trying other delays</span>
<a name="l00297"></a>00297 <span class="preprocessor">#define wrap_delay(a) SDL_Delay(a)</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span>
<a name="l00299"></a>00299 <span class="keyword">static</span> Bitu Normal_Loop(<span class="keywordtype">void</span>) {
<a name="l00300"></a>00300     <span class="keyword">static</span> Bit32s lastsleepDone = -1;
<a name="l00301"></a>00301     <span class="keyword">static</span> Bitu sleep1count = 0;
<a name="l00302"></a>00302     
<a name="l00303"></a>00303     <span class="keywordtype">bool</span> saved_allow = dosbox_allow_nonrecursive_page_fault;
<a name="l00304"></a>00304     Bit32u ticksNew;
<a name="l00305"></a>00305     Bits ret;
<a name="l00306"></a>00306 
<a name="l00307"></a>00307     <span class="keywordflow">if</span> (!menu.hidecycles || menu.showrt) { <span class="comment">/* sdlmain.cpp/render.cpp doesn&#39;t even maintain the frames count when hiding cycles! */</span>
<a name="l00308"></a>00308         ticksNew = GetTicks();
<a name="l00309"></a>00309         <span class="keywordflow">if</span> (ticksNew &gt;= <a class="code" href="namespaceGUI.html#af396fee5d5c26b98218f5803f85e3b65" title="A type which holds a number of timer ticks.">Ticks</a>) {
<a name="l00310"></a>00310             Bit32u interval = ticksNew - ticksLastFramecounter;
<a name="l00311"></a>00311             <span class="keywordtype">double</span> rtnow = PIC_FullIndex();
<a name="l00312"></a>00312 
<a name="l00313"></a>00313             <span class="keywordflow">if</span> (interval == 0) interval = 1; <span class="comment">// avoid divide by zero</span>
<a name="l00314"></a>00314 
<a name="l00315"></a>00315             rtdelta = rtnow - ticksLastRTtime;
<a name="l00316"></a>00316             rtdelta = (rtdelta * 1000) / interval;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318             ticksLastRTtime = rtnow;
<a name="l00319"></a>00319             ticksLastFramecounter = <a class="code" href="namespaceGUI.html#af396fee5d5c26b98218f5803f85e3b65" title="A type which holds a number of timer ticks.">Ticks</a>;
<a name="l00320"></a>00320             <a class="code" href="namespaceGUI.html#af396fee5d5c26b98218f5803f85e3b65" title="A type which holds a number of timer ticks.">Ticks</a> = ticksNew + 500;     <span class="comment">// next update in 500ms</span>
<a name="l00321"></a>00321             frames = (frames * 1000) / interval; <span class="comment">// compensate for interval, be more exact (FIXME: so can we adjust for fractional frame rates)</span>
<a name="l00322"></a>00322             GFX_SetTitle((Bit32s)CPU_CycleMax,-1,-1,<span class="keyword">false</span>);
<a name="l00323"></a>00323             frames = 0;
<a name="l00324"></a>00324         }
<a name="l00325"></a>00325     }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327     <span class="keywordflow">try</span> {
<a name="l00328"></a>00328         <span class="keywordflow">while</span> (1) {
<a name="l00329"></a>00329             <span class="keywordflow">if</span> (PIC_RunQueue()) {
<a name="l00330"></a>00330                 <span class="comment">/* now is the time to check for the NMI (Non-maskable interrupt) */</span>
<a name="l00331"></a>00331                 CPU_Check_NMI();
<a name="l00332"></a>00332 
<a name="l00333"></a>00333                 saved_allow = dosbox_allow_nonrecursive_page_fault;
<a name="l00334"></a>00334                 dosbox_allow_nonrecursive_page_fault = <span class="keyword">true</span>;
<a name="l00335"></a>00335                 ret = (*cpudecoder)();
<a name="l00336"></a>00336                 dosbox_allow_nonrecursive_page_fault = saved_allow;
<a name="l00337"></a>00337 
<a name="l00338"></a>00338                 <span class="keywordflow">if</span> (GCC_UNLIKELY(ret&lt;0))
<a name="l00339"></a>00339                     <span class="keywordflow">return</span> 1;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341                 <span class="keywordflow">if</span> (ret&gt;0) {
<a name="l00342"></a>00342                     <span class="keywordflow">if</span> (GCC_UNLIKELY((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)ret &gt;= CB_MAX))
<a name="l00343"></a>00343                         <span class="keywordflow">return</span> 0;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345                     <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> last_callback;
<a name="l00346"></a>00346                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_last_callback = last_callback;
<a name="l00347"></a>00347                     last_callback = (<span class="keywordtype">unsigned</span> int)ret;
<a name="l00348"></a>00348 
<a name="l00349"></a>00349                     dosbox_allow_nonrecursive_page_fault = <span class="keyword">false</span>;
<a name="l00350"></a>00350                     Bitu blah = (*CallBack_Handlers[ret])();
<a name="l00351"></a>00351                     dosbox_allow_nonrecursive_page_fault = saved_allow;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353                     last_callback = p_last_callback;
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 <span class="preprocessor">#ifdef DEBUG_CYCLE_OVERRUN_CALLBACK</span>
<a name="l00356"></a>00356 <span class="preprocessor"></span>                    {
<a name="l00357"></a>00357                         <span class="keyword">extern</span> <span class="keywordtype">char</span>* CallBack_Description[CB_MAX];
<a name="l00358"></a>00358 
<a name="l00359"></a>00359                         <span class="comment">/* I/O delay can cause negative CPU_Cycles and PIC event / audio rendering issues */</span>
<a name="l00360"></a>00360                         cpu_cycles_count_t overrun = -std::min(CPU_Cycles,(cpu_cycles_count_t)0);
<a name="l00361"></a>00361 
<a name="l00362"></a>00362                         <span class="keywordflow">if</span> (overrun &gt; (CPU_CycleMax/100))
<a name="l00363"></a>00363                             LOG_MSG(<span class="stringliteral">&quot;Normal loop: CPU cycles count overrun by %ld (%.3fms) after callback &#39;%s&#39;\n&quot;</span>,(<span class="keywordtype">signed</span> <span class="keywordtype">long</span>)overrun,(<span class="keywordtype">double</span>)overrun / CPU_CycleMax,CallBack_Description[ret]);
<a name="l00364"></a>00364                     }
<a name="l00365"></a>00365 <span class="preprocessor">#endif</span>
<a name="l00366"></a>00366 <span class="preprocessor"></span>
<a name="l00367"></a>00367                     <span class="keywordflow">if</span> (GCC_UNLIKELY(blah &gt; 0U))
<a name="l00368"></a>00368                         <span class="keywordflow">return</span> blah;
<a name="l00369"></a>00369                 }
<a name="l00370"></a>00370 <span class="preprocessor">#if C_DEBUG</span>
<a name="l00371"></a>00371 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (DEBUG_ExitLoop())
<a name="l00372"></a>00372                     <span class="keywordflow">return</span> 0;
<a name="l00373"></a>00373 <span class="preprocessor">#endif</span>
<a name="l00374"></a>00374 <span class="preprocessor"></span>            } <span class="keywordflow">else</span> {
<a name="l00375"></a>00375                 GFX_Events();
<a name="l00376"></a>00376                 <span class="keywordflow">if</span> (DOSBox_Paused() == <span class="keyword">false</span> &amp;&amp; ticksRemain &gt; 0) {
<a name="l00377"></a>00377                     TIMER_AddTick();
<a name="l00378"></a>00378                     ticksRemain--;
<a name="l00379"></a>00379                 } <span class="keywordflow">else</span> {
<a name="l00380"></a>00380                     <span class="keywordflow">goto</span> increaseticks;
<a name="l00381"></a>00381                 }
<a name="l00382"></a>00382             }
<a name="l00383"></a>00383         }
<a name="l00384"></a>00384 increaseticks:
<a name="l00385"></a>00385         <span class="keywordflow">if</span> (GCC_UNLIKELY(ticksLocked)) {
<a name="l00386"></a>00386             ticksRemainSpeedFrac=0;
<a name="l00387"></a>00387             ticksRemain=5;
<a name="l00388"></a>00388             <span class="comment">/* Reset any auto cycle guessing for this frame */</span>
<a name="l00389"></a>00389             ticksLast = GetTicks();
<a name="l00390"></a>00390             ticksAdded = 0;
<a name="l00391"></a>00391             ticksDone = 0;
<a name="l00392"></a>00392             ticksScheduled = 0;
<a name="l00393"></a>00393         } <span class="keywordflow">else</span> {
<a name="l00394"></a>00394             ticksNew=GetTicks();
<a name="l00395"></a>00395             ticksScheduled += ticksAdded;
<a name="l00396"></a>00396             <span class="keywordflow">if</span> (ticksNew &gt; ticksLast) {
<a name="l00397"></a>00397                 ticksRemain = ticksNew-ticksLast;
<a name="l00398"></a>00398 
<a name="l00399"></a>00399                 <span class="keywordflow">if</span> (emulator_speed != 100u) {
<a name="l00400"></a>00400                     ticksRemain *= emulator_speed;
<a name="l00401"></a>00401                     ticksRemain += ticksRemainSpeedFrac;
<a name="l00402"></a>00402                     ticksRemainSpeedFrac = ticksRemain % 100u;
<a name="l00403"></a>00403                     ticksRemain /= 100u;
<a name="l00404"></a>00404                 }
<a name="l00405"></a>00405                 <span class="keywordflow">else</span> {
<a name="l00406"></a>00406                     ticksRemainSpeedFrac=0;
<a name="l00407"></a>00407                 }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409                 ticksLast = ticksNew;
<a name="l00410"></a>00410                 ticksDone += (Bit32s)ticksRemain;
<a name="l00411"></a>00411                 <span class="keywordflow">if</span> ( ticksRemain &gt; 20 ) {
<a name="l00412"></a>00412                     ticksRemain = 20;
<a name="l00413"></a>00413                 }
<a name="l00414"></a>00414                 ticksAdded = ticksRemain;
<a name="l00415"></a>00415                 <span class="keywordflow">if</span> (CPU_CycleAutoAdjust &amp;&amp; !CPU_SkipCycleAutoAdjust) {
<a name="l00416"></a>00416                     <span class="keywordflow">if</span> (ticksScheduled &gt;= 250 || ticksDone &gt;= 250 || (ticksAdded &gt; 15 &amp;&amp; ticksScheduled &gt;= 5) ) {
<a name="l00417"></a>00417                         <span class="keywordflow">if</span>(ticksDone &lt; 1) ticksDone = 1; <span class="comment">// Protect against div by zero</span>
<a name="l00418"></a>00418                         <span class="comment">/* ratio we are aiming for is around 90% usage*/</span>
<a name="l00419"></a>00419                         Bit32s ratio = (Bit32s)(((Bitu)ticksScheduled * ((Bitu)CPU_CyclePercUsed*90*1024/100/100)) / (Bitu)ticksDone);
<a name="l00420"></a>00420                         Bit32s new_cmax = (Bit32s)CPU_CycleMax;
<a name="l00421"></a>00421                         Bit64s cproc = (Bit64s)CPU_CycleMax * (Bit64s)ticksScheduled;
<a name="l00422"></a>00422                         <span class="keywordtype">double</span> ratioremoved = 0.0; <span class="comment">//increase scope for logging</span>
<a name="l00423"></a>00423                         <span class="keywordflow">if</span> (cproc &gt; 0) {
<a name="l00424"></a>00424                             <span class="comment">/* ignore the cycles added due to the IO delay code in order</span>
<a name="l00425"></a>00425 <span class="comment">                               to have smoother auto cycle adjustments */</span>
<a name="l00426"></a>00426                             ratioremoved = (double) CPU_IODelayRemoved / (<span class="keywordtype">double</span>) cproc;
<a name="l00427"></a>00427                             <span class="keywordflow">if</span> (ratioremoved &lt; 1.0) {
<a name="l00428"></a>00428                                 <span class="keywordtype">double</span> ratio_not_removed = 1 - ratioremoved;
<a name="l00429"></a>00429                                 ratio = (Bit32s)((<span class="keywordtype">double</span>)ratio * ratio_not_removed);
<a name="l00430"></a>00430 
<a name="l00431"></a>00431                                 <span class="comment">/* Don&#39;t allow very high ratio which can cause us to lock as we don&#39;t scale down</span>
<a name="l00432"></a>00432 <span class="comment">                                 * for very low ratios. High ratio might result because of timing resolution */</span>
<a name="l00433"></a>00433                                 <span class="keywordflow">if</span> (ticksScheduled &gt;= 250 &amp;&amp; ticksDone &lt; 10 &amp;&amp; ratio &gt; 16384)
<a name="l00434"></a>00434                                     ratio = 16384;
<a name="l00435"></a>00435 
<a name="l00436"></a>00436                                 <span class="comment">// Limit the ratio even more when the cycles are already way above the realmode default.</span>
<a name="l00437"></a>00437                                 <span class="keywordflow">if</span> (ticksScheduled &gt;= 250 &amp;&amp; ticksDone &lt; 10 &amp;&amp; ratio &gt; 5120 &amp;&amp; CPU_CycleMax &gt; 50000)
<a name="l00438"></a>00438                                     ratio = 5120;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440                                 <span class="comment">// When downscaling multiple times in a row, ensure a minimum amount of downscaling</span>
<a name="l00441"></a>00441                                 <span class="keywordflow">if</span> (ticksAdded &gt; 15 &amp;&amp; ticksScheduled &gt;= 5 &amp;&amp; ticksScheduled &lt;= 20 &amp;&amp; ratio &gt; 800)
<a name="l00442"></a>00442                                     ratio = 800;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444                                 <span class="keywordflow">if</span> (ratio &lt;= 1024) {
<a name="l00445"></a>00445                                     <span class="comment">// ratio_not_removed = 1.0; //enabling this restores the old formula</span>
<a name="l00446"></a>00446                                     <span class="keywordtype">double</span> r = (1.0 + ratio_not_removed) /(ratio_not_removed + 1024.0/(static_cast&lt;double&gt;(ratio)));
<a name="l00447"></a>00447                                     new_cmax = 1 + <span class="keyword">static_cast&lt;</span>Bit32s<span class="keyword">&gt;</span>(CPU_CycleMax * r);
<a name="l00448"></a>00448                                 } <span class="keywordflow">else</span> {
<a name="l00449"></a>00449                                     Bit64s ratio_with_removed = (Bit64s) ((((<span class="keywordtype">double</span>)ratio - 1024.0) * ratio_not_removed) + 1024.0);
<a name="l00450"></a>00450                                     Bit64s cmax_scaled = (Bit64s)CPU_CycleMax * ratio_with_removed;
<a name="l00451"></a>00451                                     new_cmax = (Bit32s)(1 + (CPU_CycleMax &gt;&gt; 1) + cmax_scaled / (Bit64s)2048);
<a name="l00452"></a>00452                                 }
<a name="l00453"></a>00453                             }
<a name="l00454"></a>00454                         }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456                         <span class="keywordflow">if</span> (new_cmax&lt;CPU_CYCLES_LOWER_LIMIT)
<a name="l00457"></a>00457                             new_cmax=CPU_CYCLES_LOWER_LIMIT;
<a name="l00458"></a>00458 
<a name="l00459"></a>00459                         <span class="comment">/*</span>
<a name="l00460"></a>00460 <span class="comment">                           LOG_MSG(&quot;cyclelog: current %6d   cmax %6d   ratio  %5d  done %3d   sched %3d&quot;,</span>
<a name="l00461"></a>00461 <span class="comment">                           CPU_CycleMax,</span>
<a name="l00462"></a>00462 <span class="comment">                           new_cmax,</span>
<a name="l00463"></a>00463 <span class="comment">                           ratio,</span>
<a name="l00464"></a>00464 <span class="comment">                           ticksDone,</span>
<a name="l00465"></a>00465 <span class="comment">                           ticksScheduled);</span>
<a name="l00466"></a>00466 <span class="comment">                           */</span>
<a name="l00467"></a>00467                         <span class="comment">/* ratios below 1% are considered to be dropouts due to</span>
<a name="l00468"></a>00468 <span class="comment">                           temporary load imbalance, the cycles adjusting is skipped */</span>
<a name="l00469"></a>00469                         <span class="keywordflow">if</span> (ratio&gt;10) {
<a name="l00470"></a>00470                             <span class="comment">/* ratios below 12% along with a large time since the last update</span>
<a name="l00471"></a>00471 <span class="comment">                               has taken place are most likely caused by heavy load through a</span>
<a name="l00472"></a>00472 <span class="comment">                               different application, the cycles adjusting is skipped as well */</span>
<a name="l00473"></a>00473                             <span class="keywordflow">if</span> ((ratio&gt;120) || (ticksDone&lt;700)) {
<a name="l00474"></a>00474                                 CPU_CycleMax = new_cmax;
<a name="l00475"></a>00475                                 <span class="keywordflow">if</span> (CPU_CycleLimit &gt; 0) {
<a name="l00476"></a>00476                                     <span class="keywordflow">if</span> (CPU_CycleMax&gt;CPU_CycleLimit) CPU_CycleMax = CPU_CycleLimit;
<a name="l00477"></a>00477                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CPU_CycleMax &gt; 2000000) CPU_CycleMax = 2000000; <span class="comment">//Hardcoded limit, if no limit was specified.</span>
<a name="l00478"></a>00478                             }
<a name="l00479"></a>00479                         }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481                         <span class="comment">//Reset cycleguessing parameters.</span>
<a name="l00482"></a>00482                         CPU_IODelayRemoved = 0;
<a name="l00483"></a>00483                         ticksDone = 0;
<a name="l00484"></a>00484                         ticksScheduled = 0;
<a name="l00485"></a>00485                         lastsleepDone = -1;
<a name="l00486"></a>00486                         sleep1count = 0;
<a name="l00487"></a>00487                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ticksAdded &gt; 15) {
<a name="l00488"></a>00488                         <span class="comment">/* ticksAdded &gt; 15 but ticksScheduled &lt; 5, lower the cycles</span>
<a name="l00489"></a>00489 <span class="comment">                           but do not reset the scheduled/done ticks to take them into</span>
<a name="l00490"></a>00490 <span class="comment">                           account during the next auto cycle adjustment */</span>
<a name="l00491"></a>00491                         CPU_CycleMax /= 3;
<a name="l00492"></a>00492                         <span class="keywordflow">if</span> (CPU_CycleMax &lt; CPU_CYCLES_LOWER_LIMIT)
<a name="l00493"></a>00493                             CPU_CycleMax = CPU_CYCLES_LOWER_LIMIT;
<a name="l00494"></a>00494                     }
<a name="l00495"></a>00495                 }
<a name="l00496"></a>00496             } <span class="keywordflow">else</span> {
<a name="l00497"></a>00497                 ticksAdded = 0;
<a name="l00498"></a>00498 
<a name="l00499"></a>00499                 <span class="keywordflow">if</span> (!CPU_CycleAutoAdjust || CPU_SkipCycleAutoAdjust || sleep1count &lt; 3) {
<a name="l00500"></a>00500                     wrap_delay(1);
<a name="l00501"></a>00501                 } <span class="keywordflow">else</span> {
<a name="l00502"></a>00502                     <span class="comment">/* Certain configurations always give an exact sleepingtime of 1, this causes problems due to the fact that</span>
<a name="l00503"></a>00503 <span class="comment">                       dosbox keeps track of full blocks.</span>
<a name="l00504"></a>00504 <span class="comment">                       This code introduces some randomness to the time slept, which improves stability on those configurations</span>
<a name="l00505"></a>00505 <span class="comment">                     */</span>
<a name="l00506"></a>00506                   <span class="keyword">static</span> <span class="keyword">const</span> Bit32u sleeppattern[] = { 2, 2, 3, 2, 2, 4, 2};
<a name="l00507"></a>00507                   <span class="keyword">static</span> Bit32u sleepindex = 0;
<a name="l00508"></a>00508                   <span class="keywordflow">if</span> (ticksDone != lastsleepDone) sleepindex = 0;
<a name="l00509"></a>00509                   wrap_delay(sleeppattern[sleepindex++]);
<a name="l00510"></a>00510                   sleepindex %= <span class="keyword">sizeof</span>(sleeppattern) / <span class="keyword">sizeof</span>(sleeppattern[0]);
<a name="l00511"></a>00511                 }
<a name="l00512"></a>00512                 Bit32s timeslept = (Bit32s)(GetTicks() - ticksNew);
<a name="l00513"></a>00513                 <span class="comment">// Count how many times in the current block (of 250 ms) the time slept was 1 ms</span>
<a name="l00514"></a>00514                 <span class="keywordflow">if</span> (CPU_CycleAutoAdjust &amp;&amp; !CPU_SkipCycleAutoAdjust &amp;&amp; timeslept == 1) sleep1count++;
<a name="l00515"></a>00515                 lastsleepDone = ticksDone;
<a name="l00516"></a>00516 
<a name="l00517"></a>00517                 <span class="comment">// Update ticksDone with the time spent sleeping</span>
<a name="l00518"></a>00518                 ticksDone -= timeslept;
<a name="l00519"></a>00519 
<a name="l00520"></a>00520                 <span class="keywordflow">if</span> (ticksDone &lt; 0)
<a name="l00521"></a>00521                     ticksDone = 0;
<a name="l00522"></a>00522             }
<a name="l00523"></a>00523         }
<a name="l00524"></a>00524     }
<a name="l00525"></a>00525     <span class="keywordflow">catch</span> (<a class="code" href="classGuestPageFaultException.html">GuestPageFaultException</a> &amp;pf) {
<a name="l00526"></a>00526         Bitu FillFlags(<span class="keywordtype">void</span>);
<a name="l00527"></a>00527 
<a name="l00528"></a>00528         ret = 0;
<a name="l00529"></a>00529         FillFlags();
<a name="l00530"></a>00530         dosbox_allow_nonrecursive_page_fault = <span class="keyword">false</span>;
<a name="l00531"></a>00531         CPU_Exception(EXCEPTION_PF,pf.faultcode);
<a name="l00532"></a>00532         dosbox_allow_nonrecursive_page_fault = saved_allow;
<a name="l00533"></a>00533     }
<a name="l00534"></a>00534     <span class="keywordflow">catch</span> (<span class="keywordtype">int</span> x) {
<a name="l00535"></a>00535         dosbox_allow_nonrecursive_page_fault = saved_allow;
<a name="l00536"></a>00536         <span class="keywordflow">if</span> (x == 4<span class="comment">/*CMOS shutdown*/</span>) {
<a name="l00537"></a>00537             ret = 0;
<a name="l00538"></a>00538 <span class="comment">//          LOG_MSG(&quot;CMOS shutdown reset acknowledged&quot;);</span>
<a name="l00539"></a>00539         }
<a name="l00540"></a>00540         <span class="keywordflow">else</span> {
<a name="l00541"></a>00541             <span class="keywordflow">throw</span>;
<a name="l00542"></a>00542         }
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545     <span class="keywordflow">return</span> 0;
<a name="l00546"></a>00546 }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 LoopHandler *DOSBOX_GetLoop(<span class="keywordtype">void</span>) {
<a name="l00549"></a>00549     <span class="keywordflow">return</span> loop;
<a name="l00550"></a>00550 }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552 <span class="keywordtype">void</span> DOSBOX_SetLoop(LoopHandler * handler) {
<a name="l00553"></a>00553     loop=handler;
<a name="l00554"></a>00554 }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 <span class="keywordtype">void</span> DOSBOX_SetNormalLoop() {
<a name="l00557"></a>00557     loop=Normal_Loop;
<a name="l00558"></a>00558 }
<a name="l00559"></a>00559 
<a name="l00560"></a>00560 <span class="comment">//#define DEBUG_RECURSION</span>
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="preprocessor">#ifdef DEBUG_RECURSION</span>
<a name="l00563"></a>00563 <span class="preprocessor"></span><span class="keyword">volatile</span> <span class="keywordtype">int</span> runmachine_recursion = 0;
<a name="l00564"></a>00564 <span class="preprocessor">#endif</span>
<a name="l00565"></a>00565 <span class="preprocessor"></span>
<a name="l00566"></a>00566 <span class="keywordtype">void</span> DOSBOX_RunMachine(<span class="keywordtype">void</span>){
<a name="l00567"></a>00567     Bitu ret;
<a name="l00568"></a>00568 
<a name="l00569"></a>00569     <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> last_callback;
<a name="l00570"></a>00570     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_last_callback = last_callback;
<a name="l00571"></a>00571     last_callback = 0;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573 <span class="preprocessor">#ifdef DEBUG_RECURSION</span>
<a name="l00574"></a>00574 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (runmachine_recursion++ != 0)
<a name="l00575"></a>00575         LOG_MSG(<span class="stringliteral">&quot;RunMachine recursion&quot;</span>);
<a name="l00576"></a>00576 <span class="preprocessor">#endif</span>
<a name="l00577"></a>00577 <span class="preprocessor"></span>
<a name="l00578"></a>00578     <span class="keywordflow">do</span> {
<a name="l00579"></a>00579         ret=(*loop)();
<a name="l00580"></a>00580     } <span class="keywordflow">while</span> (!ret);
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 <span class="preprocessor">#ifdef DEBUG_RECURSION</span>
<a name="l00583"></a>00583 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (--runmachine_recursion &lt; 0)
<a name="l00584"></a>00584         LOG_MSG(<span class="stringliteral">&quot;RunMachine recursion leave error&quot;</span>);
<a name="l00585"></a>00585 <span class="preprocessor">#endif</span>
<a name="l00586"></a>00586 <span class="preprocessor"></span>
<a name="l00587"></a>00587     last_callback = p_last_callback;
<a name="l00588"></a>00588 }
<a name="l00589"></a>00589 
<a name="l00590"></a>00590 <span class="keyword">static</span> <span class="keywordtype">void</span> DOSBOX_UnlockSpeed( <span class="keywordtype">bool</span> pressed ) {
<a name="l00591"></a>00591     <span class="keyword">static</span> <span class="keywordtype">bool</span> autoadjust = <span class="keyword">false</span>;
<a name="l00592"></a>00592     <span class="keywordflow">if</span> (pressed) {
<a name="l00593"></a>00593         LOG_MSG(<span class="stringliteral">&quot;Fast Forward ON&quot;</span>);
<a name="l00594"></a>00594         ticksLocked = <span class="keyword">true</span>;
<a name="l00595"></a>00595         <span class="keywordflow">if</span> (CPU_CycleAutoAdjust) {
<a name="l00596"></a>00596             autoadjust = <span class="keyword">true</span>;
<a name="l00597"></a>00597             CPU_CycleAutoAdjust = <span class="keyword">false</span>;
<a name="l00598"></a>00598             CPU_CycleMax /= 3;
<a name="l00599"></a>00599             <span class="keywordflow">if</span> (CPU_CycleMax&lt;1000) CPU_CycleMax=1000;
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601     } <span class="keywordflow">else</span> {
<a name="l00602"></a>00602         LOG_MSG(<span class="stringliteral">&quot;Fast Forward OFF&quot;</span>);
<a name="l00603"></a>00603         ticksLocked = <span class="keyword">false</span>;
<a name="l00604"></a>00604         <span class="keywordflow">if</span> (autoadjust) {
<a name="l00605"></a>00605             autoadjust = <span class="keyword">false</span>;
<a name="l00606"></a>00606             CPU_CycleAutoAdjust = <span class="keyword">true</span>;
<a name="l00607"></a>00607         }
<a name="l00608"></a>00608     }
<a name="l00609"></a>00609     GFX_SetTitle(-1,-1,-1,<span class="keyword">false</span>);
<a name="l00610"></a>00610 }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 <span class="keywordtype">void</span> DOSBOX_UnlockSpeed2( <span class="keywordtype">bool</span> pressed ) {
<a name="l00613"></a>00613     <span class="keywordflow">if</span> (pressed) {
<a name="l00614"></a>00614         ticksLocked = !ticksLocked;
<a name="l00615"></a>00615         DOSBOX_UnlockSpeed(ticksLocked?<span class="keyword">true</span>:<span class="keyword">false</span>);
<a name="l00616"></a>00616 
<a name="l00617"></a>00617         <span class="comment">/* make sure the menu item keeps up with our state */</span>
<a name="l00618"></a>00618         mainMenu.get_item(<span class="stringliteral">&quot;mapper_speedlock2&quot;</span>).check(ticksLocked).refresh_item(mainMenu);
<a name="l00619"></a>00619     }
<a name="l00620"></a>00620 }
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 <span class="keywordtype">void</span> DOSBOX_NormalSpeed( <span class="keywordtype">bool</span> pressed ) {
<a name="l00623"></a>00623     <span class="keywordflow">if</span> (pressed) {
<a name="l00624"></a>00624         <span class="comment">/* should also cancel turbo mode */</span>
<a name="l00625"></a>00625         <span class="keywordflow">if</span> (ticksLocked)
<a name="l00626"></a>00626             DOSBOX_UnlockSpeed2(<span class="keyword">true</span>);
<a name="l00627"></a>00627 
<a name="l00628"></a>00628         LOG_MSG(<span class="stringliteral">&quot;Emulation speed restored to normal (100%%)&quot;</span>);
<a name="l00629"></a>00629 
<a name="l00630"></a>00630         emulator_speed = 100;
<a name="l00631"></a>00631         ticksRemainSpeedFrac = 0;
<a name="l00632"></a>00632     }
<a name="l00633"></a>00633 }
<a name="l00634"></a>00634 
<a name="l00635"></a>00635 <span class="keywordtype">void</span> DOSBOX_SpeedUp( <span class="keywordtype">bool</span> pressed ) {
<a name="l00636"></a>00636     <span class="keywordflow">if</span> (pressed) {
<a name="l00637"></a>00637         ticksRemainSpeedFrac = 0;
<a name="l00638"></a>00638         <span class="keywordflow">if</span> (emulator_speed &gt;= 5)
<a name="l00639"></a>00639             emulator_speed += 5;
<a name="l00640"></a>00640         <span class="keywordflow">else</span>
<a name="l00641"></a>00641             emulator_speed = 5;
<a name="l00642"></a>00642 
<a name="l00643"></a>00643         LOG_MSG(<span class="stringliteral">&quot;Emulation speed increased to (%u%%)&quot;</span>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)emulator_speed);
<a name="l00644"></a>00644     }
<a name="l00645"></a>00645 }
<a name="l00646"></a>00646 
<a name="l00647"></a>00647 <span class="keywordtype">void</span> DOSBOX_SlowDown( <span class="keywordtype">bool</span> pressed ) {
<a name="l00648"></a>00648     <span class="keywordflow">if</span> (pressed) {
<a name="l00649"></a>00649         ticksRemainSpeedFrac = 0;
<a name="l00650"></a>00650         <span class="keywordflow">if</span> (emulator_speed  &gt; 5)
<a name="l00651"></a>00651             emulator_speed -= 5;
<a name="l00652"></a>00652         <span class="keywordflow">else</span>
<a name="l00653"></a>00653             emulator_speed = 1;
<a name="l00654"></a>00654 
<a name="l00655"></a>00655         LOG_MSG(<span class="stringliteral">&quot;Emulation speed decreased to (%u%%)&quot;</span>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)emulator_speed);
<a name="l00656"></a>00656     }
<a name="l00657"></a>00657 }
<a name="l00658"></a>00658 
<a name="l00659"></a>00659 <span class="keywordtype">void</span> notifyError(<span class="keyword">const</span> std::string&amp; message)
<a name="l00660"></a>00660 {
<a name="l00661"></a>00661 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00662"></a>00662 <span class="preprocessor"></span>    ::MessageBox(0, message.c_str(), <span class="stringliteral">&quot;Error&quot;</span>, 0);
<a name="l00663"></a>00663 <span class="preprocessor">#endif</span>
<a name="l00664"></a>00664 <span class="preprocessor"></span>    LOG_MSG(<span class="stringliteral">&quot;%s&quot;</span>,message.c_str());
<a name="l00665"></a>00665 }
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 <span class="comment">/* TODO: move to utility header */</span>
<a name="l00668"></a>00668 <span class="preprocessor">#ifdef _MSC_VER </span><span class="comment">/* Microsoft C++ does not have strtoull */</span>
<a name="l00669"></a>00669 <span class="preprocessor"># if _MSC_VER &lt; 1800 </span><span class="comment">/* But Visual Studio 2013 apparently does (http://www.vogons.org/viewtopic.php?f=41&amp;t=31881&amp;sid=49ff69ebc0459ed6523f5a250daa4d8c&amp;start=400#p355770) */</span>
<a name="l00670"></a>00670 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> strtoull(<span class="keyword">const</span> <span class="keywordtype">char</span> *s,<span class="keywordtype">char</span> **endptr,<span class="keywordtype">int</span> base) {
<a name="l00671"></a>00671     <span class="keywordflow">return</span> _strtoui64(s,endptr,base); <span class="comment">/* pfff... whatever Microsoft */</span>
<a name="l00672"></a>00672 }
<a name="l00673"></a>00673 <span class="preprocessor"># endif</span>
<a name="l00674"></a>00674 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00675"></a>00675 <span class="preprocessor"></span>
<a name="l00676"></a>00676 <span class="comment">/* utility function. rename as appropriate and move to utility collection */</span>
<a name="l00677"></a>00677 <span class="keywordtype">void</span> parse_busclk_setting_str(<a class="code" href="classClockDomain.html">ClockDomain</a> *cd,<span class="keyword">const</span> <span class="keywordtype">char</span> *s) {
<a name="l00678"></a>00678     <span class="keyword">const</span> <span class="keywordtype">char</span> *d;
<a name="l00679"></a>00679 
<a name="l00680"></a>00680     <span class="comment">/* we&#39;re expecting an integer, a float, or an integer ratio */</span>
<a name="l00681"></a>00681     d = strchr(s,<span class="charliteral">&#39;/&#39;</span>);
<a name="l00682"></a>00682     <span class="keywordflow">if</span> (d != NULL) { <span class="comment">/* it has a slash therefore an integer ratio */</span>
<a name="l00683"></a>00683         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> num,den;
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         <span class="keywordflow">while</span> (*d == <span class="charliteral">&#39; &#39;</span> || *d == <span class="charliteral">&#39;/&#39;</span>) d++;
<a name="l00686"></a>00686         num = strtoull(s,NULL,0);
<a name="l00687"></a>00687         den = strtoull(d,NULL,0);
<a name="l00688"></a>00688         <span class="keywordflow">if</span> (num &gt;= 1ULL &amp;&amp; den &gt;= 1ULL) cd-&gt;set_frequency(num,den);
<a name="l00689"></a>00689     }
<a name="l00690"></a>00690     <span class="keywordflow">else</span> {
<a name="l00691"></a>00691         d = strchr(s,<span class="charliteral">&#39;.&#39;</span>);
<a name="l00692"></a>00692         <span class="keywordflow">if</span> (d != NULL) { <span class="comment">/* it has a dot, floating point */</span>
<a name="l00693"></a>00693             <span class="keywordtype">double</span> f = atof(s);
<a name="l00694"></a>00694             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> fi = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)floor((f*1000000)+0.5);
<a name="l00695"></a>00695             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> den = 1000000;
<a name="l00696"></a>00696 
<a name="l00697"></a>00697             <span class="keywordflow">while</span> (den &gt; 1ULL) {
<a name="l00698"></a>00698                 <span class="keywordflow">if</span> ((fi%10ULL) == 0) {
<a name="l00699"></a>00699                     den /= 10ULL;
<a name="l00700"></a>00700                     fi /= 10ULL;
<a name="l00701"></a>00701                 }
<a name="l00702"></a>00702                 <span class="keywordflow">else</span> {
<a name="l00703"></a>00703                     <span class="keywordflow">break</span>;
<a name="l00704"></a>00704                 }
<a name="l00705"></a>00705             }
<a name="l00706"></a>00706 
<a name="l00707"></a>00707             <span class="keywordflow">if</span> (fi &gt;= 1ULL) cd-&gt;set_frequency(fi,den);
<a name="l00708"></a>00708         }
<a name="l00709"></a>00709         <span class="keywordflow">else</span> {
<a name="l00710"></a>00710             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> f = strtoull(s,NULL,10);
<a name="l00711"></a>00711             <span class="keywordflow">if</span> (f &gt;= 1ULL) cd-&gt;set_frequency(f,1);
<a name="l00712"></a>00712         }
<a name="l00713"></a>00713     }
<a name="l00714"></a>00714 }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dosbox_shell_env_size = 0;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718 <span class="keywordtype">void</span> Null_Init(<a class="code" href="classSection.html">Section</a> *sec) {
<a name="l00719"></a>00719         (void)sec;
<a name="l00720"></a>00720 }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722 <span class="keyword">extern</span> Bit8u cga_comp;
<a name="l00723"></a>00723 <span class="keyword">extern</span> <span class="keywordtype">bool</span> new_cga;
<a name="l00724"></a>00724 
<a name="l00725"></a>00725 <span class="keywordtype">bool</span> dpi_aware_enable = <span class="keyword">true</span>;
<a name="l00726"></a>00726 
<a name="l00727"></a>00727 std::string dosbox_title;
<a name="l00728"></a>00728 
<a name="l00729"></a>00729 <span class="keywordtype">void</span> DOSBOX_InitTickLoop() {
<a name="l00730"></a>00730     <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;Initializing tick loop management&quot;</span>);
<a name="l00731"></a>00731 
<a name="l00732"></a>00732     ticksRemain = 0;
<a name="l00733"></a>00733     ticksLocked = <span class="keyword">false</span>;
<a name="l00734"></a>00734     ticksLastRTtime = 0;
<a name="l00735"></a>00735     ticksLast = GetTicks();
<a name="l00736"></a>00736     ticksLastRTcounter = GetTicks();
<a name="l00737"></a>00737     ticksLastFramecounter = GetTicks();
<a name="l00738"></a>00738     DOSBOX_SetLoop(&amp;Normal_Loop);
<a name="l00739"></a>00739 }
<a name="l00740"></a>00740 
<a name="l00741"></a>00741 <span class="keywordtype">void</span> Init_VGABIOS() {
<a name="l00742"></a>00742     <a class="code" href="classSection__prop.html">Section_prop</a> *section = <span class="keyword">static_cast&lt;</span><a class="code" href="classSection__prop.html">Section_prop</a> *<span class="keyword">&gt;</span>(control-&gt;GetSection(<span class="stringliteral">&quot;dosbox&quot;</span>));
<a name="l00743"></a>00743     assert(section != NULL);
<a name="l00744"></a>00744 
<a name="l00745"></a>00745     <span class="keywordflow">if</span> (IS_PC98_ARCH) {
<a name="l00746"></a>00746         <span class="comment">// There IS no VGA BIOS, this is PC-98 mode!</span>
<a name="l00747"></a>00747         VGA_BIOS_SEG = 0xC000;
<a name="l00748"></a>00748         VGA_BIOS_SEG_END = 0xC000; <span class="comment">// Important: DOS kernel uses this to determine where to place the private area!</span>
<a name="l00749"></a>00749         VGA_BIOS_Size = 0;
<a name="l00750"></a>00750         <span class="keywordflow">return</span>;
<a name="l00751"></a>00751     }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753     <span class="comment">// log</span>
<a name="l00754"></a>00754     <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;Init_VGABIOS: Initializing VGA BIOS and parsing it&#39;s settings&quot;</span>);
<a name="l00755"></a>00755 
<a name="l00756"></a>00756     <span class="comment">// mem init must have already happened.</span>
<a name="l00757"></a>00757     <span class="comment">// We can remove this once the device callout system is in place.</span>
<a name="l00758"></a>00758     assert(MemBase != NULL);
<a name="l00759"></a>00759 
<a name="l00760"></a>00760     VGA_BIOS_Size_override = (Bitu)section-&gt;Get_int(<span class="stringliteral">&quot;vga bios size override&quot;</span>);
<a name="l00761"></a>00761     <span class="keywordflow">if</span> (VGA_BIOS_Size_override &gt; 0) VGA_BIOS_Size_override = (VGA_BIOS_Size_override+0x7FFU)&amp;(~0xFFFU);
<a name="l00762"></a>00762 
<a name="l00763"></a>00763     VGA_BIOS_dont_duplicate_CGA_first_half = section-&gt;Get_bool(<span class="stringliteral">&quot;video bios dont duplicate cga first half rom font&quot;</span>);
<a name="l00764"></a>00764     VIDEO_BIOS_always_carry_14_high_font = section-&gt;Get_bool(<span class="stringliteral">&quot;video bios always offer 14-pixel high rom font&quot;</span>);
<a name="l00765"></a>00765     VIDEO_BIOS_always_carry_16_high_font = section-&gt;Get_bool(<span class="stringliteral">&quot;video bios always offer 16-pixel high rom font&quot;</span>);
<a name="l00766"></a>00766     VIDEO_BIOS_enable_CGA_8x8_second_half = section-&gt;Get_bool(<span class="stringliteral">&quot;video bios enable cga second half rom font&quot;</span>);
<a name="l00767"></a>00767     <span class="comment">/* NTS: mainline compatible mapping demands the 8x8 CGA font */</span>
<a name="l00768"></a>00768     rom_bios_8x8_cga_font = section-&gt;Get_bool(<span class="stringliteral">&quot;rom bios 8x8 CGA font&quot;</span>);
<a name="l00769"></a>00769     rom_bios_vptable_enable = section-&gt;Get_bool(<span class="stringliteral">&quot;rom bios video parameter table&quot;</span>);
<a name="l00770"></a>00770 
<a name="l00771"></a>00771     <span class="comment">/* sanity check */</span>
<a name="l00772"></a>00772     <span class="keywordflow">if</span> (VGA_BIOS_dont_duplicate_CGA_first_half &amp;&amp; !rom_bios_8x8_cga_font) <span class="comment">/* can&#39;t point at the BIOS copy if it&#39;s not there */</span>
<a name="l00773"></a>00773         VGA_BIOS_dont_duplicate_CGA_first_half = <span class="keyword">false</span>;
<a name="l00774"></a>00774 
<a name="l00775"></a>00775     <span class="keywordflow">if</span> (VGA_BIOS_Size_override &gt;= 512 &amp;&amp; VGA_BIOS_Size_override &lt;= 65536)
<a name="l00776"></a>00776         VGA_BIOS_Size = (VGA_BIOS_Size_override + 0x7FFU) &amp; (~0xFFFU);
<a name="l00777"></a>00777     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IS_VGA_ARCH) {
<a name="l00778"></a>00778         <span class="keywordflow">if</span> (svgaCard == SVGA_S3Trio)
<a name="l00779"></a>00779             VGA_BIOS_Size = 0x4000;
<a name="l00780"></a>00780         <span class="keywordflow">else</span>
<a name="l00781"></a>00781             VGA_BIOS_Size = 0x4000; <span class="comment">// FIXME: Why does 0x3800 cause Windows 3.0 386 enhanced mode to hang?</span>
<a name="l00782"></a>00782     }
<a name="l00783"></a>00783     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (machine == MCH_EGA) {
<a name="l00784"></a>00784         <span class="keywordflow">if</span> (VIDEO_BIOS_always_carry_16_high_font)
<a name="l00785"></a>00785             VGA_BIOS_Size = 0x3000;
<a name="l00786"></a>00786         <span class="keywordflow">else</span>
<a name="l00787"></a>00787             VGA_BIOS_Size = 0x2000;
<a name="l00788"></a>00788     }
<a name="l00789"></a>00789     <span class="keywordflow">else</span> {
<a name="l00790"></a>00790         <span class="keywordflow">if</span> (VIDEO_BIOS_always_carry_16_high_font &amp;&amp; VIDEO_BIOS_always_carry_14_high_font)
<a name="l00791"></a>00791             VGA_BIOS_Size = 0x3000;
<a name="l00792"></a>00792         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (VIDEO_BIOS_always_carry_16_high_font || VIDEO_BIOS_always_carry_14_high_font)
<a name="l00793"></a>00793             VGA_BIOS_Size = 0x2000;
<a name="l00794"></a>00794         <span class="keywordflow">else</span>
<a name="l00795"></a>00795             VGA_BIOS_Size = 0;
<a name="l00796"></a>00796     }
<a name="l00797"></a>00797     VGA_BIOS_SEG = 0xC000;
<a name="l00798"></a>00798     VGA_BIOS_SEG_END = (VGA_BIOS_SEG + (VGA_BIOS_Size &gt;&gt; 4));
<a name="l00799"></a>00799 
<a name="l00800"></a>00800     <span class="comment">/* clear for VGA BIOS (FIXME: Why does Project Angel like our BIOS when we memset() here, but don&#39;t like it if we memset() in the INT 10 ROM setup routine?) */</span>
<a name="l00801"></a>00801     <span class="keywordflow">if</span> (VGA_BIOS_Size != 0)
<a name="l00802"></a>00802         memset((<span class="keywordtype">char</span>*)MemBase+0xC0000,0x00,VGA_BIOS_Size);
<a name="l00803"></a>00803 }
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 <span class="keywordtype">void</span> DOSBOX_RealInit() {
<a name="l00806"></a>00806     <a class="code" href="classDOSBoxMenu_1_1item.html">DOSBoxMenu::item</a> *item;
<a name="l00807"></a>00807 
<a name="l00808"></a>00808     <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;DOSBOX_RealInit: loading settings and initializing&quot;</span>);
<a name="l00809"></a>00809 
<a name="l00810"></a>00810     MAPPER_AddHandler(DOSBOX_UnlockSpeed, MK_rightarrow, MMODHOST,<span class="stringliteral">&quot;speedlock&quot;</span>,<span class="stringliteral">&quot;Speedlock&quot;</span>);
<a name="l00811"></a>00811     {
<a name="l00812"></a>00812         MAPPER_AddHandler(DOSBOX_UnlockSpeed2, MK_nothing, 0, <span class="stringliteral">&quot;speedlock2&quot;</span>, <span class="stringliteral">&quot;Speedlock2&quot;</span>, &amp;item);
<a name="l00813"></a>00813         item-&gt;set_description(<span class="stringliteral">&quot;Toggle emulation speed, to allow running faster than realtime (fast forward)&quot;</span>);
<a name="l00814"></a>00814         item-&gt;set_text(<span class="stringliteral">&quot;Turbo (Fast Forward)&quot;</span>);
<a name="l00815"></a>00815     }
<a name="l00816"></a>00816     {
<a name="l00817"></a>00817         MAPPER_AddHandler(DOSBOX_NormalSpeed, MK_leftarrow, MMODHOST, <span class="stringliteral">&quot;speednorm&quot;</span>,<span class="stringliteral">&quot;SpeedNrm&quot;</span>, &amp;item);
<a name="l00818"></a>00818         item-&gt;set_description(<span class="stringliteral">&quot;Restore normal emulation speed&quot;</span>);
<a name="l00819"></a>00819         item-&gt;set_text(<span class="stringliteral">&quot;Normal speed&quot;</span>);
<a name="l00820"></a>00820     }
<a name="l00821"></a>00821     {
<a name="l00822"></a>00822         MAPPER_AddHandler(DOSBOX_SpeedUp, MK_rbracket, MMODHOST, <span class="stringliteral">&quot;speedup&quot;</span>,<span class="stringliteral">&quot;SpeedUp&quot;</span>, &amp;item);
<a name="l00823"></a>00823         item-&gt;set_text(<span class="stringliteral">&quot;Speed up&quot;</span>);
<a name="l00824"></a>00824     }
<a name="l00825"></a>00825     {
<a name="l00826"></a>00826         MAPPER_AddHandler(DOSBOX_SlowDown, MK_lbracket, MMODHOST,<span class="stringliteral">&quot;slowdown&quot;</span>,<span class="stringliteral">&quot;SlowDn&quot;</span>, &amp;item);
<a name="l00827"></a>00827         item-&gt;set_text(<span class="stringliteral">&quot;Slow down&quot;</span>);
<a name="l00828"></a>00828     }
<a name="l00829"></a>00829 
<a name="l00830"></a>00830     <a class="code" href="classSection__prop.html">Section_prop</a> *section = <span class="keyword">static_cast&lt;</span><a class="code" href="classSection__prop.html">Section_prop</a> *<span class="keyword">&gt;</span>(control-&gt;GetSection(<span class="stringliteral">&quot;dosbox&quot;</span>));
<a name="l00831"></a>00831     assert(section != NULL);
<a name="l00832"></a>00832 
<a name="l00833"></a>00833     <span class="comment">// TODO: allow change at any time. in fact if it were possible for DOSBox-X configuration</span>
<a name="l00834"></a>00834     <span class="comment">//       schema code to attach event callbacks when a setting changes, we would set one</span>
<a name="l00835"></a>00835     <span class="comment">//       on the title= setting now to auto-update the titlebar when this changes.</span>
<a name="l00836"></a>00836     dosbox_title = section-&gt;Get_string(<span class="stringliteral">&quot;title&quot;</span>);
<a name="l00837"></a>00837 
<a name="l00838"></a>00838     <span class="comment">// TODO: these should be parsed by DOS kernel at startup</span>
<a name="l00839"></a>00839     dosbox_shell_env_size = (<span class="keywordtype">unsigned</span> int)section-&gt;Get_int(<span class="stringliteral">&quot;shell environment size&quot;</span>);
<a name="l00840"></a>00840 
<a name="l00841"></a>00841     <span class="comment">// TODO: a bit of a challenge: if we put it in the ROM area as mainline DOSBox does then the init</span>
<a name="l00842"></a>00842     <span class="comment">//       needs to read this from the BIOS where it can map the memory appropriately. if the allocation</span>
<a name="l00843"></a>00843     <span class="comment">//       is dynamic and the private area is down at the base of memory like real DOS, then the BIOS</span>
<a name="l00844"></a>00844     <span class="comment">//       should ignore it and the DOS kernel should parse it. If we&#39;re going to put it into upper</span>
<a name="l00845"></a>00845     <span class="comment">//       areas as well, then we should also consider making it look like adapter ROM at startup</span>
<a name="l00846"></a>00846     <span class="comment">//       so it can be enumerated properly by DOS programs scanning the ROM area.</span>
<a name="l00847"></a>00847     <span class="comment">/* private area size param in bytes. round up to nearest paragraph */</span>
<a name="l00848"></a>00848     DOS_PRIVATE_SEGMENT_Size = (Bitu)((section-&gt;Get_int(<span class="stringliteral">&quot;private area size&quot;</span>) + 8) / 16);
<a name="l00849"></a>00849 
<a name="l00850"></a>00850     <span class="comment">// TODO: these should be parsed by BIOS startup</span>
<a name="l00851"></a>00851     allow_more_than_640kb = section-&gt;Get_bool(<span class="stringliteral">&quot;allow more than 640kb base memory&quot;</span>);
<a name="l00852"></a>00852 
<a name="l00853"></a>00853     <span class="comment">// TODO: should be parsed by motherboard emulation</span>
<a name="l00854"></a>00854     allow_port_92_reset = section-&gt;Get_bool(<span class="stringliteral">&quot;allow port 92 reset&quot;</span>);
<a name="l00855"></a>00855 
<a name="l00856"></a>00856     <span class="comment">// CGA/EGA/VGA-specific</span>
<a name="l00857"></a>00857     <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> vga_p3da_undefined_bits;
<a name="l00858"></a>00858     vga_p3da_undefined_bits = (<span class="keywordtype">unsigned</span> char)section-&gt;Get_hex(<span class="stringliteral">&quot;vga 3da undefined bits&quot;</span>);
<a name="l00859"></a>00859 
<a name="l00860"></a>00860     <span class="comment">// TODO: should be parsed by motherboard emulation or lower level equiv..?</span>
<a name="l00861"></a>00861     std::string cmd_machine;
<a name="l00862"></a>00862     <span class="keywordflow">if</span> (control-&gt;cmdline-&gt;FindString(<span class="stringliteral">&quot;-machine&quot;</span>,cmd_machine,<span class="keyword">true</span>)){
<a name="l00863"></a>00863         <span class="comment">//update value in config (else no matching against suggested values</span>
<a name="l00864"></a>00864         section-&gt;HandleInputline(std::string(<span class="stringliteral">&quot;machine=&quot;</span>) + cmd_machine);
<a name="l00865"></a>00865     }
<a name="l00866"></a>00866 
<a name="l00867"></a>00867     <span class="comment">// TODO: should be parsed by...? perhaps at some point we support machine= for backwards compat</span>
<a name="l00868"></a>00868     <span class="comment">//       but translate it into two separate params that specify what machine vs what video hardware.</span>
<a name="l00869"></a>00869     <span class="comment">//       or better yet as envisioned, a possible dosbox.conf schema that allows a machine with no</span>
<a name="l00870"></a>00870     <span class="comment">//       base video of it&#39;s own, and then to specify an ISA or PCI card attached to the bus that</span>
<a name="l00871"></a>00871     <span class="comment">//       provides video.</span>
<a name="l00872"></a>00872     std::string mtype(section-&gt;Get_string(<span class="stringliteral">&quot;machine&quot;</span>));
<a name="l00873"></a>00873     svgaCard = SVGA_None;
<a name="l00874"></a>00874     machine = MCH_VGA;
<a name="l00875"></a>00875     int10.vesa_nolfb = <span class="keyword">false</span>;
<a name="l00876"></a>00876     int10.vesa_oldvbe = <span class="keyword">false</span>;
<a name="l00877"></a>00877     <span class="keywordflow">if</span>      (mtype == <span class="stringliteral">&quot;cga&quot;</span>)           { machine = MCH_CGA; mono_cga = <span class="keyword">false</span>; }
<a name="l00878"></a>00878     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;cga_mono&quot;</span>)      { machine = MCH_CGA; mono_cga = <span class="keyword">true</span>; }
<a name="l00879"></a>00879     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;cga_rgb&quot;</span>)       { machine = MCH_CGA; mono_cga = <span class="keyword">false</span>; cga_comp = 2; }
<a name="l00880"></a>00880     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;cga_composite&quot;</span>) { machine = MCH_CGA; mono_cga = <span class="keyword">false</span>; cga_comp = 1; new_cga = <span class="keyword">false</span>; }
<a name="l00881"></a>00881     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;cga_composite2&quot;</span>){ machine = MCH_CGA; mono_cga = <span class="keyword">false</span>; cga_comp = 1; new_cga = <span class="keyword">true</span>; }
<a name="l00882"></a>00882     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;mcga&quot;</span>)          { machine = MCH_MCGA; }
<a name="l00883"></a>00883     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;tandy&quot;</span>)         { machine = MCH_TANDY; }
<a name="l00884"></a>00884     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;pcjr&quot;</span>)          { machine = MCH_PCJR; }
<a name="l00885"></a>00885     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;hercules&quot;</span>)      { machine = MCH_HERC; }
<a name="l00886"></a>00886     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;mda&quot;</span>)           { machine = MCH_MDA; }
<a name="l00887"></a>00887     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;ega&quot;</span>)           { machine = MCH_EGA; }
<a name="l00888"></a>00888     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;svga_s3&quot;</span>)       { svgaCard = SVGA_S3Trio; }
<a name="l00889"></a>00889     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;vesa_nolfb&quot;</span>)    { svgaCard = SVGA_S3Trio; int10.vesa_nolfb = <span class="keyword">true</span>;}
<a name="l00890"></a>00890     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;vesa_oldvbe&quot;</span>)   { svgaCard = SVGA_S3Trio; int10.vesa_oldvbe = <span class="keyword">true</span>;}
<a name="l00891"></a>00891     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;svga_et4000&quot;</span>)   { svgaCard = SVGA_TsengET4K; }
<a name="l00892"></a>00892     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;svga_et3000&quot;</span>)   { svgaCard = SVGA_TsengET3K; }
<a name="l00893"></a>00893     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;svga_paradise&quot;</span>) { svgaCard = SVGA_ParadisePVGA1A; }
<a name="l00894"></a>00894     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;vgaonly&quot;</span>)       { svgaCard = SVGA_None; }
<a name="l00895"></a>00895     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;amstrad&quot;</span>)       { machine = MCH_AMSTRAD; }
<a name="l00896"></a>00896     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;pc98&quot;</span>)          { machine = MCH_PC98; }
<a name="l00897"></a>00897     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;pc9801&quot;</span>)        { machine = MCH_PC98; } <span class="comment">/* Future differentiation */</span>
<a name="l00898"></a>00898     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;pc9821&quot;</span>)        { machine = MCH_PC98; } <span class="comment">/* Future differentiation */</span>
<a name="l00899"></a>00899 
<a name="l00900"></a>00900     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;fm_towns&quot;</span>)      { machine = MCH_VGA; want_fm_towns = <span class="keyword">true</span>; <span class="comment">/*machine = MCH_FM_TOWNS;*/</span> }
<a name="l00901"></a>00901 
<a name="l00902"></a>00902     <span class="keywordflow">else</span> E_Exit(<span class="stringliteral">&quot;DOSBOX:Unknown machine type %s&quot;</span>,mtype.c_str());
<a name="l00903"></a>00903 
<a name="l00904"></a>00904     <span class="comment">// TODO: should be parsed by motherboard emulation</span>
<a name="l00905"></a>00905     <span class="comment">// FIXME: This re-uses the existing ISA bus delay code for C-BUS in PC-98 mode</span>
<a name="l00906"></a>00906     std::string isabclk;
<a name="l00907"></a>00907 
<a name="l00908"></a>00908     <span class="keywordflow">if</span> (IS_PC98_ARCH)
<a name="l00909"></a>00909         isabclk = section-&gt;Get_string(<span class="stringliteral">&quot;cbus bus clock&quot;</span>);
<a name="l00910"></a>00910     <span class="keywordflow">else</span>
<a name="l00911"></a>00911         isabclk = section-&gt;Get_string(<span class="stringliteral">&quot;isa bus clock&quot;</span>);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913     <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std10&quot;</span>)
<a name="l00914"></a>00914         clockdom_ISA_BCLK.set_frequency(PIT_TICK_RATE_PC98_10MHZ * 4ul,1);          <span class="comment">/* 10Mhz (PC-98) */</span>
<a name="l00915"></a>00915     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std8.3&quot;</span>)
<a name="l00916"></a>00916         clockdom_ISA_BCLK.set_frequency(25000000,3);    <span class="comment">/* 25MHz / 3 = 8.333MHz, early 386 systems did this, became an industry standard &quot;norm&quot; afterwards */</span>
<a name="l00917"></a>00917     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std8&quot;</span>) {
<a name="l00918"></a>00918         <span class="keywordflow">if</span> (IS_PC98_ARCH)
<a name="l00919"></a>00919             clockdom_ISA_BCLK.set_frequency(PIT_TICK_RATE_PC98_8MHZ * 4ul,1);       <span class="comment">/* 8Mhz (PC-98) */</span>
<a name="l00920"></a>00920         <span class="keywordflow">else</span>
<a name="l00921"></a>00921             clockdom_ISA_BCLK.set_frequency(8000000,1);                             <span class="comment">/* 8Mhz (IBM PC) */</span>
<a name="l00922"></a>00922     }
<a name="l00923"></a>00923     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std6&quot;</span>)
<a name="l00924"></a>00924         clockdom_ISA_BCLK.set_frequency(6000000,1);     <span class="comment">/* 6MHz */</span>
<a name="l00925"></a>00925     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std5&quot;</span>)
<a name="l00926"></a>00926         clockdom_ISA_BCLK.set_frequency(PIT_TICK_RATE_PC98_10MHZ * 2ul,1);          <span class="comment">/* 5Mhz (PC-98) */</span>
<a name="l00927"></a>00927     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std4.77&quot;</span>)
<a name="l00928"></a>00928         clockdom_ISA_BCLK.set_frequency(clockdom_ISA_OSC.freq,clockdom_ISA_OSC.freq_div*3LL); <span class="comment">/* 14.31818MHz / 3 = 4.77MHz */</span>
<a name="l00929"></a>00929     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;oc10&quot;</span>)
<a name="l00930"></a>00930         clockdom_ISA_BCLK.set_frequency(10000000,1);    <span class="comment">/* 10MHz */</span>
<a name="l00931"></a>00931     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;oc12&quot;</span>)
<a name="l00932"></a>00932         clockdom_ISA_BCLK.set_frequency(12000000,1);    <span class="comment">/* 12MHz */</span>
<a name="l00933"></a>00933     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;oc15&quot;</span>)
<a name="l00934"></a>00934         clockdom_ISA_BCLK.set_frequency(15000000,1);    <span class="comment">/* 15MHz */</span>
<a name="l00935"></a>00935     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;oc16&quot;</span>)
<a name="l00936"></a>00936         clockdom_ISA_BCLK.set_frequency(16000000,1);    <span class="comment">/* 16MHz */</span>
<a name="l00937"></a>00937     <span class="keywordflow">else</span>
<a name="l00938"></a>00938         parse_busclk_setting_str(&amp;clockdom_ISA_BCLK,isabclk.c_str());
<a name="l00939"></a>00939 
<a name="l00940"></a>00940     std::string pcibclk = section-&gt;Get_string(<span class="stringliteral">&quot;pci bus clock&quot;</span>);
<a name="l00941"></a>00941     <span class="keywordflow">if</span> (pcibclk == <span class="stringliteral">&quot;std33.3&quot;</span>)
<a name="l00942"></a>00942         clockdom_PCI_BCLK.set_frequency(100000000,3);   <span class="comment">/* 100MHz / 3 = 33.333MHz, VERY common PCI speed */</span>
<a name="l00943"></a>00943     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pcibclk == <span class="stringliteral">&quot;std30&quot;</span>)
<a name="l00944"></a>00944         clockdom_PCI_BCLK.set_frequency(30000000,1);    <span class="comment">/* 30Mhz */</span>
<a name="l00945"></a>00945     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pcibclk == <span class="stringliteral">&quot;std25&quot;</span>)
<a name="l00946"></a>00946         clockdom_PCI_BCLK.set_frequency(25000000,1);    <span class="comment">/* 25MHz */</span>
<a name="l00947"></a>00947     <span class="keywordflow">else</span>
<a name="l00948"></a>00948         parse_busclk_setting_str(&amp;clockdom_PCI_BCLK,pcibclk.c_str());
<a name="l00949"></a>00949 
<a name="l00950"></a>00950     LOG_MSG(<span class="stringliteral">&quot;%s BCLK: %.3fHz (%llu/%llu)&quot;</span>,
<a name="l00951"></a>00951         IS_PC98_ARCH ? <span class="stringliteral">&quot;C-BUS&quot;</span> : <span class="stringliteral">&quot;ISA&quot;</span>,
<a name="l00952"></a>00952         (<span class="keywordtype">double</span>)clockdom_ISA_BCLK.freq / clockdom_ISA_BCLK.freq_div,
<a name="l00953"></a>00953         (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)clockdom_ISA_BCLK.freq,
<a name="l00954"></a>00954         (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)clockdom_ISA_BCLK.freq_div);
<a name="l00955"></a>00955 
<a name="l00956"></a>00956     clockdom_ISA_OSC.set_name(<span class="stringliteral">&quot;ISA OSC&quot;</span>);
<a name="l00957"></a>00957     clockdom_ISA_BCLK.set_name(<span class="stringliteral">&quot;ISA BCLK&quot;</span>);
<a name="l00958"></a>00958     clockdom_PCI_BCLK.set_name(<span class="stringliteral">&quot;PCI BCLK&quot;</span>);
<a name="l00959"></a>00959 
<a name="l00960"></a>00960     <span class="comment">// FM TOWNS is stub so far. According to sources like Wikipedia though,</span>
<a name="l00961"></a>00961     <span class="comment">// it boots from DOS in ROM that then loads bootcode from CD-ROM. So</span>
<a name="l00962"></a>00962     <span class="comment">// for now, allow booting into FM TOWNS mode with a warning. The</span>
<a name="l00963"></a>00963     <span class="comment">// switch to FM Towns will begin in the BOOT command with a flag to</span>
<a name="l00964"></a>00964     <span class="comment">// indicate the ISO is intended for FM TOwns.</span>
<a name="l00965"></a>00965     <span class="keywordflow">if</span> (IS_FM_TOWNS || want_fm_towns) LOG_MSG(<span class="stringliteral">&quot;FM Towns emulation not yet implemented. It&#39;s currently just a stub for future development.&quot;</span>);
<a name="l00966"></a>00966 }
<a name="l00967"></a>00967 
<a name="l00968"></a>00968 <span class="keywordtype">void</span> DOSBOX_SetupConfigSections(<span class="keywordtype">void</span>) {
<a name="l00969"></a>00969     <a class="code" href="classProp__int.html">Prop_int</a>* Pint;
<a name="l00970"></a>00970     <a class="code" href="classProp__hex.html">Prop_hex</a>* Phex;
<a name="l00971"></a>00971     <a class="code" href="classProp__bool.html">Prop_bool</a>* Pbool;
<a name="l00972"></a>00972     <a class="code" href="classProp__string.html">Prop_string</a>* Pstring;
<a name="l00973"></a>00973     <a class="code" href="classProp__double.html">Prop_double</a>* Pdouble;
<a name="l00974"></a>00974     <a class="code" href="classProp__multival.html">Prop_multival</a>* Pmulti;
<a name="l00975"></a>00975     <a class="code" href="classSection__prop.html">Section_prop</a> * secprop;
<a name="l00976"></a>00976     <a class="code" href="classProp__multival__remain.html">Prop_multival_remain</a>* Pmulti_remain;
<a name="l00977"></a>00977 
<a name="l00978"></a>00978     <span class="comment">// Some frequently used option sets</span>
<a name="l00979"></a>00979     <span class="keyword">const</span> <span class="keywordtype">char</span>* vsyncrate[] = { <span class="stringliteral">&quot;%u&quot;</span>, 0 };
<a name="l00980"></a>00980     <span class="keyword">const</span> <span class="keywordtype">char</span>* force[] = { <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;forced&quot;</span>, 0 };
<a name="l00981"></a>00981     <span class="keyword">const</span> <span class="keywordtype">char</span>* cyclest[] = { <span class="stringliteral">&quot;auto&quot;</span>,<span class="stringliteral">&quot;fixed&quot;</span>,<span class="stringliteral">&quot;max&quot;</span>,<span class="stringliteral">&quot;%u&quot;</span>,0 };
<a name="l00982"></a>00982     <span class="keyword">const</span> <span class="keywordtype">char</span>* mputypes[] = { <span class="stringliteral">&quot;intelligent&quot;</span>, <span class="stringliteral">&quot;uart&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, 0 };
<a name="l00983"></a>00983     <span class="keyword">const</span> <span class="keywordtype">char</span>* vsyncmode[] = { <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;on&quot;</span> ,<span class="stringliteral">&quot;force&quot;</span>, <span class="stringliteral">&quot;host&quot;</span>, 0 };
<a name="l00984"></a>00984     <span class="keyword">const</span> <span class="keywordtype">char</span>* captureformats[] = { <span class="stringliteral">&quot;default&quot;</span>, <span class="stringliteral">&quot;avi-zmbv&quot;</span>, <span class="stringliteral">&quot;mpegts-h264&quot;</span>, 0 };
<a name="l00985"></a>00985     <span class="keyword">const</span> <span class="keywordtype">char</span>* blocksizes[] = {<span class="stringliteral">&quot;1024&quot;</span>, <span class="stringliteral">&quot;2048&quot;</span>, <span class="stringliteral">&quot;4096&quot;</span>, <span class="stringliteral">&quot;8192&quot;</span>, <span class="stringliteral">&quot;512&quot;</span>, <span class="stringliteral">&quot;256&quot;</span>, 0};
<a name="l00986"></a>00986     <span class="keyword">const</span> <span class="keywordtype">char</span>* capturechromaformats[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;4:4:4&quot;</span>, <span class="stringliteral">&quot;4:2:2&quot;</span>, <span class="stringliteral">&quot;4:2:0&quot;</span>, 0};
<a name="l00987"></a>00987     <span class="keyword">const</span> <span class="keywordtype">char</span>* controllertypes[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;at&quot;</span>, <span class="stringliteral">&quot;xt&quot;</span>, <span class="stringliteral">&quot;pcjr&quot;</span>, <span class="stringliteral">&quot;pc98&quot;</span>, 0}; <span class="comment">// Future work: Tandy(?) and USB</span>
<a name="l00988"></a>00988     <span class="keyword">const</span> <span class="keywordtype">char</span>* auxdevices[] = {<span class="stringliteral">&quot;none&quot;</span>,<span class="stringliteral">&quot;2button&quot;</span>,<span class="stringliteral">&quot;3button&quot;</span>,<span class="stringliteral">&quot;intellimouse&quot;</span>,<span class="stringliteral">&quot;intellimouse45&quot;</span>,0};
<a name="l00989"></a>00989     <span class="keyword">const</span> <span class="keywordtype">char</span>* cputype_values[] = {<span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;8086&quot;</span>, <span class="stringliteral">&quot;8086_prefetch&quot;</span>, <span class="stringliteral">&quot;80186&quot;</span>, <span class="stringliteral">&quot;80186_prefetch&quot;</span>, <span class="stringliteral">&quot;286&quot;</span>, <span class="stringliteral">&quot;286_prefetch&quot;</span>, <span class="stringliteral">&quot;386&quot;</span>, <span class="stringliteral">&quot;386_prefetch&quot;</span>, <span class="stringliteral">&quot;486old&quot;</span>, <span class="stringliteral">&quot;486old_prefetch&quot;</span>, <span class="stringliteral">&quot;486&quot;</span>, <span class="stringliteral">&quot;486_prefetch&quot;</span>, <span class="stringliteral">&quot;pentium&quot;</span>, <span class="stringliteral">&quot;pentium_mmx&quot;</span>, <span class="stringliteral">&quot;ppro_slow&quot;</span>, 0};
<a name="l00990"></a>00990     <span class="keyword">const</span> <span class="keywordtype">char</span>* rates[] = {  <span class="stringliteral">&quot;44100&quot;</span>, <span class="stringliteral">&quot;48000&quot;</span>, <span class="stringliteral">&quot;32000&quot;</span>,<span class="stringliteral">&quot;22050&quot;</span>, <span class="stringliteral">&quot;16000&quot;</span>, <span class="stringliteral">&quot;11025&quot;</span>, <span class="stringliteral">&quot;8000&quot;</span>, <span class="stringliteral">&quot;49716&quot;</span>, 0 };
<a name="l00991"></a>00991     <span class="keyword">const</span> <span class="keywordtype">char</span>* oplrates[] = {   <span class="stringliteral">&quot;44100&quot;</span>, <span class="stringliteral">&quot;49716&quot;</span>, <span class="stringliteral">&quot;48000&quot;</span>, <span class="stringliteral">&quot;32000&quot;</span>,<span class="stringliteral">&quot;22050&quot;</span>, <span class="stringliteral">&quot;16000&quot;</span>, <span class="stringliteral">&quot;11025&quot;</span>, <span class="stringliteral">&quot;8000&quot;</span>, 0 };
<a name="l00992"></a>00992     <span class="keyword">const</span> <span class="keywordtype">char</span>* devices[] = { <span class="stringliteral">&quot;default&quot;</span>, <span class="stringliteral">&quot;win32&quot;</span>, <span class="stringliteral">&quot;alsa&quot;</span>, <span class="stringliteral">&quot;oss&quot;</span>, <span class="stringliteral">&quot;coreaudio&quot;</span>, <span class="stringliteral">&quot;coremidi&quot;</span>, <span class="stringliteral">&quot;mt32&quot;</span>, <span class="stringliteral">&quot;synth&quot;</span>, <span class="stringliteral">&quot;timidity&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, 0}; <span class="comment">// FIXME: add some way to offer the actually available choices.</span>
<a name="l00993"></a>00993     <span class="keyword">const</span> <span class="keywordtype">char</span>* apmbiosversions[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;1.0&quot;</span>, <span class="stringliteral">&quot;1.1&quot;</span>, <span class="stringliteral">&quot;1.2&quot;</span>, 0 };
<a name="l00994"></a>00994     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32log[] = {<span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>,0};
<a name="l00995"></a>00995     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32thread[] = {<span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>,0};
<a name="l00996"></a>00996     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32ReverseStereo[] = {<span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>,0};
<a name="l00997"></a>00997     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32DACModes[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>,0};
<a name="l00998"></a>00998     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32reverbModes[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>,0};
<a name="l00999"></a>00999     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32reverbTimes[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>,0};
<a name="l01000"></a>01000     <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32reverbLevels[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>,0};
<a name="l01001"></a>01001     <span class="keyword">const</span> <span class="keywordtype">char</span>* gustypes[] = { <span class="stringliteral">&quot;classic&quot;</span>, <span class="stringliteral">&quot;classic37&quot;</span>, <span class="stringliteral">&quot;max&quot;</span>, <span class="stringliteral">&quot;interwave&quot;</span>, 0 };
<a name="l01002"></a>01002     <span class="keyword">const</span> <span class="keywordtype">char</span>* sbtypes[] = { <span class="stringliteral">&quot;sb1&quot;</span>, <span class="stringliteral">&quot;sb2&quot;</span>, <span class="stringliteral">&quot;sbpro1&quot;</span>, <span class="stringliteral">&quot;sbpro2&quot;</span>, <span class="stringliteral">&quot;sb16&quot;</span>, <span class="stringliteral">&quot;sb16vibra&quot;</span>, <span class="stringliteral">&quot;gb&quot;</span>, <span class="stringliteral">&quot;ess688&quot;</span>, <span class="stringliteral">&quot;reveal_sc400&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, 0 };
<a name="l01003"></a>01003     <span class="keyword">const</span> <span class="keywordtype">char</span>* oplmodes[]={ <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;cms&quot;</span>, <span class="stringliteral">&quot;opl2&quot;</span>, <span class="stringliteral">&quot;dualopl2&quot;</span>, <span class="stringliteral">&quot;opl3&quot;</span>, <span class="stringliteral">&quot;opl3gold&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, <span class="stringliteral">&quot;hardware&quot;</span>, <span class="stringliteral">&quot;hardwaregb&quot;</span>, 0};
<a name="l01004"></a>01004     <span class="keyword">const</span> <span class="keywordtype">char</span>* serials[] = { <span class="stringliteral">&quot;dummy&quot;</span>, <span class="stringliteral">&quot;disabled&quot;</span>, <span class="stringliteral">&quot;modem&quot;</span>, <span class="stringliteral">&quot;nullmodem&quot;</span>, <span class="stringliteral">&quot;serialmouse&quot;</span>, <span class="stringliteral">&quot;directserial&quot;</span>, <span class="stringliteral">&quot;log&quot;</span>, 0 };
<a name="l01005"></a>01005     <span class="keyword">const</span> <span class="keywordtype">char</span>* acpi_rsd_ptr_settings[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;bios&quot;</span>, <span class="stringliteral">&quot;ebda&quot;</span>, 0 };
<a name="l01006"></a>01006     <span class="keyword">const</span> <span class="keywordtype">char</span>* cpm_compat_modes[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;msdos2&quot;</span>, <span class="stringliteral">&quot;msdos5&quot;</span>, <span class="stringliteral">&quot;direct&quot;</span>, 0 };
<a name="l01007"></a>01007     <span class="keyword">const</span> <span class="keywordtype">char</span>* dosv_settings[] = { <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;japanese&quot;</span>, <span class="stringliteral">&quot;chinese&quot;</span>, <span class="stringliteral">&quot;korean&quot;</span>, 0 };
<a name="l01008"></a>01008     <span class="keyword">const</span> <span class="keywordtype">char</span>* acpisettings[] = { <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;1.0&quot;</span>, <span class="stringliteral">&quot;1.0b&quot;</span>, <span class="stringliteral">&quot;2.0&quot;</span>, <span class="stringliteral">&quot;2.0a&quot;</span>, <span class="stringliteral">&quot;2.0b&quot;</span>, <span class="stringliteral">&quot;2.0c&quot;</span>, <span class="stringliteral">&quot;3.0&quot;</span>, <span class="stringliteral">&quot;3.0a&quot;</span>, <span class="stringliteral">&quot;3.0b&quot;</span>, <span class="stringliteral">&quot;4.0&quot;</span>, <span class="stringliteral">&quot;4.0a&quot;</span>, <span class="stringliteral">&quot;5.0&quot;</span>, <span class="stringliteral">&quot;5.0a&quot;</span>, <span class="stringliteral">&quot;6.0&quot;</span>, 0 };
<a name="l01009"></a>01009     <span class="keyword">const</span> <span class="keywordtype">char</span>* guspantables[] = { <span class="stringliteral">&quot;old&quot;</span>, <span class="stringliteral">&quot;accurate&quot;</span>, <span class="stringliteral">&quot;default&quot;</span>, 0 };
<a name="l01010"></a>01010     <span class="keyword">const</span> <span class="keywordtype">char</span> *sidbaseno[] = { <span class="stringliteral">&quot;240&quot;</span>, <span class="stringliteral">&quot;220&quot;</span>, <span class="stringliteral">&quot;260&quot;</span>, <span class="stringliteral">&quot;280&quot;</span>, <span class="stringliteral">&quot;2a0&quot;</span>, <span class="stringliteral">&quot;2c0&quot;</span>, <span class="stringliteral">&quot;2e0&quot;</span>, <span class="stringliteral">&quot;300&quot;</span>, 0 };
<a name="l01011"></a>01011     <span class="keyword">const</span> <span class="keywordtype">char</span>* joytypes[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;2axis&quot;</span>, <span class="stringliteral">&quot;4axis&quot;</span>, <span class="stringliteral">&quot;4axis_2&quot;</span>, <span class="stringliteral">&quot;fcs&quot;</span>, <span class="stringliteral">&quot;ch&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>,0};
<a name="l01012"></a>01012 <span class="comment">//    const char* joydeadzone[] = { &quot;0.26&quot;, 0 };</span>
<a name="l01013"></a>01013 <span class="comment">//    const char* joyresponse[] = { &quot;1.0&quot;, 0 };</span>
<a name="l01014"></a>01014     <span class="keyword">const</span> <span class="keywordtype">char</span>* iosgus[] = { <span class="stringliteral">&quot;240&quot;</span>, <span class="stringliteral">&quot;220&quot;</span>, <span class="stringliteral">&quot;260&quot;</span>, <span class="stringliteral">&quot;280&quot;</span>, <span class="stringliteral">&quot;2a0&quot;</span>, <span class="stringliteral">&quot;2c0&quot;</span>, <span class="stringliteral">&quot;2e0&quot;</span>, <span class="stringliteral">&quot;300&quot;</span>, <span class="stringliteral">&quot;210&quot;</span>, <span class="stringliteral">&quot;230&quot;</span>, <span class="stringliteral">&quot;250&quot;</span>, 0 };
<a name="l01015"></a>01015     <span class="keyword">const</span> <span class="keywordtype">char</span>* mpubases[] = {
<a name="l01016"></a>01016         <span class="stringliteral">&quot;0&quot;</span>,                                                                                    <span class="comment">/* Auto */</span>
<a name="l01017"></a>01017         <span class="stringliteral">&quot;300&quot;</span>, <span class="stringliteral">&quot;310&quot;</span>, <span class="stringliteral">&quot;320&quot;</span>, <span class="stringliteral">&quot;330&quot;</span>, <span class="stringliteral">&quot;332&quot;</span>, <span class="stringliteral">&quot;334&quot;</span>, <span class="stringliteral">&quot;336&quot;</span>, <span class="stringliteral">&quot;340&quot;</span>, <span class="stringliteral">&quot;360&quot;</span>,                          <span class="comment">/* IBM PC */</span>
<a name="l01018"></a>01018         <span class="stringliteral">&quot;c0d0&quot;</span>,<span class="stringliteral">&quot;c8d0&quot;</span>,<span class="stringliteral">&quot;d0d0&quot;</span>,<span class="stringliteral">&quot;d8d0&quot;</span>,<span class="stringliteral">&quot;e0d0&quot;</span>,<span class="stringliteral">&quot;e8d0&quot;</span>,<span class="stringliteral">&quot;f0d0&quot;</span>,<span class="stringliteral">&quot;f8d0&quot;</span>,                                <span class="comment">/* NEC PC-98 MPU98 */</span>
<a name="l01019"></a>01019         <span class="stringliteral">&quot;80d2&quot;</span>,<span class="stringliteral">&quot;80d4&quot;</span>,<span class="stringliteral">&quot;80d6&quot;</span>,<span class="stringliteral">&quot;80d8&quot;</span>,<span class="stringliteral">&quot;80da&quot;</span>,<span class="stringliteral">&quot;80dc&quot;</span>,<span class="stringliteral">&quot;80de&quot;</span>,                                       <span class="comment">/* NEC PC-98 SB16 */</span>
<a name="l01020"></a>01020         0 };
<a name="l01021"></a>01021     <span class="keyword">const</span> <span class="keywordtype">char</span>* ios[] = {
<a name="l01022"></a>01022         <span class="stringliteral">&quot;220&quot;</span>, <span class="stringliteral">&quot;240&quot;</span>, <span class="stringliteral">&quot;260&quot;</span>, <span class="stringliteral">&quot;280&quot;</span>, <span class="stringliteral">&quot;2a0&quot;</span>, <span class="stringliteral">&quot;2c0&quot;</span>, <span class="stringliteral">&quot;2e0&quot;</span>,            <span class="comment">/* IBM PC      (base+port i.e. 220h base, 22Ch is DSP) */</span>
<a name="l01023"></a>01023         <span class="stringliteral">&quot;d2&quot;</span>,  <span class="stringliteral">&quot;d4&quot;</span>,  <span class="stringliteral">&quot;d6&quot;</span>,  <span class="stringliteral">&quot;d8&quot;</span>,  <span class="stringliteral">&quot;da&quot;</span>,  <span class="stringliteral">&quot;dc&quot;</span>,  <span class="stringliteral">&quot;de&quot;</span>,             <span class="comment">/* NEC PC-98   (base+(port &lt;&lt; 8) i.e. 00D2h base, 2CD2h is DSP) */</span>
<a name="l01024"></a>01024         0 };
<a name="l01025"></a>01025     <span class="keyword">const</span> <span class="keywordtype">char</span>* ems_settings[] = { <span class="stringliteral">&quot;true&quot;</span>, <span class="stringliteral">&quot;emsboard&quot;</span>, <span class="stringliteral">&quot;emm386&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>, 0};
<a name="l01026"></a>01026     <span class="keyword">const</span> <span class="keywordtype">char</span>* irqsgus[] = { <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, <span class="stringliteral">&quot;9&quot;</span>, <span class="stringliteral">&quot;10&quot;</span>, <span class="stringliteral">&quot;11&quot;</span>, <span class="stringliteral">&quot;12&quot;</span>, 0 };
<a name="l01027"></a>01027     <span class="keyword">const</span> <span class="keywordtype">char</span>* irqssb[] = { <span class="stringliteral">&quot;7&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;9&quot;</span>, <span class="stringliteral">&quot;10&quot;</span>, <span class="stringliteral">&quot;11&quot;</span>, <span class="stringliteral">&quot;12&quot;</span>, 0 };
<a name="l01028"></a>01028     <span class="keyword">const</span> <span class="keywordtype">char</span>* dmasgus[] = { <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, 0 };
<a name="l01029"></a>01029     <span class="keyword">const</span> <span class="keywordtype">char</span>* dmassb[] = { <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, 0 };
<a name="l01030"></a>01030     <span class="keyword">const</span> <span class="keywordtype">char</span>* oplemus[] = { <span class="stringliteral">&quot;default&quot;</span>, <span class="stringliteral">&quot;compat&quot;</span>, <span class="stringliteral">&quot;fast&quot;</span>, <span class="stringliteral">&quot;nuked&quot;</span>, <span class="stringliteral">&quot;mame&quot;</span>, 0 };
<a name="l01031"></a>01031     <span class="keyword">const</span> <span class="keywordtype">char</span> *qualityno[] = { <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, 0 };
<a name="l01032"></a>01032     <span class="keyword">const</span> <span class="keywordtype">char</span>* tandys[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, 0};
<a name="l01033"></a>01033     <span class="keyword">const</span> <span class="keywordtype">char</span>* ps1opt[] = { <span class="stringliteral">&quot;on&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, 0};
<a name="l01034"></a>01034     <span class="keyword">const</span> <span class="keywordtype">char</span>* truefalseautoopt[] = { <span class="stringliteral">&quot;true&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>, 0};
<a name="l01035"></a>01035     <span class="keyword">const</span> <span class="keywordtype">char</span>* pc98fmboards[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>, <span class="stringliteral">&quot;board26k&quot;</span>, <span class="stringliteral">&quot;board86&quot;</span>, <span class="stringliteral">&quot;board86c&quot;</span>, 0};
<a name="l01036"></a>01036     <span class="keyword">const</span> <span class="keywordtype">char</span>* pc98videomodeopt[] = { <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;24khz&quot;</span>, <span class="stringliteral">&quot;31khz&quot;</span>, <span class="stringliteral">&quot;15khz&quot;</span>, 0};
<a name="l01037"></a>01037     <span class="keyword">const</span> <span class="keywordtype">char</span>* aspectmodes[] = { <span class="stringliteral">&quot;false&quot;</span>, <span class="stringliteral">&quot;true&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;yes&quot;</span>, <span class="stringliteral">&quot;no&quot;</span>, <span class="stringliteral">&quot;nearest&quot;</span>, <span class="stringliteral">&quot;bilinear&quot;</span>, 0};
<a name="l01038"></a>01038     <span class="keyword">const</span> <span class="keywordtype">char</span> *vga_ac_mapping_settings[] = { <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;4x4&quot;</span>, <span class="stringliteral">&quot;4low&quot;</span>, <span class="stringliteral">&quot;first16&quot;</span>, 0 };
<a name="l01039"></a>01039 
<a name="l01040"></a>01040     <span class="keyword">const</span> <span class="keywordtype">char</span>* irqhandler[] = {
<a name="l01041"></a>01041         <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;simple&quot;</span>, <span class="stringliteral">&quot;cooperative_2nd&quot;</span>, 0 };
<a name="l01042"></a>01042 
<a name="l01043"></a>01043     <span class="comment">/* Setup all the different modules making up DOSBox */</span>
<a name="l01044"></a>01044     <span class="keyword">const</span> <span class="keywordtype">char</span>* machines[] = {
<a name="l01045"></a>01045         <span class="stringliteral">&quot;hercules&quot;</span>, <span class="stringliteral">&quot;cga&quot;</span>, <span class="stringliteral">&quot;cga_mono&quot;</span>, <span class="stringliteral">&quot;cga_rgb&quot;</span>, <span class="stringliteral">&quot;cga_composite&quot;</span>, <span class="stringliteral">&quot;cga_composite2&quot;</span>, <span class="stringliteral">&quot;tandy&quot;</span>, <span class="stringliteral">&quot;pcjr&quot;</span>, <span class="stringliteral">&quot;ega&quot;</span>,
<a name="l01046"></a>01046         <span class="stringliteral">&quot;vgaonly&quot;</span>, <span class="stringliteral">&quot;svga_s3&quot;</span>, <span class="stringliteral">&quot;svga_et3000&quot;</span>, <span class="stringliteral">&quot;svga_et4000&quot;</span>,
<a name="l01047"></a>01047         <span class="stringliteral">&quot;svga_paradise&quot;</span>, <span class="stringliteral">&quot;vesa_nolfb&quot;</span>, <span class="stringliteral">&quot;vesa_oldvbe&quot;</span>, <span class="stringliteral">&quot;amstrad&quot;</span>, <span class="stringliteral">&quot;pc98&quot;</span>, <span class="stringliteral">&quot;pc9801&quot;</span>, <span class="stringliteral">&quot;pc9821&quot;</span>,
<a name="l01048"></a>01048 
<a name="l01049"></a>01049         <span class="stringliteral">&quot;fm_towns&quot;</span>, <span class="comment">// STUB</span>
<a name="l01050"></a>01050 
<a name="l01051"></a>01051         <span class="stringliteral">&quot;mcga&quot;</span>, <span class="stringliteral">&quot;mda&quot;</span>,
<a name="l01052"></a>01052 
<a name="l01053"></a>01053         0 };
<a name="l01054"></a>01054 
<a name="l01055"></a>01055     <span class="keyword">const</span> <span class="keywordtype">char</span>* scalers[] = { 
<a name="l01056"></a>01056         <span class="stringliteral">&quot;none&quot;</span>, <span class="stringliteral">&quot;normal2x&quot;</span>, <span class="stringliteral">&quot;normal3x&quot;</span>, <span class="stringliteral">&quot;normal4x&quot;</span>, <span class="stringliteral">&quot;normal5x&quot;</span>,
<a name="l01057"></a>01057 <span class="preprocessor">#if RENDER_USE_ADVANCED_SCALERS&gt;2</span>
<a name="l01058"></a>01058 <span class="preprocessor"></span>        <span class="stringliteral">&quot;advmame2x&quot;</span>, <span class="stringliteral">&quot;advmame3x&quot;</span>, <span class="stringliteral">&quot;advinterp2x&quot;</span>, <span class="stringliteral">&quot;advinterp3x&quot;</span>, <span class="stringliteral">&quot;hq2x&quot;</span>, <span class="stringliteral">&quot;hq3x&quot;</span>, <span class="stringliteral">&quot;2xsai&quot;</span>, <span class="stringliteral">&quot;super2xsai&quot;</span>, <span class="stringliteral">&quot;supereagle&quot;</span>,
<a name="l01059"></a>01059 <span class="preprocessor">#endif</span>
<a name="l01060"></a>01060 <span class="preprocessor"></span><span class="preprocessor">#if RENDER_USE_ADVANCED_SCALERS&gt;0</span>
<a name="l01061"></a>01061 <span class="preprocessor"></span>        <span class="stringliteral">&quot;tv2x&quot;</span>, <span class="stringliteral">&quot;tv3x&quot;</span>, <span class="stringliteral">&quot;rgb2x&quot;</span>, <span class="stringliteral">&quot;rgb3x&quot;</span>, <span class="stringliteral">&quot;scan2x&quot;</span>, <span class="stringliteral">&quot;scan3x&quot;</span>, <span class="stringliteral">&quot;gray&quot;</span>, <span class="stringliteral">&quot;gray2x&quot;</span>,
<a name="l01062"></a>01062 <span class="preprocessor">#endif</span>
<a name="l01063"></a>01063 <span class="preprocessor"></span>        <span class="stringliteral">&quot;hardware_none&quot;</span>, <span class="stringliteral">&quot;hardware2x&quot;</span>, <span class="stringliteral">&quot;hardware3x&quot;</span>, <span class="stringliteral">&quot;hardware4x&quot;</span>, <span class="stringliteral">&quot;hardware5x&quot;</span>,
<a name="l01064"></a>01064 <span class="preprocessor">#if C_XBRZ</span>
<a name="l01065"></a>01065 <span class="preprocessor"></span>        <span class="stringliteral">&quot;xbrz&quot;</span>, <span class="stringliteral">&quot;xbrz_bilinear&quot;</span>,
<a name="l01066"></a>01066 <span class="preprocessor">#endif</span>
<a name="l01067"></a>01067 <span class="preprocessor"></span>        0 };
<a name="l01068"></a>01068 
<a name="l01069"></a>01069     <span class="keyword">const</span> <span class="keywordtype">char</span>* cores[] = { <span class="stringliteral">&quot;auto&quot;</span>,
<a name="l01070"></a>01070 <span class="preprocessor">#if (C_DYNAMIC_X86) || (C_DYNREC)</span>
<a name="l01071"></a>01071 <span class="preprocessor"></span>        <span class="stringliteral">&quot;dynamic&quot;</span>,
<a name="l01072"></a>01072 <span class="preprocessor">#endif</span>
<a name="l01073"></a>01073 <span class="preprocessor"></span>        <span class="stringliteral">&quot;normal&quot;</span>, <span class="stringliteral">&quot;full&quot;</span>, <span class="stringliteral">&quot;simple&quot;</span>, 0 };
<a name="l01074"></a>01074 
<a name="l01075"></a>01075     <span class="keyword">const</span> <span class="keywordtype">char</span>* voodoo_settings[] = {
<a name="l01076"></a>01076         <span class="stringliteral">&quot;false&quot;</span>,
<a name="l01077"></a>01077         <span class="stringliteral">&quot;software&quot;</span>,
<a name="l01078"></a>01078 <span class="preprocessor">#if C_OPENGL</span>
<a name="l01079"></a>01079 <span class="preprocessor"></span>        <span class="stringliteral">&quot;opengl&quot;</span>,
<a name="l01080"></a>01080 <span class="preprocessor">#endif</span>
<a name="l01081"></a>01081 <span class="preprocessor"></span>        <span class="stringliteral">&quot;auto&quot;</span>,
<a name="l01082"></a>01082         0
<a name="l01083"></a>01083     };
<a name="l01084"></a>01084 
<a name="l01085"></a>01085 <span class="preprocessor">#if defined(__SSE__) &amp;&amp; !defined(_M_AMD64) &amp;&amp; !defined(EMSCRIPTEN)</span>
<a name="l01086"></a>01086 <span class="preprocessor"></span>    CheckSSESupport();
<a name="l01087"></a>01087 <span class="preprocessor">#endif</span>
<a name="l01088"></a>01088 <span class="preprocessor"></span>    SDLNetInited = <span class="keyword">false</span>;
<a name="l01089"></a>01089 
<a name="l01090"></a>01090     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;dosbox&quot;</span>,&amp;Null_Init);
<a name="l01091"></a>01091     Pstring = secprop-&gt;Add_path(<span class="stringliteral">&quot;language&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01092"></a>01092     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Select another language file.&quot;</span>);
<a name="l01093"></a>01093 
<a name="l01094"></a>01094     Pstring = secprop-&gt;Add_path(<span class="stringliteral">&quot;title&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01095"></a>01095     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Additional text to place in the title bar of the window&quot;</span>);
<a name="l01096"></a>01096 
<a name="l01097"></a>01097     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable 8-bit dac&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l01098"></a>01098     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow VESA BIOS calls in IBM PC mode to set DAC width. Has no effect in PC-98 mode.&quot;</span>);
<a name="l01099"></a>01099 
<a name="l01100"></a>01100 <span class="preprocessor">#if defined(MACOSX)</span>
<a name="l01101"></a>01101 <span class="preprocessor"></span>    <span class="comment">/* Let&#39;s make DPI aware OFF by default so Mac OS X users with Retina displays don&#39;t yell at us about eyestrain.</span>
<a name="l01102"></a>01102 <span class="comment">       They can turn it on in combination with a nice scaler when they want it. */</span>
<a name="l01103"></a>01103     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dpi aware&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l01104"></a>01104 <span class="preprocessor">#else</span>
<a name="l01105"></a>01105 <span class="preprocessor"></span>    Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dpi aware&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l01106"></a>01106 <span class="preprocessor">#endif</span>
<a name="l01107"></a>01107 <span class="preprocessor"></span>    Pbool-&gt;Set_help(<span class="stringliteral">&quot;Set this option (on by default) to indicate to your OS that DOSBox is DPI aware.\n&quot;</span>
<a name="l01108"></a>01108             <span class="stringliteral">&quot;If it is not set, Windows Vista/7/8/10 and higher may upscale the DOSBox window\n&quot;</span>
<a name="l01109"></a>01109             <span class="stringliteral">&quot;on higher resolution monitors which is probably not what you want.&quot;</span>);
<a name="l01110"></a>01110 
<a name="l01111"></a>01111     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;keyboard hook&quot;</span>, Property::Changeable::Always, <span class="keyword">false</span>);
<a name="l01112"></a>01112     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Use keyboard hook (currently only on Windows) to catch special keys and synchronize the keyboard LEDs with the host&quot;</span>);
<a name="l01113"></a>01113 
<a name="l01114"></a>01114     <span class="comment">// STUB OPTION, NOT YET FULLY IMPLEMENTED</span>
<a name="l01115"></a>01115     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;weitek&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01116"></a>01116     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate the Weitek coprocessor. This option only has effect if cputype=386 or cputype=486.&quot;</span>);
<a name="l01117"></a>01117 
<a name="l01118"></a>01118     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;bochs debug port e9&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01119"></a>01119     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate Bochs debug port E9h. ASCII text written to this I/O port is assumed to be debug output, and logged.&quot;</span>);
<a name="l01120"></a>01120 
<a name="l01121"></a>01121     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;machine&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;svga_s3&quot;</span>);
<a name="l01122"></a>01122     Pstring-&gt;Set_values(machines);
<a name="l01123"></a>01123     Pstring-&gt;Set_help(<span class="stringliteral">&quot;The type of machine DOSBox tries to emulate.&quot;</span>);
<a name="l01124"></a>01124 
<a name="l01125"></a>01125     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;svga lfb base&quot;</span>, Property::Changeable::OnlyAtStart, 0);
<a name="l01126"></a>01126     Phex-&gt;Set_help(<span class="stringliteral">&quot;If nonzero, define the physical memory address of the linear framebuffer.&quot;</span>);
<a name="l01127"></a>01127 
<a name="l01128"></a>01128     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pci vga&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01129"></a>01129     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, SVGA is emulated as if a PCI device (when enable pci bus=true)&quot;</span>);
<a name="l01130"></a>01130 
<a name="l01131"></a>01131     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vmemdelay&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01132"></a>01132     Pint-&gt;SetMinMax(-1,100000);
<a name="l01133"></a>01133     Pint-&gt;Set_help( <span class="stringliteral">&quot;VGA Memory I/O delay in nanoseconds. Set to -1 to use default, 0 to disable.\n&quot;</span>
<a name="l01134"></a>01134             <span class="stringliteral">&quot;Default off. Enable this option (-1 or nonzero) if you are running a game or\n&quot;</span>
<a name="l01135"></a>01135             <span class="stringliteral">&quot;demo that needs slower VGA memory (like that of older ISA hardware) to work properly.\n&quot;</span>
<a name="l01136"></a>01136             <span class="stringliteral">&quot;If your game is not sensitive to VGA RAM I/O speed, then turning on this option\n&quot;</span>
<a name="l01137"></a>01137             <span class="stringliteral">&quot;will do nothing but cause a significant drop in frame rate which is probably not\n&quot;</span>
<a name="l01138"></a>01138             <span class="stringliteral">&quot;what you want. Recommended values -1, 0 to 2000.&quot;</span>);
<a name="l01139"></a>01139 
<a name="l01140"></a>01140     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vmemsize&quot;</span>, Property::Changeable::WhenIdle,2);
<a name="l01141"></a>01141     Pint-&gt;SetMinMax(0,8);
<a name="l01142"></a>01142     Pint-&gt;Set_help(
<a name="l01143"></a>01143         <span class="stringliteral">&quot;Amount of video memory in megabytes.\n&quot;</span>
<a name="l01144"></a>01144         <span class="stringliteral">&quot;  The maximum resolution and color depth the svga_s3 will be able to display\n&quot;</span>
<a name="l01145"></a>01145         <span class="stringliteral">&quot;  is determined by this value.\n &quot;</span>
<a name="l01146"></a>01146         <span class="stringliteral">&quot;  0: 512k (800x600  at 256 colors)\n&quot;</span>
<a name="l01147"></a>01147         <span class="stringliteral">&quot;  1: 1024x768  at 256 colors or 800x600  at 64k colors\n&quot;</span>
<a name="l01148"></a>01148         <span class="stringliteral">&quot;  2: 1600x1200 at 256 colors or 1024x768 at 64k colors or 640x480 at 16M colors\n&quot;</span>
<a name="l01149"></a>01149         <span class="stringliteral">&quot;  4: 1600x1200 at 64k colors or 1024x768 at 16M colors\n&quot;</span>
<a name="l01150"></a>01150         <span class="stringliteral">&quot;  8: up to 1600x1200 at 16M colors\n&quot;</span>
<a name="l01151"></a>01151         <span class="stringliteral">&quot;For build engine games, use more memory than in the list above so it can\n&quot;</span>
<a name="l01152"></a>01152         <span class="stringliteral">&quot;use triple buffering and thus won&#39;t flicker.\n&quot;</span>
<a name="l01153"></a>01153         );
<a name="l01154"></a>01154 
<a name="l01155"></a>01155     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vmemsizekb&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01156"></a>01156     Pint-&gt;SetMinMax(0,8);
<a name="l01157"></a>01157     Pint-&gt;Set_help(
<a name="l01158"></a>01158         <span class="stringliteral">&quot;Amount of video memory in kilobytes, in addition to vmemsize&quot;</span>);
<a name="l01159"></a>01159 
<a name="l01160"></a>01160     Pstring = secprop-&gt;Add_path(<span class="stringliteral">&quot;captures&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;capture&quot;</span>);
<a name="l01161"></a>01161     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Directory where things like wave, midi, screenshot get captured.&quot;</span>);
<a name="l01162"></a>01162 
<a name="l01163"></a>01163     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;capture chroma format&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01164"></a>01164     Pstring-&gt;Set_values(capturechromaformats);
<a name="l01165"></a>01165     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Chroma format to use when capturing to H.264. &#39;auto&#39; picks the best quality option.\n&quot;</span>
<a name="l01166"></a>01166             <span class="stringliteral">&quot;4:4:4       Chroma is at full resolution. This provides the best quality, however not widely supported by editing software.\n&quot;</span>
<a name="l01167"></a>01167             <span class="stringliteral">&quot;4:2:2       Chroma is at half horizontal resolution.\n&quot;</span>
<a name="l01168"></a>01168             <span class="stringliteral">&quot;4:2:0       Chroma is at quarter resolution, which may cause minor color smearing.\n&quot;</span>
<a name="l01169"></a>01169             <span class="stringliteral">&quot;            However, this chroma format is most likely to be compatible with video editing software.&quot;</span>);
<a name="l01170"></a>01170 
<a name="l01171"></a>01171     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;capture format&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l01172"></a>01172     Pstring-&gt;Set_values(captureformats);
<a name="l01173"></a>01173     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Capture format to use when capturing video. The availability of the format depends on how DOSBox-X was compiled.\n&quot;</span>
<a name="l01174"></a>01174             <span class="stringliteral">&quot;default                     Use compiled-in default (avi-zmbv)\n&quot;</span>
<a name="l01175"></a>01175             <span class="stringliteral">&quot;avi-zmbv                    Use DOSBox-style AVI + ZMBV codec with PCM audio\n&quot;</span>
<a name="l01176"></a>01176             <span class="stringliteral">&quot;mpegts-h264                 Use MPEG transport stream + H.264 + AAC audio. Resolution &amp; refresh rate changes can be contained\n&quot;</span>
<a name="l01177"></a>01177             <span class="stringliteral">&quot;                            within one file with this choice, however not all software can support mid-stream format changes.&quot;</span>);
<a name="l01178"></a>01178 
<a name="l01179"></a>01179     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;shell environment size&quot;</span>,Property::Changeable::OnlyAtStart,0);
<a name="l01180"></a>01180     Pint-&gt;SetMinMax(0,65280);
<a name="l01181"></a>01181     Pint-&gt;Set_help(<span class="stringliteral">&quot;Size of the initial DOSBox shell environment block, in bytes. This does not affect the environment block of sub-processes spawned from the shell.\n&quot;</span>
<a name="l01182"></a>01182             <span class="stringliteral">&quot;This option has no effect unless dynamic kernel allocation is enabled.&quot;</span>);
<a name="l01183"></a>01183 
<a name="l01184"></a>01184     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;private area size&quot;</span>,Property::Changeable::OnlyAtStart,32768); <span class="comment">// DOSBox mainline compatible 32KB region</span>
<a name="l01185"></a>01185     Pint-&gt;SetMinMax(16,128*1024);
<a name="l01186"></a>01186     Pint-&gt;Set_help(<span class="stringliteral">&quot;Set DOSBox-X private memory area size. This area contains private memory structures used by the DOS kernel.\n&quot;</span>
<a name="l01187"></a>01187             <span class="stringliteral">&quot;It is discarded when you boot into another OS. Mainline DOSBox uses 32KB. Testing shows that it is possible\n&quot;</span>
<a name="l01188"></a>01188             <span class="stringliteral">&quot;to run DOSBox with as little as 4KB. If DOSBox-X aborts with error \&quot;not enough memory for internal tables\&quot;\n&quot;</span>
<a name="l01189"></a>01189             <span class="stringliteral">&quot;then you need to increase this value.&quot;</span>);
<a name="l01190"></a>01190 
<a name="l01191"></a>01191     <span class="comment">// NOTE: This will be revised as I test the DOSLIB code against more VGA/SVGA hardware!</span>
<a name="l01192"></a>01192     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;vga attribute controller mapping&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01193"></a>01193     Pstring-&gt;Set_values(vga_ac_mapping_settings);
<a name="l01194"></a>01194     Pstring-&gt;Set_help(
<a name="l01195"></a>01195             <span class="stringliteral">&quot;This affects how the attribute controller maps colors, especially in 256-color mode.\n&quot;</span>
<a name="l01196"></a>01196             <span class="stringliteral">&quot;Some SVGA cards handle the attribute controller palette differently than most SVGA cards.\n&quot;</span>
<a name="l01197"></a>01197             <span class="stringliteral">&quot;  auto                         Automatically pick the mapping based on the SVGA chipset.\n&quot;</span>
<a name="l01198"></a>01198             <span class="stringliteral">&quot;  4x4                          Split into two 4-bit nibbles, map through AC, recombine. This is standard VGA behavior including clone SVGA cards.\n&quot;</span>
<a name="l01199"></a>01199             <span class="stringliteral">&quot;  4low                         Split into two 4-bit nibbles, remap only the low 4 bits, recombine. This is standard ET4000 behavior.\n&quot;</span>
<a name="l01200"></a>01200             <span class="stringliteral">&quot;\n&quot;</span>
<a name="l01201"></a>01201             <span class="stringliteral">&quot;NOTES:\n&quot;</span>
<a name="l01202"></a>01202             <span class="stringliteral">&quot;  Demoscene executable &#39;COPPER.EXE&#39; requires the &#39;4low&#39; behavior in order to display line-fading effects\n&quot;</span>
<a name="l01203"></a>01203             <span class="stringliteral">&quot;  (including scrolling credits) correctly, else those parts of the demo show up as a blank screen.\n&quot;</span>
<a name="l01204"></a>01204             <span class="stringliteral">&quot;  \n&quot;</span>
<a name="l01205"></a>01205             <span class="stringliteral">&quot;  4low behavior is default for ET4000 emulation.&quot;</span>);
<a name="l01206"></a>01206 
<a name="l01207"></a>01207     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;a20&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;mask&quot;</span>);
<a name="l01208"></a>01208     Pstring-&gt;Set_help(<span class="stringliteral">&quot;A20 gate emulation mode.\n&quot;</span>
<a name="l01209"></a>01209               <span class="stringliteral">&quot;The on/off/on_fake/off_fake options are intended for testing and debugging DOS development,\n&quot;</span>
<a name="l01210"></a>01210               <span class="stringliteral">&quot;or to emulate obscure hardware, or to work around potential extended memory problems with DOS programs.\n&quot;</span>
<a name="l01211"></a>01211               <span class="stringliteral">&quot;on_fake/off_fake are intended to test whether a program carries out a memory test to ensure the A20\n&quot;</span>
<a name="l01212"></a>01212               <span class="stringliteral">&quot;gate is set as intended (as HIMEM.SYS does). If it goes by the gate bit alone, it WILL crash.\n&quot;</span>
<a name="l01213"></a>01213               <span class="stringliteral">&quot;This parameter is also changeable from the builtin A20GATE command.\n&quot;</span>
<a name="l01214"></a>01214               <span class="stringliteral">&quot;  fast                         Emulate A20 gating by remapping the first 64KB @ 1MB boundary (fast, mainline DOSBox behavior)\n&quot;</span>
<a name="l01215"></a>01215               <span class="stringliteral">&quot;  mask                         Emulate A20 gating by masking memory I/O address (accurate)\n&quot;</span>
<a name="l01216"></a>01216               <span class="stringliteral">&quot;  off                          Lock A20 gate off (Software/OS cannot enable A20)\n&quot;</span>
<a name="l01217"></a>01217               <span class="stringliteral">&quot;  on                           Lock A20 gate on (Software/OS cannot disable A20)\n&quot;</span>
<a name="l01218"></a>01218               <span class="stringliteral">&quot;  off_fake                     Lock A20 gate off but allow bit to toggle (hope your DOS game tests the HMA!)\n&quot;</span>
<a name="l01219"></a>01219               <span class="stringliteral">&quot;  on_fake                      Lock A20 gate on but allow bit to toggle&quot;</span>);
<a name="l01220"></a>01220 
<a name="l01221"></a>01221     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;turn off a20 gate on boot&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01222"></a>01222     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If enabled, A20 gate is switched off when booting a guest OS.\n&quot;</span>
<a name="l01223"></a>01223                     <span class="stringliteral">&quot;Enabled by default. Recommended for MS-DOS when HIMEM.SYS is not installed in the guest OS.\n&quot;</span>
<a name="l01224"></a>01224                     <span class="stringliteral">&quot;If disabled, and MS-DOS does not load HIMEM.SYS, programs and features that rely on the 1MB wraparound will fail.&quot;</span>);
<a name="l01225"></a>01225 
<a name="l01226"></a>01226     <span class="comment">/* Ref:</span>
<a name="l01227"></a>01227 <span class="comment">     *</span>
<a name="l01228"></a>01228 <span class="comment">     * &quot;Except the first generation, which C-Bus was synchronous with its 5MHz 8086, PC-98s</span>
<a name="l01229"></a>01229 <span class="comment">     *  before the age of SuperIO and PCI use either 10MHz (9.8304MHz) or 8MHz (7.9872MHz)</span>
<a name="l01230"></a>01230 <span class="comment">     *  for its C-Bus.</span>
<a name="l01231"></a>01231 <span class="comment">     * </span>
<a name="l01232"></a>01232 <span class="comment">     *  It&#39;s determined by the CPU clock base (2.4756Mhz or 1.9968MHz). For example, on a</span>
<a name="l01233"></a>01233 <span class="comment">     *  16MHz 386, C-Bus runs at 8MHz and on a 25MHz 386, C-Bus runs at 10MHz.</span>
<a name="l01234"></a>01234 <span class="comment">     *</span>
<a name="l01235"></a>01235 <span class="comment">     *  After NEC brought SuperIO and PCI to PC-98, C-Bus clock no longer ties to the CPU</span>
<a name="l01236"></a>01236 <span class="comment">     *  oscillator and got fixed to 10MHz.&quot; -Yksoft1</span>
<a name="l01237"></a>01237 <span class="comment">     *</span>
<a name="l01238"></a>01238 <span class="comment">     * Assuming this is true, the selection is given below */</span>
<a name="l01239"></a>01239 
<a name="l01240"></a>01240     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;cbus bus clock&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;std10&quot;</span>);
<a name="l01241"></a>01241     Pstring-&gt;Set_help(<span class="stringliteral">&quot;C-BUS BCLK frequency (PC-98), used to emulate I/O delay.\n&quot;</span>
<a name="l01242"></a>01242               <span class="stringliteral">&quot;WARNING: In future revisions, PCI/motherboard chipset emulation will allow the guest OS/program to alter this value at runtime.\n&quot;</span>
<a name="l01243"></a>01243               <span class="stringliteral">&quot;  std10                        10MHz (CPU speed multiple of 5MHz or PCI-based)\n&quot;</span>
<a name="l01244"></a>01244               <span class="stringliteral">&quot;  std8                         8MHz (CPU speed multiple of 4MHz)\n&quot;</span>
<a name="l01245"></a>01245               <span class="stringliteral">&quot;  std5                         5MHz (older PC-9801)\n&quot;</span>
<a name="l01246"></a>01246               <span class="stringliteral">&quot;  &lt;integer or float&gt;           Any integer or floating point value will be used as the clock frequency in Hz\n&quot;</span>
<a name="l01247"></a>01247               <span class="stringliteral">&quot;  &lt;integer/integer ratio&gt;      If a ratio is given (num/den), the ratio will be used as the clock frequency&quot;</span>);
<a name="l01248"></a>01248 
<a name="l01249"></a>01249     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;isa bus clock&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;std8.3&quot;</span>);
<a name="l01250"></a>01250     Pstring-&gt;Set_help(<span class="stringliteral">&quot;ISA BCLK frequency, used to emulate I/O delay.\n&quot;</span>
<a name="l01251"></a>01251               <span class="stringliteral">&quot;WARNING: In future revisions, PCI/motherboard chipset emulation will allow the guest OS/program to alter this value at runtime.\n&quot;</span>
<a name="l01252"></a>01252               <span class="stringliteral">&quot;  std8.3                       8.333MHz (typical 386-class or higher)\n&quot;</span>
<a name="l01253"></a>01253               <span class="stringliteral">&quot;  std8                         8MHz\n&quot;</span>
<a name="l01254"></a>01254               <span class="stringliteral">&quot;  std6                         6MHz\n&quot;</span>
<a name="l01255"></a>01255               <span class="stringliteral">&quot;  std4.77                      4.77MHz (precisely 1/3 x 14.31818MHz). Bus frequency of older PC/XT systems.\n&quot;</span>
<a name="l01256"></a>01256               <span class="stringliteral">&quot;  oc10                         10MHz\n&quot;</span>
<a name="l01257"></a>01257               <span class="stringliteral">&quot;  oc12                         12MHz\n&quot;</span>
<a name="l01258"></a>01258               <span class="stringliteral">&quot;  oc15                         15MHz\n&quot;</span>
<a name="l01259"></a>01259               <span class="stringliteral">&quot;  oc16                         16MHz\n&quot;</span>
<a name="l01260"></a>01260               <span class="stringliteral">&quot;  &lt;integer or float&gt;           Any integer or floating point value will be used as the clock frequency in Hz\n&quot;</span>
<a name="l01261"></a>01261               <span class="stringliteral">&quot;  &lt;integer/integer ratio&gt;      If a ratio is given (num/den), the ratio will be used as the clock frequency&quot;</span>);
<a name="l01262"></a>01262 
<a name="l01263"></a>01263     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;pci bus clock&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;std33.3&quot;</span>);
<a name="l01264"></a>01264     Pstring-&gt;Set_help(<span class="stringliteral">&quot;PCI bus frequency, used to emulate I/O delay.\n&quot;</span>
<a name="l01265"></a>01265               <span class="stringliteral">&quot;WARNING: In future revisions, PCI/motherboard chipset emulation will allow the guest OS/program to alter this value at runtime.\n&quot;</span>
<a name="l01266"></a>01266               <span class="stringliteral">&quot;  std33.3                      33.333MHz (very common setting on motherboards)\n&quot;</span>
<a name="l01267"></a>01267               <span class="stringliteral">&quot;  std30                        30MHz (some older mid-1990&#39;s Pentium systems)\n&quot;</span>
<a name="l01268"></a>01268               <span class="stringliteral">&quot;  std25                        25MHz\n&quot;</span>
<a name="l01269"></a>01269               <span class="stringliteral">&quot;  &lt;integer or float&gt;           Any integer or floating point value will be used as the clock frequency in Hz\n&quot;</span>
<a name="l01270"></a>01270               <span class="stringliteral">&quot;  &lt;integer/integer ratio&gt;      If a ratio is given (num/den), the ratio will be used as the clock frequency&quot;</span>);
<a name="l01271"></a>01271 
<a name="l01272"></a>01272     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;call binary on reset&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01273"></a>01273     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If set, this is the path of a binary blob to load into the ROM BIOS area and execute immediately after CPU reset.\n&quot;</span>
<a name="l01274"></a>01274                       <span class="stringliteral">&quot;It will be executed before the BIOS POST routine, only ONCE. The binary blob is expected either to IRET or to\n&quot;</span>
<a name="l01275"></a>01275                       <span class="stringliteral">&quot;jump directly to F000:FFF0 to return control to the BIOS.\n&quot;</span>
<a name="l01276"></a>01276                       <span class="stringliteral">&quot;This can be used for x86 assembly language experiments and automated testing against the CPU emulation.&quot;</span>);
<a name="l01277"></a>01277 
<a name="l01278"></a>01278     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;unhandled irq handler&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01279"></a>01279     Pstring-&gt;Set_values(irqhandler);
<a name="l01280"></a>01280     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Determines how unhandled IRQs are handled. This may help some errant DOS applications.\n&quot;</span>
<a name="l01281"></a>01281                       <span class="stringliteral">&quot;Leave unset for default behavior (simple).\n&quot;</span>
<a name="l01282"></a>01282                       <span class="stringliteral">&quot;simple               Acknowledge the IRQ, and the master (if slave IRQ)\n&quot;</span>
<a name="l01283"></a>01283                       <span class="stringliteral">&quot;mask_isr             Acknowledge IRQs in service on master and slave and mask IRQs still in service, to deal with errant handlers (em-dosbox method)&quot;</span>);
<a name="l01284"></a>01284 
<a name="l01285"></a>01285     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;call binary on boot&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01286"></a>01286     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If set, this is the path of a binary blob to load into the ROM BIOS area and execute immediately before booting the DOS system.\n&quot;</span>
<a name="l01287"></a>01287                       <span class="stringliteral">&quot;This can be used for x86 assembly language experiments and automated testing against the CPU emulation.&quot;</span>);
<a name="l01288"></a>01288 
<a name="l01289"></a>01289     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;rom bios allocation max&quot;</span>,Property::Changeable::OnlyAtStart,0);
<a name="l01290"></a>01290     Pint-&gt;SetMinMax(0,128);
<a name="l01291"></a>01291     Pint-&gt;Set_help(<span class="stringliteral">&quot;Maximum size (top down from 1MB) allowed for ROM BIOS dynamic allocation in KB&quot;</span>);
<a name="l01292"></a>01292 
<a name="l01293"></a>01293     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;rom bios minimum size&quot;</span>,Property::Changeable::OnlyAtStart,0);
<a name="l01294"></a>01294     Pint-&gt;SetMinMax(0,128);
<a name="l01295"></a>01295     Pint-&gt;Set_help(<span class="stringliteral">&quot;Once ROM BIOS layout is finalized, trim total region down to a minimum amount in KB&quot;</span>);
<a name="l01296"></a>01296 
<a name="l01297"></a>01297     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;irq delay ns&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01298"></a>01298     Pint-&gt;SetMinMax(-1,100000);
<a name="l01299"></a>01299     Pint-&gt;Set_help( <span class="stringliteral">&quot;IRQ delay in nanoseconds. Set to -1 to use default, 0 to disable.\n&quot;</span>
<a name="l01300"></a>01300                     <span class="stringliteral">&quot;This is a more precise version of the irqdelay= setting.\n&quot;</span>
<a name="l01301"></a>01301                     <span class="stringliteral">&quot;There are some old DOS games and demos that have race conditions with IRQs that need a nonzero value here to work properly.&quot;</span>);
<a name="l01302"></a>01302 
<a name="l01303"></a>01303     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;iodelay&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01304"></a>01304     Pint-&gt;SetMinMax(-1,100000);
<a name="l01305"></a>01305     Pint-&gt;Set_help( <span class="stringliteral">&quot;I/O delay in nanoseconds for I/O port access. Set to -1 to use default, 0 to disable.\n&quot;</span>
<a name="l01306"></a>01306             <span class="stringliteral">&quot;A value of 1000 (1us) is recommended for ISA bus type delays. If your game\n&quot;</span>
<a name="l01307"></a>01307             <span class="stringliteral">&quot;or demo is not sensitive to I/O port and ISA bus timing, you can turn this option off\n&quot;</span>
<a name="l01308"></a>01308             <span class="stringliteral">&quot;(set to 0) to increase game performance.&quot;</span>);
<a name="l01309"></a>01309 
<a name="l01310"></a>01310     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;iodelay16&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01311"></a>01311     Pint-&gt;SetMinMax(-1,100000);
<a name="l01312"></a>01312     Pint-&gt;Set_help( <span class="stringliteral">&quot;I/O delay for 16-bit transfers. -1 to use default, 0 to disable.&quot;</span>);
<a name="l01313"></a>01313 
<a name="l01314"></a>01314     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;iodelay32&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01315"></a>01315     Pint-&gt;SetMinMax(-1,100000);
<a name="l01316"></a>01316     Pint-&gt;Set_help( <span class="stringliteral">&quot;I/O delay for 32-bit transfers. -1 to use default, 0 to disable.&quot;</span>);
<a name="l01317"></a>01317 
<a name="l01318"></a>01318     <span class="comment">// STUB OPTION, NOT YET FULLY IMPLEMENTED</span>
<a name="l01319"></a>01319     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;acpi&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l01320"></a>01320     Pstring-&gt;Set_values(acpisettings);
<a name="l01321"></a>01321     Pstring-&gt;Set_help(<span class="stringliteral">&quot;ACPI emulation, and what version of the specification to follow.\n&quot;</span>
<a name="l01322"></a>01322             <span class="stringliteral">&quot;WARNING: This option is very experimental at this time and should not be enabled unless you&#39;re willing to accept the consequences.\n&quot;</span>
<a name="l01323"></a>01323             <span class="stringliteral">&quot;         Intended for use with ACPI-aware OSes including Linux and Windows 98/ME. This option will also slightly reduce available\n&quot;</span>
<a name="l01324"></a>01324             <span class="stringliteral">&quot;         system memory to make room for the ACPI tables, just as real BIOSes do, and reserve an IRQ for ACPI functions.&quot;</span>);
<a name="l01325"></a>01325 
<a name="l01326"></a>01326     <span class="comment">// STUB OPTION, NOT YET FULLY IMPLEMENTED</span>
<a name="l01327"></a>01327     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;acpi rsd ptr location&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01328"></a>01328     Pstring-&gt;Set_values(acpi_rsd_ptr_settings);
<a name="l01329"></a>01329     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Where to store the Root System Description Pointer structure. You can have it stored in the ROM BIOS area, or the Extended Bios Data Area.&quot;</span>);
<a name="l01330"></a>01330 
<a name="l01331"></a>01331     <span class="comment">// STUB OPTION, NOT YET FULLY IMPLEMENTED</span>
<a name="l01332"></a>01332     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;acpi sci irq&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01333"></a>01333     Pint-&gt;Set_help(<span class="stringliteral">&quot;IRQ to assign as ACPI system control interrupt. set to -1 to automatically assign.&quot;</span>);
<a name="l01334"></a>01334 
<a name="l01335"></a>01335     <span class="comment">// STUB OPTION, NOT YET FULLY IMPLEMENTED</span>
<a name="l01336"></a>01336     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;acpi iobase&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l01337"></a>01337     Phex-&gt;Set_help(<span class="stringliteral">&quot;I/O port base for the ACPI device Power Management registers. Set to 0 for automatic assignment.&quot;</span>);
<a name="l01338"></a>01338 
<a name="l01339"></a>01339     <span class="comment">// STUB OPTION, NOT YET FULLY IMPLEMENTED</span>
<a name="l01340"></a>01340     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;acpi reserved size&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01341"></a>01341     Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of memory at top to reserve for ACPI structures and tables. Set to 0 for automatic assignment.&quot;</span>);
<a name="l01342"></a>01342 
<a name="l01343"></a>01343 <span class="preprocessor">#if defined(C_EMSCRIPTEN)</span>
<a name="l01344"></a>01344 <span class="preprocessor"></span>    Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;memsize&quot;</span>, Property::Changeable::WhenIdle,4);
<a name="l01345"></a>01345 <span class="preprocessor">#else</span>
<a name="l01346"></a>01346 <span class="preprocessor"></span>    Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;memsize&quot;</span>, Property::Changeable::WhenIdle,16);
<a name="l01347"></a>01347 <span class="preprocessor">#endif</span>
<a name="l01348"></a>01348 <span class="preprocessor"></span>    Pint-&gt;SetMinMax(1,3584); <span class="comment">// 3.5GB</span>
<a name="l01349"></a>01349     Pint-&gt;Set_help(
<a name="l01350"></a>01350         <span class="stringliteral">&quot;Amount of memory DOSBox has in megabytes.\n&quot;</span>
<a name="l01351"></a>01351         <span class="stringliteral">&quot;This value is best left at its default to avoid problems with some games,\n&quot;</span>
<a name="l01352"></a>01352         <span class="stringliteral">&quot;though few games might require a higher value.\n&quot;</span>
<a name="l01353"></a>01353         <span class="stringliteral">&quot;There is generally no speed advantage when raising this value.n&quot;</span>
<a name="l01354"></a>01354         <span class="stringliteral">&quot;Programs that use 286 protected mode like Windows 3.0 in Standard Mode may crash with more than 15MB.&quot;</span>);
<a name="l01355"></a>01355 
<a name="l01356"></a>01356     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;memsizekb&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01357"></a>01357     Pint-&gt;SetMinMax(0,524288);
<a name="l01358"></a>01358     Pint-&gt;Set_help(
<a name="l01359"></a>01359         <span class="stringliteral">&quot;Amount of memory DOSBox has in kilobytes.\n&quot;</span>
<a name="l01360"></a>01360         <span class="stringliteral">&quot;This value should normally be set to 0.\n&quot;</span>
<a name="l01361"></a>01361         <span class="stringliteral">&quot;If nonzero, it is added to the memsize parameter.\n&quot;</span>
<a name="l01362"></a>01362         <span class="stringliteral">&quot;Finer grained control of total memory may be useful in\n&quot;</span>
<a name="l01363"></a>01363         <span class="stringliteral">&quot;emulating ancient DOS machines with less than 640KB of\n&quot;</span>
<a name="l01364"></a>01364         <span class="stringliteral">&quot;RAM or early 386 systems with odd extended memory sizes.&quot;</span>);
<a name="l01365"></a>01365 
<a name="l01366"></a>01366     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dos mem limit&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01367"></a>01367     Pint-&gt;SetMinMax(0,1023);
<a name="l01368"></a>01368     Pint-&gt;Set_help( <span class="stringliteral">&quot;Limit DOS conventional memory to this amount. Does not affect extended memory.\n&quot;</span>
<a name="l01369"></a>01369             <span class="stringliteral">&quot;Setting this option to a value in the range 636-639 can be used to simulate modern BIOSes\n&quot;</span>
<a name="l01370"></a>01370             <span class="stringliteral">&quot;that maintain an EBDA (Extended BIOS Data Area) at the top of conventional memory.\n&quot;</span>
<a name="l01371"></a>01371             <span class="stringliteral">&quot;You may also play with this option for diagnostic purposes or to stress test DOS programs in limited memory setups.\n&quot;</span>
<a name="l01372"></a>01372             <span class="stringliteral">&quot;\n&quot;</span>
<a name="l01373"></a>01373             <span class="stringliteral">&quot;A few DOS games &amp; demos require this option to be set:\n&quot;</span>
<a name="l01374"></a>01374             <span class="stringliteral">&quot;     Majic 12 \&quot;Show\&quot;: If UMBs are enabled, set this option to 639 to avoid MCB chain corruption error.&quot;</span>);
<a name="l01375"></a>01375 
<a name="l01376"></a>01376     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;isa memory hole at 512kb&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01377"></a>01377     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate an ISA memory hole at the 512KB to 640KB area (0x80000-0x9FFFF).&quot;</span>);
<a name="l01378"></a>01378 
<a name="l01379"></a>01379     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;reboot delay&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01380"></a>01380     Pint-&gt;SetMinMax(-1,10000);
<a name="l01381"></a>01381     Pint-&gt;Set_help(
<a name="l01382"></a>01382         <span class="stringliteral">&quot;Reboot delay. How long to pause at BIOS POST after reboot in milliseconds.\n&quot;</span>
<a name="l01383"></a>01383         <span class="stringliteral">&quot;This option is provided so that it is possible to see what the guest application\n&quot;</span>
<a name="l01384"></a>01384         <span class="stringliteral">&quot;or OS might have written to the screen before resetting the system. A value of\n&quot;</span>
<a name="l01385"></a>01385         <span class="stringliteral">&quot;-1 means to use a reasonable default.&quot;</span>);
<a name="l01386"></a>01386 
<a name="l01387"></a>01387     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;memalias&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01388"></a>01388     Pint-&gt;SetMinMax(0,32);
<a name="l01389"></a>01389     Pint-&gt;Set_help(
<a name="l01390"></a>01390         <span class="stringliteral">&quot;Memory aliasing emulation, in number of valid address bits.\n&quot;</span>
<a name="l01391"></a>01391         <span class="stringliteral">&quot;Many 386/486 class motherboards and processors prior to 1995\n&quot;</span>
<a name="l01392"></a>01392         <span class="stringliteral">&quot;suffered from memory aliasing for various technical reasons. If the software you are\n&quot;</span>
<a name="l01393"></a>01393         <span class="stringliteral">&quot;trying to run assumes aliasing, or otherwise plays cheap tricks with paging,\n&quot;</span>
<a name="l01394"></a>01394         <span class="stringliteral">&quot;enabling this option can help. Note that enabling this option can cause slight performance degredation. Set to 0 to disable.\n&quot;</span>
<a name="l01395"></a>01395         <span class="stringliteral">&quot;Recommended values when enabled:\n&quot;</span>
<a name="l01396"></a>01396         <span class="stringliteral">&quot;    24: 16MB aliasing. Common on 386SX systems (CPU had 24 external address bits)\n&quot;</span>
<a name="l01397"></a>01397         <span class="stringliteral">&quot;        or 386DX and 486 systems where the CPU communicated directly with the ISA bus (A24-A31 tied off)\n&quot;</span>
<a name="l01398"></a>01398         <span class="stringliteral">&quot;    26: 64MB aliasing. Some 486s had only 26 external address bits, some motherboards tied off A26-A31&quot;</span>);
<a name="l01399"></a>01399 
<a name="l01400"></a>01400     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 BIOS copyright string&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01401"></a>01401     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the PC-98 BIOS copyright string is placed at E800:0000. Enable this for software that detects PC-98 vs Epson.&quot;</span>);
<a name="l01402"></a>01402 
<a name="l01403"></a>01403     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 int 1b fdc timer wait&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01404"></a>01404     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 1Bh floppy access will wait for the timer to count down before returning.\n&quot;</span>
<a name="l01405"></a>01405                     <span class="stringliteral">&quot;This is needed for Ys II to run without crashing.&quot;</span>);
<a name="l01406"></a>01406 
<a name="l01407"></a>01407     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 pic init to read isr&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01408"></a>01408     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the programmable interrupt controllers are initialized by default (if PC-98 mode)\n&quot;</span>
<a name="l01409"></a>01409                     <span class="stringliteral">&quot;so that the in-service interrupt status can be read immediately. There seems to be a common\n&quot;</span>
<a name="l01410"></a>01410                     <span class="stringliteral">&quot;convention in PC-98 games to program and/or assume this mode for cooperative interrupt handling.\n&quot;</span>
<a name="l01411"></a>01411                     <span class="stringliteral">&quot;This option is enabled by default for best compatibility with PC-98 games.&quot;</span>);
<a name="l01412"></a>01412 
<a name="l01413"></a>01413     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;pc-98 fm board&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01414"></a>01414     Pstring-&gt;Set_values(pc98fmboards);
<a name="l01415"></a>01415     Pstring-&gt;Set_help(<span class="stringliteral">&quot;In PC-98 mode, selects the FM music board to emulate.&quot;</span>);
<a name="l01416"></a>01416 
<a name="l01417"></a>01417     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;pc-98 fm board irq&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01418"></a>01418     Pint-&gt;Set_help(<span class="stringliteral">&quot;If set, helps to determine the IRQ of the FM board. A setting of zero means to auto-determine the IRQ.&quot;</span>);
<a name="l01419"></a>01419 
<a name="l01420"></a>01420     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;pc-98 fm board io port&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01421"></a>01421     Phex-&gt;Set_help(<span class="stringliteral">&quot;If set, helps to determine the base I/O port of the FM board. A setting of zero means to auto-determine the port number.&quot;</span>);
<a name="l01422"></a>01422 
<a name="l01423"></a>01423     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 sound bios&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01424"></a>01424     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Set Sound BIOS enabled bit in MEMSW 4 for some games that require it.\n&quot;</span>
<a name="l01425"></a>01425                     <span class="stringliteral">&quot;TODO: Real emulation of PC-9801-26K/86 Sound BIOS&quot;</span>);
<a name="l01426"></a>01426 
<a name="l01427"></a>01427     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 load sound bios rom file&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01428"></a>01428     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, load SOUND.ROM if available and prsent that to the guest instead of trying to emulate directly.\n&quot;</span>
<a name="l01429"></a>01429                     <span class="stringliteral">&quot;This is strongly recommended, and is default enabled.\n&quot;</span>
<a name="l01430"></a>01430                     <span class="stringliteral">&quot;SOUND.ROM is a snapshot of the FM board BIOS taken from real PC-98 hardware.&quot;</span>);
<a name="l01431"></a>01431 
<a name="l01432"></a>01432     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 buffer page flip&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01433"></a>01433     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the game&#39;s request to page flip will be delayed to vertical retrace, which can eliminate tearline artifacts.\n&quot;</span>
<a name="l01434"></a>01434                     <span class="stringliteral">&quot;Note that this is NOT the behavior of actual hardware. This option is provided for the user&#39;s preference.&quot;</span>);
<a name="l01435"></a>01435 
<a name="l01436"></a>01436     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable 256-color planar&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01437"></a>01437     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow 256-color planar graphics mode if set, disable if not set.\n&quot;</span>
<a name="l01438"></a>01438                     <span class="stringliteral">&quot;This is a form of memory access in 256-color mode that existed for a short\n&quot;</span>
<a name="l01439"></a>01439                     <span class="stringliteral">&quot;time before later PC-9821 models removed it. This option must be enabled\n&quot;</span>
<a name="l01440"></a>01440                     <span class="stringliteral">&quot;to use DOSBox-X with Windows 3.1 and it&#39;s built-in 256-color driver.&quot;</span>);
<a name="l01441"></a>01441 
<a name="l01442"></a>01442     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable 256-color&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01443"></a>01443     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow 256-color graphics mode if set, disable if not set&quot;</span>);
<a name="l01444"></a>01444 
<a name="l01445"></a>01445     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable 16-color&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01446"></a>01446     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow 16-color graphics mode if set, disable if not set&quot;</span>);
<a name="l01447"></a>01447 
<a name="l01448"></a>01448     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable grcg&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01449"></a>01449     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow GRCG graphics functions if set, disable if not set&quot;</span>);
<a name="l01450"></a>01450 
<a name="l01451"></a>01451     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable egc&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01452"></a>01452     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow EGC graphics functions if set, disable if not set&quot;</span>);
<a name="l01453"></a>01453 
<a name="l01454"></a>01454     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable 188 user cg&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01455"></a>01455     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow 188+ user-defined CG cells if set&quot;</span>);
<a name="l01456"></a>01456 
<a name="l01457"></a>01457     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 start gdc at 5mhz&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01458"></a>01458     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start GDC at 5MHz if set, 2.5MHz if clear. May be required for some games.&quot;</span>);
<a name="l01459"></a>01459 
<a name="l01460"></a>01460     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 allow scanline effect&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01461"></a>01461     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, PC-98 emulation will allow the DOS application to enable the &#39;scanline effect&#39;\n&quot;</span>
<a name="l01462"></a>01462                     <span class="stringliteral">&quot;in 200-line graphics modes upconverted to 400-line raster display. When enabled, odd\n&quot;</span>
<a name="l01463"></a>01463                     <span class="stringliteral">&quot;numbered scanlines are blanked instead of doubled&quot;</span>);
<a name="l01464"></a>01464 
<a name="l01465"></a>01465     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 bus mouse&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01466"></a>01466     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable PC-98 bus mouse emulation. Disabling this option does not disable INT 33h emulation.&quot;</span>);
<a name="l01467"></a>01467 
<a name="l01468"></a>01468     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;pc-98 video mode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01469"></a>01469     Pstring-&gt;Set_values(pc98videomodeopt);
<a name="l01470"></a>01470     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Specify the preferred PC-98 video mode.\n&quot;</span>
<a name="l01471"></a>01471                       <span class="stringliteral">&quot;Valid values are 15, 24, or 31 for each specific horizontal refresh rate on the platform.\n&quot;</span>
<a name="l01472"></a>01472                       <span class="stringliteral">&quot;24khz is default and best supported at this time.\n&quot;</span>
<a name="l01473"></a>01473                       <span class="stringliteral">&quot;15khz is not implemented at this time.\n&quot;</span>
<a name="l01474"></a>01474                       <span class="stringliteral">&quot;31khz is experimental at this time.&quot;</span>);
<a name="l01475"></a>01475 
<a name="l01476"></a>01476     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;pc-98 timer master frequency&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01477"></a>01477     Pint-&gt;SetMinMax(0,2457600);
<a name="l01478"></a>01478     Pint-&gt;Set_help(<span class="stringliteral">&quot;8254 timer clock frequency (NEC PC-98). Depending on the CPU frequency the clock frequency is one of two common values.\n&quot;</span>
<a name="l01479"></a>01479                    <span class="stringliteral">&quot;If your setting is neither of the below the closest appropriate value will be chosen.\n&quot;</span>
<a name="l01480"></a>01480                    <span class="stringliteral">&quot;This setting affects the master clock rate that DOS applications must divide down from to program the timer\n&quot;</span>
<a name="l01481"></a>01481                    <span class="stringliteral">&quot;at the correct rate, which affects timer interrupt, PC speaker, and the COM1 RS-232C serial port baud rate.\n&quot;</span>
<a name="l01482"></a>01482                    <span class="stringliteral">&quot;8MHz is treated as an alias for 4MHz and 10MHz is treated as an alias for 5MHz.\n&quot;</span>
<a name="l01483"></a>01483                    <span class="stringliteral">&quot;    0: Use default (auto)\n&quot;</span>
<a name="l01484"></a>01484                    <span class="stringliteral">&quot;    4: 1.996MHz (as if 4MHz or multiple thereof CPU clock)\n&quot;</span>
<a name="l01485"></a>01485                    <span class="stringliteral">&quot;    5: 2.457MHz (as if 5MHz or multiple thereof CPU clock)&quot;</span>);
<a name="l01486"></a>01486 
<a name="l01487"></a>01487     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;pc-98 allow 4 display partition graphics&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01488"></a>01488     Pint-&gt;SetMinMax(-1,1);
<a name="l01489"></a>01489     Pint-&gt;Set_help(<span class="stringliteral">&quot;According to NEC graphics controller documentation, graphics mode is supposed to support only\n&quot;</span>
<a name="l01490"></a>01490                    <span class="stringliteral">&quot;2 display partitions. Some games rely on hardware flaws that allowed 4 partitions.\n&quot;</span>
<a name="l01491"></a>01491                    <span class="stringliteral">&quot;   -1: Default (choose automatically)\n&quot;</span>
<a name="l01492"></a>01492                    <span class="stringliteral">&quot;    0: Disable\n&quot;</span>
<a name="l01493"></a>01493                    <span class="stringliteral">&quot;    1: Enable&quot;</span>);
<a name="l01494"></a>01494 
<a name="l01495"></a>01495     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 force ibm keyboard layout&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01496"></a>01496     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Force to use a default keyboard layout like IBM US-English for PC-98 emulation.\n&quot;</span>
<a name="l01497"></a>01497                     <span class="stringliteral">&quot;Will only work with apps and games using BIOS for keyboard.&quot;</span>);
<a name="l01498"></a>01498 
<a name="l01499"></a>01499     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vga bios size override&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01500"></a>01500     Pint-&gt;SetMinMax(512,65536);
<a name="l01501"></a>01501     Pint-&gt;Set_help(<span class="stringliteral">&quot;VGA BIOS size override. Override the size of the VGA BIOS (normally 32KB in compatible or 12KB in non-compatible).&quot;</span>);
<a name="l01502"></a>01502 
<a name="l01503"></a>01503     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;video bios dont duplicate cga first half rom font&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01504"></a>01504     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, save 4KB of EGA/VGA ROM space by pointing to the copy in the ROM BIOS of the first 128 chars&quot;</span>);
<a name="l01505"></a>01505 
<a name="l01506"></a>01506     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;video bios always offer 14-pixel high rom font&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01507"></a>01507     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, video BIOS will always carry the 14-pixel ROM font. If clear, 14-pixel rom font will not be offered except for EGA/VGA emulation.&quot;</span>);
<a name="l01508"></a>01508 
<a name="l01509"></a>01509     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;video bios always offer 16-pixel high rom font&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01510"></a>01510     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, video BIOS will always carry the 16-pixel ROM font. If clear, 16-pixel rom font will not be offered except for VGA emulation.&quot;</span>);
<a name="l01511"></a>01511 
<a name="l01512"></a>01512     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;video bios enable cga second half rom font&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01513"></a>01513     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, and emulating CGA/PCjr/Tandy, automatically provide the second half of the 8x8 ROM font.\n&quot;</span>
<a name="l01514"></a>01514             <span class="stringliteral">&quot;This setting is ignored for EGA/VGA emulation. If not set, you will need a utility like GRAFTABL.COM to load the second half of the ROM font for graphics.\n&quot;</span>
<a name="l01515"></a>01515             <span class="stringliteral">&quot;NOTE: if you disable the 14 &amp; 16 pixel high font AND the second half when machine=cga, you will disable video bios completely.&quot;</span>);
<a name="l01516"></a>01516 
<a name="l01517"></a>01517     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;forcerate&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01518"></a>01518     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Force the VGA framerate to a specific value(ntsc, pal, or specific hz), no matter what&quot;</span>);
<a name="l01519"></a>01519 
<a name="l01520"></a>01520     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sierra ramdac&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01521"></a>01521     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Whether or not to emulate a Sierra or compatible RAMDAC at port 3C6h-3C9h.\n&quot;</span>
<a name="l01522"></a>01522             <span class="stringliteral">&quot;Some DOS games expect to access port 3C6h to enable highcolor/truecolor SVGA modes on older chipsets.\n&quot;</span>
<a name="l01523"></a>01523             <span class="stringliteral">&quot;Disable if you wish to emulate SVGA hardware that lacks a RAMDAC or (depending on the chipset) does\n&quot;</span>
<a name="l01524"></a>01524             <span class="stringliteral">&quot;not emulate a RAMDAC that is accessible through port 3C6h. This option has no effect for non-VGA video hardware.&quot;</span>);
<a name="l01525"></a>01525 
<a name="l01526"></a>01526     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sierra ramdac lock 565&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01527"></a>01527     Pbool-&gt;Set_help(<span class="stringliteral">&quot;When emulating High Sierra highcolor RAMDAC, assume 5:6:5 at all times if set. Else,\n&quot;</span>
<a name="l01528"></a>01528             <span class="stringliteral">&quot;bit 6 of the DAC command selects between 5:5:5 and 5:6:5. Set this option for demos or\n&quot;</span>
<a name="l01529"></a>01529             <span class="stringliteral">&quot;games that got the command byte wrong (MFX Transgrassion 2) or any other demo that is\n&quot;</span>
<a name="l01530"></a>01530             <span class="stringliteral">&quot;not rendering highcolor 16bpp correctly.&quot;</span>);
<a name="l01531"></a>01531 
<a name="l01532"></a>01532     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;page flip debug line&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01533"></a>01533     Pbool-&gt;Set_help(<span class="stringliteral">&quot;VGA debugging switch. If set, an inverse line will be drawn on the exact scanline that the CRTC display offset registers were written.\n&quot;</span>
<a name="l01534"></a>01534             <span class="stringliteral">&quot;This can be used to help diagnose whether or not the DOS game is page flipping properly according to vertical retrace if the display on-screen is flickering.&quot;</span>);
<a name="l01535"></a>01535 
<a name="l01536"></a>01536     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vertical retrace poll debug line&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01537"></a>01537     Pbool-&gt;Set_help(<span class="stringliteral">&quot;VGA debugging switch. If set, an inverse green dotted line will be drawn on the exact scanline that the CRTC status port (0x3DA) was read.\n&quot;</span>
<a name="l01538"></a>01538             <span class="stringliteral">&quot;This can be used to help diagnose whether the DOS game is propertly waiting for vertical retrace.&quot;</span>);
<a name="l01539"></a>01539 
<a name="l01540"></a>01540     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;cgasnow&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01541"></a>01541     Pbool-&gt;Set_help(<span class="stringliteral">&quot;When machine=cga, determines whether or not to emulate CGA snow in 80x25 text mode&quot;</span>);
<a name="l01542"></a>01542 
<a name="l01543"></a>01543     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;vga 3da undefined bits&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l01544"></a>01544     Phex-&gt;Set_help(<span class="stringliteral">&quot;VGA status port 3BA/3DAh only defines bits 0 and 3. This setting allows you to assign a bit pattern to the undefined bits.\n&quot;</span>
<a name="l01545"></a>01545                    <span class="stringliteral">&quot;The purpose of this hack is to deal with demos that read and handle port 3DAh in ways that might crash if all are zero.\n&quot;</span>
<a name="l01546"></a>01546                    <span class="stringliteral">&quot;By default, this value is zero.&quot;</span>);
<a name="l01547"></a>01547 
<a name="l01548"></a>01548     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;unmask timer on int 10 setmode&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l01549"></a>01549     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 10h will unmask IRQ 0 (timer) when setting video modes.&quot;</span>);
<a name="l01550"></a>01550 
<a name="l01551"></a>01551     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;unmask keyboard on int 16 read&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l01552"></a>01552     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 16h will unmask IRQ 1 (keyboard) when asked to read keyboard input.\n&quot;</span>
<a name="l01553"></a>01553                     <span class="stringliteral">&quot;It is strongly recommended that you set this option if running Windows 3.11 Windows for Workgroups in DOSBox-X.&quot;</span>);
<a name="l01554"></a>01554 
<a name="l01555"></a>01555     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int16 keyboard polling undocumented cf behavior&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l01556"></a>01556     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 16h function AH=01h will also set/clear the carry flag depending on whether input was available.\n&quot;</span>
<a name="l01557"></a>01557                     <span class="stringliteral">&quot;There are some old DOS games and demos that rely on this behavior to sense keyboard input, and this behavior\n&quot;</span>
<a name="l01558"></a>01558                     <span class="stringliteral">&quot;has been verified to occur on some old (early 90s) BIOSes.&quot;</span>);
<a name="l01559"></a>01559 
<a name="l01560"></a>01560     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow port 92 reset&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l01561"></a>01561     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), allow the application to reset the CPU through port 92h&quot;</span>);
<a name="l01562"></a>01562 
<a name="l01563"></a>01563     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable port 92&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01564"></a>01564     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate port 92h (PS/2 system control port A). If you want to emulate a system that pre-dates the PS/2, set to 0.&quot;</span>);
<a name="l01565"></a>01565 
<a name="l01566"></a>01566     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable 1st dma controller&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01567"></a>01567     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate 1st (AT) DMA controller (default). Set to 0 if you wish to emulate a system that lacks DMA (PCjr and some Tandy systems)&quot;</span>);
<a name="l01568"></a>01568 
<a name="l01569"></a>01569     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable 2nd dma controller&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01570"></a>01570     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate 2nd (AT) DMA controller (default). Set to 0 if you wish to emulate a PC/XT system without 16-bit DMA.\n&quot;</span>
<a name="l01571"></a>01571             <span class="stringliteral">&quot;Note: mainline DOSBox automatically disables 16-bit DMA when machine=cga or machine=hercules, while DOSBox-X does not.&quot;</span>);
<a name="l01572"></a>01572 
<a name="l01573"></a>01573     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow dma address decrement&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01574"></a>01574     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow increment &amp; decrement modes as specified in the 8237 datasheet.\n&quot;</span>
<a name="l01575"></a>01575             <span class="stringliteral">&quot;If clear, always increment the address (as if to emulate clone 8237 implementations that skipped the inc/dec bit).&quot;</span>);
<a name="l01576"></a>01576 
<a name="l01577"></a>01577     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;enable 128k capable 16-bit dma&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01578"></a>01578     Pstring-&gt;Set_values(truefalseautoopt);
<a name="l01579"></a>01579     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If true, DMA controller emulation models ISA hardware that permits 16-bit DMA to span 128KB.\n&quot;</span>
<a name="l01580"></a>01580                     <span class="stringliteral">&quot;If false, DMA controller emulation models PCI hardware that limits 16-bit DMA to 64KB boundaries.\n&quot;</span>
<a name="l01581"></a>01581                     <span class="stringliteral">&quot;If auto, the choice is made according to other factors in hardware emulation&quot;</span>);
<a name="l01582"></a>01582 
<a name="l01583"></a>01583     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable dma extra page registers&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01584"></a>01584     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate the extra page registers (I/O ports 0x80, 0x84-0x86, 0x88, 0x8C-0x8E), like actual hardware.\n&quot;</span>
<a name="l01585"></a>01585             <span class="stringliteral">&quot;Note that mainline DOSBox behavior is to NOT emulate these registers.&quot;</span>);
<a name="l01586"></a>01586 
<a name="l01587"></a>01587     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dma page registers write-only&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01588"></a>01588     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Normally (on AT hardware) the DMA page registers are read/write. Set this option if you want to emulate PC/XT hardware where the page registers are write-only.&quot;</span>);
<a name="l01589"></a>01589 
<a name="l01590"></a>01590     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;cascade interrupt never in service&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01591"></a>01591     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, PIC emulation will never mark cascade interrupt as in service. This is OFF by default. It is a hack for troublesome games.&quot;</span>);
<a name="l01592"></a>01592 
<a name="l01593"></a>01593     <span class="comment">// TODO: &quot;Special mode&quot; which apparently triggers this alternate behavior and used by default on PC-98, is configurable</span>
<a name="l01594"></a>01594     <span class="comment">//       by software through the PIC control words, and should control this setting if this is &quot;auto&quot;.</span>
<a name="l01595"></a>01595     <span class="comment">//       It&#39;s time for &quot;auto&quot; default setting to end once and for all the running gag that PC-98 games will not run</span>
<a name="l01596"></a>01596     <span class="comment">//       properly without having to add &quot;cascade interrupt ignore in service=true&quot; to your dosbox.conf all the time.</span>
<a name="l01597"></a>01597     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;cascade interrupt ignore in service&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01598"></a>01598     Pstring-&gt;Set_values(truefalseautoopt);
<a name="l01599"></a>01599     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If true, PIC emulation will allow slave pic interrupts even if the cascade interrupt is still \&quot;in service\&quot; (common PC-98 behavior)\n&quot;</span>
<a name="l01600"></a>01600                     <span class="stringliteral">&quot;If false, PIC emulation will consider cascade in-service state when deciding which interrupt to signal (common IBM PC behavior)\n&quot;</span>
<a name="l01601"></a>01601                     <span class="stringliteral">&quot;If auto, setting is chosen based on machine type and other configuration.&quot;</span>);
<a name="l01602"></a>01602 
<a name="l01603"></a>01603     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable slave pic&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01604"></a>01604     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable slave PIC (IRQ 8-15). Set this to 0 if you want to emulate a PC/XT type arrangement with IRQ 0-7 and no IRQ 2 cascade.&quot;</span>);
<a name="l01605"></a>01605 
<a name="l01606"></a>01606     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable pc nmi mask&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01607"></a>01607     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable PC/XT style NMI mask register (0xA0). Note that this option conflicts with the secondary PIC and will be ignored if the slave PIC is enabled.&quot;</span>);
<a name="l01608"></a>01608 
<a name="l01609"></a>01609     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;rom bios 8x8 CGA font&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01610"></a>01610     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, or mainline compatible bios mapping, a legacy 8x8 CGA font (first 128 characters) is stored at 0xF000:0xFA6E. DOS programs that do not use INT 10h to locate fonts might require that font to be located there.&quot;</span>);
<a name="l01611"></a>01611 
<a name="l01612"></a>01612     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;rom bios video parameter table&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01613"></a>01613     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, or mainline compatible bios mapping, DOSBox will emulate the video parameter table and assign that to INT 1Dh. If clear, table will not be provided.&quot;</span>);
<a name="l01614"></a>01614 
<a name="l01615"></a>01615     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow more than 640kb base memory&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01616"></a>01616     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, and space is available, allow conventional memory to extend past 640KB.\n&quot;</span>
<a name="l01617"></a>01617             <span class="stringliteral">&quot;For example, if machine=cga, conventional memory can extend out to 0xB800 and provide up to 736KB of RAM.\n&quot;</span>
<a name="l01618"></a>01618             <span class="stringliteral">&quot;This allows you to emulate PC/XT style memory extensions.&quot;</span>);
<a name="l01619"></a>01619 
<a name="l01620"></a>01620     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vesa zero buffer on get information&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01621"></a>01621     Pbool-&gt;Set_help(<span class="stringliteral">&quot;This setting affects VESA BIOS function INT 10h AX=4F00h. If set, the VESA BIOS will zero the\n&quot;</span>
<a name="l01622"></a>01622                     <span class="stringliteral">&quot;256-byte buffer defined by the standard at ES:DI, then fill in the structure. If clear, only\n&quot;</span>
<a name="l01623"></a>01623                     <span class="stringliteral">&quot;the structure members will be filled in, and memory outside the initial 20-32 bytes will remain\n&quot;</span>
<a name="l01624"></a>01624                     <span class="stringliteral">&quot;unmodified. This setting is ON by default. Some very early 1990s DOS games that support VESA\n&quot;</span>
<a name="l01625"></a>01625                     <span class="stringliteral">&quot;BIOS standards may need this setting turned OFF if the programmer did not provide enough space\n&quot;</span>
<a name="l01626"></a>01626                     <span class="stringliteral">&quot;for the entire 256 byte structure and the game crashes if it detects VESA BIOS extensions.\n&quot;</span>
<a name="l01627"></a>01627                     <span class="stringliteral">&quot;Needed for:\n&quot;</span>
<a name="l01628"></a>01628                     <span class="stringliteral">&quot;  GETSADAM.EXE&quot;</span>);
<a name="l01629"></a>01629 
<a name="l01630"></a>01630     <span class="comment">/* should be set to zero unless for very specific demos:</span>
<a name="l01631"></a>01631 <span class="comment">     *  - &quot;Melvindale&quot; by MFX (1996): Set this to 2, the nightmarish visual rendering code appears to draw 2 scanlines</span>
<a name="l01632"></a>01632 <span class="comment">     *    upward from the VESA linear framebuffer base we return, causing DOSBox to emit warnings about illegal read/writes</span>
<a name="l01633"></a>01633 <span class="comment">     *    from 0xBFFFF000-0xBFFFFFFF (just before the base of the framebuffer at 0xC0000000). It also has the effect of</span>
<a name="l01634"></a>01634 <span class="comment">     *    properly centering the picture on the screen. I suppose it&#39;s a miracle the demo didn&#39;t crash people&#39;s computers</span>
<a name="l01635"></a>01635 <span class="comment">     *    writing to undefined areas like that. */</span>
<a name="l01636"></a>01636     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vesa lfb base scanline adjust&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l01637"></a>01637     Pint-&gt;Set_help(<span class="stringliteral">&quot;If non-zero, the VESA BIOS will report the linear framebuffer offset by this many scanlines.\n&quot;</span>
<a name="l01638"></a>01638             <span class="stringliteral">&quot;This does not affect the linear framebuffer&#39;s location. It only affects the linear framebuffer\n&quot;</span>
<a name="l01639"></a>01639             <span class="stringliteral">&quot;location reported by the VESA BIOS. Set to nonzero for DOS games with sloppy VESA graphics pointer management.\n&quot;</span>
<a name="l01640"></a>01640             <span class="stringliteral">&quot;    MFX \&quot;Melvindale\&quot; (1996): Set this option to 2 to center the picture properly.&quot;</span>);
<a name="l01641"></a>01641 
<a name="l01642"></a>01642     <span class="comment">/* If set, all VESA BIOS modes map 128KB of video RAM at A0000-BFFFF even though VESA BIOS emulation</span>
<a name="l01643"></a>01643 <span class="comment">     * reports a 64KB window. Some demos like the 1996 Wired report</span>
<a name="l01644"></a>01644 <span class="comment">     * (ftp.scene.org/pub/parties/1995/wired95/misc/e-w95rep.zip) assume they can write past the window</span>
<a name="l01645"></a>01645 <span class="comment">     * by spilling into B0000 without bank switching. */</span>
<a name="l01646"></a>01646     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vesa map non-lfb modes to 128kb region&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01647"></a>01647     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, VESA BIOS SVGA modes will be set to map 128KB of video memory to A0000-BFFFF instead of\n&quot;</span>
<a name="l01648"></a>01648                     <span class="stringliteral">&quot;64KB at A0000-AFFFF. This does not affect the SVGA window size or granularity.\n&quot;</span>
<a name="l01649"></a>01649                     <span class="stringliteral">&quot;Some games or demoscene productions assume that they can render into the next SVGA window/bank\n&quot;</span>
<a name="l01650"></a>01650                     <span class="stringliteral">&quot;by writing to video memory beyond the current SVGA window address and will not appear correctly\n&quot;</span>
<a name="l01651"></a>01651                     <span class="stringliteral">&quot;without this option.&quot;</span>);
<a name="l01652"></a>01652 
<a name="l01653"></a>01653     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow hpel effects&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01654"></a>01654     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow the DOS demo or program to change the horizontal pel (panning) register per scanline.\n&quot;</span>
<a name="l01655"></a>01655             <span class="stringliteral">&quot;Some early DOS demos use this to create waving or sinus effects on the picture. Not very many VGA\n&quot;</span>
<a name="l01656"></a>01656             <span class="stringliteral">&quot;chipsets allow this, so far, only ATI chipsets are known to support this effect. Disabled by default.&quot;</span>);
<a name="l01657"></a>01657 
<a name="l01658"></a>01658     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow hretrace effects&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01659"></a>01659     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow the DOS demo or program to make the picture wavy by playing with the &#39;start horizontal&quot;</span>
<a name="l01660"></a>01660             <span class="stringliteral">&quot;retrace&#39; register of the CRTC during the active picture. Some early DOS demos (Copper by Surprise!&quot;</span>
<a name="l01661"></a>01661             <span class="stringliteral">&quot;productions) need this option set for some demo effects to work. Disabled by default.&quot;</span>);
<a name="l01662"></a>01662 
<a name="l01663"></a>01663     Pdouble = secprop-&gt;Add_double(<span class="stringliteral">&quot;hretrace effect weight&quot;</span>,Property::Changeable::Always,4.0);
<a name="l01664"></a>01664     Pdouble-&gt;Set_help(<span class="stringliteral">&quot;If emulating hretrace effects, this parameter adds &#39;weight&#39; to the offset to smooth it out.\n&quot;</span>
<a name="l01665"></a>01665             <span class="stringliteral">&quot;the larger the number, the more averaging is applied. This is intended to emulate the inertia\n&quot;</span>
<a name="l01666"></a>01666             <span class="stringliteral">&quot;of the electron beam in a CRT monitor&quot;</span>);
<a name="l01667"></a>01667 
<a name="l01668"></a>01668     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vesa modelist cap&quot;</span>,Property::Changeable::Always,0);
<a name="l01669"></a>01669     Pint-&gt;Set_help(<span class="stringliteral">&quot;IF nonzero, the VESA modelist is capped so that it contains no more than the specified number of video modes.\n&quot;</span>
<a name="l01670"></a>01670             <span class="stringliteral">&quot;Set this option to a value between 8 to 32 if the DOS application has problems with long modelists or a fixed\n&quot;</span>
<a name="l01671"></a>01671             <span class="stringliteral">&quot;buffer for querying modes. Such programs may crash if given the entire modelist supported by DOSBox-X.\n&quot;</span>
<a name="l01672"></a>01672             <span class="stringliteral">&quot;  Warcraft II by Blizzard ................ Set to a value between 8 and 16. This game has a fixed buffer that it\n&quot;</span>
<a name="l01673"></a>01673             <span class="stringliteral">&quot;                                           reads the modelist into. DOSBox-X&#39;s normal modelist is too long and\n&quot;</span>
<a name="l01674"></a>01674             <span class="stringliteral">&quot;                                           the game will overrun the buffer and crash without this setting.&quot;</span>);
<a name="l01675"></a>01675 
<a name="l01676"></a>01676     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vesa modelist width limit&quot;</span>,Property::Changeable::Always,0);
<a name="l01677"></a>01677     Pint-&gt;Set_help(<span class="stringliteral">&quot;IF nonzero, VESA modes with horizontal resolution higher than the specified pixel count will not be listed.\n&quot;</span>
<a name="l01678"></a>01678             <span class="stringliteral">&quot;This is another way the modelist can be capped for DOS applications that have trouble with long modelists.&quot;</span>);
<a name="l01679"></a>01679 
<a name="l01680"></a>01680     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vesa modelist height limit&quot;</span>,Property::Changeable::Always,0);
<a name="l01681"></a>01681     Pint-&gt;Set_help(<span class="stringliteral">&quot;IF nonzero, VESA modes with vertical resolution higher than the specified pixel count will not be listed.\n&quot;</span>
<a name="l01682"></a>01682             <span class="stringliteral">&quot;This is another way the modelist can be capped for DOS applications that have trouble with long modelists.&quot;</span>);
<a name="l01683"></a>01683 
<a name="l01684"></a>01684     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vesa vbe put modelist in vesa information&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01685"></a>01685     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the VESA modelist is placed in the VESA information structure itself when the DOS application\n&quot;</span>
<a name="l01686"></a>01686                     <span class="stringliteral">&quot;queries information on the VESA BIOS. Setting this option may help with some games, though it limits\n&quot;</span>
<a name="l01687"></a>01687                     <span class="stringliteral">&quot;the mode list reported to the DOS application.&quot;</span>);
<a name="l01688"></a>01688 
<a name="l01689"></a>01689     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vesa vbe 1.2 modes are 32bpp&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01690"></a>01690     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, truecolor (16M color) VESA BIOS modes in the 0x100-0x11F range are 32bpp. If clear, they are 24bpp.\n&quot;</span>
<a name="l01691"></a>01691             <span class="stringliteral">&quot;Some DOS games and demos assume one bit depth or the other and do not enumerate VESA BIOS modes, which is why this\n&quot;</span>
<a name="l01692"></a>01692             <span class="stringliteral">&quot;option exists.&quot;</span>);
<a name="l01693"></a>01693 
<a name="l01694"></a>01694     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow low resolution vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01695"></a>01695     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow low resolution VESA modes (320x200x16/24/32bpp and so on). You could set this to false to simulate\n&quot;</span>
<a name="l01696"></a>01696             <span class="stringliteral">&quot;SVGA hardware with a BIOS that does not support the lowres modes for testing purposes.&quot;</span>);
<a name="l01697"></a>01697 
<a name="l01698"></a>01698     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 32bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01699"></a>01699     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 32bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01700"></a>01700 
<a name="l01701"></a>01701     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 24bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01702"></a>01702     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 24bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01703"></a>01703 
<a name="l01704"></a>01704     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 16bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01705"></a>01705     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 16bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01706"></a>01706 
<a name="l01707"></a>01707     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 15bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01708"></a>01708     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 15bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01709"></a>01709 
<a name="l01710"></a>01710     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 8bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01711"></a>01711     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 8bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01712"></a>01712 
<a name="l01713"></a>01713     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 4bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01714"></a>01714     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 4bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01715"></a>01715 
<a name="l01716"></a>01716     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 4bpp packed vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01717"></a>01717     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 4bpp packed VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01718"></a>01718 
<a name="l01719"></a>01719     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow tty vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01720"></a>01720     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with text VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01721"></a>01721 
<a name="l01722"></a>01722     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;double-buffered line compare&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01723"></a>01723     Pbool-&gt;Set_help(<span class="stringliteral">&quot;This setting affects the VGA Line Compare register. Set to false (default value) to emulate most VGA behavior\n&quot;</span>
<a name="l01724"></a>01724             <span class="stringliteral">&quot;Set to true for the value to latch once at the start of the frame.&quot;</span>);
<a name="l01725"></a>01725 
<a name="l01726"></a>01726     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore vblank wraparound&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01727"></a>01727     Pbool-&gt;Set_help(<span class="stringliteral">&quot;DOSBox-X can handle active display properly if games or demos reprogram vertical blanking to end in the active picture area.\n&quot;</span>
<a name="l01728"></a>01728             <span class="stringliteral">&quot;If the wraparound handling prevents the game from displaying properly, set this to false. Out of bounds vblank values will be ignored.\n&quot;</span>);
<a name="l01729"></a>01729 
<a name="l01730"></a>01730     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable vga resize delay&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01731"></a>01731     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game you are running relies on certain VGA raster tricks that affect active display area, enable this option.\n&quot;</span>
<a name="l01732"></a>01732             <span class="stringliteral">&quot;This adds a delay between VGA mode changes and window updates. It also means that if you are capturing a demo or game,\n&quot;</span>
<a name="l01733"></a>01733             <span class="stringliteral">&quot;that your capture will also show a few garbled frames at any point mode changes occur, which is why this option is disabled\n&quot;</span>
<a name="l01734"></a>01734             <span class="stringliteral">&quot;by default. If you intend to run certain DOS games and demos like DoWhackaDo, enable this option.&quot;</span>);
<a name="l01735"></a>01735 
<a name="l01736"></a>01736     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;resize only on vga active display width increase&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01737"></a>01737     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, changes to the Display End register of the CRTC do not trigger DOSBox to resize it&#39;s window\n&quot;</span>
<a name="l01738"></a>01738             <span class="stringliteral">&quot;IF the value written is less than the current value. Some demos like DoWhackaDo need this option set\n&quot;</span>
<a name="l01739"></a>01739             <span class="stringliteral">&quot;because of the way it&#39;s raster effects work. If the DOSBox window rapidly changes size during a demo\n&quot;</span>
<a name="l01740"></a>01740             <span class="stringliteral">&quot;try setting this option. Else, leave it turned off. Changes to other VGA CRTC registers will trigger\n&quot;</span>
<a name="l01741"></a>01741             <span class="stringliteral">&quot;a DOSBox mode change as normal regardless of this setting.&quot;</span>);
<a name="l01742"></a>01742 
<a name="l01743"></a>01743     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable pci bus&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l01744"></a>01744     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable PCI bus emulation&quot;</span>);
<a name="l01745"></a>01745 
<a name="l01746"></a>01746     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vga palette update on full load&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01747"></a>01747     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, all three bytes of the palette entry must be loaded before taking the color,\n&quot;</span>
<a name="l01748"></a>01748                     <span class="stringliteral">&quot;which is fairly typical SVGA behavior. If not set, partial changes are allowed.&quot;</span>);
<a name="l01749"></a>01749 
<a name="l01750"></a>01750     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore odd-even mode in non-cga modes&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01751"></a>01751     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Some demoscene productions use VGA Mode X but accidentally enable odd/even mode.\n&quot;</span>
<a name="l01752"></a>01752                     <span class="stringliteral">&quot;Setting this option can correct for that and render the demo properly.\n&quot;</span>
<a name="l01753"></a>01753                     <span class="stringliteral">&quot;This option forces VGA emulation to ignore odd/even mode except in text and CGA modes.&quot;</span>);
<a name="l01754"></a>01754 
<a name="l01755"></a>01755     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;render&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l01756"></a>01756     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;frameskip&quot;</span>,Property::Changeable::Always,0);
<a name="l01757"></a>01757     Pint-&gt;SetMinMax(0,10);
<a name="l01758"></a>01758     Pint-&gt;Set_help(<span class="stringliteral">&quot;How many frames DOSBox skips before drawing one.&quot;</span>);
<a name="l01759"></a>01759 
<a name="l01760"></a>01760     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;alt render&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01761"></a>01761     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, use a new experimental rendering engine&quot;</span>);
<a name="l01762"></a>01762 
<a name="l01763"></a>01763     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;aspect&quot;</span>, Property::Changeable::Always, <span class="stringliteral">&quot;false&quot;</span>);
<a name="l01764"></a>01764     Pstring-&gt;Set_values(aspectmodes);
<a name="l01765"></a>01765     Pstring-&gt;Set_help(
<a name="l01766"></a>01766         <span class="stringliteral">&quot;Aspect ratio correction mode. Can be set to the following values:\n&quot;</span>
<a name="l01767"></a>01767         <span class="stringliteral">&quot;  &#39;false&#39; (default):\n&quot;</span>
<a name="l01768"></a>01768         <span class="stringliteral">&quot;      &#39;direct3d&#39;/opengl outputs: image is simply scaled to full window/fullscreen size, possibly resulting in disproportional image\n&quot;</span>
<a name="l01769"></a>01769         <span class="stringliteral">&quot;      &#39;surface&#39; output: it does no aspect ratio correction (default), resulting in disproportional images if VGA mode pixel ratio is not 4:3\n&quot;</span>
<a name="l01770"></a>01770         <span class="stringliteral">&quot;  &#39;true&#39;:\n&quot;</span>
<a name="l01771"></a>01771         <span class="stringliteral">&quot;      &#39;direct3d&#39;/opengl outputs: uses output driver functions to scale / pad image with black bars, correcting output to proportional 4:3 image\n&quot;</span>
<a name="l01772"></a>01772         <span class="stringliteral">&quot;          In most cases image degradation should not be noticeable (it all depends on the video adapter and how much the image is upscaled).\n&quot;</span>
<a name="l01773"></a>01773         <span class="stringliteral">&quot;          Should have none to negligible impact on performance, mostly being done in hardware\n&quot;</span>
<a name="l01774"></a>01774         <span class="stringliteral">&quot;      &#39;surface&#39; output: inherits old DOSBox aspect ratio correction method (adjusting rendered image line count to correct output to 4:3 ratio)\n&quot;</span>
<a name="l01775"></a>01775         <span class="stringliteral">&quot;          Due to source image manipulation this mode does not mix well with scalers, i.e. multiline scalers like hq2x/hq3x will work poorly\n&quot;</span>
<a name="l01776"></a>01776         <span class="stringliteral">&quot;          Slightly degrades visual image quality. Has a tiny impact on performance&quot;</span>
<a name="l01777"></a>01777 #<span class="keywordflow">if</span> C_XBRZ
<a name="l01778"></a>01778         <span class="stringliteral">&quot;\n&quot;</span>
<a name="l01779"></a>01779         <span class="stringliteral">&quot;          When using xBRZ scaler with &#39;surface&#39; output, aspect ratio correction is done by the scaler itself, so none of the above apply&quot;</span>
<a name="l01780"></a>01780 #endif
<a name="l01781"></a>01781 #<span class="keywordflow">if</span> C_SURFACE_POSTRENDER_ASPECT
<a name="l01782"></a>01782         <span class="stringliteral">&quot;\n&quot;</span>
<a name="l01783"></a>01783         <span class="stringliteral">&quot;  &#39;nearest&#39;:\n&quot;</span>
<a name="l01784"></a>01784         <span class="stringliteral">&quot;      &#39;direct3d&#39;/opengl outputs: not available, fallbacks to &#39;true&#39; mode automatically\n&quot;</span>
<a name="l01785"></a>01785         <span class="stringliteral">&quot;      &#39;surface&#39; output: scaler friendly aspect ratio correction, works by rescaling rendered image using nearest neighbor scaler\n&quot;</span>
<a name="l01786"></a>01786         <span class="stringliteral">&quot;          Complex scalers work. Image quality is on par with &#39;true&#39; mode (and better with scalers). More CPU intensive than &#39;true&#39; mode\n&quot;</span>
<a name="l01787"></a>01787 #<span class="keywordflow">if</span> C_XBRZ
<a name="l01788"></a>01788         <span class="stringliteral">&quot;          When using xBRZ scaler with &#39;surface&#39; output, aspect ratio correction is done by the scaler itself, so it fallbacks to &#39;true&#39; mode\n&quot;</span>
<a name="l01789"></a>01789 #endif
<a name="l01790"></a>01790         <span class="stringliteral">&quot;  &#39;bilinear&#39;:\n&quot;</span>
<a name="l01791"></a>01791         <span class="stringliteral">&quot;      &#39;direct3d&#39;/opengl outputs: not available, fallbacks to &#39;true&#39; mode automatically\n&quot;</span>
<a name="l01792"></a>01792         <span class="stringliteral">&quot;      &#39;surface&#39; output: scaler friendly aspect ratio correction, works by rescaling rendered image using bilinear scaler\n&quot;</span>
<a name="l01793"></a>01793         <span class="stringliteral">&quot;          Complex scalers work. Image quality is much better, should be on par with using &#39;direct3d&#39; output + &#39;true&#39; mode\n&quot;</span>
<a name="l01794"></a>01794         <span class="stringliteral">&quot;          Very CPU intensive, high end CPU may be required&quot;</span>
<a name="l01795"></a>01795 #<span class="keywordflow">if</span> C_XBRZ
<a name="l01796"></a>01796         <span class="stringliteral">&quot;\n&quot;</span>
<a name="l01797"></a>01797         <span class="stringliteral">&quot;          When using xBRZ scaler with &#39;surface&#39; output, aspect ratio correction is done by the scaler itself, so it fallbacks to &#39;true&#39; mode&quot;</span>
<a name="l01798"></a>01798 #endif
<a name="l01799"></a>01799 #endif
<a name="l01800"></a>01800     );
<a name="l01801"></a>01801 
<a name="l01802"></a>01802     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;char9&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01803"></a>01803     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow 9-pixel wide text mode fonts.&quot;</span>);
<a name="l01804"></a>01804 
<a name="l01805"></a>01805     <span class="comment">/* NTS: In the original code borrowed from yhkong, this was named &quot;multiscan&quot;. All it really does is disable</span>
<a name="l01806"></a>01806 <span class="comment">     *      the doublescan down-rezzing DOSBox normally does with 320x240 graphics so that you get the full rendition of what a VGA output would emit. */</span>
<a name="l01807"></a>01807     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;doublescan&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01808"></a>01808     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, doublescanned output emits two scanlines for each source line, in the\n&quot;</span>
<a name="l01809"></a>01809             <span class="stringliteral">&quot;same manner as the actual VGA output (320x200 is rendered as 640x400 for example).\n&quot;</span>
<a name="l01810"></a>01810             <span class="stringliteral">&quot;If clear, doublescanned output is rendered at the native source resolution (320x200 as 320x200).\n&quot;</span>
<a name="l01811"></a>01811             <span class="stringliteral">&quot;This affects the raster PRIOR to the software or hardware scalers. Choose wisely.\n&quot;</span>);
<a name="l01812"></a>01812 
<a name="l01813"></a>01813     Pmulti = secprop-&gt;Add_multi(<span class="stringliteral">&quot;scaler&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot; &quot;</span>);
<a name="l01814"></a>01814     Pmulti-&gt;SetValue(<span class="stringliteral">&quot;normal2x&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l01815"></a>01815     Pmulti-&gt;Set_help(<span class="stringliteral">&quot;Scaler used to enlarge/enhance low resolution modes. If &#39;forced&#39; is appended,\n&quot;</span>
<a name="l01816"></a>01816                      <span class="stringliteral">&quot;then the scaler will be used even if the result might not be desired.\n&quot;</span>
<a name="l01817"></a>01817                      <span class="stringliteral">&quot;To fit a scaler in the resolution used at full screen may require a border or side bars.\n&quot;</span>
<a name="l01818"></a>01818                      <span class="stringliteral">&quot;To fill the screen entirely, depending on your hardware, a different scaler/fullresolution might work.&quot;</span>);
<a name="l01819"></a>01819     Pstring = Pmulti-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;normal2x&quot;</span>);
<a name="l01820"></a>01820     Pstring-&gt;Set_values(scalers);
<a name="l01821"></a>01821 
<a name="l01822"></a>01822     Pstring = Pmulti-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;force&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01823"></a>01823     Pstring-&gt;Set_values(force);
<a name="l01824"></a>01824 
<a name="l01825"></a>01825 <span class="preprocessor">#if C_XBRZ</span>
<a name="l01826"></a>01826 <span class="preprocessor"></span>    Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;xbrz slice&quot;</span>,Property::Changeable::OnlyAtStart,16);
<a name="l01827"></a>01827     Pint-&gt;SetMinMax(1,1024);
<a name="l01828"></a>01828     Pint-&gt;Set_help(<span class="stringliteral">&quot;Number of screen lines to process in single xBRZ scaler taskset task, affects xBRZ performance, 16 is the default&quot;</span>);
<a name="l01829"></a>01829 
<a name="l01830"></a>01830     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;xbrz fixed scale factor&quot;</span>,Property::Changeable::OnlyAtStart, 0);
<a name="l01831"></a>01831     Pint-&gt;SetMinMax(0,6);
<a name="l01832"></a>01832     Pint-&gt;Set_help(<span class="stringliteral">&quot;To use fixed xBRZ scale factor (i.e. to attune performance), set it to 2-6, 0 - use automatic calculation (default)&quot;</span>);
<a name="l01833"></a>01833 
<a name="l01834"></a>01834     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;xbrz max scale factor&quot;</span>,Property::Changeable::OnlyAtStart, 0);
<a name="l01835"></a>01835     Pint-&gt;SetMinMax(0,6);
<a name="l01836"></a>01836     Pint-&gt;Set_help(<span class="stringliteral">&quot;To cap maximum xBRZ scale factor used (i.e. to attune performance), set it to 2-6, 0 - use scaler allowed maximum (default)&quot;</span>);
<a name="l01837"></a>01837 <span class="preprocessor">#endif</span>
<a name="l01838"></a>01838 <span class="preprocessor"></span>
<a name="l01839"></a>01839     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;autofit&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01840"></a>01840     Pbool-&gt;Set_help(
<a name="l01841"></a>01841         <span class="stringliteral">&quot;Best fits image to window\n&quot;</span>
<a name="l01842"></a>01842         <span class="stringliteral">&quot;- Intended for output=direct3d, fullresolution=original, aspect=true&quot;</span>);
<a name="l01843"></a>01843 
<a name="l01844"></a>01844     Pmulti = secprop-&gt;Add_multi(<span class="stringliteral">&quot;monochrome_pal&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot; &quot;</span>);
<a name="l01845"></a>01845     Pmulti-&gt;SetValue(<span class="stringliteral">&quot;green&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l01846"></a>01846     Pmulti-&gt;Set_help(<span class="stringliteral">&quot;Specify the color of monochrome display.\n&quot;</span>
<a name="l01847"></a>01847         <span class="stringliteral">&quot;Possible values: green, amber, gray, white\n&quot;</span>
<a name="l01848"></a>01848         <span class="stringliteral">&quot;Append &#39;bright&#39; for a brighter look.&quot;</span>);
<a name="l01849"></a>01849     Pstring = Pmulti-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;color&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;green&quot;</span>);
<a name="l01850"></a>01850     <span class="keyword">const</span> <span class="keywordtype">char</span>* monochrome_pal_colors[]={
<a name="l01851"></a>01851       <span class="stringliteral">&quot;green&quot;</span>,<span class="stringliteral">&quot;amber&quot;</span>,<span class="stringliteral">&quot;gray&quot;</span>,<span class="stringliteral">&quot;white&quot;</span>,0
<a name="l01852"></a>01852     };
<a name="l01853"></a>01853     Pstring-&gt;Set_values(monochrome_pal_colors);
<a name="l01854"></a>01854     Pstring = Pmulti-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;bright&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01855"></a>01855     <span class="keyword">const</span> <span class="keywordtype">char</span>* bright[] = { <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;bright&quot;</span>, 0 };
<a name="l01856"></a>01856     Pstring-&gt;Set_values(bright);
<a name="l01857"></a>01857 
<a name="l01858"></a>01858     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;vsync&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l01859"></a>01859 
<a name="l01860"></a>01860     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;vsyncmode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l01861"></a>01861     Pstring-&gt;Set_values(vsyncmode);
<a name="l01862"></a>01862     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Synchronize vsync timing to the host display. Requires calibration within dosbox.&quot;</span>);
<a name="l01863"></a>01863     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;vsyncrate&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;75&quot;</span>);
<a name="l01864"></a>01864     Pstring-&gt;Set_values(vsyncrate);
<a name="l01865"></a>01865     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Vsync rate used if vsync is enabled. Ignored if vsyncmode is set to host (win32).&quot;</span>);
<a name="l01866"></a>01866 
<a name="l01867"></a>01867     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;cpu&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l01868"></a>01868     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;core&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01869"></a>01869     Pstring-&gt;Set_values(cores);
<a name="l01870"></a>01870     Pstring-&gt;Set_help(<span class="stringliteral">&quot;CPU Core used in emulation. auto will switch to dynamic if available and appropriate.\n&quot;</span>
<a name="l01871"></a>01871             <span class="stringliteral">&quot;WARNING: Do not use dynamic or auto setting core with Windows 95 or other preemptive\n&quot;</span>
<a name="l01872"></a>01872             <span class="stringliteral">&quot;multitasking OSes with protected mode paging, you should use the normal core instead.&quot;</span>);
<a name="l01873"></a>01873 
<a name="l01874"></a>01874     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;fpu&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01875"></a>01875     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable FPU emulation&quot;</span>);
<a name="l01876"></a>01876 
<a name="l01877"></a>01877     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;segment limits&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01878"></a>01878     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enforce segment limits&quot;</span>);
<a name="l01879"></a>01879 
<a name="l01880"></a>01880     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;double fault&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01881"></a>01881     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate double fault exception&quot;</span>);
<a name="l01882"></a>01882 
<a name="l01883"></a>01883     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;reset on triple fault&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01884"></a>01884     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Reset CPU on triple fault condition (failure to handle double fault)&quot;</span>);
<a name="l01885"></a>01885 
<a name="l01886"></a>01886     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;always report double fault&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01887"></a>01887     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Always report (to log file) double faults if set. Else, a double fault is reported only once. Set this option for debugging purposes.&quot;</span>);
<a name="l01888"></a>01888 
<a name="l01889"></a>01889     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;always report triple fault&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01890"></a>01890     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Always report (to log file) triple faults if set. Else, a triple fault is reported only once. Set this option for debugging purposes.&quot;</span>);
<a name="l01891"></a>01891 
<a name="l01892"></a>01892     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable msr&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01893"></a>01893     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow RDMSR/WRMSR instructions. This option is only meaningful when cputype=pentium.\n&quot;</span>
<a name="l01894"></a>01894             <span class="stringliteral">&quot;WARNING: Leaving this option enabled while installing Windows 95/98/ME can cause crashes.&quot;</span>);
<a name="l01895"></a>01895 
<a name="l01896"></a>01896     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable cmpxchg8b&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01897"></a>01897     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable Pentium CMPXCHG8B instruction. Enable this explicitly if using software that uses this instruction.\n&quot;</span>
<a name="l01898"></a>01898             <span class="stringliteral">&quot;You must enable this option to run Windows ME because portions of the kernel rely on this instruction.&quot;</span>);
<a name="l01899"></a>01899 
<a name="l01900"></a>01900     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore undefined msr&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01901"></a>01901     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Ignore RDMSR/WRMSR on undefined registers. Normally the CPU will fire an Invalid Opcode exception in that case.\n&quot;</span>
<a name="l01902"></a>01902             <span class="stringliteral">&quot;This option is off by default, enable if using software or drivers that assumes the presence of\n&quot;</span>
<a name="l01903"></a>01903             <span class="stringliteral">&quot;certain MSR registers without checking. If you are using certain versions of the 3Dfx glide drivers for MS-DOS\n&quot;</span>
<a name="l01904"></a>01904             <span class="stringliteral">&quot;you will need to set this to TRUE as 3Dfx appears to have coded GLIDE2.OVL to assume the presence\n&quot;</span>
<a name="l01905"></a>01905             <span class="stringliteral">&quot;of Pentium Pro/Pentium II MTRR registers.\n&quot;</span>
<a name="l01906"></a>01906             <span class="stringliteral">&quot;WARNING: Leaving this option enabled while installing Windows 95/98/ME can cause crashes.&quot;</span>);
<a name="l01907"></a>01907 
<a name="l01908"></a>01908     <span class="comment">/* NTS: This setting is honored by all cpu cores except dynamic core */</span>
<a name="l01909"></a>01909     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;interruptible rep string op&quot;</span>,Property::Changeable::Always,-1);
<a name="l01910"></a>01910     Pint-&gt;SetMinMax(-1,65536);
<a name="l01911"></a>01911     Pint-&gt;Set_help(<span class="stringliteral">&quot;if nonzero, REP string instructions (LODS/MOVS/STOS/INS/OUTS) are interruptible (by interrupts or other events).\n&quot;</span>
<a name="l01912"></a>01912             <span class="stringliteral">&quot;if zero, REP string instructions are carried out in full before processing events and interrupts.\n&quot;</span>
<a name="l01913"></a>01913             <span class="stringliteral">&quot;Set to -1 for a reasonable default setting based on cpu type and other configuration.\n&quot;</span>
<a name="l01914"></a>01914             <span class="stringliteral">&quot;A setting of 0 can improve emulation speed at the expense of emulation accuracy.\n&quot;</span>
<a name="l01915"></a>01915             <span class="stringliteral">&quot;A nonzero setting (1-8) may be needed for DOS games and demos that use the IRQ 0 interrupt to play digitized samples\n&quot;</span>
<a name="l01916"></a>01916             <span class="stringliteral">&quot;while doing VGA palette animation at the same time (use case of REP OUTS), where the non-interruptible version\n&quot;</span>
<a name="l01917"></a>01917             <span class="stringliteral">&quot;would cause an audible drop in audio pitch.&quot;</span>);
<a name="l01918"></a>01918 
<a name="l01919"></a>01919     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dynamic core cache block size&quot;</span>,Property::Changeable::Always,32);
<a name="l01920"></a>01920     Pint-&gt;SetMinMax(1,65536);
<a name="l01921"></a>01921     Pint-&gt;Set_help(<span class="stringliteral">&quot;dynamic core cache block size. default value is 32. change this value carefully.\n&quot;</span>
<a name="l01922"></a>01922             <span class="stringliteral">&quot;according to forum discussion, setting this to 1 can aid debugging, however doing so\n&quot;</span>
<a name="l01923"></a>01923             <span class="stringliteral">&quot;also causes problems with 32-bit protected mode DOS games and reduces the performance\n&quot;</span>
<a name="l01924"></a>01924             <span class="stringliteral">&quot;of the dynamic core.\n&quot;</span>);
<a name="l01925"></a>01925 
<a name="l01926"></a>01926     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;cputype&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01927"></a>01927     Pstring-&gt;Set_values(cputype_values);
<a name="l01928"></a>01928     Pstring-&gt;Set_help(<span class="stringliteral">&quot;CPU Type used in emulation. auto emulates a 486 which tolerates Pentium instructions.&quot;</span>);
<a name="l01929"></a>01929 
<a name="l01930"></a>01930     Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;cycles&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot; &quot;</span>);
<a name="l01931"></a>01931     Pmulti_remain-&gt;Set_help(
<a name="l01932"></a>01932         <span class="stringliteral">&quot;Amount of instructions DOSBox tries to emulate each millisecond.\n&quot;</span>
<a name="l01933"></a>01933         <span class="stringliteral">&quot;Setting this value too high results in sound dropouts and lags.\n&quot;</span>
<a name="l01934"></a>01934         <span class="stringliteral">&quot;Cycles can be set in 3 ways:\n&quot;</span>
<a name="l01935"></a>01935         <span class="stringliteral">&quot;  &#39;auto&#39;          tries to guess what a game needs.\n&quot;</span>
<a name="l01936"></a>01936         <span class="stringliteral">&quot;                  It usually works, but can fail for certain games.\n&quot;</span>
<a name="l01937"></a>01937         <span class="stringliteral">&quot;  &#39;fixed #number&#39; will set a fixed amount of cycles. This is what you usually\n&quot;</span>
<a name="l01938"></a>01938         <span class="stringliteral">&quot;                  need if &#39;auto&#39; fails (Example: fixed 4000).\n&quot;</span>
<a name="l01939"></a>01939         <span class="stringliteral">&quot;  &#39;max&#39;           will allocate as much cycles as your computer is able to\n&quot;</span>
<a name="l01940"></a>01940         <span class="stringliteral">&quot;                  handle.&quot;</span>);
<a name="l01941"></a>01941 
<a name="l01942"></a>01942     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01943"></a>01943     Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;auto&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l01944"></a>01944     Pstring-&gt;Set_values(cyclest);
<a name="l01945"></a>01945 
<a name="l01946"></a>01946     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01947"></a>01947 
<a name="l01948"></a>01948     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cycleup&quot;</span>,Property::Changeable::Always,10);
<a name="l01949"></a>01949     Pint-&gt;SetMinMax(1,1000000);
<a name="l01950"></a>01950     Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of cycles to decrease/increase with keycombos.(CTRL-F11/CTRL-F12)&quot;</span>);
<a name="l01951"></a>01951 
<a name="l01952"></a>01952     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cycledown&quot;</span>,Property::Changeable::Always,20);
<a name="l01953"></a>01953     Pint-&gt;SetMinMax(1,1000000);
<a name="l01954"></a>01954     Pint-&gt;Set_help(<span class="stringliteral">&quot;Setting it lower than 100 will be a percentage.&quot;</span>);
<a name="l01955"></a>01955 
<a name="l01956"></a>01956     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;use dynamic core with paging on&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01957"></a>01957     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow dynamic core with 386 paging enabled. This is generally OK for DOS games and Windows 3.1.\n&quot;</span>
<a name="l01958"></a>01958                     <span class="stringliteral">&quot;If the game becomes unstable, turn off this option.\n&quot;</span>
<a name="l01959"></a>01959                     <span class="stringliteral">&quot;WARNING: Do NOT use this option with preemptive multitasking OSes including Windows 95 and Windows NT.&quot;</span>);
<a name="l01960"></a>01960             
<a name="l01961"></a>01961     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore opcode 63&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01962"></a>01962     Pbool-&gt;Set_help(<span class="stringliteral">&quot;When debugging, do not report illegal opcode 0x63.\n&quot;</span>
<a name="l01963"></a>01963             <span class="stringliteral">&quot;Enable this option to ignore spurious errors while debugging from within Windows 3.1/9x/ME&quot;</span>);
<a name="l01964"></a>01964 
<a name="l01965"></a>01965     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01966"></a>01966     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate Advanced Power Management BIOS calls&quot;</span>);
<a name="l01967"></a>01967 
<a name="l01968"></a>01968     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios pnp&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01969"></a>01969     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If emulating ISA PnP BIOS, announce APM BIOS in PnP enumeration.\n&quot;</span>
<a name="l01970"></a>01970             <span class="stringliteral">&quot;Warning: this can cause Windows 95 OSR2 and later to enumerate the APM BIOS twice and cause problems.&quot;</span>);
<a name="l01971"></a>01971 
<a name="l01972"></a>01972     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;apmbios version&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01973"></a>01973     Pstring-&gt;Set_values(apmbiosversions);
<a name="l01974"></a>01974     Pstring-&gt;Set_help(<span class="stringliteral">&quot;What version of the APM BIOS specification to emulate.\n&quot;</span>
<a name="l01975"></a>01975             <span class="stringliteral">&quot;You will need at least APM BIOS v1.1 for emulation to work with Windows 95/98/ME&quot;</span>);
<a name="l01976"></a>01976 
<a name="l01977"></a>01977     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios allow realmode&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01978"></a>01978     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow guest OS to connect from real mode.&quot;</span>);
<a name="l01979"></a>01979 
<a name="l01980"></a>01980     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios allow 16-bit protected mode&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01981"></a>01981     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow guest OS to connect from 16-bit protected mode.&quot;</span>);
<a name="l01982"></a>01982 
<a name="l01983"></a>01983     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios allow 32-bit protected mode&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01984"></a>01984     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow guest OS to connect from 32-bit protected mode.\n&quot;</span>
<a name="l01985"></a>01985             <span class="stringliteral">&quot;If you want power management in Windows 95/98/ME (beyond using the APM to shutdown the computer) you MUST enable this option.\n&quot;</span>
<a name="l01986"></a>01986             <span class="stringliteral">&quot;Windows 95/98/ME does not support the 16-bit real and protected mode APM BIOS entry points.\n&quot;</span>
<a name="l01987"></a>01987             <span class="stringliteral">&quot;Please note at this time that 32-bit APM is unstable under Windows ME&quot;</span>);
<a name="l01988"></a>01988 
<a name="l01989"></a>01989     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;integration device&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01990"></a>01990     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable DOSBox integration I/O device. This can be used by the guest OS to match mouse pointer position, for example. EXPERIMENTAL!&quot;</span>);
<a name="l01991"></a>01991 
<a name="l01992"></a>01992     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;integration device pnp&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01993"></a>01993     Pbool-&gt;Set_help(<span class="stringliteral">&quot;List DOSBox integration I/O device as part of ISA PnP enumeration. This has no purpose yet.&quot;</span>);
<a name="l01994"></a>01994 
<a name="l01995"></a>01995     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;isapnpbios&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01996"></a>01996     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate ISA Plug &amp; Play BIOS. Enable if using DOSBox to run a PnP aware DOS program or if booting Windows 9x.\n&quot;</span>
<a name="l01997"></a>01997             <span class="stringliteral">&quot;Do not disable if Windows 9x is configured around PnP devices, you will likely confuse it.&quot;</span>);
<a name="l01998"></a>01998 
<a name="l01999"></a>01999     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;realbig16&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02000"></a>02000     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow the B (big) bit in real mode. If set, allow the DOS program to set the B bit,\n&quot;</span>
<a name="l02001"></a>02001         <span class="stringliteral">&quot;then jump to realmode with B still set (aka Huge Unreal mode). Needed for Project Angel.&quot;</span>);
<a name="l02002"></a>02002 
<a name="l02003"></a>02003     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;keyboard&quot;</span>,&amp;Null_Init);
<a name="l02004"></a>02004     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;aux&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02005"></a>02005     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable emulation of the 8042 auxiliary port. PS/2 mouse emulation requires this to be enabled.\n&quot;</span>
<a name="l02006"></a>02006             <span class="stringliteral">&quot;You should enable this if you will be running Windows ME or any other OS that does not use the BIOS to receive mouse events.&quot;</span>);
<a name="l02007"></a>02007 
<a name="l02008"></a>02008     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow output port reset&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02009"></a>02009     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), allow the application to reset the CPU through the keyboard controller.\n&quot;</span>
<a name="l02010"></a>02010             <span class="stringliteral">&quot;This option is required to allow Windows ME to reboot properly, whereas Windows 9x and earlier\n&quot;</span>
<a name="l02011"></a>02011             <span class="stringliteral">&quot;will reboot without this option using INT 19h&quot;</span>);
<a name="l02012"></a>02012 
<a name="l02013"></a>02013     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;controllertype&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02014"></a>02014     Pstring-&gt;Set_values(controllertypes);
<a name="l02015"></a>02015     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of keyboard controller (and keyboard) attached.\n&quot;</span>
<a name="l02016"></a>02016                       <span class="stringliteral">&quot;auto     Automatically pick according to machine type\n&quot;</span>
<a name="l02017"></a>02017                       <span class="stringliteral">&quot;at       AT (PS/2) type keyboard\n&quot;</span>
<a name="l02018"></a>02018                       <span class="stringliteral">&quot;xt       IBM PC/XT type keyboard\n&quot;</span>
<a name="l02019"></a>02019                       <span class="stringliteral">&quot;pcjr     IBM PCjr type keyboard (only if machine=pcjr)\n&quot;</span>
<a name="l02020"></a>02020                       <span class="stringliteral">&quot;pc98     PC-98 keyboard emulation (only if machine=pc98)&quot;</span>);
<a name="l02021"></a>02021 
<a name="l02022"></a>02022     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;auxdevice&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;intellimouse&quot;</span>);
<a name="l02023"></a>02023     Pstring-&gt;Set_values(auxdevices);
<a name="l02024"></a>02024     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of PS/2 mouse attached to the AUX port&quot;</span>);
<a name="l02025"></a>02025 
<a name="l02026"></a>02026     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;pci&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>); <span class="comment">//PCI bus</span>
<a name="l02027"></a>02027 
<a name="l02028"></a>02028     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;voodoo&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02029"></a>02029     Pstring-&gt;Set_values(voodoo_settings);
<a name="l02030"></a>02030     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable VOODOO support.&quot;</span>);
<a name="l02031"></a>02031 
<a name="l02032"></a>02032     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;mixer&quot;</span>,&amp;Null_Init);
<a name="l02033"></a>02033     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;nosound&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02034"></a>02034     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable silent mode, sound is still emulated though.&quot;</span>);
<a name="l02035"></a>02035 
<a name="l02036"></a>02036     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sample accurate&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02037"></a>02037     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable sample accurate mixing, at the expense of some emulation performance. Enable this option for DOS games and demos that\n&quot;</span>
<a name="l02038"></a>02038             <span class="stringliteral">&quot;require such accuracy for correct Tandy/OPL output including digitized speech. This option can also help eliminate minor\n&quot;</span>
<a name="l02039"></a>02039             <span class="stringliteral">&quot;errors in Gravis Ultrasound emulation that result in random echo/attenuation effects.&quot;</span>);
<a name="l02040"></a>02040 
<a name="l02041"></a>02041     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;swapstereo&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>); 
<a name="l02042"></a>02042     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Swaps the left and right stereo channels.&quot;</span>); 
<a name="l02043"></a>02043 
<a name="l02044"></a>02044     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;rate&quot;</span>,Property::Changeable::OnlyAtStart,44100);
<a name="l02045"></a>02045     Pint-&gt;SetMinMax(8000,192000);
<a name="l02046"></a>02046     Pint-&gt;Set_help(<span class="stringliteral">&quot;Mixer sample rate, setting any device&#39;s rate higher than this will probably lower their sound quality.&quot;</span>);
<a name="l02047"></a>02047 
<a name="l02048"></a>02048     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;blocksize&quot;</span>,Property::Changeable::OnlyAtStart,1024);
<a name="l02049"></a>02049     Pint-&gt;Set_values(blocksizes);
<a name="l02050"></a>02050     Pint-&gt;Set_help(<span class="stringliteral">&quot;Mixer block size, larger blocks might help sound stuttering but sound will also be more lagged.&quot;</span>);
<a name="l02051"></a>02051 
<a name="l02052"></a>02052     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;prebuffer&quot;</span>,Property::Changeable::OnlyAtStart,25);
<a name="l02053"></a>02053     Pint-&gt;SetMinMax(0,100);
<a name="l02054"></a>02054     Pint-&gt;Set_help(<span class="stringliteral">&quot;How many milliseconds of data to keep on top of the blocksize.&quot;</span>);
<a name="l02055"></a>02055 
<a name="l02056"></a>02056     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;midi&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l02057"></a>02057 
<a name="l02058"></a>02058     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mpu401&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;intelligent&quot;</span>);
<a name="l02059"></a>02059     Pstring-&gt;Set_values(mputypes);
<a name="l02060"></a>02060     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of MPU-401 to emulate.&quot;</span>);
<a name="l02061"></a>02061 
<a name="l02062"></a>02062     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;mpubase&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*default*/</span>);
<a name="l02063"></a>02063     Phex-&gt;Set_values(mpubases);
<a name="l02064"></a>02064     Phex-&gt;Set_help(<span class="stringliteral">&quot;The IO address of the MPU-401.\n&quot;</span>
<a name="l02065"></a>02065                    <span class="stringliteral">&quot;Set to 0 to use a default I/O address.\n&quot;</span>
<a name="l02066"></a>02066                    <span class="stringliteral">&quot;300h to 330h are for use with IBM PC mode.\n&quot;</span>
<a name="l02067"></a>02067                    <span class="stringliteral">&quot;C0D0h to F8D0h (in steps of 800h) are for use with NEC PC-98 mode (MPU98).\n&quot;</span>
<a name="l02068"></a>02068                    <span class="stringliteral">&quot;80D2h through 80DEh are for use with NEC PC-98 Sound Blaster 16 MPU-401 emulation.\n&quot;</span>
<a name="l02069"></a>02069                    <span class="stringliteral">&quot;If not assigned (0), 330h is the default for IBM PC and E0D0h is the default for PC-98.&quot;</span>);
<a name="l02070"></a>02070 
<a name="l02071"></a>02071     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mididevice&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l02072"></a>02072     Pstring-&gt;Set_values(devices);
<a name="l02073"></a>02073     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Device that will receive the MIDI data from MPU-401.&quot;</span>);
<a name="l02074"></a>02074 
<a name="l02075"></a>02075     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;midiconfig&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02076"></a>02076     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Special configuration options for the device driver. This is usually the id or part of the name of the device you want to use (find the id/name with mixer/listmidi).\n&quot;</span>
<a name="l02077"></a>02077                       <span class="stringliteral">&quot;Or in the case of coreaudio or synth, you can specify a soundfont here.\n&quot;</span>
<a name="l02078"></a>02078                       <span class="stringliteral">&quot;When using a Roland MT-32 rev. 0 as midi output device, some games may require a delay in order to prevent &#39;buffer overflow&#39; issues.\n&quot;</span>
<a name="l02079"></a>02079                       <span class="stringliteral">&quot;In that case, add &#39;delaysysex&#39;, for example: midiconfig=2 delaysysex\n&quot;</span>
<a name="l02080"></a>02080                       <span class="stringliteral">&quot;See the README/Manual for more details.&quot;</span>);
<a name="l02081"></a>02081 
<a name="l02082"></a>02082     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;samplerate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l02083"></a>02083     Pint-&gt;Set_values(rates);
<a name="l02084"></a>02084     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate for MIDI synthesizer, if applicable.&quot;</span>);
<a name="l02085"></a>02085     
<a name="l02086"></a>02086     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mpuirq&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l02087"></a>02087     Pint-&gt;SetMinMax(-1,15);
<a name="l02088"></a>02088     Pint-&gt;Set_help(<span class="stringliteral">&quot;MPU-401 IRQ. -1 to automatically choose.&quot;</span>);
<a name="l02089"></a>02089 
<a name="l02090"></a>02090     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.reverse.stereo&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l02091"></a>02091     Pstring-&gt;Set_values(mt32ReverseStereo);
<a name="l02092"></a>02092     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Reverse stereo channels for MT-32 output&quot;</span>);
<a name="l02093"></a>02093 
<a name="l02094"></a>02094     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.verbose&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l02095"></a>02095     Pstring-&gt;Set_values(mt32log);
<a name="l02096"></a>02096     Pstring-&gt;Set_help(<span class="stringliteral">&quot;MT-32 debug logging&quot;</span>);
<a name="l02097"></a>02097 
<a name="l02098"></a>02098     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.thread&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l02099"></a>02099     Pstring-&gt;Set_values(mt32thread);
<a name="l02100"></a>02100     Pstring-&gt;Set_help(<span class="stringliteral">&quot;MT-32 rendering in separate thread&quot;</span>);
<a name="l02101"></a>02101 
<a name="l02102"></a>02102     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.dac&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02103"></a>02103     Pstring-&gt;Set_values(mt32DACModes);
<a name="l02104"></a>02104     Pstring-&gt;Set_help(<span class="stringliteral">&quot;MT-32 DAC input emulation mode\n&quot;</span>
<a name="l02105"></a>02105         <span class="stringliteral">&quot;Nice = 0 - default\n&quot;</span>
<a name="l02106"></a>02106         <span class="stringliteral">&quot;Produces samples at double the volume, without tricks.\n&quot;</span>
<a name="l02107"></a>02107         <span class="stringliteral">&quot;Higher quality than the real devices\n\n&quot;</span>
<a name="l02108"></a>02108 
<a name="l02109"></a>02109         <span class="stringliteral">&quot;Pure = 1\n&quot;</span>
<a name="l02110"></a>02110         <span class="stringliteral">&quot;Produces samples that exactly match the bits output from the emulated LA32.\n&quot;</span>
<a name="l02111"></a>02111         <span class="stringliteral">&quot;Nicer overdrive characteristics than the DAC hacks (it simply clips samples within range)\n&quot;</span>
<a name="l02112"></a>02112         <span class="stringliteral">&quot;Much less likely to overdrive than any other mode.\n&quot;</span>
<a name="l02113"></a>02113         <span class="stringliteral">&quot;Half the volume of any of the other modes, meaning its volume relative to the reverb\n&quot;</span>
<a name="l02114"></a>02114         <span class="stringliteral">&quot;output when mixed together directly will sound wrong. So, reverb level must be lowered.\n&quot;</span>
<a name="l02115"></a>02115         <span class="stringliteral">&quot;Perfect for developers while debugging :)\n\n&quot;</span>
<a name="l02116"></a>02116 
<a name="l02117"></a>02117         <span class="stringliteral">&quot;GENERATION1 = 2\n&quot;</span>
<a name="l02118"></a>02118         <span class="stringliteral">&quot;Re-orders the LA32 output bits as in early generation MT-32s (according to Wikipedia).\n&quot;</span>
<a name="l02119"></a>02119         <span class="stringliteral">&quot;Bit order at DAC (where each number represents the original LA32 output bit number, and XX means the bit is always low):\n&quot;</span>
<a name="l02120"></a>02120         <span class="stringliteral">&quot;15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 XX\n\n&quot;</span>
<a name="l02121"></a>02121 
<a name="l02122"></a>02122         <span class="stringliteral">&quot;GENERATION2 = 3\n&quot;</span>
<a name="l02123"></a>02123         <span class="stringliteral">&quot;Re-orders the LA32 output bits as in later geneerations (personally confirmed on my CM-32L - KG).\n&quot;</span>
<a name="l02124"></a>02124         <span class="stringliteral">&quot;Bit order at DAC (where each number represents the original LA32 output bit number):\n&quot;</span>
<a name="l02125"></a>02125         <span class="stringliteral">&quot;15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 14\n&quot;</span>);
<a name="l02126"></a>02126 
<a name="l02127"></a>02127     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.reverb.mode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02128"></a>02128     Pstring-&gt;Set_values(mt32reverbModes);
<a name="l02129"></a>02129     Pstring-&gt;Set_help(<span class="stringliteral">&quot;MT-32 reverb mode&quot;</span>);
<a name="l02130"></a>02130 
<a name="l02131"></a>02131     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mt32.reverb.time&quot;</span>,Property::Changeable::WhenIdle,5);
<a name="l02132"></a>02132     Pint-&gt;Set_values(mt32reverbTimes);
<a name="l02133"></a>02133     Pint-&gt;Set_help(<span class="stringliteral">&quot;MT-32 reverb decaying time&quot;</span>); 
<a name="l02134"></a>02134 
<a name="l02135"></a>02135     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mt32.reverb.level&quot;</span>,Property::Changeable::WhenIdle,3);
<a name="l02136"></a>02136     Pint-&gt;Set_values(mt32reverbLevels);
<a name="l02137"></a>02137     Pint-&gt;Set_help(<span class="stringliteral">&quot;MT-32 reverb level&quot;</span>);
<a name="l02138"></a>02138 
<a name="l02139"></a>02139     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mt32.partials&quot;</span>,Property::Changeable::WhenIdle,32);
<a name="l02140"></a>02140     Pint-&gt;SetMinMax(0,256);
<a name="l02141"></a>02141     Pint-&gt;Set_help(<span class="stringliteral">&quot;MT-32 max partials allowed (0-256)&quot;</span>);
<a name="l02142"></a>02142 
<a name="l02143"></a>02143     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;debug&quot;</span>,&amp;Null_Init);
<a name="l02144"></a>02144 
<a name="l02145"></a>02145     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;sblaster&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l02146"></a>02146     
<a name="l02147"></a>02147     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;sbtype&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;sb16&quot;</span>);
<a name="l02148"></a>02148     Pstring-&gt;Set_values(sbtypes);
<a name="l02149"></a>02149     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of Soundblaster to emulate. gb is Gameblaster.&quot;</span>);
<a name="l02150"></a>02150 
<a name="l02151"></a>02151     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;sbbase&quot;</span>,Property::Changeable::WhenIdle,0x220);
<a name="l02152"></a>02152     Phex-&gt;Set_values(ios);
<a name="l02153"></a>02153     Phex-&gt;Set_help(<span class="stringliteral">&quot;The IO address of the soundblaster.\n&quot;</span>
<a name="l02154"></a>02154                    <span class="stringliteral">&quot;220h to 2E0h are for use with IBM PC Sound Blaster emulation.\n&quot;</span>
<a name="l02155"></a>02155                    <span class="stringliteral">&quot;D2h to DEh are for use with NEC PC-98 Sound Blaster 16 emulation.&quot;</span>);
<a name="l02156"></a>02156 
<a name="l02157"></a>02157     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;irq&quot;</span>,Property::Changeable::WhenIdle,7);
<a name="l02158"></a>02158     Pint-&gt;Set_values(irqssb);
<a name="l02159"></a>02159     Pint-&gt;Set_help(<span class="stringliteral">&quot;The IRQ number of the soundblaster. Set to -1 to start DOSBox with the IRQ unassigned&quot;</span>);
<a name="l02160"></a>02160 
<a name="l02161"></a>02161     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mindma&quot;</span>,Property::Changeable::OnlyAtStart,-1);
<a name="l02162"></a>02162     Pint-&gt;Set_help( <span class="stringliteral">&quot;Minimum DMA transfer left to increase attention across DSP blocks, in milliseconds. Set to -1 for default.\n&quot;</span>
<a name="l02163"></a>02163             <span class="stringliteral">&quot;There are some DOS games/demos that use single-cycle DSP playback in their music tracker and they micromanage\n&quot;</span>
<a name="l02164"></a>02164             <span class="stringliteral">&quot;the DMA transfer per block poorly in a way that causes popping and artifacts. Setting this option to 0 for\n&quot;</span>
<a name="l02165"></a>02165             <span class="stringliteral">&quot;such DOS applications may reduce audible popping and artifacts.&quot;</span>);
<a name="l02166"></a>02166 
<a name="l02167"></a>02167     <span class="comment">/* Sound Blaster IRQ hacks.</span>
<a name="l02168"></a>02168 <span class="comment">     *</span>
<a name="l02169"></a>02169 <span class="comment">     * These hacks reduce emulation accuracy but can be set to work around bugs or mistakes in some old</span>
<a name="l02170"></a>02170 <span class="comment">     * games and demos related to handling the Sound Blaster IRQ.</span>
<a name="l02171"></a>02171 <span class="comment">     *</span>
<a name="l02172"></a>02172 <span class="comment">     * - Saga by Dust (1993):</span>
<a name="l02173"></a>02173 <span class="comment">     *     Sound Blaster support has a fatal flaw in that the Sound Blaster interrupt handler it installs assumes</span>
<a name="l02174"></a>02174 <span class="comment">     *     DS == CS. It uses the DS register to read local variables needed to manage the Sound Blaster card but</span>
<a name="l02175"></a>02175 <span class="comment">     *     it makes no attempt to push DS and then load the DS segment value it needs. While the demo may seem to</span>
<a name="l02176"></a>02176 <span class="comment">     *     run normally at first, eventually the interrupt is fired at just the right time to catch the demo in</span>
<a name="l02177"></a>02177 <span class="comment">     *     the middle of it&#39;s graphics routines (DS=A000). Since the ISR uses DS to load the Sound Blaster DSP</span>
<a name="l02178"></a>02178 <span class="comment">     *     I/O port, it reads some random value from *video RAM* and then hangs in a loop waiting for that I/O</span>
<a name="l02179"></a>02179 <span class="comment">     *     port to clear bit 7! Setting &#39;cs_equ_ds&#39; works around that bug by instructing PIC emulation not to</span>
<a name="l02180"></a>02180 <span class="comment">     *     fire the interrupt unless segment registers CS and DS match. */</span>
<a name="l02181"></a>02181     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;irq hack&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;none&quot;</span>);
<a name="l02182"></a>02182     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Specify a hack related to the Sound Blaster IRQ to avoid crashes in a handful of games and demos.\n&quot;</span>
<a name="l02183"></a>02183             <span class="stringliteral">&quot;    none                   Emulate IRQs normally\n&quot;</span>
<a name="l02184"></a>02184             <span class="stringliteral">&quot;    cs_equ_ds              Do not fire IRQ unless two CPU segment registers match: CS == DS. Read Dosbox-X Wiki or source code for details.&quot;</span>);
<a name="l02185"></a>02185 
<a name="l02186"></a>02186     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dma&quot;</span>,Property::Changeable::WhenIdle,1);
<a name="l02187"></a>02187     Pint-&gt;Set_values(dmassb);
<a name="l02188"></a>02188     Pint-&gt;Set_help(<span class="stringliteral">&quot;The DMA number of the soundblaster. Set to -1 to start DOSBox with the IRQ unassigned&quot;</span>);
<a name="l02189"></a>02189 
<a name="l02190"></a>02190     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;hdma&quot;</span>,Property::Changeable::WhenIdle,5);
<a name="l02191"></a>02191     Pint-&gt;Set_values(dmassb);
<a name="l02192"></a>02192     Pint-&gt;Set_help(<span class="stringliteral">&quot;The High DMA number of the soundblaster. Set to -1 to start DOSBox with the IRQ unassigned&quot;</span>);
<a name="l02193"></a>02193 
<a name="l02194"></a>02194     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pic unmask irq&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02195"></a>02195     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the sound blaster IRQ already unmasked at the PIC.\n&quot;</span>
<a name="l02196"></a>02196             <span class="stringliteral">&quot;Some early DOS games/demos that support Sound Blaster expect the IRQ to fire but make\n&quot;</span>
<a name="l02197"></a>02197             <span class="stringliteral">&quot;no attempt to unmask the IRQ. If audio cuts out no matter what IRQ you try, then try\n&quot;</span>
<a name="l02198"></a>02198             <span class="stringliteral">&quot;setting this option.\n&quot;</span>
<a name="l02199"></a>02199             <span class="stringliteral">&quot;Option is needed for:\n&quot;</span>
<a name="l02200"></a>02200             <span class="stringliteral">&quot;   Public NMI \&quot;jump\&quot; demo (1992)&quot;</span>);
<a name="l02201"></a>02201 
<a name="l02202"></a>02202     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable speaker&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02203"></a>02203     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the sound blaster speaker enabled.\n&quot;</span>
<a name="l02204"></a>02204                     <span class="stringliteral">&quot;Sound Blaster Pro and older cards have a speaker disable/enable command.\n&quot;</span>
<a name="l02205"></a>02205                     <span class="stringliteral">&quot;Normally the card boots up with the speaker disabled. If a DOS game or demo\n&quot;</span>
<a name="l02206"></a>02206                     <span class="stringliteral">&quot;attempts to play without enabling the speaker, set this option to true to\n&quot;</span>
<a name="l02207"></a>02207                     <span class="stringliteral">&quot;compensate. This setting has no meaning if emulating a Sound Blaster 16 card.&quot;</span>);
<a name="l02208"></a>02208 
<a name="l02209"></a>02209     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable asp&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02210"></a>02210     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate the presence of the Sound Blaster 16 Advanced Sound Processor/Creative Sound Processor chip.\n&quot;</span>
<a name="l02211"></a>02211             <span class="stringliteral">&quot;NOTE: This only emulates it&#39;s presence and the basic DSP commands to communicate with it. Actual ASP/CSP functions are not yet implemented.&quot;</span>);
<a name="l02212"></a>02212 
<a name="l02213"></a>02213     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;disable filtering&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02214"></a>02214     Pbool-&gt;Set_help(<span class="stringliteral">&quot;By default DOSBox-X filters Sound Blaster output to emulate lowpass filters and analog output limitations.\n&quot;</span>
<a name="l02215"></a>02215             <span class="stringliteral">&quot;Set this option to true to disable filtering. Note that doing so disables emulation of the Sound Blaster Pro\n&quot;</span>
<a name="l02216"></a>02216             <span class="stringliteral">&quot;output filter and ESS AudioDrive lowpass filter.&quot;</span>);
<a name="l02217"></a>02217 
<a name="l02218"></a>02218     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dsp write buffer status must return 0x7f or 0xff&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02219"></a>02219     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, force port 22Ch (DSP write buffer status) to return 0x7F or 0xFF. If not set, the port\n&quot;</span>
<a name="l02220"></a>02220             <span class="stringliteral">&quot;may return 0x7F or 0xFF depending on what type of Sound Blaster is being emulated.\n&quot;</span>
<a name="l02221"></a>02221             <span class="stringliteral">&quot;Set this option for some early DOS demos that make that assumption about port 22Ch.\n&quot;</span>
<a name="l02222"></a>02222             <span class="stringliteral">&quot;Option is needed for:\n&quot;</span>
<a name="l02223"></a>02223             <span class="stringliteral">&quot;   Overload by Hysteria (1992) - Audio will crackle/saturate (8-bit overflow) except when sbtype=sb16&quot;</span>);
<a name="l02224"></a>02224 
<a name="l02225"></a>02225     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pre-set sbpro stereo&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02226"></a>02226     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the Sound Blaster Pro stereo bit set (in the mixer).\n&quot;</span>
<a name="l02227"></a>02227             <span class="stringliteral">&quot;A few demos support Sound Blaster Pro but forget to set this bit.\n&quot;</span>
<a name="l02228"></a>02228             <span class="stringliteral">&quot;Option is needed for:\n&quot;</span>
<a name="l02229"></a>02229             <span class="stringliteral">&quot;   Inconexia by Iguana (1993)&quot;</span>);
<a name="l02230"></a>02230 
<a name="l02231"></a>02231     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sbmixer&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02232"></a>02232     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow the soundblaster mixer to modify the DOSBox mixer.&quot;</span>);
<a name="l02233"></a>02233 
<a name="l02234"></a>02234     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;oplmode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02235"></a>02235     Pstring-&gt;Set_values(oplmodes);
<a name="l02236"></a>02236     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of OPL emulation. On &#39;auto&#39; the mode is determined by sblaster type.\n&quot;</span>
<a name="l02237"></a>02237         <span class="stringliteral">&quot;To emulate Adlib, set sbtype=none and oplmode=opl2. To emulate a Game Blaster, set\n&quot;</span>
<a name="l02238"></a>02238         <span class="stringliteral">&quot;sbtype=none and oplmode=cms&quot;</span>);
<a name="l02239"></a>02239 
<a name="l02240"></a>02240     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;adlib force timer overflow on detect&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02241"></a>02241     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, Adlib/OPL emulation will signal &#39;overflow&#39; on timers after 50 I/O reads.\n&quot;</span>
<a name="l02242"></a>02242             <span class="stringliteral">&quot;This is a temporary hack to work around timing bugs noted in DOSBox-X. Certain\n&quot;</span>
<a name="l02243"></a>02243             <span class="stringliteral">&quot;games (Wolfenstein 3D) poll the Adlib status port a fixed number of times assuming\n&quot;</span>
<a name="l02244"></a>02244             <span class="stringliteral">&quot;that the poll loop takes long enough for the Adlib timer to run out. If the game\n&quot;</span>
<a name="l02245"></a>02245             <span class="stringliteral">&quot;cannot reliably detect Adlib at higher cycles counts, but can reliably detect at\n&quot;</span>
<a name="l02246"></a>02246             <span class="stringliteral">&quot;lower cycles counts, set this option.\n&quot;</span>
<a name="l02247"></a>02247             <span class="stringliteral">&quot;NOTE: Technically this decreases emulation accuracy, however it also reflects the\n&quot;</span>
<a name="l02248"></a>02248             <span class="stringliteral">&quot;      fact that DOSBox-X&#39;s I/O timing code needs some work to better match the\n&quot;</span>
<a name="l02249"></a>02249             <span class="stringliteral">&quot;      slowness of the ISA bus per I/O read in consideration of DOS games. So this\n&quot;</span>
<a name="l02250"></a>02250             <span class="stringliteral">&quot;      option is ON by default.&quot;</span>);
<a name="l02251"></a>02251     <span class="comment">/* NTS: The reason I mention Wolfenstein 3D is that it seems coded not to probe for Sound Blaster unless it</span>
<a name="l02252"></a>02252 <span class="comment">     *      first detects the Adlib at port 0x388. No Adlib, no Sound Blaster. */</span>
<a name="l02253"></a>02253     <span class="comment">/* ^ NTS: To see what I mean, download Wolf3d source code, look at ID_SD.C line 1585 (Adlib detection routine).</span>
<a name="l02254"></a>02254 <span class="comment">     *        Note it sets Timer 1, then reads port 388h 100 times before reading status to detect whether the</span>
<a name="l02255"></a>02255 <span class="comment">     *        timer &quot;overflowed&quot; (fairly typical Adlib detection code).</span>
<a name="l02256"></a>02256 <span class="comment">     *        Some quick math: 8333333Hz ISA BCLK / 6 cycles per read (3 wait states) = 1388888 reads/second possible</span>
<a name="l02257"></a>02257 <span class="comment">     *                         100 I/O reads * (1 / 1388888) = 72us */</span> 
<a name="l02258"></a>02258 
<a name="l02259"></a>02259     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;oplemu&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l02260"></a>02260     Pstring-&gt;Set_values(oplemus);
<a name="l02261"></a>02261     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Provider for the OPL emulation. compat might provide better quality (see oplrate as well).&quot;</span>);
<a name="l02262"></a>02262 
<a name="l02263"></a>02263     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;oplrate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l02264"></a>02264     Pint-&gt;Set_values(oplrates);
<a name="l02265"></a>02265     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of OPL music emulation. Use 49716 for highest quality (set the mixer rate accordingly).&quot;</span>);
<a name="l02266"></a>02266 
<a name="l02267"></a>02267     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;hardwarebase&quot;</span>,Property::Changeable::WhenIdle,0x220);
<a name="l02268"></a>02268     Phex-&gt;Set_help(<span class="stringliteral">&quot;base address of the real hardware soundblaster:\n&quot;</span>\
<a name="l02269"></a>02269         <span class="stringliteral">&quot;210,220,230,240,250,260,280&quot;</span>);
<a name="l02270"></a>02270 
<a name="l02271"></a>02271     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;force dsp auto-init&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02272"></a>02272     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Treat all single-cycle DSP commands as auto-init to keep playback going.\n&quot;</span>
<a name="l02273"></a>02273             <span class="stringliteral">&quot;This option is a workaround for DOS games or demos that use single-cycle DSP playback commands and\n&quot;</span>
<a name="l02274"></a>02274             <span class="stringliteral">&quot;have problems with missing the Sound Blaster IRQ under load. Do not enable unless you need this workaround.\n&quot;</span>
<a name="l02275"></a>02275             <span class="stringliteral">&quot;Needed for:\n&quot;</span>
<a name="l02276"></a>02276             <span class="stringliteral">&quot;  - Extreme \&quot;lunatic\&quot; demo (1993)&quot;</span>);
<a name="l02277"></a>02277 
<a name="l02278"></a>02278     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;force goldplay&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02279"></a>02279     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Always render Sound Blaster output sample-at-a-time. Testing option. You probably don&#39;t want to enable this.&quot;</span>);
<a name="l02280"></a>02280 
<a name="l02281"></a>02281     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;goldplay&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02282"></a>02282     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable goldplay emulation.&quot;</span>);
<a name="l02283"></a>02283 
<a name="l02284"></a>02284     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;goldplay stereo&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02285"></a>02285     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable workaround for goldplay stereo playback. Many DOS demos using this technique\n&quot;</span>
<a name="l02286"></a>02286             <span class="stringliteral">&quot;don&#39;t seem to know they need to double the frequency when programming the DSP time constant for Pro stereo output.\n&quot;</span>
<a name="l02287"></a>02287             <span class="stringliteral">&quot;If stereo playback seems to have artifacts consider enabling this option. For accurate emulation of Sound Blaster\n&quot;</span>
<a name="l02288"></a>02288             <span class="stringliteral">&quot;hardware, disable this option.&quot;</span>);
<a name="l02289"></a>02289 
<a name="l02290"></a>02290     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;dsp require interrupt acknowledge&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02291"></a>02291     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If set, the DSP will halt DMA playback until IRQ acknowledgement occurs even in auto-init mode (SB16 behavior).\n&quot;</span>
<a name="l02292"></a>02292             <span class="stringliteral">&quot;If clear, IRQ acknowledgement will have no effect on auto-init playback (SB Pro and earlier &amp; clone behavior)\n&quot;</span>
<a name="l02293"></a>02293             <span class="stringliteral">&quot;If set to &#39;auto&#39; then behavior is determined by sbtype= setting.\n&quot;</span>
<a name="l02294"></a>02294             <span class="stringliteral">&quot;This is a setting for hardware accuracy in emulation. If audio briefly plays then stops then your DOS game\n&quot;</span>
<a name="l02295"></a>02295             <span class="stringliteral">&quot;and it&#39;s not using IRQ (but using DMA), try setting this option to &#39;false&#39;&quot;</span>);
<a name="l02296"></a>02296 
<a name="l02297"></a>02297     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dsp write busy delay&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l02298"></a>02298     Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of time in nanoseconds the DSP chip signals &#39;busy&#39; after writing to the DSP (port 2xCh). Set to -1 to use card-specific defaults.\n&quot;</span>
<a name="l02299"></a>02299             <span class="stringliteral">&quot;WARNING: Setting the value too high (above 20000ns) may have detrimental effects to DOS games that use IRQ 0 and DSP command 0x10 to play audio.\n&quot;</span>
<a name="l02300"></a>02300             <span class="stringliteral">&quot;         Setting the value way too high (above 1000000ns) can cause significant lag in DOS games.&quot;</span>);
<a name="l02301"></a>02301 
<a name="l02302"></a>02302     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;blaster environment variable&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02303"></a>02303     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Whether or not to set the BLASTER environment variable automatically at startup&quot;</span>);
<a name="l02304"></a>02304 
<a name="l02305"></a>02305     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sample rate limits&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02306"></a>02306     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), limit DSP sample rate to what real hardware is limited to&quot;</span>);
<a name="l02307"></a>02307 
<a name="l02308"></a>02308     <span class="comment">/* recommended for:</span>
<a name="l02309"></a>02309 <span class="comment">     *   1992 demo &quot;overload&quot; (if set, Sound Blaster support can run at 24KHz without causing demo to hang in the IRQ 0 timer)</span>
<a name="l02310"></a>02310 <span class="comment">     *   1993 demo &quot;xmas 93&quot; (superiority complex) because the demo&#39;s Sound Blaster mode writes at the timer interrupt rate without polling the DSP to check busy state */</span>
<a name="l02311"></a>02311     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;instant direct dac&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02312"></a>02312     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, direct DAC output commands are instantaneous. This option is intended as a quick fix for\n&quot;</span>
<a name="l02313"></a>02313             <span class="stringliteral">&quot;games or demos that play direct DAC music/sound from the IRQ 0 timer who a) write the DSP command\n&quot;</span>
<a name="l02314"></a>02314             <span class="stringliteral">&quot;and data without polling the DSP to ensure it&#39;s ready or b) can get locked into the IRQ 0 handler\n&quot;</span>
<a name="l02315"></a>02315             <span class="stringliteral">&quot;waiting for DSP status when instructed to play at or beyond the DSP&#39;s maximum direct DAC sample rate.\n&quot;</span>
<a name="l02316"></a>02316             <span class="stringliteral">&quot;This fix allows broken Sound Blaster code to work and should not be enabled unless necessary.&quot;</span>);
<a name="l02317"></a>02317 
<a name="l02318"></a>02318     <span class="comment">/* accuracy emulation: SB16 does not honor SBPro stereo bit in the mixer */</span>
<a name="l02319"></a>02319     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;stereo control with sbpro only&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02320"></a>02320     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Default on. If set, Sound Blaster Pro stereo is not available when emulating sb16 or sb16vibra.\n&quot;</span>
<a name="l02321"></a>02321             <span class="stringliteral">&quot;If clear, sb16 emulation will honor the sbpro stereo bit. Note that Creative SB16 cards do not\n&quot;</span>
<a name="l02322"></a>02322             <span class="stringliteral">&quot;honor the stereo bit, and this option allows DOSBox emulate that fact. Accuracy setting.&quot;</span>);
<a name="l02323"></a>02323 
<a name="l02324"></a>02324     <span class="comment">/* NTS: It turns out (SB16 at least) the DSP will periodically set bit 7 (busy) by itself at some</span>
<a name="l02325"></a>02325 <span class="comment">     *      clock rate even if it&#39;s idle. Casual testing on an old Pentium system with a ViBRA shows</span>
<a name="l02326"></a>02326 <span class="comment">     *      it&#39;s possible to see both 0x7F and 0xFF come back if you repeatedly type &quot;i 22c&quot; in DOS</span>
<a name="l02327"></a>02327 <span class="comment">     *      DEBUG.EXE.  FIXME: At what clock rate and duty cycle does this happen? */</span>
<a name="l02328"></a>02328     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dsp busy cycle rate&quot;</span>,Property::Changeable::WhenIdle,-1<span class="comment">/*default*/</span>);
<a name="l02329"></a>02329     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sound Blaster 16 DSP chips appear to go busy periodically at some high clock rate\n&quot;</span>
<a name="l02330"></a>02330             <span class="stringliteral">&quot;whether the DSP is actually doing anything for the system or not. This is an accuracy\n&quot;</span>
<a name="l02331"></a>02331             <span class="stringliteral">&quot;option for Sound Blaster emulation. If this option is nonzero, it will be interpreted\n&quot;</span>
<a name="l02332"></a>02332             <span class="stringliteral">&quot;as the busy cycle rate in Hz. If zero, busy cycle will not be emulated. If -1, sound\n&quot;</span>
<a name="l02333"></a>02333             <span class="stringliteral">&quot;blaster emulation will automatically choose a setting based on the sbtype= setting&quot;</span>);
<a name="l02334"></a>02334 
<a name="l02335"></a>02335     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dsp busy cycle always&quot;</span>,Property::Changeable::WhenIdle,-1<span class="comment">/*default*/</span>);
<a name="l02336"></a>02336     Pint-&gt;Set_help(<span class="stringliteral">&quot;If set, the DSP busy cycle always happens. If clear, DSP busy cycle only happens when\n&quot;</span>
<a name="l02337"></a>02337             <span class="stringliteral">&quot;audio playback is running. Default setting is to pick according to the sound card.&quot;</span>);
<a name="l02338"></a>02338 
<a name="l02339"></a>02339     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dsp busy cycle duty&quot;</span>,Property::Changeable::WhenIdle,-1<span class="comment">/*default*/</span>);
<a name="l02340"></a>02340     Pint-&gt;Set_help(<span class="stringliteral">&quot;If emulating SB16 busy cycle, this value (0 to 100) controls the duty cycle of the busy cycle.\n&quot;</span>
<a name="l02341"></a>02341             <span class="stringliteral">&quot;If this option is set to -1, Sound Blaster emulation will choose a value automatically according\n&quot;</span>
<a name="l02342"></a>02342             <span class="stringliteral">&quot;to sbtype=. If 0, busy cycle emulation is disabled.&quot;</span>);
<a name="l02343"></a>02343 
<a name="l02344"></a>02344     <span class="comment">/* NTS: Confirmed: My Sound Blaster 2.0 (at least) mirrors the DSP on port 22Ch and 22Dh. This option</span>
<a name="l02345"></a>02345 <span class="comment">     *      will only take effect with sbtype sb1 and sb2, so make it enabled by default. Accuracy setting. */</span>
<a name="l02346"></a>02346     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;io port aliasing&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02347"></a>02347     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, Sound Blaster ports alias by not decoding the LSB of the I/O port.\n&quot;</span>
<a name="l02348"></a>02348             <span class="stringliteral">&quot;This option only applies when sbtype is set to sb1 or sb2 (not SBPro or SB16).\n&quot;</span>
<a name="l02349"></a>02349             <span class="stringliteral">&quot;This is a hack for the Electromotive Force &#39;Internal Damage&#39; demo which apparently\n&quot;</span>
<a name="l02350"></a>02350             <span class="stringliteral">&quot;relies on this behavior for Sound Blaster output and should be enabled for accuracy in emulation.&quot;</span>);
<a name="l02351"></a>02351 
<a name="l02352"></a>02352     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;gus&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>); <span class="comment">//done</span>
<a name="l02353"></a>02353     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;gus&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);  
<a name="l02354"></a>02354     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable the Gravis Ultrasound emulation.&quot;</span>);
<a name="l02355"></a>02355 
<a name="l02356"></a>02356     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;autoamp&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02357"></a>02357     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, GF1 output will reduce in volume automatically if the sum of all channels exceeds full volume.\n&quot;</span>
<a name="l02358"></a>02358                     <span class="stringliteral">&quot;If not set, then loud music will clip to full volume just as it would on real hardware.\n&quot;</span>
<a name="l02359"></a>02359                     <span class="stringliteral">&quot;Enable this option for loud music if you want a more pleasing rendition without saturation and distortion.&quot;</span>);
<a name="l02360"></a>02360 
<a name="l02361"></a>02361     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;unmask dma&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02362"></a>02362     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the DMA channel already unmasked at the controller.\n&quot;</span>
<a name="l02363"></a>02363             <span class="stringliteral">&quot;Use this for DOS applications that expect to operate the GUS but forget to unmask the DMA channel.&quot;</span>);
<a name="l02364"></a>02364 
<a name="l02365"></a>02365     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore channel count while active&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02366"></a>02366     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Ignore writes to the active channel count register when the DAC is enabled (bit 1 of GUS reset)\n&quot;</span>
<a name="l02367"></a>02367                     <span class="stringliteral">&quot;This is a HACK for demoscene prod &#39;Ice Fever&#39; without which the music sounds wrong.\n&quot;</span>
<a name="l02368"></a>02368                     <span class="stringliteral">&quot;According to current testing real hardware does not behave this way.&quot;</span>);
<a name="l02369"></a>02369 
<a name="l02370"></a>02370     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pic unmask irq&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02371"></a>02371     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the GUS IRQ already unmasked at the PIC.&quot;</span>);
<a name="l02372"></a>02372 
<a name="l02373"></a>02373     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;startup initialized&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02374"></a>02374     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, start the GF1 in a fully initialized state (as if ULTRINIT had been run).\n&quot;</span>
<a name="l02375"></a>02375                     <span class="stringliteral">&quot;If clear, leave the card in an uninitialized state (as if cold boot).\n&quot;</span>
<a name="l02376"></a>02376                     <span class="stringliteral">&quot;Some DOS games or demoscene productions will hang or fail to use the Ultrasound hardware\n&quot;</span>
<a name="l02377"></a>02377                     <span class="stringliteral">&quot;because they assume the card is initialized and their hardware detect does not fully initialize the card.&quot;</span>);
<a name="l02378"></a>02378 
<a name="l02379"></a>02379     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dma enable on dma control polling&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02380"></a>02380     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, automatically enable GUS DMA transfer bit in specific cases when the DMA control register is being polled.\n&quot;</span>
<a name="l02381"></a>02381                     <span class="stringliteral">&quot;THIS IS A HACK. Some games and demoscene productions need this hack to avoid hanging while uploading sample data\n&quot;</span>
<a name="l02382"></a>02382                     <span class="stringliteral">&quot;to the Gravis Ultrasound due to bugs in their implementation.&quot;</span>);
<a name="l02383"></a>02383 
<a name="l02384"></a>02384     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;clear dma tc irq if excess polling&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02385"></a>02385     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS application is seen polling the IRQ status register rapidly, automatically clear the DMA TC IRQ status.\n&quot;</span>
<a name="l02386"></a>02386             <span class="stringliteral">&quot;This is a hack that should only be used with DOS applications that need it to avoid bugs in their GUS support code.\n&quot;</span>
<a name="l02387"></a>02387             <span class="stringliteral">&quot;Needed for:\n&quot;</span>
<a name="l02388"></a>02388             <span class="stringliteral">&quot;  Warcraft II by Blizzard ............. if using GUS for music and sound, set this option to prevent the game from\n&quot;</span>
<a name="l02389"></a>02389             <span class="stringliteral">&quot;                                        hanging when you click on the buttons in the main menu.&quot;</span>);
<a name="l02390"></a>02390 
<a name="l02391"></a>02391     <span class="comment">/* some DOS demos, especially where the programmers wrote their own tracker, forget to set &quot;master IRQ enable&quot; on the GUS,</span>
<a name="l02392"></a>02392 <span class="comment">     * and then wonder why music isn&#39;t playing. prior to some GUS bugfixes they happend to work anyway because DOSBox also</span>
<a name="l02393"></a>02393 <span class="comment">     * ignored master IRQ enable. you can restore that buggy behavior here.</span>
<a name="l02394"></a>02394 <span class="comment">     *</span>
<a name="l02395"></a>02395 <span class="comment">     * DOS games &amp; demos that need this:</span>
<a name="l02396"></a>02396 <span class="comment">     *   - &quot;Juice&quot; by Psychic Link (writes 0x300 to GUS reset which only enables DAC and takes card out of reset, does not enable IRQ) */</span>
<a name="l02397"></a>02397     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;force master irq enable&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02398"></a>02398     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Set this option if a DOS game or demo initializes the GUS but is unable to play any music.\n&quot;</span>
<a name="l02399"></a>02399             <span class="stringliteral">&quot;Usually the cause is buggy GUS support that resets the GUS but fails to set the Master IRQ enable bit.&quot;</span>);
<a name="l02400"></a>02400 
<a name="l02401"></a>02401     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;gus panning table&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l02402"></a>02402     Pstring-&gt;Set_values(guspantables);
<a name="l02403"></a>02403     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Controls which table or equation is used for the Gravis Ultrasound panning emulation.\n&quot;</span>
<a name="l02404"></a>02404             <span class="stringliteral">&quot;accurate emulation attempts to better reflect how the actual hardware handles panning,\n&quot;</span>
<a name="l02405"></a>02405             <span class="stringliteral">&quot;while the old emulation uses a simpler idealistic mapping.&quot;</span>);
<a name="l02406"></a>02406 
<a name="l02407"></a>02407     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;gusrate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l02408"></a>02408     Pint-&gt;Set_values(rates);
<a name="l02409"></a>02409     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of Ultrasound emulation.&quot;</span>);
<a name="l02410"></a>02410 
<a name="l02411"></a>02411     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;gus fixed render rate&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02412"></a>02412     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, Gravis Ultrasound audio output is rendered at a fixed sample rate specified by &#39;gusrate&#39;. This can provide better quality than real hardware,\n&quot;</span>
<a name="l02413"></a>02413             <span class="stringliteral">&quot;if desired. Else, Gravis Ultrasound emulation will change the sample rate of it&#39;s output according to the number of active channels, just like real hardware.\n&quot;</span>
<a name="l02414"></a>02414             <span class="stringliteral">&quot;Note: DOSBox-X defaults to &#39;false&#39;, while mainline DOSBox SVN is currently hardcoded to render as if this setting is &#39;true&#39;.&quot;</span>);
<a name="l02415"></a>02415 
<a name="l02416"></a>02416     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;gusmemsize&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l02417"></a>02417     Pint-&gt;SetMinMax(-1,1024);
<a name="l02418"></a>02418     Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of RAM on the Gravis Ultrasound in KB. Set to -1 for default.&quot;</span>);
<a name="l02419"></a>02419 
<a name="l02420"></a>02420     Pdouble = secprop-&gt;Add_double(<span class="stringliteral">&quot;gus master volume&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l02421"></a>02421     Pdouble-&gt;SetMinMax(-120.0,6.0);
<a name="l02422"></a>02422     Pdouble-&gt;Set_help(<span class="stringliteral">&quot;Master Gravis Ultrasound GF1 volume, in decibels. Reducing the master volume can help with games or demoscene productions where the music is too loud and clipping&quot;</span>);
<a name="l02423"></a>02423 
<a name="l02424"></a>02424     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;gusbase&quot;</span>,Property::Changeable::WhenIdle,0x240);
<a name="l02425"></a>02425     Phex-&gt;Set_values(iosgus);
<a name="l02426"></a>02426     Phex-&gt;Set_help(<span class="stringliteral">&quot;The IO base address of the Gravis Ultrasound.&quot;</span>);
<a name="l02427"></a>02427 
<a name="l02428"></a>02428     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;gusirq&quot;</span>,Property::Changeable::WhenIdle,5);
<a name="l02429"></a>02429     Pint-&gt;Set_values(irqsgus);
<a name="l02430"></a>02430     Pint-&gt;Set_help(<span class="stringliteral">&quot;The IRQ number of the Gravis Ultrasound.&quot;</span>);
<a name="l02431"></a>02431 
<a name="l02432"></a>02432     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;gusdma&quot;</span>,Property::Changeable::WhenIdle,3);
<a name="l02433"></a>02433     Pint-&gt;Set_values(dmasgus);
<a name="l02434"></a>02434     Pint-&gt;Set_help(<span class="stringliteral">&quot;The DMA channel of the Gravis Ultrasound.&quot;</span>);
<a name="l02435"></a>02435  
<a name="l02436"></a>02436     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;irq hack&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;none&quot;</span>);
<a name="l02437"></a>02437     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Specify a hack related to the Gravis Ultrasound IRQ to avoid crashes in a handful of games and demos.\n&quot;</span>
<a name="l02438"></a>02438             <span class="stringliteral">&quot;    none                   Emulate IRQs normally\n&quot;</span>
<a name="l02439"></a>02439             <span class="stringliteral">&quot;    cs_equ_ds              Do not fire IRQ unless two CPU segment registers match: CS == DS. Read Dosbox-X Wiki or source code for details.&quot;</span>);
<a name="l02440"></a>02440 
<a name="l02441"></a>02441     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;gustype&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;classic&quot;</span>);
<a name="l02442"></a>02442     Pstring-&gt;Set_values(gustypes);
<a name="l02443"></a>02443     Pstring-&gt;Set_help(  <span class="stringliteral">&quot;Type of Gravis Ultrasound to emulate.\n&quot;</span>
<a name="l02444"></a>02444                 <span class="stringliteral">&quot;classic             Original Gravis Ultrasound chipset\n&quot;</span>
<a name="l02445"></a>02445                 <span class="stringliteral">&quot;classic37           Original Gravis Ultrasound with ICS Mixer (rev 3.7)\n&quot;</span>
<a name="l02446"></a>02446                 <span class="stringliteral">&quot;max                 Gravis Ultrasound MAX emulation (with CS4231 codec)\n&quot;</span>
<a name="l02447"></a>02447                 <span class="stringliteral">&quot;interwave           Gravis Ultrasound Plug &amp; Play (interwave)&quot;</span>);
<a name="l02448"></a>02448 
<a name="l02449"></a>02449     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;ultradir&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;C:\\ULTRASND&quot;</span>);
<a name="l02450"></a>02450     Pstring-&gt;Set_help(
<a name="l02451"></a>02451         <span class="stringliteral">&quot;Path to Ultrasound directory. In this directory\n&quot;</span>
<a name="l02452"></a>02452         <span class="stringliteral">&quot;there should be a MIDI directory that contains\n&quot;</span>
<a name="l02453"></a>02453         <span class="stringliteral">&quot;the patch files for GUS playback. Patch sets used\n&quot;</span>
<a name="l02454"></a>02454         <span class="stringliteral">&quot;with Timidity should work fine.&quot;</span>);
<a name="l02455"></a>02455 
<a name="l02456"></a>02456     secprop = control-&gt;AddSection_prop(<span class="stringliteral">&quot;innova&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l02457"></a>02457     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;innova&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02458"></a>02458     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable the Innovation SSI-2001 emulation.&quot;</span>);
<a name="l02459"></a>02459     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;samplerate&quot;</span>,Property::Changeable::WhenIdle,22050);
<a name="l02460"></a>02460     Pint-&gt;Set_values(rates);
<a name="l02461"></a>02461     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of Innovation SSI-2001 emulation&quot;</span>);
<a name="l02462"></a>02462     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;sidbase&quot;</span>,Property::Changeable::WhenIdle,0x280);
<a name="l02463"></a>02463     Phex-&gt;Set_values(sidbaseno);
<a name="l02464"></a>02464     Phex-&gt;Set_help(<span class="stringliteral">&quot;SID base port (typically 280h).&quot;</span>);
<a name="l02465"></a>02465     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;quality&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l02466"></a>02466     Pint-&gt;Set_values(qualityno);
<a name="l02467"></a>02467     Pint-&gt;Set_help(<span class="stringliteral">&quot;Set SID emulation quality level (0 to 3).&quot;</span>);
<a name="l02468"></a>02468 
<a name="l02469"></a>02469     secprop = control-&gt;AddSection_prop(<span class="stringliteral">&quot;speaker&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l02470"></a>02470     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pcspeaker&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02471"></a>02471     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable PC-Speaker emulation.&quot;</span>);
<a name="l02472"></a>02472 
<a name="l02473"></a>02473     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;initial frequency&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l02474"></a>02474     Pint-&gt;Set_help(<span class="stringliteral">&quot;PC speaker PIT timer is programmed to this frequency on startup. If the DOS game\n&quot;</span>
<a name="l02475"></a>02475             <span class="stringliteral">&quot;or demo causes a long audible beep at startup (leaving the gate open) try setting\n&quot;</span>
<a name="l02476"></a>02476             <span class="stringliteral">&quot;this option to 0 to silence the PC speaker until reprogrammed by the demo.\n&quot;</span>
<a name="l02477"></a>02477             <span class="stringliteral">&quot;Set to 0 for some early Abaddon demos including \&quot;Torso\&quot; and \&quot;Cycling\&quot;.&quot;</span>);
<a name="l02478"></a>02478 
<a name="l02479"></a>02479     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;pcrate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l02480"></a>02480     Pint-&gt;Set_values(rates);
<a name="l02481"></a>02481     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of the PC-Speaker sound generation.&quot;</span>);
<a name="l02482"></a>02482 
<a name="l02483"></a>02483     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;tandy&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02484"></a>02484     Pstring-&gt;Set_values(tandys);
<a name="l02485"></a>02485     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable Tandy Sound System emulation. For &#39;auto&#39;, emulation is present only if machine is set to &#39;tandy&#39;.&quot;</span>);
<a name="l02486"></a>02486 
<a name="l02487"></a>02487     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;tandyrate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l02488"></a>02488     Pint-&gt;Set_values(rates);
<a name="l02489"></a>02489     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of the Tandy 3-Voice generation.&quot;</span>);
<a name="l02490"></a>02490 
<a name="l02491"></a>02491     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;disney&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02492"></a>02492     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable Disney Sound Source emulation. (Covox Voice Master and Speech Thing compatible).&quot;</span>);
<a name="l02493"></a>02493     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;ps1audio&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l02494"></a>02494     Pstring-&gt;Set_values(ps1opt);
<a name="l02495"></a>02495     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable PS1 audio emulation.&quot;</span>);
<a name="l02496"></a>02496     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;ps1audiorate&quot;</span>,Property::Changeable::OnlyAtStart,22050);
<a name="l02497"></a>02497     Pint-&gt;Set_values(rates);
<a name="l02498"></a>02498     Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of the PS1 audio emulation.&quot;</span>);
<a name="l02499"></a>02499 
<a name="l02500"></a>02500     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;joystick&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>);<span class="comment">//done</span>
<a name="l02501"></a>02501     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;joysticktype&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02502"></a>02502     Pstring-&gt;Set_values(joytypes);
<a name="l02503"></a>02503     Pstring-&gt;Set_help(
<a name="l02504"></a>02504         <span class="stringliteral">&quot;Type of joystick to emulate: auto (default), none,\n&quot;</span>
<a name="l02505"></a>02505         <span class="stringliteral">&quot;2axis (supports two joysticks),\n&quot;</span>
<a name="l02506"></a>02506         <span class="stringliteral">&quot;4axis (supports one joystick, first joystick used),\n&quot;</span>
<a name="l02507"></a>02507         <span class="stringliteral">&quot;4axis_2 (supports one joystick, second joystick used),\n&quot;</span>
<a name="l02508"></a>02508         <span class="stringliteral">&quot;fcs (Thrustmaster), ch (CH Flightstick).\n&quot;</span>
<a name="l02509"></a>02509         <span class="stringliteral">&quot;none disables joystick emulation.\n&quot;</span>
<a name="l02510"></a>02510         <span class="stringliteral">&quot;auto chooses emulation depending on real joystick(s).\n&quot;</span>
<a name="l02511"></a>02511         <span class="stringliteral">&quot;(Remember to reset dosbox&#39;s mapperfile if you saved it earlier)&quot;</span>);
<a name="l02512"></a>02512 
<a name="l02513"></a>02513     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;timed&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02514"></a>02514     Pbool-&gt;Set_help(<span class="stringliteral">&quot;enable timed intervals for axis. Experiment with this option, if your joystick drifts (away).&quot;</span>);
<a name="l02515"></a>02515 
<a name="l02516"></a>02516     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;autofire&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02517"></a>02517     Pbool-&gt;Set_help(<span class="stringliteral">&quot;continuously fires as long as you keep the button pressed.&quot;</span>);
<a name="l02518"></a>02518 
<a name="l02519"></a>02519     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;swap34&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02520"></a>02520     Pbool-&gt;Set_help(<span class="stringliteral">&quot;swap the 3rd and the 4th axis. can be useful for certain joysticks.&quot;</span>);
<a name="l02521"></a>02521 
<a name="l02522"></a>02522     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;buttonwrap&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02523"></a>02523     Pbool-&gt;Set_help(<span class="stringliteral">&quot;enable button wrapping at the number of emulated buttons.&quot;</span>);
<a name="l02524"></a>02524 
<a name="l02525"></a>02525         <span class="comment">/*improved joystick</span>
<a name="l02526"></a>02526 <span class="comment">         * each axis has its own deadzone and response</span>
<a name="l02527"></a>02527 <span class="comment">         * each axis index can be remapped, e.g. fix poor driver mappings</span>
<a name="l02528"></a>02528 <span class="comment">         */</span>
<a name="l02529"></a>02529 
<a name="l02530"></a>02530         <span class="comment">/* logical axes settings*/</span>
<a name="l02531"></a>02531         std::vector&lt;int&gt; sticks = { 2, 1 };
<a name="l02532"></a>02532         <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0u; i &lt; sticks.size(); i++)
<a name="l02533"></a>02533         {
<a name="l02534"></a>02534                 <span class="keyword">const</span> <span class="keyword">auto</span> count = sticks[i];
<a name="l02535"></a>02535                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> j = 0; j &lt; count; j++)
<a name="l02536"></a>02536                 {
<a name="l02537"></a>02537                         <span class="keyword">const</span> <span class="keyword">auto</span> joy = std::to_string(i + 1);
<a name="l02538"></a>02538                         <span class="keyword">const</span> <span class="keyword">auto</span> stick = std::to_string(j + 1);
<a name="l02539"></a>02539                         <span class="keyword">const</span> <span class="keyword">auto</span> name = <span class="stringliteral">&quot;joy&quot;</span> + joy + <span class="stringliteral">&quot;deadzone&quot;</span> + stick;
<a name="l02540"></a>02540                         <span class="keyword">const</span> <span class="keyword">auto</span> help = <span class="stringliteral">&quot;deadzone for joystick &quot;</span> + joy + <span class="stringliteral">&quot; thumbstick &quot;</span> + stick + <span class="stringliteral">&quot;.&quot;</span>;
<a name="l02541"></a>02541                         Pdouble = secprop-&gt;Add_double(name, Property::Changeable::WhenIdle, 0.25);
<a name="l02542"></a>02542                         Pdouble-&gt;SetMinMax(0.0, 1.0);
<a name="l02543"></a>02543                         Pdouble-&gt;Set_help(help);
<a name="l02544"></a>02544                 }
<a name="l02545"></a>02545         }
<a name="l02546"></a>02546         <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0u; i &lt; sticks.size(); i++)
<a name="l02547"></a>02547         {
<a name="l02548"></a>02548                 <span class="keyword">const</span> <span class="keyword">auto</span> count = sticks[i];
<a name="l02549"></a>02549                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> j = 0; j &lt; count; j++)
<a name="l02550"></a>02550                 {
<a name="l02551"></a>02551                         <span class="keyword">const</span> <span class="keyword">auto</span> joy = std::to_string(i + 1);
<a name="l02552"></a>02552                         <span class="keyword">const</span> <span class="keyword">auto</span> stick = std::to_string(j + 1);
<a name="l02553"></a>02553                         <span class="keyword">const</span> <span class="keyword">auto</span> name = <span class="stringliteral">&quot;joy&quot;</span> + joy + <span class="stringliteral">&quot;response&quot;</span> + stick;
<a name="l02554"></a>02554                         <span class="keyword">const</span> <span class="keyword">auto</span> help = <span class="stringliteral">&quot;response for joystick &quot;</span> + joy + <span class="stringliteral">&quot; thumbstick &quot;</span> + stick + <span class="stringliteral">&quot;.&quot;</span>;
<a name="l02555"></a>02555                         Pdouble = secprop-&gt;Add_double(name, Property::Changeable::WhenIdle, 1.0);
<a name="l02556"></a>02556                         Pdouble-&gt;SetMinMax(-5.0, 5.0);
<a name="l02557"></a>02557                         Pdouble-&gt;Set_help(help);
<a name="l02558"></a>02558                 }
<a name="l02559"></a>02559         }
<a name="l02560"></a>02560 
<a name="l02561"></a>02561         <span class="keyword">const</span> <span class="keyword">auto</span> joysticks = 2;
<a name="l02562"></a>02562         <span class="keyword">const</span> <span class="keyword">auto</span> axes = 8;
<a name="l02563"></a>02563         <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i &lt; joysticks; i++)
<a name="l02564"></a>02564         {
<a name="l02565"></a>02565                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> j = 0; j &lt; axes; j++)
<a name="l02566"></a>02566                 {
<a name="l02567"></a>02567                         <span class="keyword">const</span> <span class="keyword">auto</span> joy = std::to_string(i + 1);
<a name="l02568"></a>02568                         <span class="keyword">const</span> <span class="keyword">auto</span> axis = std::to_string(j);
<a name="l02569"></a>02569                         <span class="keyword">const</span> <span class="keyword">auto</span> propname = <span class="stringliteral">&quot;joy&quot;</span> + joy + <span class="stringliteral">&quot;axis&quot;</span> + axis;
<a name="l02570"></a>02570                         Pint = secprop-&gt;Add_int(propname, Property::Changeable::WhenIdle, j);
<a name="l02571"></a>02571                         Pint-&gt;SetMinMax(0, axes - 1);
<a name="l02572"></a>02572                         <span class="keyword">const</span> <span class="keyword">auto</span> help = <span class="stringliteral">&quot;axis for joystick &quot;</span> + joy + <span class="stringliteral">&quot; axis &quot;</span> + axis + <span class="stringliteral">&quot;.&quot;</span>;
<a name="l02573"></a>02573                         Pint-&gt;Set_help(help);
<a name="l02574"></a>02574                 }
<a name="l02575"></a>02575         }
<a name="l02576"></a>02576         <span class="comment">/*physical axes settings*/</span>
<a name="l02577"></a>02577         secprop = control-&gt;AddSection_prop(<span class="stringliteral">&quot;mapper&quot;</span>, &amp;Null_Init, <span class="keyword">true</span>);
<a name="l02578"></a>02578 
<a name="l02579"></a>02579         <span class="keyword">const</span> <span class="keyword">auto</span> directions = 2;
<a name="l02580"></a>02580         <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i &lt; joysticks; i++)
<a name="l02581"></a>02581         {
<a name="l02582"></a>02582                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> j = 0; j &lt; axes; j++)
<a name="l02583"></a>02583                 {
<a name="l02584"></a>02584                         <span class="keywordflow">for</span> (<span class="keyword">auto</span> k = 0; k &lt; directions; k++)
<a name="l02585"></a>02585                         {
<a name="l02586"></a>02586                                 <span class="keyword">const</span> <span class="keyword">auto</span> joy = std::to_string(i + 1);
<a name="l02587"></a>02587                                 <span class="keyword">const</span> <span class="keyword">auto</span> axis = std::to_string(j);
<a name="l02588"></a>02588                                 <span class="keyword">const</span> <span class="keyword">auto</span> dir = k == 0 ? <span class="stringliteral">&quot;-&quot;</span> : <span class="stringliteral">&quot;+&quot;</span>;
<a name="l02589"></a>02589                                 <span class="keyword">const</span> <span class="keyword">auto</span> name = <span class="stringliteral">&quot;joy&quot;</span> + joy + <span class="stringliteral">&quot;deadzone&quot;</span> + axis + dir;
<a name="l02590"></a>02590                                 Pdouble = secprop-&gt;Add_double(name, Property::Changeable::WhenIdle, 0.6);
<a name="l02591"></a>02591                                 Pdouble-&gt;SetMinMax(0.0, 1.0);
<a name="l02592"></a>02592                                 <span class="keyword">const</span> <span class="keyword">auto</span> help = <span class="stringliteral">&quot;deadzone for joystick &quot;</span> + joy + <span class="stringliteral">&quot; axis &quot;</span> + axis + dir;
<a name="l02593"></a>02593                                 Pdouble-&gt;Set_help(help);
<a name="l02594"></a>02594                         }
<a name="l02595"></a>02595                 }
<a name="l02596"></a>02596         }
<a name="l02597"></a>02597 
<a name="l02598"></a>02598 
<a name="l02599"></a>02599     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;serial&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l02600"></a>02600 
<a name="l02601"></a>02601     Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;serial1&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02602"></a>02602     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;dummy&quot;</span>);
<a name="l02603"></a>02603     Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;dummy&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02604"></a>02604     Pstring-&gt;Set_values(serials);
<a name="l02605"></a>02605     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02606"></a>02606     Pmulti_remain-&gt;Set_help(
<a name="l02607"></a>02607         <span class="stringliteral">&quot;set type of device connected to com port.\n&quot;</span>
<a name="l02608"></a>02608         <span class="stringliteral">&quot;Can be disabled, dummy, modem, nullmodem, directserial.\n&quot;</span>
<a name="l02609"></a>02609         <span class="stringliteral">&quot;Additional parameters must be in the same line in the form of\n&quot;</span>
<a name="l02610"></a>02610         <span class="stringliteral">&quot;parameter:value. Parameter for all types is irq (optional).\n&quot;</span>
<a name="l02611"></a>02611         <span class="stringliteral">&quot;for directserial: realport (required), rxdelay (optional).\n&quot;</span>
<a name="l02612"></a>02612         <span class="stringliteral">&quot;                 (realport:COM1 realport:ttyS0).\n&quot;</span>
<a name="l02613"></a>02613         <span class="stringliteral">&quot;for modem: listenport (optional).\n&quot;</span>
<a name="l02614"></a>02614         <span class="stringliteral">&quot;for nullmodem: server, rxdelay, txdelay, telnet, usedtr,\n&quot;</span>
<a name="l02615"></a>02615         <span class="stringliteral">&quot;               transparent, port, inhsocket, nonlocal (all optional).\n&quot;</span>
<a name="l02616"></a>02616         <span class="stringliteral">&quot;               connections are limited to localhost unless you specify nonlocal:1\n&quot;</span>
<a name="l02617"></a>02617         <span class="stringliteral">&quot;Example: serial1=modem listenport:5000&quot;</span>);
<a name="l02618"></a>02618 
<a name="l02619"></a>02619     Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;serial2&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02620"></a>02620     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;dummy&quot;</span>);
<a name="l02621"></a>02621     Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;dummy&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02622"></a>02622     Pstring-&gt;Set_values(serials);
<a name="l02623"></a>02623     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02624"></a>02624     Pmulti_remain-&gt;Set_help(<span class="stringliteral">&quot;see serial1&quot;</span>);
<a name="l02625"></a>02625 
<a name="l02626"></a>02626     Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;serial3&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02627"></a>02627     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l02628"></a>02628     Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;disabled&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02629"></a>02629     Pstring-&gt;Set_values(serials);
<a name="l02630"></a>02630     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02631"></a>02631     Pmulti_remain-&gt;Set_help(<span class="stringliteral">&quot;see serial1&quot;</span>);
<a name="l02632"></a>02632 
<a name="l02633"></a>02633     Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;serial4&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02634"></a>02634     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l02635"></a>02635     Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;disabled&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02636"></a>02636     Pstring-&gt;Set_values(serials);
<a name="l02637"></a>02637     Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02638"></a>02638     Pmulti_remain-&gt;Set_help(<span class="stringliteral">&quot;see serial1&quot;</span>);
<a name="l02639"></a>02639 
<a name="l02640"></a>02640 <span class="preprocessor">#if C_PRINTER</span>
<a name="l02641"></a>02641 <span class="preprocessor"></span>    <span class="comment">// printer redirection parameters</span>
<a name="l02642"></a>02642     secprop = control-&gt;AddSection_prop(<span class="stringliteral">&quot;printer&quot;</span>, &amp;Null_Init);
<a name="l02643"></a>02643     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;printer&quot;</span>, Property::Changeable::WhenIdle, <span class="keyword">true</span>);
<a name="l02644"></a>02644     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable printer emulation.&quot;</span>);
<a name="l02645"></a>02645     <span class="comment">//secprop-&gt;Add_string(&quot;fontpath&quot;,&quot;%%windir%%\\fonts&quot;);</span>
<a name="l02646"></a>02646     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dpi&quot;</span>, Property::Changeable::WhenIdle, 360);
<a name="l02647"></a>02647     Pint-&gt;Set_help(<span class="stringliteral">&quot;Resolution of printer (default 360).&quot;</span>);
<a name="l02648"></a>02648     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;width&quot;</span>, Property::Changeable::WhenIdle, 85);
<a name="l02649"></a>02649     Pint-&gt;Set_help(<span class="stringliteral">&quot;Width of paper in 1/10 inch (default 85 = 8.5&#39;&#39;).&quot;</span>);
<a name="l02650"></a>02650     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;height&quot;</span>, Property::Changeable::WhenIdle, 110);
<a name="l02651"></a>02651     Pint-&gt;Set_help(<span class="stringliteral">&quot;Height of paper in 1/10 inch (default 110 = 11.0&#39;&#39;).&quot;</span>);
<a name="l02652"></a>02652 <span class="preprocessor">#ifdef C_LIBPNG</span>
<a name="l02653"></a>02653 <span class="preprocessor"></span>    Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;printoutput&quot;</span>, Property::Changeable::WhenIdle, <span class="stringliteral">&quot;png&quot;</span>);
<a name="l02654"></a>02654 <span class="preprocessor">#else</span>
<a name="l02655"></a>02655 <span class="preprocessor"></span>    Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;printoutput&quot;</span>, Property::Changeable::WhenIdle, <span class="stringliteral">&quot;ps&quot;</span>);
<a name="l02656"></a>02656 <span class="preprocessor">#endif</span>
<a name="l02657"></a>02657 <span class="preprocessor"></span>    Pstring-&gt;Set_help(<span class="stringliteral">&quot;Output method for finished pages: \n&quot;</span>
<a name="l02658"></a>02658 #ifdef C_LIBPNG
<a name="l02659"></a>02659         <span class="stringliteral">&quot;  png     : Creates PNG images (default)\n&quot;</span>
<a name="l02660"></a>02660 #endif
<a name="l02661"></a>02661         <span class="stringliteral">&quot;  ps      : Creates Postscript\n&quot;</span>
<a name="l02662"></a>02662         <span class="stringliteral">&quot;  bmp     : Creates BMP images (very huge files, not recommend)\n&quot;</span>
<a name="l02663"></a>02663 #<span class="keywordflow">if</span> defined (WIN32)
<a name="l02664"></a>02664         <span class="stringliteral">&quot;  printer : Send to an actual printer (Print dialog will appear)&quot;</span>
<a name="l02665"></a>02665 #endif
<a name="l02666"></a>02666     );
<a name="l02667"></a>02667 
<a name="l02668"></a>02668     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;multipage&quot;</span>, Property::Changeable::WhenIdle, <span class="keyword">false</span>);
<a name="l02669"></a>02669     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Adds all pages to one Postscript file or printer job until CTRL-F2 is pressed.&quot;</span>);
<a name="l02670"></a>02670 
<a name="l02671"></a>02671     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;docpath&quot;</span>, Property::Changeable::WhenIdle, <span class="stringliteral">&quot;.&quot;</span>);
<a name="l02672"></a>02672     Pstring-&gt;Set_help(<span class="stringliteral">&quot;The path where the output files are stored.&quot;</span>);
<a name="l02673"></a>02673 
<a name="l02674"></a>02674     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;timeout&quot;</span>, Property::Changeable::WhenIdle, 0);
<a name="l02675"></a>02675     Pint-&gt;Set_help(<span class="stringliteral">&quot;(in milliseconds) if nonzero: the time the page will\n&quot;</span>
<a name="l02676"></a>02676         <span class="stringliteral">&quot;be ejected automatically after when no more data\n&quot;</span>
<a name="l02677"></a>02677         <span class="stringliteral">&quot;arrives at the printer.&quot;</span>);
<a name="l02678"></a>02678 <span class="preprocessor">#endif</span>
<a name="l02679"></a>02679 <span class="preprocessor"></span>
<a name="l02680"></a>02680     <span class="comment">// parallel ports</span>
<a name="l02681"></a>02681     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;parallel&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l02682"></a>02682     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;parallel1&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l02683"></a>02683     Pstring-&gt;Set_help(
<a name="l02684"></a>02684             <span class="stringliteral">&quot;parallel1-3 -- set type of device connected to lpt port.\n&quot;</span>
<a name="l02685"></a>02685             <span class="stringliteral">&quot;Can be:\n&quot;</span>
<a name="l02686"></a>02686             <span class="stringliteral">&quot;   reallpt (direct parallel port passthrough),\n&quot;</span>
<a name="l02687"></a>02687             <span class="stringliteral">&quot;   file (records data to a file or passes it to a device),\n&quot;</span>
<a name="l02688"></a>02688             <span class="stringliteral">&quot;   printer (virtual dot-matrix printer, see [printer] section)\n&quot;</span>
<a name="l02689"></a>02689             <span class="stringliteral">&quot;       disney (attach Disney Sound Source emulation to this port)\n&quot;</span>
<a name="l02690"></a>02690             <span class="stringliteral">&quot;Additional parameters must be in the same line in the form of\n&quot;</span>
<a name="l02691"></a>02691             <span class="stringliteral">&quot;parameter:value.\n&quot;</span>
<a name="l02692"></a>02692             <span class="stringliteral">&quot;  for reallpt:\n&quot;</span>
<a name="l02693"></a>02693             <span class="stringliteral">&quot;  Windows:\n&quot;</span>
<a name="l02694"></a>02694             <span class="stringliteral">&quot;    realbase (the base address of your real parallel port).\n&quot;</span>
<a name="l02695"></a>02695             <span class="stringliteral">&quot;      Default: 378\n&quot;</span>
<a name="l02696"></a>02696             <span class="stringliteral">&quot;    ecpbase (base address of the ECP registers, optional).\n&quot;</span>
<a name="l02697"></a>02697             <span class="stringliteral">&quot;  Linux: realport (the parallel port device i.e. /dev/parport0).\n&quot;</span>
<a name="l02698"></a>02698             <span class="stringliteral">&quot;  for file: \n&quot;</span>
<a name="l02699"></a>02699             <span class="stringliteral">&quot;    dev:&lt;devname&gt; (i.e. dev:lpt1) to forward data to a device,\n&quot;</span>
<a name="l02700"></a>02700             <span class="stringliteral">&quot;    or append:&lt;file&gt; appends data to the specified file.\n&quot;</span>
<a name="l02701"></a>02701             <span class="stringliteral">&quot;    Without the above parameters data is written to files in the capture dir.\n&quot;</span>
<a name="l02702"></a>02702             <span class="stringliteral">&quot;    Additional parameters: timeout:&lt;milliseconds&gt; = how long to wait before\n&quot;</span>
<a name="l02703"></a>02703             <span class="stringliteral">&quot;    closing the file on inactivity (default:500), addFF to add a formfeed when\n&quot;</span>
<a name="l02704"></a>02704             <span class="stringliteral">&quot;    closing, addLF to add a linefeed if the app doesn&#39;t, cp:&lt;codepage number&gt;\n&quot;</span>
<a name="l02705"></a>02705             <span class="stringliteral">&quot;    to perform codepage translation, i.e. cp:437\n&quot;</span>
<a name="l02706"></a>02706             <span class="stringliteral">&quot;  for printer:\n&quot;</span>
<a name="l02707"></a>02707             <span class="stringliteral">&quot;    printer still has it&#39;s own configuration section above.&quot;</span>
<a name="l02708"></a>02708     );
<a name="l02709"></a>02709     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;parallel2&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l02710"></a>02710     Pstring-&gt;Set_help(<span class="stringliteral">&quot;see parallel1&quot;</span>);
<a name="l02711"></a>02711     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;parallel3&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l02712"></a>02712     Pstring-&gt;Set_help(<span class="stringliteral">&quot;see parallel1&quot;</span>);
<a name="l02713"></a>02713 
<a name="l02714"></a>02714     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dongle&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02715"></a>02715     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable dongle&quot;</span>);
<a name="l02716"></a>02716 
<a name="l02717"></a>02717     <span class="comment">/* All the DOS Related stuff, which will eventually start up in the shell */</span>
<a name="l02718"></a>02718     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;dos&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>);<span class="comment">//done</span>
<a name="l02719"></a>02719     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;xms&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02720"></a>02720     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable XMS support.&quot;</span>);
<a name="l02721"></a>02721 
<a name="l02722"></a>02722     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;xms handles&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l02723"></a>02723     Pint-&gt;Set_help(<span class="stringliteral">&quot;Number of XMS handles available for the DOS environment, or 0 to use a reasonable default&quot;</span>);
<a name="l02724"></a>02724 
<a name="l02725"></a>02725     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;shell configuration as commands&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02726"></a>02726     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow entering dosbox.conf configuration parameters as shell commands to get and set settings.\n&quot;</span>
<a name="l02727"></a>02727                     <span class="stringliteral">&quot;This is disabled by default to avoid conflicts between commands and executables.\n&quot;</span>
<a name="l02728"></a>02728                     <span class="stringliteral">&quot;It is recommended to get and set dosbox.conf settings using the CONFIG command instead.\n&quot;</span>
<a name="l02729"></a>02729                     <span class="stringliteral">&quot;Compatibility with DOSBox SVN can be improved by enabling this option.&quot;</span>);
<a name="l02730"></a>02730 
<a name="l02731"></a>02731     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;hma&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02732"></a>02732     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Report through XMS that HMA exists (not necessarily available)&quot;</span>);
<a name="l02733"></a>02733 
<a name="l02734"></a>02734     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;hma allow reservation&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02735"></a>02735     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow TSR and application (anything other than the DOS kernel) to request control of the HMA.\n&quot;</span>
<a name="l02736"></a>02736             <span class="stringliteral">&quot;They will not be able to request control however if the DOS kernel is configured to occupy the HMA (DOS=HIGH)&quot;</span>);
<a name="l02737"></a>02737 
<a name="l02738"></a>02738     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;hard drive data rate limit&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l02739"></a>02739     Pint-&gt;Set_help(<span class="stringliteral">&quot;Slow down (limit) hard disk throughput. This setting controls the limit in bytes/second.\n&quot;</span>
<a name="l02740"></a>02740                    <span class="stringliteral">&quot;Set to 0 to disable the limit, or -1 to use a reasonable default.&quot;</span>);
<a name="l02741"></a>02741 
<a name="l02742"></a>02742     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;hma minimum allocation&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l02743"></a>02743     Pint-&gt;Set_help(<span class="stringliteral">&quot;Minimum allocation size for HMA in bytes (equivalent to /HMAMIN= parameter).&quot;</span>);
<a name="l02744"></a>02744 
<a name="l02745"></a>02745     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;log console&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02746"></a>02746     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, log DOS CON output to the log file.&quot;</span>);
<a name="l02747"></a>02747 
<a name="l02748"></a>02748     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dos in hma&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02749"></a>02749     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Report that DOS occupies HMA (equiv. DOS=HIGH)&quot;</span>);
<a name="l02750"></a>02750 
<a name="l02751"></a>02751     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dos sda size&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l02752"></a>02752     Pint-&gt;Set_help(<span class="stringliteral">&quot;SDA (swappable data area) size, in bytes. Set to 0 to use a reasonable default.&quot;</span>);
<a name="l02753"></a>02753 
<a name="l02754"></a>02754     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;hma free space&quot;</span>,Property::Changeable::WhenIdle,34*1024); <span class="comment">/* default 34KB (TODO: How much does MS-DOS 5.0 usually occupy?) */</span>
<a name="l02755"></a>02755     Pint-&gt;Set_help(<span class="stringliteral">&quot;Controls the amount of free space available in HMA. This setting is not meaningful unless the\n&quot;</span>
<a name="l02756"></a>02756             <span class="stringliteral">&quot;DOS kernel occupies HMA and the emulated DOS version is at least 5.0.&quot;</span>);
<a name="l02757"></a>02757 
<a name="l02758"></a>02758     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;cpm compatibility mode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02759"></a>02759     Pstring-&gt;Set_values(cpm_compat_modes);
<a name="l02760"></a>02760     Pstring-&gt;Set_help(
<a name="l02761"></a>02761             <span class="stringliteral">&quot;This controls how the DOS kernel sets up the CP/M compatibility code in the PSP segment.\n&quot;</span>
<a name="l02762"></a>02762             <span class="stringliteral">&quot;Several options are provided to emulate one of several undocumented behaviors related to the CP/M entry point.\n&quot;</span>
<a name="l02763"></a>02763             <span class="stringliteral">&quot;If set to auto, DOSBox-X will pick the best option to allow it to work properly.\n&quot;</span>
<a name="l02764"></a>02764             <span class="stringliteral">&quot;Unless set to &#39;off&#39;, this option will require the DOS kernel to occupy the first 256 bytes of the HMA memory area\n&quot;</span>
<a name="l02765"></a>02765             <span class="stringliteral">&quot;to prevent crashes when the A20 gate is switched on.\n&quot;</span>
<a name="l02766"></a>02766             <span class="stringliteral">&quot;   auto      Pick the best option\n&quot;</span>
<a name="l02767"></a>02767             <span class="stringliteral">&quot;   off       Turn off the CP/M entry point (program will abort if called)\n&quot;</span>
<a name="l02768"></a>02768             <span class="stringliteral">&quot;   msdos2    MS-DOS 2.x behavior, offset field also doubles as data segment size\n&quot;</span>
<a name="l02769"></a>02769             <span class="stringliteral">&quot;   msdos5    MS-DOS 5.x behavior, entry point becomes one of two fixed addresses\n&quot;</span>
<a name="l02770"></a>02770             <span class="stringliteral">&quot;   direct    Non-standard behavior, encode the CALL FAR directly to the entry point rather than indirectly&quot;</span>);
<a name="l02771"></a>02771 
<a name="l02772"></a>02772     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;share&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02773"></a>02773     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Report SHARE.EXE as resident. Does not actually emulate SHARE functions.&quot;</span>);
<a name="l02774"></a>02774 
<a name="l02775"></a>02775     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;minimum dos initial private segment&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l02776"></a>02776     Phex-&gt;Set_help(<span class="stringliteral">&quot;In non-mainline mapping mode, where DOS structures are allocated from base memory, this sets the\n&quot;</span>
<a name="l02777"></a>02777             <span class="stringliteral">&quot;minimum segment value. Recommended value is 0x70. You may reduce the value down to 0x50 if freeing\n&quot;</span>
<a name="l02778"></a>02778             <span class="stringliteral">&quot;up more memory is important. Set to 0 for default.&quot;</span>);
<a name="l02779"></a>02779 
<a name="l02780"></a>02780     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;minimum mcb segment&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l02781"></a>02781     Phex-&gt;Set_help(<span class="stringliteral">&quot;Minimum segment value to begin memory allocation from, in hexadecimal. Set to 0 for default.\n&quot;</span>
<a name="l02782"></a>02782             <span class="stringliteral">&quot;You can increase available DOS memory by reducing this value down to as low as 0x51, however\n&quot;</span>
<a name="l02783"></a>02783             <span class="stringliteral">&quot;setting it to low can cause some DOS programs to crash or run erratically, and some DOS games\n&quot;</span>
<a name="l02784"></a>02784             <span class="stringliteral">&quot;and demos to cause intermittent static noises when using Sound Blaster output. DOS programs\n&quot;</span>
<a name="l02785"></a>02785             <span class="stringliteral">&quot;compressed with Microsoft EXEPACK will not run if the minimum MCB segment is below 64KB.&quot;</span>);
<a name="l02786"></a>02786 
<a name="l02787"></a>02787     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;minimum mcb free&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l02788"></a>02788     Phex-&gt;Set_help(<span class="stringliteral">&quot;Minimum free segment value to leave free. At startup, the DOS kernel will allocate memory\n&quot;</span>
<a name="l02789"></a>02789                    <span class="stringliteral">&quot;up to this point. This can be used to deal with EXEPACK issues or DOS programs that cannot\n&quot;</span>
<a name="l02790"></a>02790                    <span class="stringliteral">&quot;be loaded too low in memory. This differs from &#39;minimum mcb segment&#39; in that this affects\n&quot;</span>
<a name="l02791"></a>02791                    <span class="stringliteral">&quot;the lowest free block instead of the starting point of the mcb chain.&quot;</span>);
<a name="l02792"></a>02792 
<a name="l02793"></a>02793     <span class="comment">// TODO: Enable by default WHEN the &#39;SD&#39; signature becomes valid, and a valid device list within</span>
<a name="l02794"></a>02794     <span class="comment">//       is emulated properly.</span>
<a name="l02795"></a>02795     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable dummy device mcb&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02796"></a>02796     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), allocate a fake device MCB at the base of conventional memory.\n&quot;</span>
<a name="l02797"></a>02797             <span class="stringliteral">&quot;Clearing this option can reclaim a small amount of conventional memory at the expense of\n&quot;</span>
<a name="l02798"></a>02798             <span class="stringliteral">&quot;some minor DOS compatibility.&quot;</span>);
<a name="l02799"></a>02799 
<a name="l02800"></a>02800     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;maximum environment block size on exec&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l02801"></a>02801     Pint-&gt;SetMinMax(-1,65535);
<a name="l02802"></a>02802     Pint-&gt;Set_help(<span class="stringliteral">&quot;Maximum environment block size to copy for child processes. Set to -1 for default.&quot;</span>);
<a name="l02803"></a>02803 
<a name="l02804"></a>02804     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;additional environment block size on exec&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l02805"></a>02805     Pint-&gt;SetMinMax(-1,65535);
<a name="l02806"></a>02806     Pint-&gt;Set_help(<span class="stringliteral">&quot;When executing a program, compute the size of the parent block then add this amount to allow for a few additional variables.\n&quot;</span>
<a name="l02807"></a>02807             <span class="stringliteral">&quot;If the subprocesses will never add/modify the environment block, you can free up a few additional bytes by setting this to 0.\n&quot;</span>
<a name="l02808"></a>02808             <span class="stringliteral">&quot;Set to -1 for default setting.&quot;</span>);
<a name="l02809"></a>02809 
<a name="l02810"></a>02810     <span class="comment">// DEPRECATED, REMOVE</span>
<a name="l02811"></a>02811     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable a20 on windows init&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02812"></a>02812     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, DOSBox will enable the A20 gate when Windows 3.1/9x broadcasts the INIT message\n&quot;</span>
<a name="l02813"></a>02813             <span class="stringliteral">&quot;at startup. Windows 3.1 appears to make assumptions at some key points on startup about\n&quot;</span>
<a name="l02814"></a>02814             <span class="stringliteral">&quot;A20 that don&#39;t quite hold up and cause Windows 3.1 to crash when you set A20 emulation\n&quot;</span>
<a name="l02815"></a>02815             <span class="stringliteral">&quot;to a20=mask as opposed to a20=fast. This option is enabled by default.&quot;</span>);
<a name="l02816"></a>02816 
<a name="l02817"></a>02817     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero memory on xms memory allocation&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02818"></a>02818     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, memory returned by XMS allocation call is zeroed first. This is NOT what\n&quot;</span>
<a name="l02819"></a>02819             <span class="stringliteral">&quot;DOS actually does, but if set, can help certain DOS games and demos cope with problems\n&quot;</span>
<a name="l02820"></a>02820             <span class="stringliteral">&quot;related to uninitialized variables in extended memory. When enabled this option may\n&quot;</span>
<a name="l02821"></a>02821             <span class="stringliteral">&quot;incur a slight to moderate performance penalty.&quot;</span>);
<a name="l02822"></a>02822 
<a name="l02823"></a>02823     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;dosv&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l02824"></a>02824     Pstring-&gt;Set_values(dosv_settings);
<a name="l02825"></a>02825     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable DOS/V emulation and specify which version to emulate. This option is intended for\n&quot;</span>
<a name="l02826"></a>02826             <span class="stringliteral">&quot;use with games or software originating from Asia that use the double byte character set\n&quot;</span>
<a name="l02827"></a>02827             <span class="stringliteral">&quot;encodings and the DOS/V extensions to display Japanese, Chinese, or Korean text.\n&quot;</span>
<a name="l02828"></a>02828             <span class="stringliteral">&quot;Note that enabling DOS/V replaces 80x25 text mode (INT 10h mode 3) with a EGA/VGA graphics\n&quot;</span>
<a name="l02829"></a>02829             <span class="stringliteral">&quot;mode that emulates text mode to display the characters and may be incompatible with non-Asian\n&quot;</span>
<a name="l02830"></a>02830             <span class="stringliteral">&quot;software that assumes direct access to the text mode via segment 0xB800.\n&quot;</span>
<a name="l02831"></a>02831             <span class="stringliteral">&quot;WARNING: This option is very experimental at this time.&quot;</span>);
<a name="l02832"></a>02832 
<a name="l02833"></a>02833     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;ems&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;true&quot;</span>);
<a name="l02834"></a>02834     Pstring-&gt;Set_values(ems_settings);
<a name="l02835"></a>02835     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable EMS support. The default (=true) provides the best\n&quot;</span>
<a name="l02836"></a>02836         <span class="stringliteral">&quot;compatibility but certain applications may run better with\n&quot;</span>
<a name="l02837"></a>02837         <span class="stringliteral">&quot;other choices, or require EMS support to be disabled (=false)\n&quot;</span>
<a name="l02838"></a>02838         <span class="stringliteral">&quot;to work at all.&quot;</span>);
<a name="l02839"></a>02839 
<a name="l02840"></a>02840     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vcpi&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02841"></a>02841     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set and expanded memory is enabled, also emulate VCPI.&quot;</span>);
<a name="l02842"></a>02842 
<a name="l02843"></a>02843     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;unmask timer on disk io&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02844"></a>02844     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 21h emulation will unmask IRQ 0 (timer interrupt) when the application opens/closes/reads/writes files.&quot;</span>);
<a name="l02845"></a>02845 
<a name="l02846"></a>02846     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero int 67h if no ems&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02847"></a>02847     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If ems=false, leave interrupt vector 67h zeroed out (default true).\n&quot;</span>
<a name="l02848"></a>02848             <span class="stringliteral">&quot;This is a workaround for games or demos that try to detect EMS by whether or not INT 67h is 0000:0000 rather than a proper test.\n&quot;</span>
<a name="l02849"></a>02849             <span class="stringliteral">&quot;This option also affects whether INT 67h is zeroed when booting a guest OS&quot;</span>);
<a name="l02850"></a>02850 
<a name="l02851"></a>02851     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero unused int 68h&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02852"></a>02852     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Leave INT 68h zero at startup.\n&quot;</span>
<a name="l02853"></a>02853             <span class="stringliteral">&quot;Set this to true for certain games that use INT 68h in unusual ways that require a zero value.\n&quot;</span>
<a name="l02854"></a>02854             <span class="stringliteral">&quot;Note that the vector is left at zero anyway when machine=cga.\n&quot;</span>
<a name="l02855"></a>02855             <span class="stringliteral">&quot;This is needed to properly run 1988 game &#39;PopCorn&#39;.&quot;</span>);
<a name="l02856"></a>02856 
<a name="l02857"></a>02857     <span class="comment">/* FIXME: The vm86 monitor in src/ints/ems.cpp is not very stable! Option is default OFF until stabilized! */</span>
<a name="l02858"></a>02858     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;emm386 startup active&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02859"></a>02859     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set and expanded memory is set to emulate emm386, start the DOS machine with EMM386.EXE active\n&quot;</span>
<a name="l02860"></a>02860             <span class="stringliteral">&quot;(running the 16-bit DOS environment from within Virtual 8086 mode). If you will be running anything\n&quot;</span>
<a name="l02861"></a>02861             <span class="stringliteral">&quot;that involves a DOS extender you will also need to enable the VCPI interface as well.&quot;</span>);
<a name="l02862"></a>02862 
<a name="l02863"></a>02863     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero memory on ems memory allocation&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02864"></a>02864     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, memory returned by EMS allocation call is zeroed first. This is NOT what\n&quot;</span>
<a name="l02865"></a>02865             <span class="stringliteral">&quot;DOS actually does, but if set, can help certain DOS games and demos cope with problems\n&quot;</span>
<a name="l02866"></a>02866             <span class="stringliteral">&quot;related to uninitialized variables in expanded memory. When enabled this option may\n&quot;</span>
<a name="l02867"></a>02867             <span class="stringliteral">&quot;incur a slight to moderate performance penalty.&quot;</span>);
<a name="l02868"></a>02868 
<a name="l02869"></a>02869     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;ems system handle memory size&quot;</span>,Property::Changeable::WhenIdle,384);
<a name="l02870"></a>02870     Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of memory associated with system handle, in KB&quot;</span>);
<a name="l02871"></a>02871 
<a name="l02872"></a>02872     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ems system handle on even megabyte&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02873"></a>02873     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, try to allocate the EMM system handle on an even megabyte.\n&quot;</span>
<a name="l02874"></a>02874             <span class="stringliteral">&quot;If the DOS game or demo fiddles with the A20 gate while using EMM386.EXE emulation in virtual 8086 mode, setting this option may help prevent crashes.\n&quot;</span>
<a name="l02875"></a>02875             <span class="stringliteral">&quot;However, forcing allocation on an even megabyte will also cause some extended memory fragmentation and reduce the\n&quot;</span>
<a name="l02876"></a>02876             <span class="stringliteral">&quot;overall amount of extended memory available to the DOS game depending on whether it expects large contiguous chunks\n&quot;</span>
<a name="l02877"></a>02877             <span class="stringliteral">&quot;of extended memory.&quot;</span>);
<a name="l02878"></a>02878 
<a name="l02879"></a>02879     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;umb&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02880"></a>02880     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable UMB support.&quot;</span>);
<a name="l02881"></a>02881 
<a name="l02882"></a>02882     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;umb start&quot;</span>,Property::Changeable::OnlyAtStart,0); <span class="comment">/* &lt;- (0=auto) 0xD000 is mainline DOSBox compatible behavior */</span>
<a name="l02883"></a>02883     Phex-&gt;Set_help(<span class="stringliteral">&quot;UMB region starting segment&quot;</span>);
<a name="l02884"></a>02884 
<a name="l02885"></a>02885     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;umb end&quot;</span>,Property::Changeable::OnlyAtStart,0); <span class="comment">/* &lt;- (0=auto) 0xEFFF is mainline DOSBox compatible (where base=0xD000 and size=0x2000) */</span>
<a name="l02886"></a>02886     Phex-&gt;Set_help(<span class="stringliteral">&quot;UMB region last segment&quot;</span>);
<a name="l02887"></a>02887 
<a name="l02888"></a>02888     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;kernel allocation in umb&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02889"></a>02889     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, dynamic kernel allocation=1, and private area in umb=1, all kernel structures will be allocated from the private area in UMB.\n&quot;</span>
<a name="l02890"></a>02890             <span class="stringliteral">&quot;If you intend to run Windows 3.1 in DOSBox, you must set this option to false else Windows 3.1 will not start.&quot;</span>);
<a name="l02891"></a>02891 
<a name="l02892"></a>02892     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;keep umb on boot&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02893"></a>02893     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If emulating UMBs, keep the UMB around after boot (Mainline DOSBox behavior). If clear, UMB is unmapped when you boot an operating system.&quot;</span>);
<a name="l02894"></a>02894 
<a name="l02895"></a>02895     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;keep private area on boot&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02896"></a>02896     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, keep the DOSBox private area around after boot (Mainline DOSBox behavior). If clear, unmap and discard the private area when you boot an operating system.&quot;</span>);
<a name="l02897"></a>02897 
<a name="l02898"></a>02898     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;private area in umb&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02899"></a>02899     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, keep private DOS segment in upper memory block, usually segment 0xC800 (Mainline DOSBox behavior)\n&quot;</span>
<a name="l02900"></a>02900             <span class="stringliteral">&quot;If clear, place private DOS segment at the base of system memory (just below the MCB)&quot;</span>);
<a name="l02901"></a>02901 
<a name="l02902"></a>02902     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;ver&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02903"></a>02903     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Set DOS version. Specify as major.minor format. A single number is treated as the major version (LFN patch compat). Common settings are:\n&quot;</span>
<a name="l02904"></a>02904             <span class="stringliteral">&quot;auto (or unset)                  Pick a DOS kernel version automatically\n&quot;</span>
<a name="l02905"></a>02905             <span class="stringliteral">&quot;3.3                              MS-DOS 3.3 emulation (not tested!)\n&quot;</span>
<a name="l02906"></a>02906             <span class="stringliteral">&quot;5.0                              MS-DOS 5.0 emulation (recommended for DOS gaming)\n&quot;</span>
<a name="l02907"></a>02907             <span class="stringliteral">&quot;6.22                             MS-DOS 6.22 emulation\n&quot;</span>
<a name="l02908"></a>02908             <span class="stringliteral">&quot;7.0                              Windows 95 (pure DOS mode) emulation\n&quot;</span>);
<a name="l02909"></a>02909 
<a name="l02910"></a>02910     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;automount&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02911"></a>02911     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable automatic mount.&quot;</span>);
<a name="l02912"></a>02912 
<a name="l02913"></a>02913     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int33&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02914"></a>02914     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable INT 33H (mouse) support.&quot;</span>);
<a name="l02915"></a>02915 
<a name="l02916"></a>02916     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int33 hide host cursor if interrupt subroutine&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02917"></a>02917     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the cursor on the host will be hidden if the DOS application provides it&#39;s own\n&quot;</span>
<a name="l02918"></a>02918                     <span class="stringliteral">&quot;interrupt subroutine for the mouse driver to call, which is usually an indication that\n&quot;</span>
<a name="l02919"></a>02919                     <span class="stringliteral">&quot;the DOS game wishes to draw the cursor with it&#39;s own support routines (DeluxePaint II).&quot;</span>);
<a name="l02920"></a>02920 
<a name="l02921"></a>02921     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int33 hide host cursor when polling&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02922"></a>02922     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the cursor on the host will be hidden even if the DOS application has also\n&quot;</span>
<a name="l02923"></a>02923                     <span class="stringliteral">&quot;hidden the cursor in the guest, as long as the DOS application is polling position\n&quot;</span>
<a name="l02924"></a>02924                     <span class="stringliteral">&quot;and button status. This can be useful for DOS programs that draw the cursor on their\n&quot;</span>
<a name="l02925"></a>02925                     <span class="stringliteral">&quot;own instead of using the mouse driver, including most games and DeluxePaint II.&quot;</span>);
<a name="l02926"></a>02926 
<a name="l02927"></a>02927     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int33 disable cell granularity&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02928"></a>02928     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the mouse pointer position is reported at full precision (as if 640x200 coordinates) in all modes.\n&quot;</span>
<a name="l02929"></a>02929                     <span class="stringliteral">&quot;If not set, the mouse pointer position is rounded to the top-left corner of a character cell in text modes.\n&quot;</span>
<a name="l02930"></a>02930                     <span class="stringliteral">&quot;This option is OFF by default.&quot;</span>);
<a name="l02931"></a>02931 
<a name="l02932"></a>02932     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int 13 extensions&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02933"></a>02933     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable INT 13h extensions (functions 0x40-0x48). You will need this enabled if the virtual hard drive image is 8.4GB or larger.&quot;</span>);
<a name="l02934"></a>02934 
<a name="l02935"></a>02935     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;biosps2&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02936"></a>02936     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate BIOS INT 15h PS/2 mouse services\n&quot;</span>
<a name="l02937"></a>02937         <span class="stringliteral">&quot;Note that some OS&#39;s like Microsoft Windows neither use INT 33h nor\n&quot;</span>
<a name="l02938"></a>02938         <span class="stringliteral">&quot;probe the AUX port directly and depend on this BIOS interface exclusively\n&quot;</span>
<a name="l02939"></a>02939         <span class="stringliteral">&quot;for PS/2 mouse support. In other cases there is no harm in leaving this enabled&quot;</span>);
<a name="l02940"></a>02940 
<a name="l02941"></a>02941     <span class="comment">/* bugfix for Yodel &quot;mayday&quot; demo */</span>
<a name="l02942"></a>02942     <span class="comment">/* TODO: Set this option to default to &quot;true&quot; if it turns out most BIOSes unmask the IRQ during INT 15h AH=86 WAIT */</span>
<a name="l02943"></a>02943     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int15 wait force unmask irq&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02944"></a>02944     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Some demos or games mistakingly use INT 15h AH=0x86 (WAIT) while leaving the IRQs needed for it masked.\n&quot;</span>
<a name="l02945"></a>02945             <span class="stringliteral">&quot;If this option is set (by default), the necessary IRQs will be unmasked when INT 15 AH=0x86 is used so that the game or demo does not hang.&quot;</span>);
<a name="l02946"></a>02946 
<a name="l02947"></a>02947     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int15 mouse callback does not preserve registers&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02948"></a>02948     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Set to true if the guest OS or DOS program assigns an INT 15h mouse callback,\n&quot;</span>
<a name="l02949"></a>02949             <span class="stringliteral">&quot;but does not properly preserve CPU registers. Diagnostic function only (default off).&quot;</span>);
<a name="l02950"></a>02950 
<a name="l02951"></a>02951     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;keyboardlayout&quot;</span>,Property::Changeable::WhenIdle, <span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02952"></a>02952     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Language code of the keyboard layout (or none).&quot;</span>);
<a name="l02953"></a>02953 
<a name="l02954"></a>02954     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dbcs&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02955"></a>02955     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable DBCS table.\n&quot;</span>
<a name="l02956"></a>02956             <span class="stringliteral">&quot;CAUTION: Some software will crash without the DBCS table, including the Open Watcom installer.\n&quot;</span>);
<a name="l02957"></a>02957 
<a name="l02958"></a>02958     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;filenamechar&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02959"></a>02959     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable filename char table&quot;</span>);
<a name="l02960"></a>02960 
<a name="l02961"></a>02961     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;collating and uppercase&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02962"></a>02962     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable collating and uppercase table&quot;</span>);
<a name="l02963"></a>02963 
<a name="l02964"></a>02964     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;files&quot;</span>,Property::Changeable::OnlyAtStart,127);
<a name="l02965"></a>02965     Pint-&gt;Set_help(<span class="stringliteral">&quot;Number of file handles available to DOS programs. (equivalent to \&quot;files=\&quot; in config.sys)&quot;</span>);
<a name="l02966"></a>02966 
<a name="l02967"></a>02967     <span class="comment">// DEPRECATED, REMOVE</span>
<a name="l02968"></a>02968     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;con device use int 16h to detect keyboard input&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02969"></a>02969     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, use INT 16h to detect keyboard input (MS-DOS 6.22 behavior). If clear, detect keyboard input by\n&quot;</span>
<a name="l02970"></a>02970             <span class="stringliteral">&quot;peeking into the BIOS keyboard buffer (Mainline DOSBox behavior). You will need to set this\n&quot;</span>
<a name="l02971"></a>02971             <span class="stringliteral">&quot;option for programs that hook INT 16h to handle keyboard input ahead of the DOS console.\n&quot;</span>
<a name="l02972"></a>02972             <span class="stringliteral">&quot;Microsoft Scandisk needs this option to respond to keyboard input correctly.&quot;</span>);
<a name="l02973"></a>02973 
<a name="l02974"></a>02974     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero memory on int 21h memory allocation&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02975"></a>02975     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, memory returned by the INT 21h allocation call is zeroed first. This is NOT what\n&quot;</span>
<a name="l02976"></a>02976             <span class="stringliteral">&quot;DOS actually does, but if set, can help certain DOS games and demos cope with problems\n&quot;</span>
<a name="l02977"></a>02977             <span class="stringliteral">&quot;related to uninitialized variables in the data or stack segment. If you intend to run a\n&quot;</span>
<a name="l02978"></a>02978             <span class="stringliteral">&quot;game or demo known to have this problem (Second Unreal, for example), set to true, else\n&quot;</span>
<a name="l02979"></a>02979             <span class="stringliteral">&quot;set to false. When enabled this option may incur a slight to moderate performance penalty.&quot;</span>);
<a name="l02980"></a>02980 
<a name="l02981"></a>02981     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;ipx&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l02982"></a>02982     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ipx&quot;</span>,Property::Changeable::WhenIdle, <span class="keyword">false</span>);
<a name="l02983"></a>02983     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable ipx over UDP/IP emulation.&quot;</span>);
<a name="l02984"></a>02984 
<a name="l02985"></a>02985     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;ne2000&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l02986"></a>02986     MSG_Add(<span class="stringliteral">&quot;NE2000_CONFIGFILE_HELP&quot;</span>,
<a name="l02987"></a>02987         <span class="stringliteral">&quot;macaddr -- The physical address the emulator will use on your network.\n&quot;</span>
<a name="l02988"></a>02988         <span class="stringliteral">&quot;           If you have multiple DOSBoxes running on your network,\n&quot;</span>
<a name="l02989"></a>02989         <span class="stringliteral">&quot;           this has to be changed. Modify the last three number blocks.\n&quot;</span>
<a name="l02990"></a>02990         <span class="stringliteral">&quot;           I.e. AC:DE:48:88:99:AB.\n&quot;</span>
<a name="l02991"></a>02991         <span class="stringliteral">&quot;realnic -- Specifies which of your network interfaces is used.\n&quot;</span>
<a name="l02992"></a>02992         <span class="stringliteral">&quot;           Write \&#39;list\&#39; here to see the list of devices in the\n&quot;</span>
<a name="l02993"></a>02993         <span class="stringliteral">&quot;           Status Window. Then make your choice and put either the\n&quot;</span>
<a name="l02994"></a>02994         <span class="stringliteral">&quot;           interface number (2 or something) or a part of your adapters\n&quot;</span>
<a name="l02995"></a>02995         <span class="stringliteral">&quot;           name, e.g. VIA here.\n&quot;</span>
<a name="l02996"></a>02996 
<a name="l02997"></a>02997     );
<a name="l02998"></a>02998 
<a name="l02999"></a>02999     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ne2000&quot;</span>, Property::Changeable::WhenIdle, <span class="keyword">false</span>);
<a name="l03000"></a>03000     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable Ethernet passthrough. Requires [Win]Pcap.&quot;</span>);
<a name="l03001"></a>03001 
<a name="l03002"></a>03002     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;nicbase&quot;</span>, Property::Changeable::WhenIdle, 0x300);
<a name="l03003"></a>03003     Phex-&gt;Set_help(<span class="stringliteral">&quot;The base address of the NE2000 board.&quot;</span>);
<a name="l03004"></a>03004 
<a name="l03005"></a>03005     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;nicirq&quot;</span>, Property::Changeable::WhenIdle, 3);
<a name="l03006"></a>03006     Pint-&gt;Set_help(<span class="stringliteral">&quot;The interrupt it uses. Note serial2 uses IRQ3 as default.&quot;</span>);
<a name="l03007"></a>03007 
<a name="l03008"></a>03008     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;macaddr&quot;</span>, Property::Changeable::WhenIdle,<span class="stringliteral">&quot;AC:DE:48:88:99:AA&quot;</span>);
<a name="l03009"></a>03009     Pstring-&gt;Set_help(<span class="stringliteral">&quot;The physical address the emulator will use on your network.\n&quot;</span>
<a name="l03010"></a>03010         <span class="stringliteral">&quot;If you have multiple DOSBoxes running on your network,\n&quot;</span>
<a name="l03011"></a>03011         <span class="stringliteral">&quot;this has to be changed for each. AC:DE:48 is an address range reserved for\n&quot;</span>
<a name="l03012"></a>03012         <span class="stringliteral">&quot;private use, so modify the last three number blocks.\n&quot;</span>
<a name="l03013"></a>03013         <span class="stringliteral">&quot;I.e. AC:DE:48:88:99:AB.&quot;</span>);
<a name="l03014"></a>03014 
<a name="l03015"></a>03015     <span class="comment">/* TODO: Change default to &quot;nat&quot; and then begin implementing support for emulating</span>
<a name="l03016"></a>03016 <span class="comment">     *       an ethernet connection with DOSBox-X as a NAT/firewall between the guest</span>
<a name="l03017"></a>03017 <span class="comment">     *       and the OS. Sort of like &quot;NAT&quot; mode in VirtualBox. When that works, we</span>
<a name="l03018"></a>03018 <span class="comment">     *       can then compile NE2000 support with and without libpcap/winpcap support. */</span>
<a name="l03019"></a>03019     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;realnic&quot;</span>, Property::Changeable::WhenIdle,<span class="stringliteral">&quot;list&quot;</span>);
<a name="l03020"></a>03020     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Specifies which of your network interfaces is used.\n&quot;</span>
<a name="l03021"></a>03021         <span class="stringliteral">&quot;Write \&#39;list\&#39; here to see the list of devices in the\n&quot;</span>
<a name="l03022"></a>03022         <span class="stringliteral">&quot;Status Window. Then make your choice and put either the\n&quot;</span>
<a name="l03023"></a>03023         <span class="stringliteral">&quot;interface number (2 or something) or a part of your adapters\n&quot;</span>
<a name="l03024"></a>03024         <span class="stringliteral">&quot;name, e.g. VIA here.&quot;</span>);
<a name="l03025"></a>03025 
<a name="l03026"></a>03026     <span class="comment">/* floppy controller emulation options and setup */</span>
<a name="l03027"></a>03027     secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;fdc, primary&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>);
<a name="l03028"></a>03028 
<a name="l03029"></a>03029     <span class="comment">/* Primary FDC on by default, secondary is not. Most PCs have only one floppy controller. */</span>
<a name="l03030"></a>03030     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l03031"></a>03031     Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable floppy controller interface&quot;</span>);
<a name="l03032"></a>03032 
<a name="l03033"></a>03033     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pnp&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l03034"></a>03034     Pbool-&gt;Set_help(<span class="stringliteral">&quot;List floppy controller in ISA PnP BIOS enumeration&quot;</span>);
<a name="l03035"></a>03035 
<a name="l03036"></a>03036     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;irq&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use FDC default*/</span>);
<a name="l03037"></a>03037     Pint-&gt;Set_help(<span class="stringliteral">&quot;IRQ used by floppy controller. Set to 0 for default.\n&quot;</span>
<a name="l03038"></a>03038         <span class="stringliteral">&quot;WARNING: Setting the IRQ to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the floppy controller.\n&quot;</span>
<a name="l03039"></a>03039         <span class="stringliteral">&quot;         Setting the IRQ to one already occupied by another device or IDE controller will trigger \&quot;resource conflict\&quot; errors in Windows 95.\n&quot;</span>
<a name="l03040"></a>03040         <span class="stringliteral">&quot;         Normally, floppy controllers use IRQ 6.&quot;</span>);
<a name="l03041"></a>03041 
<a name="l03042"></a>03042     Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;io&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use FDC default*/</span>);
<a name="l03043"></a>03043     Phex-&gt;Set_help(<span class="stringliteral">&quot;Base I/O port for floppy controller. Set to 0 for default.\n&quot;</span>
<a name="l03044"></a>03044         <span class="stringliteral">&quot;WARNING: Setting the I/O port to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l03045"></a>03045         <span class="stringliteral">&quot;         Standard I/O ports are 3F0 and 370.&quot;</span>);
<a name="l03046"></a>03046 
<a name="l03047"></a>03047     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dma&quot;</span>,Property::Changeable::WhenIdle,-1<span class="comment">/*use FDC default*/</span>);
<a name="l03048"></a>03048     Pint-&gt;Set_help(<span class="stringliteral">&quot;DMA channel for floppy controller. Set to -1 for default.\n&quot;</span>
<a name="l03049"></a>03049         <span class="stringliteral">&quot;WARNING: Setting the DMA channel to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l03050"></a>03050         <span class="stringliteral">&quot;         Standard DMA channel is 2.&quot;</span>);
<a name="l03051"></a>03051 
<a name="l03052"></a>03052     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int13fakev86io&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03053"></a>03053     Pbool-&gt;Set_help(
<a name="l03054"></a>03054         <span class="stringliteral">&quot;If set, and int13fakeio is set, certain INT 13h commands will\n&quot;</span>
<a name="l03055"></a>03055         <span class="stringliteral">&quot;cause floppy emulation to issue fake CPU I/O traps (GPF) in\n&quot;</span>
<a name="l03056"></a>03056         <span class="stringliteral">&quot;virtual 8086 mode and a fake IRQ signal. you must enable this option\n&quot;</span>
<a name="l03057"></a>03057         <span class="stringliteral">&quot;if you want 32-bit floppy access in Windows 95 to work with DOSBox.&quot;</span>);
<a name="l03058"></a>03058 
<a name="l03059"></a>03059     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;instant mode&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03060"></a>03060     Pbool-&gt;Set_help(
<a name="l03061"></a>03061         <span class="stringliteral">&quot;If set, all floppy operations are &#39;instantaneous&#39;, they are carried\n&quot;</span>
<a name="l03062"></a>03062         <span class="stringliteral">&quot;out without any delay. Real hardware of course has motor, command\n&quot;</span>
<a name="l03063"></a>03063         <span class="stringliteral">&quot;and data I/O delays and so this option is off by default for realistic\n&quot;</span>
<a name="l03064"></a>03064         <span class="stringliteral">&quot;emulation.&quot;</span>);
<a name="l03065"></a>03065 
<a name="l03066"></a>03066     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;auto-attach to int 13h&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l03067"></a>03067     Pbool-&gt;Set_help(
<a name="l03068"></a>03068         <span class="stringliteral">&quot;If set, DOSBox-X will automatically attach a disk image as being\n&quot;</span>
<a name="l03069"></a>03069         <span class="stringliteral">&quot;inserted into a floppy drive attached to the controller when imgmount is used\n&quot;</span>
<a name="l03070"></a>03070         <span class="stringliteral">&quot;to mount a disk image to drive 0/1 or A/B. If not set, you must specify\n&quot;</span>
<a name="l03071"></a>03071         <span class="stringliteral">&quot;the -fdc option to imgmount to attach drive A/B to the floppy controller\n&quot;</span>
<a name="l03072"></a>03072         <span class="stringliteral">&quot;manually. You must use the -fdc option regardless if loading floppies into\n&quot;</span>
<a name="l03073"></a>03073         <span class="stringliteral">&quot;drives attached to any other FDC than the primary controller&quot;</span>);
<a name="l03074"></a>03074 
<a name="l03075"></a>03075     <span class="comment">/* FIXME: From http://wiki.osdev.org/Floppy_Disk_Controller#Configure</span>
<a name="l03076"></a>03076 <span class="comment">     *</span>
<a name="l03077"></a>03077 <span class="comment">     *    &quot;The three modes are PC-AT mode, PS/2 mode, and Model 30 mode. The most likely mode ... is model 30 mode.</span>
<a name="l03078"></a>03078 <span class="comment">     *    You may find some pre-1996 Pentium machines using PS/2 mode. You can ignore PC-AT mode.&quot;</span>
<a name="l03079"></a>03079 <span class="comment">     *</span>
<a name="l03080"></a>03080 <span class="comment">     *    What? What the fuck are you talking about?</span>
<a name="l03081"></a>03081 <span class="comment">     *</span>
<a name="l03082"></a>03082 <span class="comment">     *    &quot;AT mode&quot; seems to imply the presense of port 3F7. PS/2 mode seems to imply the presense of 3F0-3F1 and 3F7.</span>
<a name="l03083"></a>03083 <span class="comment">     *    A Toshiba laptop (Satellite Pro 465CDX) has port 3F7 but not 3F0-3F1. By other documentation I&#39;ve found, that</span>
<a name="l03084"></a>03084 <span class="comment">     *    means this laptop (which came out late 1997) is running in AT mode! There&#39;s plenty of hardware running in both</span>
<a name="l03085"></a>03085 <span class="comment">     *    PS/2 and AT mode, even some very old stuff in my pile of junk dating back to 1990!</span>
<a name="l03086"></a>03086 <span class="comment">     *</span>
<a name="l03087"></a>03087 <span class="comment">     *    Somehow I think this information is as correct as their ATAPI programming docs on how to read CD-ROM</span>
<a name="l03088"></a>03088 <span class="comment">     *    sectors: it&#39;s a start but it&#39;s mostly wrong. Hopefully DOSLIB will shed light on what the real differences</span>
<a name="l03089"></a>03089 <span class="comment">     *    are and what is most common. --J.C. */</span>
<a name="l03090"></a>03090     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;ps2&quot;</span>);
<a name="l03091"></a>03091     Pstring-&gt;Set_help(
<a name="l03092"></a>03092         <span class="stringliteral">&quot;Floppy controller mode. What the controller acts like.\n&quot;</span>
<a name="l03093"></a>03093         <span class="stringliteral">&quot;  ps2                          PS/2 mode (most common)\n&quot;</span>
<a name="l03094"></a>03094         <span class="stringliteral">&quot;  ps2_model30                  PS/2 model 30\n&quot;</span>
<a name="l03095"></a>03095         <span class="stringliteral">&quot;  at                           AT mode\n&quot;</span>
<a name="l03096"></a>03096         <span class="stringliteral">&quot;  xt                           PC/XT mode&quot;</span>);
<a name="l03097"></a>03097 
<a name="l03098"></a>03098     <span class="comment">/* FIXME: Not yet implemented. Future plans */</span>
<a name="l03099"></a>03099     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;chip&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;82077aa&quot;</span>);
<a name="l03100"></a>03100     Pstring-&gt;Set_help(
<a name="l03101"></a>03101         <span class="stringliteral">&quot;Floppy controller chipset\n&quot;</span>
<a name="l03102"></a>03102         <span class="stringliteral">&quot;  82077aa                      Intel 82077AA chipset\n&quot;</span>
<a name="l03103"></a>03103         <span class="stringliteral">&quot;  82072                        Intel 82072 chipset\n&quot;</span>
<a name="l03104"></a>03104         <span class="stringliteral">&quot;  nec_uPD765                   NEC uPD765 chipset\n&quot;</span>
<a name="l03105"></a>03105         <span class="stringliteral">&quot;  none                         No chipset (For PC/XT mode)&quot;</span>);
<a name="l03106"></a>03106 
<a name="l03107"></a>03107     <span class="comment">/* IDE emulation options and setup */</span>
<a name="l03108"></a>03108     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; MAX_IDE_CONTROLLERS;i++) {
<a name="l03109"></a>03109         secprop=control-&gt;AddSection_prop(ide_names[i],&amp;Null_Init,<span class="keyword">false</span>);<span class="comment">//done</span>
<a name="l03110"></a>03110 
<a name="l03111"></a>03111         <span class="comment">/* Primary and Secondary are on by default, Teritary and Quaternary are off by default.</span>
<a name="l03112"></a>03112 <span class="comment">         * Throughout the life of the IDE interface it was far more common for a PC to have just</span>
<a name="l03113"></a>03113 <span class="comment">         * a Primary and Secondary interface */</span>
<a name="l03114"></a>03114         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable&quot;</span>,Property::Changeable::OnlyAtStart,(i &lt; 2) ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l03115"></a>03115         <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable IDE interface&quot;</span>);
<a name="l03116"></a>03116 
<a name="l03117"></a>03117         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pnp&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l03118"></a>03118         <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(<span class="stringliteral">&quot;List IDE device in ISA PnP BIOS enumeration&quot;</span>);
<a name="l03119"></a>03119 
<a name="l03120"></a>03120         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;irq&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE default*/</span>);
<a name="l03121"></a>03121         <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;IRQ used by IDE controller. Set to 0 for default.\n&quot;</span>
<a name="l03122"></a>03122                 <span class="stringliteral">&quot;WARNING: Setting the IRQ to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l03123"></a>03123                 <span class="stringliteral">&quot;         Setting the IRQ to one already occupied by another device or IDE controller will trigger \&quot;resource conflict\&quot; errors in Windows 95.\n&quot;</span>
<a name="l03124"></a>03124                 <span class="stringliteral">&quot;         Using IRQ 9, 12, 13, or IRQ 2-7 may cause problems with MS-DOS CD-ROM drivers.&quot;</span>);
<a name="l03125"></a>03125 
<a name="l03126"></a>03126         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;io&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE default*/</span>);
<a name="l03127"></a>03127         <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Base I/O port for IDE controller. Set to 0 for default.\n&quot;</span>
<a name="l03128"></a>03128                 <span class="stringliteral">&quot;WARNING: Setting the I/O port to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l03129"></a>03129                 <span class="stringliteral">&quot;         Using any port other than 1F0, 170, 1E8 or 168 can prevent MS-DOS CD-ROM drivers from detecting the IDE controller.&quot;</span>);
<a name="l03130"></a>03130 
<a name="l03131"></a>03131         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;altio&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE default*/</span>);
<a name="l03132"></a>03132         <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Alternate I/O port for IDE controller (alt status, etc). Set to 0 for default.\n&quot;</span>
<a name="l03133"></a>03133                 <span class="stringliteral">&quot;WARNING: Setting the I/O port to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l03134"></a>03134                 <span class="stringliteral">&quot;         For best compatability set this value to io+0x206, for example, io=1F0 altio=3F6.\n&quot;</span>
<a name="l03135"></a>03135                 <span class="stringliteral">&quot;         The primary IDE controller will not claim port 3F7 if the primary floppy controller is enabled due to I/O port overlap in the 3F0-3F7 range.&quot;</span>);
<a name="l03136"></a>03136 
<a name="l03137"></a>03137         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int13fakeio&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03138"></a>03138         <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(
<a name="l03139"></a>03139                 <span class="stringliteral">&quot;If set, force IDE state change on certain INT 13h commands.\n&quot;</span>
<a name="l03140"></a>03140                 <span class="stringliteral">&quot;IDE registers will be changed as if BIOS had carried out the action.\n&quot;</span>
<a name="l03141"></a>03141                 <span class="stringliteral">&quot;If you are running Windows 3.11 or Windows 3.11 Windows for Workgroups\n&quot;</span>
<a name="l03142"></a>03142                 <span class="stringliteral">&quot;you must enable this option (and use -reservecyl 1) if you want 32-bit\n&quot;</span>
<a name="l03143"></a>03143                 <span class="stringliteral">&quot;disk access to work correctly in DOSBox.&quot;</span>);
<a name="l03144"></a>03144 
<a name="l03145"></a>03145         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int13fakev86io&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03146"></a>03146         <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(
<a name="l03147"></a>03147                 <span class="stringliteral">&quot;If set, and int13fakeio is set, certain INT 13h commands will\n&quot;</span>
<a name="l03148"></a>03148                 <span class="stringliteral">&quot;cause IDE emulation to issue fake CPU I/O traps (GPF) in\n&quot;</span>
<a name="l03149"></a>03149                 <span class="stringliteral">&quot;virtual 8086 mode and a fake IRQ signal. you must enable this option\n&quot;</span>
<a name="l03150"></a>03150                 <span class="stringliteral">&quot;if you want 32-bit disk access in Windows 95 to work with DOSBox.&quot;</span>);
<a name="l03151"></a>03151 
<a name="l03152"></a>03152         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable pio32&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03153"></a>03153         <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(
<a name="l03154"></a>03154                 <span class="stringliteral">&quot;If set, 32-bit I/O reads and writes are handled directly (much like PCI IDE implementations)\n&quot;</span>
<a name="l03155"></a>03155                 <span class="stringliteral">&quot;If clear, 32-bit I/O will be handled as if two 16-bit I/O (much like ISA IDE implementations)&quot;</span>);
<a name="l03156"></a>03156 
<a name="l03157"></a>03157         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore pio32&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l03158"></a>03158         <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(
<a name="l03159"></a>03159                 <span class="stringliteral">&quot;If 32-bit I/O is enabled, attempts to read/write 32-bit I/O will be ignored entirely.\n&quot;</span>
<a name="l03160"></a>03160                 <span class="stringliteral">&quot;In this way, you can have DOSBox emulate one of the strange quirks of 1995-1997 era\n&quot;</span>
<a name="l03161"></a>03161                 <span class="stringliteral">&quot;laptop hardware&quot;</span>);
<a name="l03162"></a>03162 
<a name="l03163"></a>03163         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cd-rom spinup time&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE or CD-ROM default*/</span>);
<a name="l03164"></a>03164         <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Emulated CD-ROM time in ms to spin up if CD is stationary.\n&quot;</span>
<a name="l03165"></a>03165                 <span class="stringliteral">&quot;Set to 0 to use controller or CD-ROM drive-specific default.&quot;</span>);
<a name="l03166"></a>03166 
<a name="l03167"></a>03167         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cd-rom spindown timeout&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE or CD-ROM default*/</span>);
<a name="l03168"></a>03168         <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Emulated CD-ROM time in ms that drive will spin down automatically when not in use\n&quot;</span>
<a name="l03169"></a>03169                 <span class="stringliteral">&quot;Set to 0 to use controller or CD-ROM drive-specific default.&quot;</span>);
<a name="l03170"></a>03170 
<a name="l03171"></a>03171         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cd-rom insertion delay&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE or CD-ROM default*/</span>);
<a name="l03172"></a>03172         <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Emulated CD-ROM time in ms that drive will report \&quot;medium not present\&quot;\n&quot;</span>
<a name="l03173"></a>03173                 <span class="stringliteral">&quot;to emulate the time it takes for someone to take out a CD and insert a new one when\n&quot;</span>
<a name="l03174"></a>03174                 <span class="stringliteral">&quot;DOSBox is instructed to swap or change CDs.\n&quot;</span>
<a name="l03175"></a>03175                 <span class="stringliteral">&quot;When running Windows 95 or higher a delay of 4000ms is recommended to ensure that\n&quot;</span>
<a name="l03176"></a>03176                 <span class="stringliteral">&quot;auto-insert notification triggers properly.\n&quot;</span>
<a name="l03177"></a>03177                 <span class="stringliteral">&quot;Set to 0 to use controller or CD-ROM drive-specific default.&quot;</span>);
<a name="l03178"></a>03178     }
<a name="l03179"></a>03179 
<a name="l03180"></a>03180     <span class="comment">//TODO ?</span>
<a name="l03181"></a>03181     control-&gt;AddSection_line(<span class="stringliteral">&quot;autoexec&quot;</span>,&amp;Null_Init);
<a name="l03182"></a>03182     MSG_Add(<span class="stringliteral">&quot;AUTOEXEC_CONFIGFILE_HELP&quot;</span>,
<a name="l03183"></a>03183         <span class="stringliteral">&quot;Lines in this section will be run at startup.\n&quot;</span>
<a name="l03184"></a>03184         <span class="stringliteral">&quot;You can put your MOUNT lines here.\n&quot;</span>
<a name="l03185"></a>03185     );
<a name="l03186"></a>03186     MSG_Add(<span class="stringliteral">&quot;CONFIGFILE_INTRO&quot;</span>,
<a name="l03187"></a>03187             <span class="stringliteral">&quot;# This is the configuration file for DOSBox %s. (Please use the latest version of DOSBox)\n&quot;</span>
<a name="l03188"></a>03188             <span class="stringliteral">&quot;# Lines starting with a # are comment lines and are ignored by DOSBox.\n&quot;</span>
<a name="l03189"></a>03189             <span class="stringliteral">&quot;# They are used to (briefly) document the effect of each option.\n&quot;</span>
<a name="l03190"></a>03190         <span class="stringliteral">&quot;# To write out ALL options, use command &#39;config -all&#39; with -wc or -writeconf options.\n&quot;</span>);
<a name="l03191"></a>03191     MSG_Add(<span class="stringliteral">&quot;CONFIG_SUGGESTED_VALUES&quot;</span>, <span class="stringliteral">&quot;Possible values&quot;</span>);
<a name="l03192"></a>03192 }
<a name="l03193"></a>03193 
<a name="l03194"></a>03194 <span class="keywordtype">int</span> utf8_encode(<span class="keywordtype">char</span> **ptr,<span class="keywordtype">char</span> *fence,uint32_t code) {
<a name="l03195"></a>03195     <span class="keywordtype">int</span> uchar_size=1;
<a name="l03196"></a>03196     <span class="keywordtype">char</span> *p = *ptr;
<a name="l03197"></a>03197 
<a name="l03198"></a>03198     <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03199"></a>03199     <span class="keywordflow">if</span> (code &gt;= (uint32_t)0x80000000UL) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03200"></a>03200     <span class="keywordflow">if</span> (p &gt;= fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03201"></a>03201 
<a name="l03202"></a>03202     <span class="keywordflow">if</span> (code &gt;= 0x4000000) uchar_size = 6;
<a name="l03203"></a>03203     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 0x200000) uchar_size = 5;
<a name="l03204"></a>03204     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 0x10000) uchar_size = 4;
<a name="l03205"></a>03205     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 0x800) uchar_size = 3;
<a name="l03206"></a>03206     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 0x80) uchar_size = 2;
<a name="l03207"></a>03207 
<a name="l03208"></a>03208     <span class="keywordflow">if</span> ((p+uchar_size) &gt; fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03209"></a>03209 
<a name="l03210"></a>03210     <span class="keywordflow">switch</span> (uchar_size) {
<a name="l03211"></a>03211         <span class="keywordflow">case</span> 1: *p++ = (char)code;
<a name="l03212"></a>03212             <span class="keywordflow">break</span>;
<a name="l03213"></a>03213         <span class="keywordflow">case</span> 2: *p++ = (char)(0xC0 | (code &gt;&gt; 6));
<a name="l03214"></a>03214             *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l03215"></a>03215             <span class="keywordflow">break</span>;
<a name="l03216"></a>03216         <span class="keywordflow">case</span> 3: *p++ = (char)(0xE0 | (code &gt;&gt; 12));
<a name="l03217"></a>03217             *p++ = (char)(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
<a name="l03218"></a>03218             *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l03219"></a>03219             <span class="keywordflow">break</span>;
<a name="l03220"></a>03220         <span class="keywordflow">case</span> 4: *p++ = (char)(0xF0 | (code &gt;&gt; 18));
<a name="l03221"></a>03221             *p++ = (char)(0x80 | ((code &gt;&gt; 12) &amp; 0x3F));
<a name="l03222"></a>03222             *p++ = (char)(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
<a name="l03223"></a>03223             *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l03224"></a>03224             <span class="keywordflow">break</span>;
<a name="l03225"></a>03225         <span class="keywordflow">case</span> 5: *p++ = (char)(0xF8 | (code &gt;&gt; 24));
<a name="l03226"></a>03226             *p++ = (char)(0x80 | ((code &gt;&gt; 18) &amp; 0x3F));
<a name="l03227"></a>03227             *p++ = (char)(0x80 | ((code &gt;&gt; 12) &amp; 0x3F));
<a name="l03228"></a>03228             *p++ = (char)(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
<a name="l03229"></a>03229             *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l03230"></a>03230             <span class="keywordflow">break</span>;
<a name="l03231"></a>03231         <span class="keywordflow">case</span> 6: *p++ = (char)(0xFC | (code &gt;&gt; 30));
<a name="l03232"></a>03232             *p++ = (char)(0x80 | ((code &gt;&gt; 24) &amp; 0x3F));
<a name="l03233"></a>03233             *p++ = (char)(0x80 | ((code &gt;&gt; 18) &amp; 0x3F));
<a name="l03234"></a>03234             *p++ = (char)(0x80 | ((code &gt;&gt; 12) &amp; 0x3F));
<a name="l03235"></a>03235             *p++ = (char)(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
<a name="l03236"></a>03236             *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l03237"></a>03237             <span class="keywordflow">break</span>;
<a name="l03238"></a>03238     }
<a name="l03239"></a>03239 
<a name="l03240"></a>03240     *ptr = p;
<a name="l03241"></a>03241     <span class="keywordflow">return</span> 0;
<a name="l03242"></a>03242 }
<a name="l03243"></a>03243 
<a name="l03244"></a>03244 <span class="keywordtype">int</span> utf8_decode(<span class="keyword">const</span> <span class="keywordtype">char</span> **ptr,<span class="keyword">const</span> <span class="keywordtype">char</span> *fence) {
<a name="l03245"></a>03245     <span class="keyword">const</span> <span class="keywordtype">char</span> *p = *ptr;
<a name="l03246"></a>03246     <span class="keywordtype">int</span> uchar_size=1;
<a name="l03247"></a>03247     <span class="keywordtype">int</span> ret = 0,c;
<a name="l03248"></a>03248 
<a name="l03249"></a>03249     <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03250"></a>03250     <span class="keywordflow">if</span> (p &gt;= fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03251"></a>03251 
<a name="l03252"></a>03252     ret = (<span class="keywordtype">unsigned</span> char)(*p);
<a name="l03253"></a>03253     <span class="keywordflow">if</span> (ret &gt;= 0xFE) { p++; <span class="keywordflow">return</span> UTF8ERR_INVALID; }
<a name="l03254"></a>03254     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xFC) uchar_size=6;
<a name="l03255"></a>03255     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xF8) uchar_size=5;
<a name="l03256"></a>03256     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xF0) uchar_size=4;
<a name="l03257"></a>03257     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xE0) uchar_size=3;
<a name="l03258"></a>03258     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xC0) uchar_size=2;
<a name="l03259"></a>03259     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0x80) { p++; <span class="keywordflow">return</span> UTF8ERR_INVALID; }
<a name="l03260"></a>03260 
<a name="l03261"></a>03261     <span class="keywordflow">if</span> ((p+uchar_size) &gt; fence)
<a name="l03262"></a>03262         <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03263"></a>03263 
<a name="l03264"></a>03264     <span class="keywordflow">switch</span> (uchar_size) {
<a name="l03265"></a>03265         <span class="keywordflow">case</span> 1: p++;
<a name="l03266"></a>03266             <span class="keywordflow">break</span>;
<a name="l03267"></a>03267         <span class="keywordflow">case</span> 2: ret = (ret&amp;0x1F)&lt;&lt;6; p++;
<a name="l03268"></a>03268             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03269"></a>03269             ret |= c&amp;0x3F;
<a name="l03270"></a>03270             <span class="keywordflow">break</span>;
<a name="l03271"></a>03271         <span class="keywordflow">case</span> 3: ret = (ret&amp;0xF)&lt;&lt;12; p++;
<a name="l03272"></a>03272             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03273"></a>03273             ret |= (c&amp;0x3F)&lt;&lt;6;
<a name="l03274"></a>03274             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03275"></a>03275             ret |= c&amp;0x3F;
<a name="l03276"></a>03276             <span class="keywordflow">break</span>;
<a name="l03277"></a>03277         <span class="keywordflow">case</span> 4: ret = (ret&amp;0x7)&lt;&lt;18; p++;
<a name="l03278"></a>03278             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03279"></a>03279             ret |= (c&amp;0x3F)&lt;&lt;12;
<a name="l03280"></a>03280             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03281"></a>03281             ret |= (c&amp;0x3F)&lt;&lt;6;
<a name="l03282"></a>03282             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03283"></a>03283             ret |= c&amp;0x3F;
<a name="l03284"></a>03284             <span class="keywordflow">break</span>;
<a name="l03285"></a>03285         <span class="keywordflow">case</span> 5: ret = (ret&amp;0x3)&lt;&lt;24; p++;
<a name="l03286"></a>03286             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03287"></a>03287             ret |= (c&amp;0x3F)&lt;&lt;18;
<a name="l03288"></a>03288             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03289"></a>03289             ret |= (c&amp;0x3F)&lt;&lt;12;
<a name="l03290"></a>03290             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03291"></a>03291             ret |= (c&amp;0x3F)&lt;&lt;6;
<a name="l03292"></a>03292             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03293"></a>03293             ret |= c&amp;0x3F;
<a name="l03294"></a>03294             <span class="keywordflow">break</span>;
<a name="l03295"></a>03295         <span class="keywordflow">case</span> 6: ret = (ret&amp;0x1)&lt;&lt;30; p++;
<a name="l03296"></a>03296             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03297"></a>03297             ret |= (c&amp;0x3F)&lt;&lt;24;
<a name="l03298"></a>03298             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03299"></a>03299             ret |= (c&amp;0x3F)&lt;&lt;18;
<a name="l03300"></a>03300             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03301"></a>03301             ret |= (c&amp;0x3F)&lt;&lt;12;
<a name="l03302"></a>03302             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03303"></a>03303             ret |= (c&amp;0x3F)&lt;&lt;6;
<a name="l03304"></a>03304             c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03305"></a>03305             ret |= c&amp;0x3F;
<a name="l03306"></a>03306             <span class="keywordflow">break</span>;
<a name="l03307"></a>03307     }
<a name="l03308"></a>03308 
<a name="l03309"></a>03309     *ptr = p;
<a name="l03310"></a>03310     <span class="keywordflow">return</span> ret;
<a name="l03311"></a>03311 }
<a name="l03312"></a>03312 
<a name="l03313"></a>03313 <span class="keywordtype">int</span> utf16le_encode(<span class="keywordtype">char</span> **ptr,<span class="keywordtype">char</span> *fence,uint32_t code) {
<a name="l03314"></a>03314     <span class="keywordtype">char</span> *p = *ptr;
<a name="l03315"></a>03315 
<a name="l03316"></a>03316     <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03317"></a>03317     <span class="keywordflow">if</span> (code &gt; 0x10FFFF) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03318"></a>03318     <span class="keywordflow">if</span> (code &gt; 0xFFFF) { <span class="comment">/* UTF-16 surrogate pair */</span>
<a name="l03319"></a>03319         uint32_t lo = (code - 0x10000) &amp; 0x3FF;
<a name="l03320"></a>03320         uint32_t hi = ((code - 0x10000) &gt;&gt; 10) &amp; 0x3FF;
<a name="l03321"></a>03321         <span class="keywordflow">if</span> ((p+2+2) &gt; fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03322"></a>03322         *p++ = (char)( (hi+0xD800)       &amp; 0xFF);
<a name="l03323"></a>03323         *p++ = (char)(((hi+0xD800) &gt;&gt; 8) &amp; 0xFF);
<a name="l03324"></a>03324         *p++ = (char)( (lo+0xDC00)       &amp; 0xFF);
<a name="l03325"></a>03325         *p++ = (char)(((lo+0xDC00) &gt;&gt; 8) &amp; 0xFF);
<a name="l03326"></a>03326     }
<a name="l03327"></a>03327     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((code&amp;0xF800) == 0xD800) { <span class="comment">/* do not allow accidental surrogate pairs (0xD800-0xDFFF) */</span>
<a name="l03328"></a>03328         <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03329"></a>03329     }
<a name="l03330"></a>03330     <span class="keywordflow">else</span> {
<a name="l03331"></a>03331         <span class="keywordflow">if</span> ((p+2) &gt; fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03332"></a>03332         *p++ = (char)( code       &amp; 0xFF);
<a name="l03333"></a>03333         *p++ = (char)((code &gt;&gt; 8) &amp; 0xFF);
<a name="l03334"></a>03334     }
<a name="l03335"></a>03335 
<a name="l03336"></a>03336     *ptr = p;
<a name="l03337"></a>03337     <span class="keywordflow">return</span> 0;
<a name="l03338"></a>03338 }
<a name="l03339"></a>03339 
<a name="l03340"></a>03340 <span class="keywordtype">int</span> utf16le_decode(<span class="keyword">const</span> <span class="keywordtype">char</span> **ptr,<span class="keyword">const</span> <span class="keywordtype">char</span> *fence) {
<a name="l03341"></a>03341     <span class="keyword">const</span> <span class="keywordtype">char</span> *p = *ptr;
<a name="l03342"></a>03342     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ret,b=2;
<a name="l03343"></a>03343 
<a name="l03344"></a>03344     <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03345"></a>03345     <span class="keywordflow">if</span> ((p+1) &gt;= fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03346"></a>03346 
<a name="l03347"></a>03347     ret = (<span class="keywordtype">unsigned</span> char)p[0];
<a name="l03348"></a>03348     ret |= ((<span class="keywordtype">unsigned</span> int)((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)p[1])) &lt;&lt; 8;
<a name="l03349"></a>03349     <span class="keywordflow">if</span> (ret &gt;= 0xD800U &amp;&amp; ret &lt;= 0xDBFFU)
<a name="l03350"></a>03350         b=4;
<a name="l03351"></a>03351     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xDC00U &amp;&amp; ret &lt;= 0xDFFFU)
<a name="l03352"></a>03352         { p++; <span class="keywordflow">return</span> UTF8ERR_INVALID; }
<a name="l03353"></a>03353 
<a name="l03354"></a>03354     <span class="keywordflow">if</span> ((p+b) &gt; fence)
<a name="l03355"></a>03355         <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l03356"></a>03356 
<a name="l03357"></a>03357     p += 2;
<a name="l03358"></a>03358     <span class="keywordflow">if</span> (ret &gt;= 0xD800U &amp;&amp; ret &lt;= 0xDBFFU) {
<a name="l03359"></a>03359         <span class="comment">/* decode surrogate pair */</span>
<a name="l03360"></a>03360         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hi = ret &amp; 0x3FFU;
<a name="l03361"></a>03361         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lo = (<span class="keywordtype">unsigned</span> char)p[0];
<a name="l03362"></a>03362         lo |= ((<span class="keywordtype">unsigned</span> int)((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)p[1])) &lt;&lt; 8;
<a name="l03363"></a>03363         p += 2;
<a name="l03364"></a>03364         <span class="keywordflow">if</span> (lo &lt; 0xDC00U || lo &gt; 0xDFFFU) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l03365"></a>03365         lo &amp;= 0x3FFU;
<a name="l03366"></a>03366         ret = ((hi &lt;&lt; 10U) | lo) + 0x10000U;
<a name="l03367"></a>03367     }
<a name="l03368"></a>03368 
<a name="l03369"></a>03369     *ptr = p;
<a name="l03370"></a>03370     <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)ret;
<a name="l03371"></a>03371 }
<a name="l03372"></a>03372 
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 14 2019 12:08:01 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
