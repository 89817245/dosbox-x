<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DOSBox-X: src/dosbox.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DOSBox-X
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">src/dosbox.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  Copyright (C) 2002-2015  The DOSBox Team</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> *  This program is free software; you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment"> *  (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *  This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment"> *  GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment"> *  along with this program; if not, write to the Free Software</span>
<a name="l00016"></a>00016 <span class="comment"> *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">/* NTS: Valgrind hunting shows memory leak from C++ new operator somewhere</span>
<a name="l00020"></a>00020 <span class="comment"> *      with the JACK library indirectly invoked by SDL audio. Can we resolve</span>
<a name="l00021"></a>00021 <span class="comment"> *      that too eventually? */</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/* NTS: Valgrind hunting also shows one of the section INIT functions (I can&#39;t</span>
<a name="l00024"></a>00024 <span class="comment"> *      yet tell which one because the stack trace doesn&#39;t show it) is allocating</span>
<a name="l00025"></a>00025 <span class="comment"> *      something and is not freeing it. */</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">/* NTS: Valgrind hunting has a moderate to high signal-to-noise ratio because</span>
<a name="l00028"></a>00028 <span class="comment"> *      of memory leaks (lazy memory allocation) from other libraries in the</span>
<a name="l00029"></a>00029 <span class="comment"> *      system, including:</span>
<a name="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031"></a>00031 <span class="comment"> *         ncurses</span>
<a name="l00032"></a>00032 <span class="comment"> *         libSDL</span>
<a name="l00033"></a>00033 <span class="comment"> *         libX11 and libXCB</span>
<a name="l00034"></a>00034 <span class="comment"> *         libasound (ALSA sound library)</span>
<a name="l00035"></a>00035 <span class="comment"> *         PulseAudio library calls</span>
<a name="l00036"></a>00036 <span class="comment"> *         JACK library calls</span>
<a name="l00037"></a>00037 <span class="comment"> *         libdl (the dlopen/dlclose functions allocate something and never free it)</span>
<a name="l00038"></a>00038 <span class="comment"> *         and a whole bunch of unidentified malloc calls without a matching free.</span>
<a name="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040"></a>00040 <span class="comment"> *      On my dev system, a reported leak of 450KB (77KB possibly lost + 384KB still reachable</span>
<a name="l00041"></a>00041 <span class="comment"> *      according to Valgrind) is normal.</span>
<a name="l00042"></a>00042 <span class="comment"> *</span>
<a name="l00043"></a>00043 <span class="comment"> *      Now you ask: why do I care so much about Valgrind, memory leaks, and cleaning</span>
<a name="l00044"></a>00044 <span class="comment"> *      up the code? The less spurious memory leaks, the easier it is to identify</span>
<a name="l00045"></a>00045 <span class="comment"> *      actual leaks among the noise and to patch them up. Thus, &quot;valgrind hunting&quot; --J.C. */</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;ctime&gt;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;dosbox.h&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;debug.h&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &quot;video.h&quot;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &quot;pic.h&quot;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;cpu.h&quot;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;ide.h&quot;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &quot;callback.h&quot;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &quot;inout.h&quot;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;mixer.h&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;timer.h&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;dos_inc.h&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &quot;setup.h&quot;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &quot;control.h&quot;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &quot;cross.h&quot;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &quot;programs.h&quot;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &quot;support.h&quot;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &quot;mapper.h&quot;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &quot;ints/int10.h&quot;</span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &quot;menu.h&quot;</span>
<a name="l00073"></a>00073 <span class="preprocessor">#include &quot;render.h&quot;</span>
<a name="l00074"></a>00074 <span class="preprocessor">#include &quot;pci_bus.h&quot;</span>
<a name="l00075"></a>00075 <span class="preprocessor">#include &quot;parport.h&quot;</span>
<a name="l00076"></a>00076 <span class="preprocessor">#include &quot;clockdomain.h&quot;</span>
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#define WIN32_LEAN_AND_MEAN</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#include &lt;windows.h&gt;</span>
<a name="l00081"></a>00081 <span class="preprocessor">#endif</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span>
<a name="l00083"></a>00083 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="comment">/*===================================TODO: Move to it&#39;s own file==============================*/</span>
<a name="l00086"></a>00086 <span class="preprocessor">#if defined(__SSE__) &amp;&amp; !defined(_M_AMD64)</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="keywordtype">bool</span> sse2_available = <span class="keyword">false</span>;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="preprocessor"># ifdef __GNUC__</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#  define cpuid(func,ax,bx,cx,dx)\</span>
<a name="l00091"></a>00091 <span class="preprocessor">        __asm__ __volatile__ (&quot;cpuid&quot;:\</span>
<a name="l00092"></a>00092 <span class="preprocessor">        &quot;=a&quot; (ax), &quot;=b&quot; (bx), &quot;=c&quot; (cx), &quot;=d&quot; (dx) : &quot;a&quot; (func));</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor"># endif </span><span class="comment">/* __GNUC__ */</span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="preprocessor"># if defined(_MSC_VER)</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#  define cpuid(func,a,b,c,d)\</span>
<a name="l00097"></a>00097 <span class="preprocessor">        __asm mov eax, func\</span>
<a name="l00098"></a>00098 <span class="preprocessor">        __asm cpuid\</span>
<a name="l00099"></a>00099 <span class="preprocessor">        __asm mov a, eax\</span>
<a name="l00100"></a>00100 <span class="preprocessor">        __asm mov b, ebx\</span>
<a name="l00101"></a>00101 <span class="preprocessor">        __asm mov c, ecx\</span>
<a name="l00102"></a>00102 <span class="preprocessor">        __asm mov d, edx</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><span class="preprocessor"># endif </span><span class="comment">/* _MSC_VER */</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="keywordtype">void</span> CheckSSESupport()
<a name="l00106"></a>00106 {
<a name="l00107"></a>00107 <span class="preprocessor">#if defined (__GNUC__) || (_MSC_VER)</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span>        Bitu a, b, c, d;
<a name="l00109"></a>00109         cpuid(1, a, b, c, d);
<a name="l00110"></a>00110         sse2_available = ((d &gt;&gt; 26) &amp; 1)?<span class="keyword">true</span>:<span class="keyword">false</span>;
<a name="l00111"></a>00111 <span class="preprocessor">#endif</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>}
<a name="l00113"></a>00113 <span class="preprocessor">#endif</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="comment">/*=============================================================================*/</span>
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="keyword">extern</span> <span class="keywordtype">void</span>                     GFX_SetTitle(Bit32s cycles,Bits frameskip,Bits timing,<span class="keywordtype">bool</span> paused);
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="keyword">extern</span> Bitu                     frames;
<a name="l00119"></a>00119 <span class="keyword">extern</span> Bitu                     cycle_count;
<a name="l00120"></a>00120 <span class="keyword">extern</span> <span class="keywordtype">bool</span>                     sse2_available;
<a name="l00121"></a>00121 <span class="keyword">extern</span> <span class="keywordtype">bool</span>                     dynamic_dos_kernel_alloc;
<a name="l00122"></a>00122 <span class="keyword">extern</span> Bitu                     DOS_PRIVATE_SEGMENT_Size;
<a name="l00123"></a>00123 <span class="keyword">extern</span> <span class="keywordtype">bool</span>                     VGA_BIOS_dont_duplicate_CGA_first_half;
<a name="l00124"></a>00124 <span class="keyword">extern</span> <span class="keywordtype">bool</span>                     VIDEO_BIOS_always_carry_14_high_font;
<a name="l00125"></a>00125 <span class="keyword">extern</span> <span class="keywordtype">bool</span>                     VIDEO_BIOS_always_carry_16_high_font;
<a name="l00126"></a>00126 <span class="keyword">extern</span> <span class="keywordtype">bool</span>                     VIDEO_BIOS_enable_CGA_8x8_second_half;
<a name="l00127"></a>00127 <span class="keyword">extern</span> <span class="keywordtype">bool</span>                     allow_more_than_640kb;
<a name="l00128"></a>00128 <span class="keyword">extern</span> <span class="keywordtype">bool</span>                     adapter_rom_is_ram;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="keywordtype">bool</span>                            dos_con_use_int16_to_detect_input = <span class="keyword">true</span>;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 <span class="keywordtype">bool</span>                            dbg_zero_on_dos_allocmem = <span class="keyword">true</span>;
<a name="l00133"></a>00133 <span class="keywordtype">bool</span>                            dbg_zero_on_xms_allocmem = <span class="keyword">true</span>;
<a name="l00134"></a>00134 <span class="keywordtype">bool</span>                            dbg_zero_on_ems_allocmem = <span class="keyword">true</span>;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 <span class="comment">/* the exact frequency of the NTSC color subcarrier ~3.579545454...MHz or 315/88 */</span>
<a name="l00137"></a>00137 <span class="comment">/* see: http://en.wikipedia.org/wiki/Colorburst */</span>
<a name="l00138"></a>00138 <span class="preprocessor">#define                         NTSC_COLOR_SUBCARRIER_NUM               (315000000ULL)</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span><span class="preprocessor">#define                         NTSC_COLOR_SUBCARRIER_DEN               (88ULL)</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>
<a name="l00141"></a>00141 <span class="comment">/* PCI bus clock</span>
<a name="l00142"></a>00142 <span class="comment"> * Usual setting: 100MHz / 3 = 33.333MHz</span>
<a name="l00143"></a>00143 <span class="comment"> *                 90MHz / 3 = 30.000MHz */</span>
<a name="l00144"></a>00144 <a class="code" href="classClockDomain.html">ClockDomain</a>                     clockdom_PCI_BCLK(100000000,3);         <span class="comment">/* MASTER 100MHz / 3 = 33.33333MHz */</span>
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="comment">/* ISA bus OSC clock (14.31818MHz), using a crystal that is 4x the NTSC subcarrier frequency 3.5795454..MHz */</span>
<a name="l00147"></a>00147 <a class="code" href="classClockDomain.html">ClockDomain</a>                     clockdom_ISA_OSC(NTSC_COLOR_SUBCARRIER_NUM*4,NTSC_COLOR_SUBCARRIER_DEN);
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="comment">/* ISA bus clock (varies between 4.77MHz to 8.333MHz)</span>
<a name="l00150"></a>00150 <span class="comment"> * PC/XT: ISA oscillator clock (14.31818MHz / 3) = 4.77MHz</span>
<a name="l00151"></a>00151 <span class="comment"> * Some systems keep CPU synchronous to bus clock: 4.77MHz, 6MHz, 8MHz, 8.333MHz</span>
<a name="l00152"></a>00152 <span class="comment"> * Later systems: 25MHz / 3 = 8.333MHz</span>
<a name="l00153"></a>00153 <span class="comment"> *                33MHz / 4 = 8.333MHz</span>
<a name="l00154"></a>00154 <span class="comment"> * PCI bus systems: PCI bus clock 33MHz / 4 = 8.333MHz (especially Intel chipsets according to PIIX datasheets) */</span>
<a name="l00155"></a>00155 <a class="code" href="classClockDomain.html">ClockDomain</a>                     clockdom_ISA_BCLK(25000000,3);          <span class="comment">/* MASTER 25000000Hz / 3 = 8.333333MHz */</span>
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="comment">/* 8254 PIT. slave to a clock determined by motherboard.</span>
<a name="l00158"></a>00158 <span class="comment"> * PC/XT: slave to ISA busclock (4.77MHz / 4) = 1.193181MHz</span>
<a name="l00159"></a>00159 <span class="comment"> * AT/later: ISA oscillator clock (14.31818MHz / 12) */</span>
<a name="l00160"></a>00160 <span class="comment">/* 14.1818MHz / 12 == (NTSC * 4) / 12 == (NTSC * 4) / (4*3) == NTSC / 3 */</span>
<a name="l00161"></a>00161 <a class="code" href="classClockDomain.html">ClockDomain</a>                     clockdom_8254_PIT(NTSC_COLOR_SUBCARRIER_NUM,NTSC_COLOR_SUBCARRIER_DEN*3);
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">/* 8250 UART.</span>
<a name="l00164"></a>00164 <span class="comment"> * PC/XT: ??? What did IBM use on the motherboard to drive the UART? Is it some divisor of the ISA OSC clock?? Closest I can calculate: 14.31818MHz / 8 = 1.78MHz.</span>
<a name="l00165"></a>00165 <span class="comment"> * Other hardware (guess): Independent clock crystal: 115200 * 16 = 1843200Hz = 1.843200MHz based on datasheet (http://www.ti.com/lit/ds/symlink/pc16550d.pdf)</span>
<a name="l00166"></a>00166 <span class="comment"> *</span>
<a name="l00167"></a>00167 <span class="comment"> * Feel free to correct me if I&#39;m wrong. */</span>
<a name="l00168"></a>00168 <a class="code" href="classClockDomain.html">ClockDomain</a>                     clockdom_8250_UART(115200 * 16);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <a class="code" href="classConfig.html">Config</a>*                         control;
<a name="l00171"></a>00171 MachineType                     machine;
<a name="l00172"></a>00172 <span class="keywordtype">bool</span>                            PS1AudioCard;           <span class="comment">// Perhaps have PS1 as a machine type...?</span>
<a name="l00173"></a>00173 SVGACards                       svgaCard;
<a name="l00174"></a>00174 <span class="keywordtype">bool</span>                            SDLNetInited;
<a name="l00175"></a>00175 Bit32s                          ticksDone;
<a name="l00176"></a>00176 Bit32u                          ticksScheduled;
<a name="l00177"></a>00177 <span class="keywordtype">bool</span>                            ticksLocked;
<a name="l00178"></a>00178 <span class="keywordtype">bool</span>                            mono_cga=<span class="keyword">false</span>;
<a name="l00179"></a>00179 <span class="keywordtype">bool</span>                            ignore_opcode_63 = <span class="keyword">true</span>;
<a name="l00180"></a>00180 <span class="keywordtype">bool</span>                            mainline_compatible_mapping = <span class="keyword">true</span>;
<a name="l00181"></a>00181 <span class="keywordtype">bool</span>                            mainline_compatible_bios_mapping = <span class="keyword">true</span>;
<a name="l00182"></a>00182 <span class="keywordtype">int</span>                             dynamic_core_cache_block_size = 32;
<a name="l00183"></a>00183 Bitu                            VGA_BIOS_Size_override = 0;
<a name="l00184"></a>00184 Bitu                            VGA_BIOS_SEG = 0xC000;
<a name="l00185"></a>00185 Bitu                            VGA_BIOS_SEG_END = 0xC800;
<a name="l00186"></a>00186 Bitu                            VGA_BIOS_Size = 0x8000;
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keyword">static</span> Bit32u                   ticksRemain;
<a name="l00189"></a>00189 <span class="keyword">static</span> Bit32u                   ticksLast;
<a name="l00190"></a>00190 <span class="keyword">static</span> Bit32u           ticksLastFramecounter;
<a name="l00191"></a>00191 <span class="keyword">static</span> Bit32u           ticksLastRTcounter;
<a name="l00192"></a>00192 <span class="keyword">static</span> <span class="keywordtype">double</span>           ticksLastRTtime;
<a name="l00193"></a>00193 <span class="keyword">static</span> Bit32u                   ticksAdded;
<a name="l00194"></a>00194 <span class="keyword">static</span> Bit32u                   <a class="code" href="namespaceGUI.html#af396fee5d5c26b98218f5803f85e3b65" title="A type which holds a number of timer ticks.">Ticks</a> = 0;
<a name="l00195"></a>00195 <span class="keyword">extern</span> <span class="keywordtype">double</span>           rtdelta;
<a name="l00196"></a>00196 <span class="keyword">static</span> LoopHandler*             loop;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 <span class="comment">/* The whole load of startups for all the subfunctions */</span>
<a name="l00199"></a>00199 <span class="keywordtype">void</span>                            LOG_StartUp(<span class="keywordtype">void</span>);
<a name="l00200"></a>00200 <span class="keywordtype">void</span>                            MEM_Init(<a class="code" href="classSection.html">Section</a> *);
<a name="l00201"></a>00201 <span class="keywordtype">void</span>                            ISAPNP_Cfg_Init(<a class="code" href="classSection.html">Section</a> *);
<a name="l00202"></a>00202 <span class="keywordtype">void</span>                            ROMBIOS_Init(<a class="code" href="classSection.html">Section</a> *);
<a name="l00203"></a>00203 <span class="keywordtype">void</span>                            CALLBACK_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00204"></a>00204 <span class="keywordtype">void</span>                            PROGRAMS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00205"></a>00205 <span class="keywordtype">void</span>                            RENDER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00206"></a>00206 <span class="keywordtype">void</span>                            VGA_VsyncInit(<a class="code" href="classSection.html">Section</a>*);
<a name="l00207"></a>00207 <span class="keywordtype">void</span>                            VGA_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00208"></a>00208 <span class="keywordtype">void</span>                            DOS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00209"></a>00209 <span class="keywordtype">void</span>                            CPU_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00210"></a>00210 <span class="preprocessor">#if C_FPU</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span><span class="keywordtype">void</span>                            FPU_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00212"></a>00212 <span class="preprocessor">#endif</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span><span class="keywordtype">void</span>                            DMA_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00214"></a>00214 <span class="keywordtype">void</span>                            MIXER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00215"></a>00215 <span class="keywordtype">void</span>                            MIDI_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00216"></a>00216 <span class="keywordtype">void</span>                            HARDWARE_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00217"></a>00217 <span class="keywordtype">void</span>                            PCIBUS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00218"></a>00218 <span class="keywordtype">void</span>                            PCI_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00219"></a>00219 <span class="keywordtype">void</span>                            VOODOO_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 <span class="keywordtype">void</span>                            IDE_Primary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00222"></a>00222 <span class="keywordtype">void</span>                            IDE_Secondary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00223"></a>00223 <span class="keywordtype">void</span>                            IDE_Tertiary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00224"></a>00224 <span class="keywordtype">void</span>                            IDE_Quaternary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00225"></a>00225 <span class="keywordtype">void</span>                            IDE_Quinternary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00226"></a>00226 <span class="keywordtype">void</span>                            IDE_Sexternary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00227"></a>00227 <span class="keywordtype">void</span>                            IDE_Septernary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00228"></a>00228 <span class="keywordtype">void</span>                            IDE_Octernary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="keywordtype">void</span>                            FDC_Primary_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="keywordtype">void</span>                            KEYBOARD_Init(<a class="code" href="classSection.html">Section</a>*);        <span class="comment">//TODO This should setup INT 16 too but ok ;)</span>
<a name="l00233"></a>00233 <span class="keywordtype">void</span>                            JOYSTICK_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00234"></a>00234 <span class="keywordtype">void</span>                            MOUSE_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00235"></a>00235 <span class="keywordtype">void</span>                            SBLASTER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00236"></a>00236 <span class="keywordtype">void</span>                            GUS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00237"></a>00237 <span class="keywordtype">void</span>                            MPU401_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00238"></a>00238 <span class="keywordtype">void</span>                            PCSPEAKER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00239"></a>00239 <span class="keywordtype">void</span>                            TANDYSOUND_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00240"></a>00240 <span class="keywordtype">void</span>                            DISNEY_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00241"></a>00241 <span class="keywordtype">void</span>                            PS1SOUND_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00242"></a>00242 <span class="keywordtype">void</span>                            INNOVA_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00243"></a>00243 <span class="keywordtype">void</span>                            SERIAL_Init(<a class="code" href="classSection.html">Section</a>*); 
<a name="l00244"></a>00244 <span class="keywordtype">void</span>                            DONGLE_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00245"></a>00245 <span class="preprocessor">#if C_IPX</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span><span class="keywordtype">void</span>                            IPX_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00247"></a>00247 <span class="preprocessor">#endif</span>
<a name="l00248"></a>00248 <span class="preprocessor"></span><span class="keywordtype">void</span>                            SID_Init(<a class="code" href="classSection.html">Section</a>* sec);
<a name="l00249"></a>00249 <span class="keywordtype">void</span>                            PIC_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00250"></a>00250 <span class="keywordtype">void</span>                            TIMER_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00251"></a>00251 <span class="keywordtype">void</span>                            BIOS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00252"></a>00252 <span class="keywordtype">void</span>                            DEBUG_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00253"></a>00253 <span class="keywordtype">void</span>                            CMOS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00254"></a>00254 <span class="keywordtype">void</span>                            MSCDEX_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00255"></a>00255 <span class="keywordtype">void</span>                            DRIVES_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00256"></a>00256 <span class="keywordtype">void</span>                            CDROM_Image_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00257"></a>00257 <span class="keywordtype">void</span>                            EMS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00258"></a>00258 <span class="keywordtype">void</span>                            XMS_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00259"></a>00259 <span class="keywordtype">void</span>                            DOS_KeyboardLayout_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00260"></a>00260 <span class="keywordtype">void</span>                            AUTOEXEC_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00261"></a>00261 <span class="keywordtype">void</span>                            INT10_Init(<a class="code" href="classSection.html">Section</a>*);
<a name="l00262"></a>00262 <span class="preprocessor">#if C_NE2000</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span><span class="keywordtype">void</span>                            NE2K_Init(<a class="code" href="classSection.html">Section</a>* sec);
<a name="l00264"></a>00264 <span class="preprocessor">#endif</span>
<a name="l00265"></a>00265 <span class="preprocessor"></span>
<a name="l00266"></a>00266 <span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> time_to_clockdom(<a class="code" href="classClockDomain.html">ClockDomain</a> &amp;src,<span class="keywordtype">double</span> t) {
<a name="l00267"></a>00267         <span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> lt = (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)t;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269         lt *= (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)src.freq;
<a name="l00270"></a>00270         lt /= (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)src.freq_div;
<a name="l00271"></a>00271         <span class="keywordflow">return</span> lt;
<a name="l00272"></a>00272 }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> update_clockdom_from_now(<a class="code" href="classClockDomain.html">ClockDomain</a> &amp;dst) {
<a name="l00275"></a>00275         <span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> s;
<a name="l00276"></a>00276 
<a name="l00277"></a>00277         <span class="comment">/* PIC_Ticks (if I read the code correctly) is millisecond ticks, units of 1/1000 seconds.</span>
<a name="l00278"></a>00278 <span class="comment">         * PIC_TickIndexND() units of submillisecond time in units of 1/CPU_CycleMax. */</span>
<a name="l00279"></a>00279         s  = (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)PIC_Ticks * dst.freq;
<a name="l00280"></a>00280         s += ((<span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)PIC_TickIndexND() * dst.freq) / (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)CPU_CycleMax;
<a name="l00281"></a>00281         <span class="comment">/* convert down to frequency counts, not freq x 1000 */</span>
<a name="l00282"></a>00282         s /= 1000LL * (<span class="keywordtype">signed</span> <span class="keywordtype">long</span> long)dst.freq_div;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284         <span class="comment">/* guard against time going backwards slightly (as PIC_TickIndexND() will do sometimes by tiny amounts) */</span>
<a name="l00285"></a>00285         if (dst.counter &lt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)s) dst.counter = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)s;
<a name="l00286"></a>00286 
<a name="l00287"></a>00287         <span class="keywordflow">return</span> dst.counter;
<a name="l00288"></a>00288 }
<a name="l00289"></a>00289 
<a name="l00290"></a>00290 <span class="comment">/* for ISA components that rely on dividing down from OSC */</span>
<a name="l00291"></a>00291 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> update_ISA_OSC_clock() {
<a name="l00292"></a>00292         <span class="keywordflow">return</span> update_clockdom_from_now(clockdom_ISA_OSC);
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="comment">/* for PIT emulation. The PIT ticks at exactly 1/12 the ISA OSC clock. */</span>
<a name="l00296"></a>00296 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> update_8254_PIT_clock() {
<a name="l00297"></a>00297         clockdom_8254_PIT.counter = update_ISA_OSC_clock() / 12ULL;
<a name="l00298"></a>00298         <span class="keywordflow">return</span> clockdom_8254_PIT.counter;
<a name="l00299"></a>00299 }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="comment">/* for ISA components */</span>
<a name="l00302"></a>00302 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> update_ISA_BCLK_clock() {
<a name="l00303"></a>00303         <span class="keywordflow">return</span> update_clockdom_from_now(clockdom_ISA_BCLK);
<a name="l00304"></a>00304 }
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 <span class="comment">/* for PCI components */</span>
<a name="l00307"></a>00307 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> update_PCI_BCLK_clock() {
<a name="l00308"></a>00308         <span class="keywordflow">return</span> update_clockdom_from_now(clockdom_PCI_BCLK);
<a name="l00309"></a>00309 }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="preprocessor">#include &quot;paging.h&quot;</span>
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="keyword">extern</span> <span class="keywordtype">bool</span> rom_bios_vptable_enable;
<a name="l00314"></a>00314 <span class="keyword">extern</span> <span class="keywordtype">bool</span> rom_bios_8x8_cga_font;
<a name="l00315"></a>00315 <span class="keyword">extern</span> <span class="keywordtype">bool</span> allow_port_92_reset;
<a name="l00316"></a>00316 <span class="keyword">extern</span> <span class="keywordtype">bool</span> allow_keyb_reset;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 <span class="keyword">extern</span> <span class="keywordtype">bool</span> DOSBox_Paused();
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 <span class="keyword">static</span> Bitu Normal_Loop(<span class="keywordtype">void</span>) {
<a name="l00321"></a>00321     <span class="keywordtype">bool</span> saved_allow = dosbox_allow_nonrecursive_page_fault;
<a name="l00322"></a>00322     Bit32u ticksNew;
<a name="l00323"></a>00323         Bits ret;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     <span class="keywordflow">if</span> (!menu.hidecycles || menu.showrt) { <span class="comment">/* sdlmain.cpp/render.cpp doesn&#39;t even maintain the frames count when hiding cycles! */</span>
<a name="l00326"></a>00326         ticksNew = GetTicks();
<a name="l00327"></a>00327         <span class="keywordflow">if</span> (ticksNew &gt;= <a class="code" href="namespaceGUI.html#af396fee5d5c26b98218f5803f85e3b65" title="A type which holds a number of timer ticks.">Ticks</a>) {
<a name="l00328"></a>00328             Bit32u interval = ticksNew - ticksLastFramecounter;
<a name="l00329"></a>00329             <span class="keywordtype">double</span> rtnow = PIC_FullIndex();
<a name="l00330"></a>00330 
<a name="l00331"></a>00331             <span class="keywordflow">if</span> (interval == 0) interval = 1; <span class="comment">// avoid divide by zero</span>
<a name="l00332"></a>00332 
<a name="l00333"></a>00333             rtdelta = rtnow - ticksLastRTtime;
<a name="l00334"></a>00334             rtdelta = (rtdelta * 1000) / interval;
<a name="l00335"></a>00335 
<a name="l00336"></a>00336             ticksLastRTtime = rtnow;
<a name="l00337"></a>00337             ticksLastFramecounter = <a class="code" href="namespaceGUI.html#af396fee5d5c26b98218f5803f85e3b65" title="A type which holds a number of timer ticks.">Ticks</a>;
<a name="l00338"></a>00338             <a class="code" href="namespaceGUI.html#af396fee5d5c26b98218f5803f85e3b65" title="A type which holds a number of timer ticks.">Ticks</a> = ticksNew + 500;             <span class="comment">// next update in 500ms</span>
<a name="l00339"></a>00339             frames = (frames * 1000) / interval; <span class="comment">// compensate for interval, be more exact (FIXME: so can we adjust for fractional frame rates)</span>
<a name="l00340"></a>00340             GFX_SetTitle(CPU_CycleMax,-1,-1,<span class="keyword">false</span>);
<a name="l00341"></a>00341             frames = 0;
<a name="l00342"></a>00342         }
<a name="l00343"></a>00343     }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345     <span class="keywordflow">try</span> {
<a name="l00346"></a>00346         <span class="keywordflow">while</span> (1) {
<a name="l00347"></a>00347             <span class="keywordflow">if</span> (PIC_RunQueue()) {
<a name="l00348"></a>00348                 <span class="comment">/* now is the time to check for the NMI (Non-maskable interrupt) */</span>
<a name="l00349"></a>00349                 CPU_Check_NMI();
<a name="l00350"></a>00350 
<a name="l00351"></a>00351                 saved_allow = dosbox_allow_nonrecursive_page_fault;
<a name="l00352"></a>00352                 dosbox_allow_nonrecursive_page_fault = <span class="keyword">true</span>;
<a name="l00353"></a>00353                 ret = (*cpudecoder)();
<a name="l00354"></a>00354                 dosbox_allow_nonrecursive_page_fault = saved_allow;
<a name="l00355"></a>00355 
<a name="l00356"></a>00356                 <span class="keywordflow">if</span> (GCC_UNLIKELY(ret&lt;0))
<a name="l00357"></a>00357                     <span class="keywordflow">return</span> 1;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359                 <span class="keywordflow">if</span> (ret&gt;0) {
<a name="l00360"></a>00360                     <span class="keywordflow">if</span> (GCC_UNLIKELY(ret &gt;= CB_MAX))
<a name="l00361"></a>00361                         <span class="keywordflow">return</span> 0;
<a name="l00362"></a>00362 
<a name="l00363"></a>00363                     dosbox_allow_nonrecursive_page_fault = <span class="keyword">false</span>;
<a name="l00364"></a>00364                     Bitu blah = (*CallBack_Handlers[ret])();
<a name="l00365"></a>00365                     dosbox_allow_nonrecursive_page_fault = saved_allow;
<a name="l00366"></a>00366                     <span class="keywordflow">if</span> (GCC_UNLIKELY(blah))
<a name="l00367"></a>00367                         <span class="keywordflow">return</span> blah;
<a name="l00368"></a>00368                 }
<a name="l00369"></a>00369 <span class="preprocessor">#if C_DEBUG</span>
<a name="l00370"></a>00370 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (DEBUG_ExitLoop())
<a name="l00371"></a>00371                     <span class="keywordflow">return</span> 0;
<a name="l00372"></a>00372 <span class="preprocessor">#endif</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span>            } <span class="keywordflow">else</span> {
<a name="l00374"></a>00374                 GFX_Events();
<a name="l00375"></a>00375                 <span class="keywordflow">if</span> (DOSBox_Paused() == <span class="keyword">false</span> &amp;&amp; ticksRemain &gt; 0) {
<a name="l00376"></a>00376                     TIMER_AddTick();
<a name="l00377"></a>00377                     ticksRemain--;
<a name="l00378"></a>00378                 } <span class="keywordflow">else</span> {
<a name="l00379"></a>00379                     <span class="keywordflow">goto</span> increaseticks;
<a name="l00380"></a>00380                 }
<a name="l00381"></a>00381             }
<a name="l00382"></a>00382         }
<a name="l00383"></a>00383 increaseticks:
<a name="l00384"></a>00384         <span class="keywordflow">if</span> (GCC_UNLIKELY(ticksLocked)) {
<a name="l00385"></a>00385             ticksRemain=5;
<a name="l00386"></a>00386             <span class="comment">/* Reset any auto cycle guessing for this frame */</span>
<a name="l00387"></a>00387             ticksLast = GetTicks();
<a name="l00388"></a>00388             ticksAdded = 0;
<a name="l00389"></a>00389             ticksDone = 0;
<a name="l00390"></a>00390             ticksScheduled = 0;
<a name="l00391"></a>00391         } <span class="keywordflow">else</span> {
<a name="l00392"></a>00392             ticksNew=GetTicks();
<a name="l00393"></a>00393             ticksScheduled += ticksAdded;
<a name="l00394"></a>00394             <span class="keywordflow">if</span> (ticksNew &gt; ticksLast) {
<a name="l00395"></a>00395                 ticksRemain = ticksNew-ticksLast;
<a name="l00396"></a>00396                 ticksLast = ticksNew;
<a name="l00397"></a>00397                 ticksDone += ticksRemain;
<a name="l00398"></a>00398                 <span class="keywordflow">if</span> ( ticksRemain &gt; 20 ) {
<a name="l00399"></a>00399                     ticksRemain = 20;
<a name="l00400"></a>00400                 }
<a name="l00401"></a>00401                 ticksAdded = ticksRemain;
<a name="l00402"></a>00402                 <span class="keywordflow">if</span> (CPU_CycleAutoAdjust &amp;&amp; !CPU_SkipCycleAutoAdjust) {
<a name="l00403"></a>00403                     <span class="keywordflow">if</span> (ticksScheduled &gt;= 250 || ticksDone &gt;= 250 || (ticksAdded &gt; 15 &amp;&amp; ticksScheduled &gt;= 5) ) {
<a name="l00404"></a>00404                         <span class="keywordflow">if</span>(ticksDone &lt; 1) ticksDone = 1; <span class="comment">// Protect against div by zero</span>
<a name="l00405"></a>00405                         <span class="comment">/* ratio we are aiming for is around 90% usage*/</span>
<a name="l00406"></a>00406                         Bit32s ratio = (ticksScheduled * (CPU_CyclePercUsed*90*1024/100/100)) / ticksDone;
<a name="l00407"></a>00407                         Bit32s new_cmax = CPU_CycleMax;
<a name="l00408"></a>00408                         Bit64s cproc = (Bit64s)CPU_CycleMax * (Bit64s)ticksScheduled;
<a name="l00409"></a>00409                         <span class="keywordflow">if</span> (cproc &gt; 0) {
<a name="l00410"></a>00410                             <span class="comment">/* ignore the cycles added due to the IO delay code in order</span>
<a name="l00411"></a>00411 <span class="comment">                               to have smoother auto cycle adjustments */</span>
<a name="l00412"></a>00412                             <span class="keywordtype">double</span> ratioremoved = (double) CPU_IODelayRemoved / (<span class="keywordtype">double</span>) cproc;
<a name="l00413"></a>00413                             <span class="keywordflow">if</span> (ratioremoved &lt; 1.0) {
<a name="l00414"></a>00414                                 ratio = (Bit32s)((<span class="keywordtype">double</span>)ratio * (1 - ratioremoved));
<a name="l00415"></a>00415                                 <span class="comment">/* Don&#39;t allow very high ratio which can cause us to lock as we don&#39;t scale down</span>
<a name="l00416"></a>00416 <span class="comment">                                 * for very low ratios. High ratio might result because of timing resolution */</span>
<a name="l00417"></a>00417                                 <span class="keywordflow">if</span> (ticksScheduled &gt;= 250 &amp;&amp; ticksDone &lt; 10 &amp;&amp; ratio &gt; 20480) 
<a name="l00418"></a>00418                                     ratio = 20480;
<a name="l00419"></a>00419                                 Bit64s cmax_scaled = (Bit64s)CPU_CycleMax * (Bit64s)ratio;
<a name="l00420"></a>00420                                 <span class="comment">/* The auto cycle code seems reliable enough to disable the fast cut back code.</span>
<a name="l00421"></a>00421 <span class="comment">                                 * This should improve the fluency of complex games.</span>
<a name="l00422"></a>00422 <span class="comment">                                 if (ratio &lt;= 1024) </span>
<a name="l00423"></a>00423 <span class="comment">                                 new_cmax = (Bit32s)(cmax_scaled / (Bit64s)1024);</span>
<a name="l00424"></a>00424 <span class="comment">                                 else </span>
<a name="l00425"></a>00425 <span class="comment">                                 */</span>
<a name="l00426"></a>00426                                 new_cmax = (Bit32s)(1 + (CPU_CycleMax &gt;&gt; 1) + cmax_scaled / (Bit64s)2048);
<a name="l00427"></a>00427                             }
<a name="l00428"></a>00428                         }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430                         <span class="keywordflow">if</span> (new_cmax&lt;CPU_CYCLES_LOWER_LIMIT)
<a name="l00431"></a>00431                             new_cmax=CPU_CYCLES_LOWER_LIMIT;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433                         <span class="comment">/*</span>
<a name="l00434"></a>00434 <span class="comment">                           LOG_MSG(&quot;cyclelog: current %6d   cmax %6d   ratio  %5d  done %3d   sched %3d&quot;,</span>
<a name="l00435"></a>00435 <span class="comment">                           CPU_CycleMax,</span>
<a name="l00436"></a>00436 <span class="comment">                           new_cmax,</span>
<a name="l00437"></a>00437 <span class="comment">                           ratio,</span>
<a name="l00438"></a>00438 <span class="comment">                           ticksDone,</span>
<a name="l00439"></a>00439 <span class="comment">                           ticksScheduled);</span>
<a name="l00440"></a>00440 <span class="comment">                           */</span>  
<a name="l00441"></a>00441                         <span class="comment">/* ratios below 1% are considered to be dropouts due to</span>
<a name="l00442"></a>00442 <span class="comment">                           temporary load imbalance, the cycles adjusting is skipped */</span>
<a name="l00443"></a>00443                         <span class="keywordflow">if</span> (ratio&gt;10) {
<a name="l00444"></a>00444                             <span class="comment">/* ratios below 12% along with a large time since the last update</span>
<a name="l00445"></a>00445 <span class="comment">                               has taken place are most likely caused by heavy load through a</span>
<a name="l00446"></a>00446 <span class="comment">                               different application, the cycles adjusting is skipped as well */</span>
<a name="l00447"></a>00447                             <span class="keywordflow">if</span> ((ratio&gt;120) || (ticksDone&lt;700)) {
<a name="l00448"></a>00448                                 CPU_CycleMax = new_cmax;
<a name="l00449"></a>00449                                 <span class="keywordflow">if</span> (CPU_CycleLimit &gt; 0) {
<a name="l00450"></a>00450                                     <span class="keywordflow">if</span> (CPU_CycleMax&gt;CPU_CycleLimit) CPU_CycleMax = CPU_CycleLimit;
<a name="l00451"></a>00451                                 }
<a name="l00452"></a>00452                             }
<a name="l00453"></a>00453                         }
<a name="l00454"></a>00454                         CPU_IODelayRemoved = 0;
<a name="l00455"></a>00455                         ticksDone = 0;
<a name="l00456"></a>00456                         ticksScheduled = 0;
<a name="l00457"></a>00457                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ticksAdded &gt; 15) {
<a name="l00458"></a>00458                         <span class="comment">/* ticksAdded &gt; 15 but ticksScheduled &lt; 5, lower the cycles</span>
<a name="l00459"></a>00459 <span class="comment">                           but do not reset the scheduled/done ticks to take them into</span>
<a name="l00460"></a>00460 <span class="comment">                           account during the next auto cycle adjustment */</span>
<a name="l00461"></a>00461                         CPU_CycleMax /= 3;
<a name="l00462"></a>00462                         <span class="keywordflow">if</span> (CPU_CycleMax &lt; CPU_CYCLES_LOWER_LIMIT)
<a name="l00463"></a>00463                             CPU_CycleMax = CPU_CYCLES_LOWER_LIMIT;
<a name="l00464"></a>00464                     }
<a name="l00465"></a>00465                 }
<a name="l00466"></a>00466             } <span class="keywordflow">else</span> {
<a name="l00467"></a>00467                 ticksAdded = 0;
<a name="l00468"></a>00468                 SDL_Delay(1);
<a name="l00469"></a>00469                 ticksDone -= GetTicks() - ticksNew;
<a name="l00470"></a>00470                 <span class="keywordflow">if</span> (ticksDone &lt; 0)
<a name="l00471"></a>00471                     ticksDone = 0;
<a name="l00472"></a>00472             }
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474     }
<a name="l00475"></a>00475     <span class="keywordflow">catch</span> (<a class="code" href="classGuestPageFaultException.html">GuestPageFaultException</a> &amp;pf) {
<a name="l00476"></a>00476         Bitu FillFlags(<span class="keywordtype">void</span>);
<a name="l00477"></a>00477 
<a name="l00478"></a>00478         ret = 0;
<a name="l00479"></a>00479         FillFlags();
<a name="l00480"></a>00480         dosbox_allow_nonrecursive_page_fault = <span class="keyword">false</span>;
<a name="l00481"></a>00481         CPU_Exception(EXCEPTION_PF,pf.faultcode);
<a name="l00482"></a>00482         dosbox_allow_nonrecursive_page_fault = saved_allow;
<a name="l00483"></a>00483     }
<a name="l00484"></a>00484     <span class="keywordflow">catch</span> (<span class="keywordtype">int</span> x) {
<a name="l00485"></a>00485         dosbox_allow_nonrecursive_page_fault = saved_allow;
<a name="l00486"></a>00486         <span class="keywordflow">if</span> (x == 4<span class="comment">/*CMOS shutdown*/</span>) {
<a name="l00487"></a>00487             ret = 0;
<a name="l00488"></a>00488 <span class="comment">//                      LOG_MSG(&quot;CMOS shutdown reset acknowledged&quot;);</span>
<a name="l00489"></a>00489         }
<a name="l00490"></a>00490         <span class="keywordflow">else</span> {
<a name="l00491"></a>00491             <span class="keywordflow">throw</span>;
<a name="l00492"></a>00492         }
<a name="l00493"></a>00493     }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495     <span class="keywordflow">return</span> 0;
<a name="l00496"></a>00496 }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 LoopHandler *DOSBOX_GetLoop(<span class="keywordtype">void</span>) {
<a name="l00499"></a>00499     <span class="keywordflow">return</span> loop;
<a name="l00500"></a>00500 }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502 <span class="keywordtype">void</span> DOSBOX_SetLoop(LoopHandler * handler) {
<a name="l00503"></a>00503         loop=handler;
<a name="l00504"></a>00504 }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="keywordtype">void</span> DOSBOX_SetNormalLoop() {
<a name="l00507"></a>00507         loop=Normal_Loop;
<a name="l00508"></a>00508 }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510 <span class="keywordtype">void</span> DOSBOX_RunMachine(<span class="keywordtype">void</span>){
<a name="l00511"></a>00511         Bitu ret;
<a name="l00512"></a>00512         <span class="keywordflow">do</span> {
<a name="l00513"></a>00513                 ret=(*loop)();
<a name="l00514"></a>00514         } <span class="keywordflow">while</span> (!ret);
<a name="l00515"></a>00515 }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="keyword">static</span> <span class="keywordtype">void</span> DOSBOX_UnlockSpeed( <span class="keywordtype">bool</span> pressed ) {
<a name="l00518"></a>00518         <span class="keyword">static</span> <span class="keywordtype">bool</span> autoadjust = <span class="keyword">false</span>;
<a name="l00519"></a>00519         <span class="keywordflow">if</span> (pressed) {
<a name="l00520"></a>00520                 LOG_MSG(<span class="stringliteral">&quot;Fast Forward ON&quot;</span>);
<a name="l00521"></a>00521                 ticksLocked = <span class="keyword">true</span>;
<a name="l00522"></a>00522                 <span class="keywordflow">if</span> (CPU_CycleAutoAdjust) {
<a name="l00523"></a>00523                         autoadjust = <span class="keyword">true</span>;
<a name="l00524"></a>00524                         CPU_CycleAutoAdjust = <span class="keyword">false</span>;
<a name="l00525"></a>00525                         CPU_CycleMax /= 3;
<a name="l00526"></a>00526                         <span class="keywordflow">if</span> (CPU_CycleMax&lt;1000) CPU_CycleMax=1000;
<a name="l00527"></a>00527                 }
<a name="l00528"></a>00528         } <span class="keywordflow">else</span> {
<a name="l00529"></a>00529                 LOG_MSG(<span class="stringliteral">&quot;Fast Forward OFF&quot;</span>);
<a name="l00530"></a>00530                 ticksLocked = <span class="keyword">false</span>;
<a name="l00531"></a>00531                 <span class="keywordflow">if</span> (autoadjust) {
<a name="l00532"></a>00532                         autoadjust = <span class="keyword">false</span>;
<a name="l00533"></a>00533                         CPU_CycleAutoAdjust = <span class="keyword">true</span>;
<a name="l00534"></a>00534                 }
<a name="l00535"></a>00535         }
<a name="l00536"></a>00536         GFX_SetTitle(-1,-1,-1,<span class="keyword">false</span>);
<a name="l00537"></a>00537 }
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 <span class="keywordtype">void</span> DOSBOX_UnlockSpeed2( <span class="keywordtype">bool</span> pressed ) {
<a name="l00540"></a>00540         <span class="keywordflow">if</span> (pressed) {
<a name="l00541"></a>00541                 ticksLocked =! ticksLocked;
<a name="l00542"></a>00542                 DOSBOX_UnlockSpeed(ticksLocked?<span class="keyword">true</span>:<span class="keyword">false</span>);
<a name="l00543"></a>00543         }
<a name="l00544"></a>00544 }
<a name="l00545"></a>00545 
<a name="l00546"></a>00546 <span class="keywordtype">void</span> notifyError(<span class="keyword">const</span> std::string&amp; message)
<a name="l00547"></a>00547 {
<a name="l00548"></a>00548 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00549"></a>00549 <span class="preprocessor"></span>    ::MessageBox(0, message.c_str(), <span class="stringliteral">&quot;Error&quot;</span>, 0);
<a name="l00550"></a>00550 <span class="preprocessor">#endif</span>
<a name="l00551"></a>00551 <span class="preprocessor"></span>    LOG_MSG(<span class="stringliteral">&quot;%s&quot;</span>,message.c_str());
<a name="l00552"></a>00552 }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="comment">/* TODO: move to utility header */</span>
<a name="l00555"></a>00555 <span class="preprocessor">#ifdef _MSC_VER </span><span class="comment">/* Microsoft C++ does not have strtoull */</span>
<a name="l00556"></a>00556 <span class="preprocessor"># if _MSC_VER &lt; 1800 </span><span class="comment">/* But Visual Studio 2013 apparently does (http://www.vogons.org/viewtopic.php?f=41&amp;t=31881&amp;sid=49ff69ebc0459ed6523f5a250daa4d8c&amp;start=400#p355770) */</span>
<a name="l00557"></a>00557 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> strtoull(<span class="keyword">const</span> <span class="keywordtype">char</span> *s,<span class="keywordtype">char</span> **endptr,<span class="keywordtype">int</span> base) {
<a name="l00558"></a>00558         <span class="keywordflow">return</span> _strtoui64(s,endptr,base); <span class="comment">/* pfff... whatever Microsoft */</span>
<a name="l00559"></a>00559 }
<a name="l00560"></a>00560 <span class="preprocessor"># endif</span>
<a name="l00561"></a>00561 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00562"></a>00562 <span class="preprocessor"></span>
<a name="l00563"></a>00563 <span class="comment">/* utility function. rename as appropriate and move to utility collection */</span>
<a name="l00564"></a>00564 <span class="keywordtype">void</span> parse_busclk_setting_str(<a class="code" href="classClockDomain.html">ClockDomain</a> *cd,<span class="keyword">const</span> <span class="keywordtype">char</span> *s) {
<a name="l00565"></a>00565         <span class="keyword">const</span> <span class="keywordtype">char</span> *d;
<a name="l00566"></a>00566 
<a name="l00567"></a>00567         <span class="comment">/* we&#39;re expecting an integer, a float, or an integer ratio */</span>
<a name="l00568"></a>00568         d = strchr(s,<span class="charliteral">&#39;/&#39;</span>);
<a name="l00569"></a>00569         <span class="keywordflow">if</span> (d != NULL) { <span class="comment">/* it has a slash therefore an integer ratio */</span>
<a name="l00570"></a>00570                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> num,den;
<a name="l00571"></a>00571 
<a name="l00572"></a>00572                 <span class="keywordflow">while</span> (*d == <span class="charliteral">&#39; &#39;</span> || *d == <span class="charliteral">&#39;/&#39;</span>) d++;
<a name="l00573"></a>00573                 num = strtoull(s,NULL,0);
<a name="l00574"></a>00574                 den = strtoull(d,NULL,0);
<a name="l00575"></a>00575                 <span class="keywordflow">if</span> (num &gt;= 1ULL &amp;&amp; den &gt;= 1ULL) cd-&gt;set_frequency(num,den);
<a name="l00576"></a>00576         }
<a name="l00577"></a>00577         <span class="keywordflow">else</span> {
<a name="l00578"></a>00578                 d = strchr(s,<span class="charliteral">&#39;.&#39;</span>);
<a name="l00579"></a>00579                 <span class="keywordflow">if</span> (d != NULL) { <span class="comment">/* it has a dot, floating point */</span>
<a name="l00580"></a>00580                         <span class="keywordtype">double</span> f = atof(s);
<a name="l00581"></a>00581                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> fi = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)floor((f*1000000)+0.5);
<a name="l00582"></a>00582                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> den = 1000000;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584                         <span class="keywordflow">while</span> (den &gt; 1ULL) {
<a name="l00585"></a>00585                                 <span class="keywordflow">if</span> ((fi%10ULL) == 0) {
<a name="l00586"></a>00586                                         den /= 10ULL;
<a name="l00587"></a>00587                                         fi /= 10ULL;
<a name="l00588"></a>00588                                 }
<a name="l00589"></a>00589                                 <span class="keywordflow">else</span> {
<a name="l00590"></a>00590                                         <span class="keywordflow">break</span>;
<a name="l00591"></a>00591                                 }
<a name="l00592"></a>00592                         }
<a name="l00593"></a>00593 
<a name="l00594"></a>00594                         <span class="keywordflow">if</span> (fi &gt;= 1ULL) cd-&gt;set_frequency(fi,den);
<a name="l00595"></a>00595                 }
<a name="l00596"></a>00596                 <span class="keywordflow">else</span> {
<a name="l00597"></a>00597                         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> f = strtoull(s,NULL,10);
<a name="l00598"></a>00598                         <span class="keywordflow">if</span> (f &gt;= 1ULL) cd-&gt;set_frequency(f,1);
<a name="l00599"></a>00599                 }
<a name="l00600"></a>00600         }
<a name="l00601"></a>00601 }
<a name="l00602"></a>00602 
<a name="l00603"></a>00603 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dosbox_shell_env_size = 0;
<a name="l00604"></a>00604 
<a name="l00605"></a>00605 <span class="keywordtype">void</span> clocktree_build_conversion_list();
<a name="l00606"></a>00606 
<a name="l00607"></a>00607 <span class="keywordtype">void</span> Null_Init(<a class="code" href="classSection.html">Section</a> *sec) {
<a name="l00608"></a>00608         sec = sec;
<a name="l00609"></a>00609 }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611 <span class="keyword">extern</span> Bit8u cga_comp;
<a name="l00612"></a>00612 <span class="keyword">extern</span> <span class="keywordtype">bool</span> new_cga;
<a name="l00613"></a>00613 
<a name="l00614"></a>00614 <span class="keywordtype">bool</span> dpi_aware_enable = <span class="keyword">true</span>;
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 std::string dosbox_title;
<a name="l00617"></a>00617 
<a name="l00618"></a>00618 <span class="keywordtype">void</span> DOSBOX_InitTickLoop() {
<a name="l00619"></a>00619         <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;Initializing tick loop management&quot;</span>);
<a name="l00620"></a>00620 
<a name="l00621"></a>00621         ticksRemain = 0;
<a name="l00622"></a>00622         ticksLocked = <span class="keyword">false</span>;
<a name="l00623"></a>00623     ticksLastRTtime = 0;
<a name="l00624"></a>00624         ticksLast = GetTicks();
<a name="l00625"></a>00625     ticksLastRTcounter = GetTicks();
<a name="l00626"></a>00626     ticksLastFramecounter = GetTicks();
<a name="l00627"></a>00627         DOSBOX_SetLoop(&amp;Normal_Loop);
<a name="l00628"></a>00628 }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="keywordtype">void</span> Init_VGABIOS() {
<a name="l00631"></a>00631         <a class="code" href="classSection__prop.html">Section_prop</a> *section = <span class="keyword">static_cast&lt;</span><a class="code" href="classSection__prop.html">Section_prop</a> *<span class="keyword">&gt;</span>(control-&gt;GetSection(<span class="stringliteral">&quot;dosbox&quot;</span>));
<a name="l00632"></a>00632         assert(section != NULL);
<a name="l00633"></a>00633 
<a name="l00634"></a>00634     <span class="keywordflow">if</span> (IS_PC98_ARCH) {
<a name="l00635"></a>00635         VGA_BIOS_Size = 0;
<a name="l00636"></a>00636         <span class="keywordflow">return</span>;
<a name="l00637"></a>00637     }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639         <span class="comment">// log</span>
<a name="l00640"></a>00640         <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;Init_VGABIOS: Initializing VGA BIOS and parsing it&#39;s settings&quot;</span>);
<a name="l00641"></a>00641 
<a name="l00642"></a>00642         <span class="comment">// mem init must have already happened.</span>
<a name="l00643"></a>00643         <span class="comment">// We can remove this once the device callout system is in place.</span>
<a name="l00644"></a>00644         assert(MemBase != NULL);
<a name="l00645"></a>00645 
<a name="l00646"></a>00646         VGA_BIOS_Size_override = section-&gt;Get_int(<span class="stringliteral">&quot;vga bios size override&quot;</span>);
<a name="l00647"></a>00647         <span class="keywordflow">if</span> (VGA_BIOS_Size_override &gt; 0) VGA_BIOS_Size_override = (VGA_BIOS_Size_override+0x7FF)&amp;(~0xFFF);
<a name="l00648"></a>00648 
<a name="l00649"></a>00649         VGA_BIOS_dont_duplicate_CGA_first_half = section-&gt;Get_bool(<span class="stringliteral">&quot;video bios dont duplicate cga first half rom font&quot;</span>);
<a name="l00650"></a>00650         VIDEO_BIOS_always_carry_14_high_font = section-&gt;Get_bool(<span class="stringliteral">&quot;video bios always offer 14-pixel high rom font&quot;</span>);
<a name="l00651"></a>00651         VIDEO_BIOS_always_carry_16_high_font = section-&gt;Get_bool(<span class="stringliteral">&quot;video bios always offer 16-pixel high rom font&quot;</span>);
<a name="l00652"></a>00652         VIDEO_BIOS_enable_CGA_8x8_second_half = section-&gt;Get_bool(<span class="stringliteral">&quot;video bios enable cga second half rom font&quot;</span>);
<a name="l00653"></a>00653         <span class="comment">/* NTS: mainline compatible mapping demands the 8x8 CGA font */</span>
<a name="l00654"></a>00654         rom_bios_8x8_cga_font = mainline_compatible_bios_mapping || section-&gt;Get_bool(<span class="stringliteral">&quot;rom bios 8x8 CGA font&quot;</span>);
<a name="l00655"></a>00655         rom_bios_vptable_enable = mainline_compatible_bios_mapping || section-&gt;Get_bool(<span class="stringliteral">&quot;rom bios video parameter table&quot;</span>);
<a name="l00656"></a>00656 
<a name="l00657"></a>00657         <span class="comment">/* sanity check */</span>
<a name="l00658"></a>00658         <span class="keywordflow">if</span> (VGA_BIOS_dont_duplicate_CGA_first_half &amp;&amp; !rom_bios_8x8_cga_font) <span class="comment">/* can&#39;t point at the BIOS copy if it&#39;s not there */</span>
<a name="l00659"></a>00659                 VGA_BIOS_dont_duplicate_CGA_first_half = <span class="keyword">false</span>;
<a name="l00660"></a>00660 
<a name="l00661"></a>00661         <span class="keywordflow">if</span> (VGA_BIOS_Size_override &gt;= 512 &amp;&amp; VGA_BIOS_Size_override &lt;= 65536)
<a name="l00662"></a>00662                 VGA_BIOS_Size = (VGA_BIOS_Size_override + 0x7FF) &amp; (~0xFFF);
<a name="l00663"></a>00663         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IS_VGA_ARCH)
<a name="l00664"></a>00664                 VGA_BIOS_Size = mainline_compatible_mapping ? 0x8000 : 0x3000; <span class="comment">/* &lt;- Experimentation shows the S3 emulation can fit in 12KB, doesn&#39;t need all 32KB */</span>
<a name="l00665"></a>00665         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (machine == MCH_EGA) {
<a name="l00666"></a>00666                 <span class="keywordflow">if</span> (mainline_compatible_mapping)
<a name="l00667"></a>00667                         VGA_BIOS_Size = 0x8000;
<a name="l00668"></a>00668                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (VIDEO_BIOS_always_carry_16_high_font)
<a name="l00669"></a>00669                         VGA_BIOS_Size = 0x3000;
<a name="l00670"></a>00670                 <span class="keywordflow">else</span>
<a name="l00671"></a>00671                         VGA_BIOS_Size = 0x2000;
<a name="l00672"></a>00672         }
<a name="l00673"></a>00673         <span class="keywordflow">else</span> {
<a name="l00674"></a>00674                 <span class="keywordflow">if</span> (mainline_compatible_mapping)
<a name="l00675"></a>00675                         VGA_BIOS_Size = 0x8000;
<a name="l00676"></a>00676                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (VIDEO_BIOS_always_carry_16_high_font &amp;&amp; VIDEO_BIOS_always_carry_14_high_font)
<a name="l00677"></a>00677                         VGA_BIOS_Size = 0x3000;
<a name="l00678"></a>00678                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (VIDEO_BIOS_always_carry_16_high_font || VIDEO_BIOS_always_carry_14_high_font)
<a name="l00679"></a>00679                         VGA_BIOS_Size = 0x2000;
<a name="l00680"></a>00680                 <span class="keywordflow">else</span>
<a name="l00681"></a>00681                         VGA_BIOS_Size = 0;
<a name="l00682"></a>00682         }
<a name="l00683"></a>00683         VGA_BIOS_SEG = 0xC000;
<a name="l00684"></a>00684         VGA_BIOS_SEG_END = (VGA_BIOS_SEG + (VGA_BIOS_Size &gt;&gt; 4));
<a name="l00685"></a>00685 
<a name="l00686"></a>00686         <span class="comment">/* clear for VGA BIOS (FIXME: Why does Project Angel like our BIOS when we memset() here, but don&#39;t like it if we memset() in the INT 10 ROM setup routine?) */</span>
<a name="l00687"></a>00687         <span class="keywordflow">if</span> (VGA_BIOS_Size != 0)
<a name="l00688"></a>00688                 memset((<span class="keywordtype">char</span>*)MemBase+0xC0000,0x00,VGA_BIOS_Size);
<a name="l00689"></a>00689 }
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 <span class="keywordtype">void</span> DOSBOX_RealInit() {
<a name="l00692"></a>00692         <a class="code" href="classLOG.html">LOG</a>(LOG_MISC,LOG_DEBUG)(<span class="stringliteral">&quot;DOSBOX_RealInit: loading settings and initializing&quot;</span>);
<a name="l00693"></a>00693 
<a name="l00694"></a>00694         MAPPER_AddHandler(DOSBOX_UnlockSpeed, MK_f12, MMOD2,<span class="stringliteral">&quot;speedlock&quot;</span>,<span class="stringliteral">&quot;Speedlock&quot;</span>);
<a name="l00695"></a>00695         MAPPER_AddHandler(DOSBOX_UnlockSpeed2, MK_f11, MMOD2,<span class="stringliteral">&quot;speedlock2&quot;</span>,<span class="stringliteral">&quot;Speedlock2&quot;</span>);
<a name="l00696"></a>00696 
<a name="l00697"></a>00697         <a class="code" href="classSection__prop.html">Section_prop</a> *section = <span class="keyword">static_cast&lt;</span><a class="code" href="classSection__prop.html">Section_prop</a> *<span class="keyword">&gt;</span>(control-&gt;GetSection(<span class="stringliteral">&quot;dosbox&quot;</span>));
<a name="l00698"></a>00698         assert(section != NULL);
<a name="l00699"></a>00699 
<a name="l00700"></a>00700         <span class="comment">// boot-time option whether or not to report ourself as &quot;DPI aware&quot; to Windows so the</span>
<a name="l00701"></a>00701         <span class="comment">// DWM doesn&#39;t upscale our window for backwards compat.</span>
<a name="l00702"></a>00702         dpi_aware_enable = section-&gt;Get_bool(<span class="stringliteral">&quot;dpi aware&quot;</span>);
<a name="l00703"></a>00703 
<a name="l00704"></a>00704         <span class="comment">// TODO: allow change at any time. in fact if it were possible for DOSBox-X configuration</span>
<a name="l00705"></a>00705         <span class="comment">//       schema code to attach event callbacks when a setting changes, we would set one</span>
<a name="l00706"></a>00706         <span class="comment">//       on the title= setting now to auto-update the titlebar when this changes.</span>
<a name="l00707"></a>00707         dosbox_title = section-&gt;Get_string(<span class="stringliteral">&quot;title&quot;</span>);
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         <span class="comment">// TODO: these should be parsed by DOS kernel at startup</span>
<a name="l00710"></a>00710         dosbox_shell_env_size = section-&gt;Get_int(<span class="stringliteral">&quot;shell environment size&quot;</span>);
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         <span class="comment">/* these ARE general DOSBox configuration options */</span>
<a name="l00713"></a>00713         mainline_compatible_mapping = section-&gt;Get_bool(<span class="stringliteral">&quot;mainline compatible mapping&quot;</span>);
<a name="l00714"></a>00714         adapter_rom_is_ram = section-&gt;Get_bool(<span class="stringliteral">&quot;adapter rom is ram&quot;</span>);
<a name="l00715"></a>00715 
<a name="l00716"></a>00716         <span class="comment">// TODO: a bit of a challenge: if we put it in the ROM area as mainline DOSBox does then the init</span>
<a name="l00717"></a>00717         <span class="comment">//       needs to read this from the BIOS where it can map the memory appropriately. if the allocation</span>
<a name="l00718"></a>00718         <span class="comment">//       is dynamic and the private area is down at the base of memory like real DOS, then the BIOS</span>
<a name="l00719"></a>00719         <span class="comment">//       should ignore it and the DOS kernel should parse it. If we&#39;re going to put it into upper</span>
<a name="l00720"></a>00720         <span class="comment">//       areas as well, then we should also consider making it look like adapter ROM at startup</span>
<a name="l00721"></a>00721         <span class="comment">//       so it can be enumerated properly by DOS programs scanning the ROM area.</span>
<a name="l00722"></a>00722         <span class="comment">/* private area size param in bytes. round up to nearest paragraph */</span>
<a name="l00723"></a>00723         DOS_PRIVATE_SEGMENT_Size = (section-&gt;Get_int(<span class="stringliteral">&quot;private area size&quot;</span>) + 8) / 16;
<a name="l00724"></a>00724 
<a name="l00725"></a>00725         <span class="comment">// TODO: these should be parsed by BIOS startup</span>
<a name="l00726"></a>00726         mainline_compatible_bios_mapping = section-&gt;Get_bool(<span class="stringliteral">&quot;mainline compatible bios mapping&quot;</span>);
<a name="l00727"></a>00727         allow_more_than_640kb = section-&gt;Get_bool(<span class="stringliteral">&quot;allow more than 640kb base memory&quot;</span>);
<a name="l00728"></a>00728 
<a name="l00729"></a>00729         <span class="comment">// TODO: should be parsed by motherboard emulation</span>
<a name="l00730"></a>00730         allow_port_92_reset = section-&gt;Get_bool(<span class="stringliteral">&quot;allow port 92 reset&quot;</span>);
<a name="l00731"></a>00731 
<a name="l00732"></a>00732     <span class="comment">// CGA/EGA/VGA-specific</span>
<a name="l00733"></a>00733     <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> vga_p3da_undefined_bits;
<a name="l00734"></a>00734     vga_p3da_undefined_bits = section-&gt;Get_hex(<span class="stringliteral">&quot;vga 3da undefined bits&quot;</span>);
<a name="l00735"></a>00735 
<a name="l00736"></a>00736         <span class="comment">// TODO: should be parsed by motherboard emulation or lower level equiv..?</span>
<a name="l00737"></a>00737         std::string cmd_machine;
<a name="l00738"></a>00738         <span class="keywordflow">if</span> (control-&gt;cmdline-&gt;FindString(<span class="stringliteral">&quot;-machine&quot;</span>,cmd_machine,<span class="keyword">true</span>)){
<a name="l00739"></a>00739                 <span class="comment">//update value in config (else no matching against suggested values</span>
<a name="l00740"></a>00740                 section-&gt;HandleInputline(std::string(<span class="stringliteral">&quot;machine=&quot;</span>) + cmd_machine);
<a name="l00741"></a>00741         }
<a name="l00742"></a>00742 
<a name="l00743"></a>00743         <span class="comment">// TODO: should be parsed by...? perhaps at some point we support machine= for backwards compat</span>
<a name="l00744"></a>00744         <span class="comment">//       but translate it into two separate params that specify what machine vs what video hardware.</span>
<a name="l00745"></a>00745         <span class="comment">//       or better yet as envisioned, a possible dosbox.conf schema that allows a machine with no</span>
<a name="l00746"></a>00746         <span class="comment">//       base video of it&#39;s own, and then to specify an ISA or PCI card attached to the bus that</span>
<a name="l00747"></a>00747         <span class="comment">//       provides video.</span>
<a name="l00748"></a>00748         std::string mtype(section-&gt;Get_string(<span class="stringliteral">&quot;machine&quot;</span>));
<a name="l00749"></a>00749         svgaCard = SVGA_None; 
<a name="l00750"></a>00750         machine = MCH_VGA;
<a name="l00751"></a>00751         int10.vesa_nolfb = <span class="keyword">false</span>;
<a name="l00752"></a>00752         int10.vesa_oldvbe = <span class="keyword">false</span>;
<a name="l00753"></a>00753         <span class="keywordflow">if</span>      (mtype == <span class="stringliteral">&quot;cga&quot;</span>)           { machine = MCH_CGA; mono_cga = <span class="keyword">false</span>; }
<a name="l00754"></a>00754         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;cga_mono&quot;</span>)      { machine = MCH_CGA; mono_cga = <span class="keyword">true</span>; }
<a name="l00755"></a>00755         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;cga_rgb&quot;</span>)       { machine = MCH_CGA; mono_cga = <span class="keyword">false</span>; cga_comp = 2; }
<a name="l00756"></a>00756         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;cga_composite&quot;</span>) { machine = MCH_CGA; mono_cga = <span class="keyword">false</span>; cga_comp = 1; new_cga = <span class="keyword">false</span>; }
<a name="l00757"></a>00757         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;cga_composite2&quot;</span>){ machine = MCH_CGA; mono_cga = <span class="keyword">false</span>; cga_comp = 1; new_cga = <span class="keyword">true</span>; }
<a name="l00758"></a>00758         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;tandy&quot;</span>)         { machine = MCH_TANDY; }
<a name="l00759"></a>00759         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;pcjr&quot;</span>)          { machine = MCH_PCJR; }
<a name="l00760"></a>00760         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;hercules&quot;</span>)      { machine = MCH_HERC; }
<a name="l00761"></a>00761         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;ega&quot;</span>)           { machine = MCH_EGA; }
<a name="l00762"></a>00762         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;svga_s3&quot;</span>)       { svgaCard = SVGA_S3Trio; }
<a name="l00763"></a>00763         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;vesa_nolfb&quot;</span>)    { svgaCard = SVGA_S3Trio; int10.vesa_nolfb = <span class="keyword">true</span>;}
<a name="l00764"></a>00764         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;vesa_oldvbe&quot;</span>)   { svgaCard = SVGA_S3Trio; int10.vesa_oldvbe = <span class="keyword">true</span>;}
<a name="l00765"></a>00765         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;svga_et4000&quot;</span>)   { svgaCard = SVGA_TsengET4K; }
<a name="l00766"></a>00766         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;svga_et3000&quot;</span>)   { svgaCard = SVGA_TsengET3K; }
<a name="l00767"></a>00767         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;svga_paradise&quot;</span>) { svgaCard = SVGA_ParadisePVGA1A; }
<a name="l00768"></a>00768         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;vgaonly&quot;</span>)       { svgaCard = SVGA_None; }
<a name="l00769"></a>00769         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;amstrad&quot;</span>)       { machine = MCH_AMSTRAD; }
<a name="l00770"></a>00770         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;pc98&quot;</span>)          { machine = MCH_PC98; }
<a name="l00771"></a>00771         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;pc9801&quot;</span>)        { machine = MCH_PC98; } <span class="comment">/* Future differentiation */</span>
<a name="l00772"></a>00772         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mtype == <span class="stringliteral">&quot;pc9821&quot;</span>)        { machine = MCH_PC98; } <span class="comment">/* Future differentiation */</span>
<a name="l00773"></a>00773         <span class="keywordflow">else</span> E_Exit(<span class="stringliteral">&quot;DOSBOX:Unknown machine type %s&quot;</span>,mtype.c_str());
<a name="l00774"></a>00774 
<a name="l00775"></a>00775         <span class="comment">// TODO: should be parsed by motherboard emulation</span>
<a name="l00776"></a>00776         std::string isabclk = section-&gt;Get_string(<span class="stringliteral">&quot;isa bus clock&quot;</span>);
<a name="l00777"></a>00777         <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std8.3&quot;</span>)
<a name="l00778"></a>00778                 clockdom_ISA_BCLK.set_frequency(25000000,3);    <span class="comment">/* 25MHz / 3 = 8.333MHz, early 386 systems did this, became an industry standard &quot;norm&quot; afterwards */</span>
<a name="l00779"></a>00779         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std8&quot;</span>)
<a name="l00780"></a>00780                 clockdom_ISA_BCLK.set_frequency(8000000,1);     <span class="comment">/* 8Mhz */</span>
<a name="l00781"></a>00781         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std6&quot;</span>)
<a name="l00782"></a>00782                 clockdom_ISA_BCLK.set_frequency(6000000,1);     <span class="comment">/* 6MHz */</span>
<a name="l00783"></a>00783         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;std4.77&quot;</span>)
<a name="l00784"></a>00784                 clockdom_ISA_BCLK.set_frequency(clockdom_ISA_OSC.freq,clockdom_ISA_OSC.freq_div*3LL); <span class="comment">/* 14.31818MHz / 3 = 4.77MHz */</span>
<a name="l00785"></a>00785         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;oc10&quot;</span>)
<a name="l00786"></a>00786                 clockdom_ISA_BCLK.set_frequency(10000000,1);    <span class="comment">/* 10MHz */</span>
<a name="l00787"></a>00787         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;oc12&quot;</span>)
<a name="l00788"></a>00788                 clockdom_ISA_BCLK.set_frequency(12000000,1);    <span class="comment">/* 12MHz */</span>
<a name="l00789"></a>00789         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;oc15&quot;</span>)
<a name="l00790"></a>00790                 clockdom_ISA_BCLK.set_frequency(15000000,1);    <span class="comment">/* 15MHz */</span>
<a name="l00791"></a>00791         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isabclk == <span class="stringliteral">&quot;oc16&quot;</span>)
<a name="l00792"></a>00792                 clockdom_ISA_BCLK.set_frequency(16000000,1);    <span class="comment">/* 16MHz */</span>
<a name="l00793"></a>00793         <span class="keywordflow">else</span>
<a name="l00794"></a>00794                 parse_busclk_setting_str(&amp;clockdom_ISA_BCLK,isabclk.c_str());
<a name="l00795"></a>00795 
<a name="l00796"></a>00796         std::string pcibclk = section-&gt;Get_string(<span class="stringliteral">&quot;pci bus clock&quot;</span>);
<a name="l00797"></a>00797         <span class="keywordflow">if</span> (pcibclk == <span class="stringliteral">&quot;std33.3&quot;</span>)
<a name="l00798"></a>00798                 clockdom_PCI_BCLK.set_frequency(100000000,3);   <span class="comment">/* 100MHz / 3 = 33.333MHz, VERY common PCI speed */</span>
<a name="l00799"></a>00799         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pcibclk == <span class="stringliteral">&quot;std30&quot;</span>)
<a name="l00800"></a>00800                 clockdom_PCI_BCLK.set_frequency(30000000,1);    <span class="comment">/* 30Mhz */</span>
<a name="l00801"></a>00801         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pcibclk == <span class="stringliteral">&quot;std25&quot;</span>)
<a name="l00802"></a>00802                 clockdom_PCI_BCLK.set_frequency(25000000,1);    <span class="comment">/* 25MHz */</span>
<a name="l00803"></a>00803         <span class="keywordflow">else</span>
<a name="l00804"></a>00804                 parse_busclk_setting_str(&amp;clockdom_PCI_BCLK,pcibclk.c_str());
<a name="l00805"></a>00805 
<a name="l00806"></a>00806         clockdom_ISA_OSC.set_name(<span class="stringliteral">&quot;ISA OSC&quot;</span>);
<a name="l00807"></a>00807         clockdom_8254_PIT.set_name(<span class="stringliteral">&quot;8254 PIT&quot;</span>);
<a name="l00808"></a>00808         clockdom_8250_UART.set_name(<span class="stringliteral">&quot;8250 UART&quot;</span>);
<a name="l00809"></a>00809         clockdom_ISA_BCLK.set_name(<span class="stringliteral">&quot;ISA BCLK&quot;</span>);
<a name="l00810"></a>00810         clockdom_PCI_BCLK.set_name(<span class="stringliteral">&quot;PCI BCLK&quot;</span>);
<a name="l00811"></a>00811 }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 <span class="keywordtype">void</span> DOSBOX_SetupConfigSections(<span class="keywordtype">void</span>) {
<a name="l00814"></a>00814         <a class="code" href="classProp__int.html">Prop_int</a>* Pint;
<a name="l00815"></a>00815         <a class="code" href="classProp__hex.html">Prop_hex</a>* Phex;
<a name="l00816"></a>00816         <a class="code" href="classProp__bool.html">Prop_bool</a>* Pbool;
<a name="l00817"></a>00817         <a class="code" href="classProp__string.html">Prop_string</a>* Pstring;
<a name="l00818"></a>00818         <a class="code" href="classProp__double.html">Prop_double</a>* Pdouble;
<a name="l00819"></a>00819         <a class="code" href="classProp__multival.html">Prop_multival</a>* Pmulti;
<a name="l00820"></a>00820         <a class="code" href="classSection__prop.html">Section_prop</a> * secprop;
<a name="l00821"></a>00821         <a class="code" href="classProp__multival__remain.html">Prop_multival_remain</a>* Pmulti_remain;
<a name="l00822"></a>00822 
<a name="l00823"></a>00823         <span class="comment">// Some frequently used option sets</span>
<a name="l00824"></a>00824         <span class="keyword">const</span> <span class="keywordtype">char</span>* vsyncrate[] = { <span class="stringliteral">&quot;%u&quot;</span>, 0 };
<a name="l00825"></a>00825         <span class="keyword">const</span> <span class="keywordtype">char</span>* force[] = { <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;forced&quot;</span>, 0 };
<a name="l00826"></a>00826         <span class="keyword">const</span> <span class="keywordtype">char</span>* cyclest[] = { <span class="stringliteral">&quot;auto&quot;</span>,<span class="stringliteral">&quot;fixed&quot;</span>,<span class="stringliteral">&quot;max&quot;</span>,<span class="stringliteral">&quot;%u&quot;</span>,0 };
<a name="l00827"></a>00827         <span class="keyword">const</span> <span class="keywordtype">char</span>* mputypes[] = { <span class="stringliteral">&quot;intelligent&quot;</span>, <span class="stringliteral">&quot;uart&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, 0 };
<a name="l00828"></a>00828         <span class="keyword">const</span> <span class="keywordtype">char</span>* vsyncmode[] = { <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;on&quot;</span> ,<span class="stringliteral">&quot;force&quot;</span>, <span class="stringliteral">&quot;host&quot;</span>, 0 };
<a name="l00829"></a>00829         <span class="keyword">const</span> <span class="keywordtype">char</span>* captureformats[] = { <span class="stringliteral">&quot;default&quot;</span>, <span class="stringliteral">&quot;avi-zmbv&quot;</span>, <span class="stringliteral">&quot;mpegts-h264&quot;</span>, 0 };
<a name="l00830"></a>00830         <span class="keyword">const</span> <span class="keywordtype">char</span>* blocksizes[] = {<span class="stringliteral">&quot;1024&quot;</span>, <span class="stringliteral">&quot;2048&quot;</span>, <span class="stringliteral">&quot;4096&quot;</span>, <span class="stringliteral">&quot;8192&quot;</span>, <span class="stringliteral">&quot;512&quot;</span>, <span class="stringliteral">&quot;256&quot;</span>, 0};
<a name="l00831"></a>00831     <span class="keyword">const</span> <span class="keywordtype">char</span>* capturechromaformats[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;4:4:4&quot;</span>, <span class="stringliteral">&quot;4:2:2&quot;</span>, <span class="stringliteral">&quot;4:2:0&quot;</span>, 0};
<a name="l00832"></a>00832         <span class="keyword">const</span> <span class="keywordtype">char</span>* auxdevices[] = {<span class="stringliteral">&quot;none&quot;</span>,<span class="stringliteral">&quot;2button&quot;</span>,<span class="stringliteral">&quot;3button&quot;</span>,<span class="stringliteral">&quot;intellimouse&quot;</span>,<span class="stringliteral">&quot;intellimouse45&quot;</span>,0};
<a name="l00833"></a>00833         <span class="keyword">const</span> <span class="keywordtype">char</span>* cputype_values[] = {<span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;8086&quot;</span>, <span class="stringliteral">&quot;8086_prefetch&quot;</span>, <span class="stringliteral">&quot;80186&quot;</span>, <span class="stringliteral">&quot;80186_prefetch&quot;</span>, <span class="stringliteral">&quot;286&quot;</span>, <span class="stringliteral">&quot;286_prefetch&quot;</span>, <span class="stringliteral">&quot;386&quot;</span>, <span class="stringliteral">&quot;386_prefetch&quot;</span>, <span class="stringliteral">&quot;486&quot;</span>, <span class="stringliteral">&quot;486_prefetch&quot;</span>, <span class="stringliteral">&quot;pentium&quot;</span>, <span class="stringliteral">&quot;pentium_mmx&quot;</span>, <span class="stringliteral">&quot;ppro_slow&quot;</span>, 0};
<a name="l00834"></a>00834         <span class="keyword">const</span> <span class="keywordtype">char</span>* rates[] = {  <span class="stringliteral">&quot;44100&quot;</span>, <span class="stringliteral">&quot;48000&quot;</span>, <span class="stringliteral">&quot;32000&quot;</span>,<span class="stringliteral">&quot;22050&quot;</span>, <span class="stringliteral">&quot;16000&quot;</span>, <span class="stringliteral">&quot;11025&quot;</span>, <span class="stringliteral">&quot;8000&quot;</span>, <span class="stringliteral">&quot;49716&quot;</span>, 0 };
<a name="l00835"></a>00835         <span class="keyword">const</span> <span class="keywordtype">char</span>* oplrates[] = {   <span class="stringliteral">&quot;44100&quot;</span>, <span class="stringliteral">&quot;49716&quot;</span>, <span class="stringliteral">&quot;48000&quot;</span>, <span class="stringliteral">&quot;32000&quot;</span>,<span class="stringliteral">&quot;22050&quot;</span>, <span class="stringliteral">&quot;16000&quot;</span>, <span class="stringliteral">&quot;11025&quot;</span>, <span class="stringliteral">&quot;8000&quot;</span>, 0 };
<a name="l00836"></a>00836         <span class="keyword">const</span> <span class="keywordtype">char</span>* devices[] = { <span class="stringliteral">&quot;default&quot;</span>, <span class="stringliteral">&quot;win32&quot;</span>, <span class="stringliteral">&quot;alsa&quot;</span>, <span class="stringliteral">&quot;oss&quot;</span>, <span class="stringliteral">&quot;coreaudio&quot;</span>, <span class="stringliteral">&quot;coremidi&quot;</span>, <span class="stringliteral">&quot;mt32&quot;</span>, <span class="stringliteral">&quot;synth&quot;</span>, <span class="stringliteral">&quot;timidity&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, 0}; <span class="comment">// FIXME: add some way to offer the actually available choices.</span>
<a name="l00837"></a>00837         <span class="keyword">const</span> <span class="keywordtype">char</span>* apmbiosversions[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;1.0&quot;</span>, <span class="stringliteral">&quot;1.1&quot;</span>, <span class="stringliteral">&quot;1.2&quot;</span>, 0 };
<a name="l00838"></a>00838         <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32log[] = {<span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>,0};
<a name="l00839"></a>00839         <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32thread[] = {<span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>,0};
<a name="l00840"></a>00840         <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32ReverseStereo[] = {<span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>,0};
<a name="l00841"></a>00841         <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32DACModes[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>,0};
<a name="l00842"></a>00842         <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32reverbModes[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>,0};
<a name="l00843"></a>00843         <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32reverbTimes[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>,0};
<a name="l00844"></a>00844         <span class="keyword">const</span> <span class="keywordtype">char</span> *mt32reverbLevels[] = {<span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;4&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>,0};
<a name="l00845"></a>00845         <span class="keyword">const</span> <span class="keywordtype">char</span>* gustypes[] = { <span class="stringliteral">&quot;classic&quot;</span>, <span class="stringliteral">&quot;classic37&quot;</span>, <span class="stringliteral">&quot;max&quot;</span>, <span class="stringliteral">&quot;interwave&quot;</span>, 0 };
<a name="l00846"></a>00846         <span class="keyword">const</span> <span class="keywordtype">char</span>* sbtypes[] = { <span class="stringliteral">&quot;sb1&quot;</span>, <span class="stringliteral">&quot;sb2&quot;</span>, <span class="stringliteral">&quot;sbpro1&quot;</span>, <span class="stringliteral">&quot;sbpro2&quot;</span>, <span class="stringliteral">&quot;sb16&quot;</span>, <span class="stringliteral">&quot;sb16vibra&quot;</span>, <span class="stringliteral">&quot;gb&quot;</span>, <span class="stringliteral">&quot;ess688&quot;</span>, <span class="stringliteral">&quot;reveal_sc400&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, 0 };
<a name="l00847"></a>00847         <span class="keyword">const</span> <span class="keywordtype">char</span>* oplmodes[]={ <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;cms&quot;</span>, <span class="stringliteral">&quot;opl2&quot;</span>, <span class="stringliteral">&quot;dualopl2&quot;</span>, <span class="stringliteral">&quot;opl3&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>, <span class="stringliteral">&quot;hardware&quot;</span>, <span class="stringliteral">&quot;hardwaregb&quot;</span>, 0};
<a name="l00848"></a>00848         <span class="keyword">const</span> <span class="keywordtype">char</span>* serials[] = { <span class="stringliteral">&quot;dummy&quot;</span>, <span class="stringliteral">&quot;disabled&quot;</span>, <span class="stringliteral">&quot;modem&quot;</span>, <span class="stringliteral">&quot;nullmodem&quot;</span>, <span class="stringliteral">&quot;serialmouse&quot;</span>, <span class="stringliteral">&quot;directserial&quot;</span>, <span class="stringliteral">&quot;log&quot;</span>, 0 };
<a name="l00849"></a>00849         <span class="keyword">const</span> <span class="keywordtype">char</span>* acpi_rsd_ptr_settings[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;bios&quot;</span>, <span class="stringliteral">&quot;ebda&quot;</span>, 0 };
<a name="l00850"></a>00850     <span class="keyword">const</span> <span class="keywordtype">char</span>* cpm_compat_modes[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;msdos2&quot;</span>, <span class="stringliteral">&quot;msdos5&quot;</span>, <span class="stringliteral">&quot;direct&quot;</span>, 0 };
<a name="l00851"></a>00851         <span class="keyword">const</span> <span class="keywordtype">char</span>* dosv_settings[] = { <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;japanese&quot;</span>, <span class="stringliteral">&quot;chinese&quot;</span>, <span class="stringliteral">&quot;korean&quot;</span>, 0 };
<a name="l00852"></a>00852         <span class="keyword">const</span> <span class="keywordtype">char</span>* acpisettings[] = { <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;1.0&quot;</span>, <span class="stringliteral">&quot;1.0b&quot;</span>, <span class="stringliteral">&quot;2.0&quot;</span>, <span class="stringliteral">&quot;2.0a&quot;</span>, <span class="stringliteral">&quot;2.0b&quot;</span>, <span class="stringliteral">&quot;2.0c&quot;</span>, <span class="stringliteral">&quot;3.0&quot;</span>, <span class="stringliteral">&quot;3.0a&quot;</span>, <span class="stringliteral">&quot;3.0b&quot;</span>, <span class="stringliteral">&quot;4.0&quot;</span>, <span class="stringliteral">&quot;4.0a&quot;</span>, <span class="stringliteral">&quot;5.0&quot;</span>, <span class="stringliteral">&quot;5.0a&quot;</span>, <span class="stringliteral">&quot;6.0&quot;</span>, 0 };
<a name="l00853"></a>00853         <span class="keyword">const</span> <span class="keywordtype">char</span>* guspantables[] = { <span class="stringliteral">&quot;old&quot;</span>, <span class="stringliteral">&quot;accurate&quot;</span>, <span class="stringliteral">&quot;default&quot;</span>, 0 };
<a name="l00854"></a>00854         <span class="keyword">const</span> <span class="keywordtype">char</span> *sidbaseno[] = { <span class="stringliteral">&quot;240&quot;</span>, <span class="stringliteral">&quot;220&quot;</span>, <span class="stringliteral">&quot;260&quot;</span>, <span class="stringliteral">&quot;280&quot;</span>, <span class="stringliteral">&quot;2a0&quot;</span>, <span class="stringliteral">&quot;2c0&quot;</span>, <span class="stringliteral">&quot;2e0&quot;</span>, <span class="stringliteral">&quot;300&quot;</span>, 0 };
<a name="l00855"></a>00855         <span class="keyword">const</span> <span class="keywordtype">char</span>* joytypes[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;2axis&quot;</span>, <span class="stringliteral">&quot;4axis&quot;</span>, <span class="stringliteral">&quot;4axis_2&quot;</span>, <span class="stringliteral">&quot;fcs&quot;</span>, <span class="stringliteral">&quot;ch&quot;</span>, <span class="stringliteral">&quot;none&quot;</span>,0};
<a name="l00856"></a>00856         <span class="keyword">const</span> <span class="keywordtype">char</span>* iosgus[] = { <span class="stringliteral">&quot;240&quot;</span>, <span class="stringliteral">&quot;220&quot;</span>, <span class="stringliteral">&quot;260&quot;</span>, <span class="stringliteral">&quot;280&quot;</span>, <span class="stringliteral">&quot;2a0&quot;</span>, <span class="stringliteral">&quot;2c0&quot;</span>, <span class="stringliteral">&quot;2e0&quot;</span>, <span class="stringliteral">&quot;300&quot;</span>, <span class="stringliteral">&quot;210&quot;</span>, <span class="stringliteral">&quot;230&quot;</span>, <span class="stringliteral">&quot;250&quot;</span>, 0 };
<a name="l00857"></a>00857         <span class="keyword">const</span> <span class="keywordtype">char</span>* ios[] = { <span class="stringliteral">&quot;220&quot;</span>, <span class="stringliteral">&quot;240&quot;</span>, <span class="stringliteral">&quot;260&quot;</span>, <span class="stringliteral">&quot;280&quot;</span>, <span class="stringliteral">&quot;2a0&quot;</span>, <span class="stringliteral">&quot;2c0&quot;</span>, <span class="stringliteral">&quot;2e0&quot;</span>, <span class="stringliteral">&quot;300&quot;</span>, 0 };
<a name="l00858"></a>00858         <span class="keyword">const</span> <span class="keywordtype">char</span>* ems_settings[] = { <span class="stringliteral">&quot;true&quot;</span>, <span class="stringliteral">&quot;emsboard&quot;</span>, <span class="stringliteral">&quot;emm386&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>, 0};
<a name="l00859"></a>00859         <span class="keyword">const</span> <span class="keywordtype">char</span>* irqsgus[] = { <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, <span class="stringliteral">&quot;9&quot;</span>, <span class="stringliteral">&quot;10&quot;</span>, <span class="stringliteral">&quot;11&quot;</span>, <span class="stringliteral">&quot;12&quot;</span>, 0 };
<a name="l00860"></a>00860         <span class="keyword">const</span> <span class="keywordtype">char</span>* irqssb[] = { <span class="stringliteral">&quot;7&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;9&quot;</span>, <span class="stringliteral">&quot;10&quot;</span>, <span class="stringliteral">&quot;11&quot;</span>, <span class="stringliteral">&quot;12&quot;</span>, 0 };
<a name="l00861"></a>00861         <span class="keyword">const</span> <span class="keywordtype">char</span>* dmasgus[] = { <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, 0 };
<a name="l00862"></a>00862         <span class="keyword">const</span> <span class="keywordtype">char</span>* dmassb[] = { <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;5&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;6&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>, 0 };
<a name="l00863"></a>00863         <span class="keyword">const</span> <span class="keywordtype">char</span>* oplemus[] = { <span class="stringliteral">&quot;default&quot;</span>, <span class="stringliteral">&quot;compat&quot;</span>, <span class="stringliteral">&quot;fast&quot;</span>, <span class="stringliteral">&quot;nuked&quot;</span>, 0 };
<a name="l00864"></a>00864         <span class="keyword">const</span> <span class="keywordtype">char</span> *qualityno[] = { <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;3&quot;</span>, 0 };
<a name="l00865"></a>00865         <span class="keyword">const</span> <span class="keywordtype">char</span>* tandys[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, 0};
<a name="l00866"></a>00866         <span class="keyword">const</span> <span class="keywordtype">char</span>* ps1opt[] = { <span class="stringliteral">&quot;on&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, 0};
<a name="l00867"></a>00867         <span class="keyword">const</span> <span class="keywordtype">char</span>* truefalseautoopt[] = { <span class="stringliteral">&quot;true&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>, <span class="stringliteral">&quot;auto&quot;</span>, 0};
<a name="l00868"></a>00868     <span class="keyword">const</span> <span class="keywordtype">char</span>* pc98fmboards[] = { <span class="stringliteral">&quot;auto&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>, <span class="stringliteral">&quot;false&quot;</span>, <span class="stringliteral">&quot;board26k&quot;</span>, <span class="stringliteral">&quot;board86&quot;</span>, <span class="stringliteral">&quot;board86c&quot;</span>, 0};
<a name="l00869"></a>00869 
<a name="l00870"></a>00870         <span class="keyword">const</span> <span class="keywordtype">char</span>* irqssbhack[] = {
<a name="l00871"></a>00871                 <span class="stringliteral">&quot;none&quot;</span>, <span class="stringliteral">&quot;cs_equ_ds&quot;</span>, 0
<a name="l00872"></a>00872         };
<a name="l00873"></a>00873 
<a name="l00874"></a>00874         <span class="comment">/* Setup all the different modules making up DOSBox */</span>
<a name="l00875"></a>00875         <span class="keyword">const</span> <span class="keywordtype">char</span>* machines[] = {
<a name="l00876"></a>00876                 <span class="stringliteral">&quot;hercules&quot;</span>, <span class="stringliteral">&quot;cga&quot;</span>, <span class="stringliteral">&quot;cga_mono&quot;</span>, <span class="stringliteral">&quot;cga_rgb&quot;</span>, <span class="stringliteral">&quot;cga_composite&quot;</span>, <span class="stringliteral">&quot;cga_composite2&quot;</span>, <span class="stringliteral">&quot;tandy&quot;</span>, <span class="stringliteral">&quot;pcjr&quot;</span>, <span class="stringliteral">&quot;ega&quot;</span>,
<a name="l00877"></a>00877                 <span class="stringliteral">&quot;vgaonly&quot;</span>, <span class="stringliteral">&quot;svga_s3&quot;</span>, <span class="stringliteral">&quot;svga_et3000&quot;</span>, <span class="stringliteral">&quot;svga_et4000&quot;</span>,
<a name="l00878"></a>00878                 <span class="stringliteral">&quot;svga_paradise&quot;</span>, <span class="stringliteral">&quot;vesa_nolfb&quot;</span>, <span class="stringliteral">&quot;vesa_oldvbe&quot;</span>, <span class="stringliteral">&quot;amstrad&quot;</span>, <span class="stringliteral">&quot;pc98&quot;</span>, <span class="stringliteral">&quot;pc9801&quot;</span>, <span class="stringliteral">&quot;pc9821&quot;</span>, 0 };
<a name="l00879"></a>00879 
<a name="l00880"></a>00880         <span class="keyword">const</span> <span class="keywordtype">char</span>* scalers[] = { 
<a name="l00881"></a>00881                 <span class="stringliteral">&quot;none&quot;</span>, <span class="stringliteral">&quot;normal2x&quot;</span>, <span class="stringliteral">&quot;normal3x&quot;</span>, <span class="stringliteral">&quot;normal4x&quot;</span>, <span class="stringliteral">&quot;normal5x&quot;</span>,
<a name="l00882"></a>00882 <span class="preprocessor">#if RENDER_USE_ADVANCED_SCALERS&gt;2</span>
<a name="l00883"></a>00883 <span class="preprocessor"></span>                <span class="stringliteral">&quot;advmame2x&quot;</span>, <span class="stringliteral">&quot;advmame3x&quot;</span>, <span class="stringliteral">&quot;advinterp2x&quot;</span>, <span class="stringliteral">&quot;advinterp3x&quot;</span>, <span class="stringliteral">&quot;hq2x&quot;</span>, <span class="stringliteral">&quot;hq3x&quot;</span>, <span class="stringliteral">&quot;2xsai&quot;</span>, <span class="stringliteral">&quot;super2xsai&quot;</span>, <span class="stringliteral">&quot;supereagle&quot;</span>,
<a name="l00884"></a>00884 <span class="preprocessor">#endif</span>
<a name="l00885"></a>00885 <span class="preprocessor"></span><span class="preprocessor">#if RENDER_USE_ADVANCED_SCALERS&gt;0</span>
<a name="l00886"></a>00886 <span class="preprocessor"></span>                <span class="stringliteral">&quot;tv2x&quot;</span>, <span class="stringliteral">&quot;tv3x&quot;</span>, <span class="stringliteral">&quot;rgb2x&quot;</span>, <span class="stringliteral">&quot;rgb3x&quot;</span>, <span class="stringliteral">&quot;scan2x&quot;</span>, <span class="stringliteral">&quot;scan3x&quot;</span>,
<a name="l00887"></a>00887 <span class="preprocessor">#endif</span>
<a name="l00888"></a>00888 <span class="preprocessor"></span>                <span class="stringliteral">&quot;hardware_none&quot;</span>, <span class="stringliteral">&quot;hardware2x&quot;</span>, <span class="stringliteral">&quot;hardware3x&quot;</span>, <span class="stringliteral">&quot;hardware4x&quot;</span>, <span class="stringliteral">&quot;hardware5x&quot;</span>,
<a name="l00889"></a>00889                 0 };
<a name="l00890"></a>00890 
<a name="l00891"></a>00891         <span class="keyword">const</span> <span class="keywordtype">char</span>* cores[] = { <span class="stringliteral">&quot;auto&quot;</span>,
<a name="l00892"></a>00892 <span class="preprocessor">#if (C_DYNAMIC_X86)</span>
<a name="l00893"></a>00893 <span class="preprocessor"></span>                <span class="stringliteral">&quot;dynamic&quot;</span>,
<a name="l00894"></a>00894 <span class="preprocessor">#endif</span>
<a name="l00895"></a>00895 <span class="preprocessor"></span>                <span class="stringliteral">&quot;normal&quot;</span>, <span class="stringliteral">&quot;full&quot;</span>, <span class="stringliteral">&quot;simple&quot;</span>, 0 };
<a name="l00896"></a>00896 
<a name="l00897"></a>00897         <span class="keyword">const</span> <span class="keywordtype">char</span>* voodoo_settings[] = {
<a name="l00898"></a>00898                 <span class="stringliteral">&quot;false&quot;</span>,
<a name="l00899"></a>00899                 <span class="stringliteral">&quot;software&quot;</span>,
<a name="l00900"></a>00900 <span class="preprocessor">#if C_OPENGL</span>
<a name="l00901"></a>00901 <span class="preprocessor"></span>                <span class="stringliteral">&quot;opengl&quot;</span>,
<a name="l00902"></a>00902 <span class="preprocessor">#endif</span>
<a name="l00903"></a>00903 <span class="preprocessor"></span>                <span class="stringliteral">&quot;auto&quot;</span>,
<a name="l00904"></a>00904                 0
<a name="l00905"></a>00905         };
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 <span class="preprocessor">#if defined(__SSE__) &amp;&amp; !defined(_M_AMD64)</span>
<a name="l00908"></a>00908 <span class="preprocessor"></span>        CheckSSESupport();
<a name="l00909"></a>00909 <span class="preprocessor">#endif</span>
<a name="l00910"></a>00910 <span class="preprocessor"></span>        SDLNetInited = <span class="keyword">false</span>;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;dosbox&quot;</span>,&amp;Null_Init);
<a name="l00913"></a>00913         Pstring = secprop-&gt;Add_path(<span class="stringliteral">&quot;language&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l00914"></a>00914         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Select another language file.&quot;</span>);
<a name="l00915"></a>00915 
<a name="l00916"></a>00916         Pstring = secprop-&gt;Add_path(<span class="stringliteral">&quot;title&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l00917"></a>00917         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Additional text to place in the title bar of the window&quot;</span>);
<a name="l00918"></a>00918 
<a name="l00919"></a>00919         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dpi aware&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l00920"></a>00920         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Set this option (on by default) to indicate to your OS that DOSBox is DPI aware.\n&quot;</span>
<a name="l00921"></a>00921                         <span class="stringliteral">&quot;If it is not set, Windows Vista/7/8/10 and higher may upscale the DOSBox window\n&quot;</span>
<a name="l00922"></a>00922                         <span class="stringliteral">&quot;on higher resolution monitors which is probably not what you want.&quot;</span>);
<a name="l00923"></a>00923 
<a name="l00924"></a>00924         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;keyboard hook&quot;</span>, Property::Changeable::Always, <span class="keyword">false</span>);
<a name="l00925"></a>00925         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Use keyboard hook (currently only on Windows) to catch special keys and synchronize the keyboard LEDs with the host&quot;</span>);
<a name="l00926"></a>00926 
<a name="l00927"></a>00927         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;weitek&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l00928"></a>00928         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate the Weitek coprocessor. This option only has effect if cputype=386 or cputype=486.&quot;</span>);
<a name="l00929"></a>00929 
<a name="l00930"></a>00930         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;bochs debug port e9&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l00931"></a>00931         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate Bochs debug port E9h. ASCII text written to this I/O port is assumed to be debug output, and logged.&quot;</span>);
<a name="l00932"></a>00932 
<a name="l00933"></a>00933         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;machine&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;svga_s3&quot;</span>);
<a name="l00934"></a>00934         Pstring-&gt;Set_values(machines);
<a name="l00935"></a>00935         Pstring-&gt;Set_help(<span class="stringliteral">&quot;The type of machine DOSBox tries to emulate.&quot;</span>);
<a name="l00936"></a>00936 
<a name="l00937"></a>00937         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vmemdelay&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l00938"></a>00938         Pint-&gt;SetMinMax(-1,100000);
<a name="l00939"></a>00939         Pint-&gt;Set_help( <span class="stringliteral">&quot;VGA Memory I/O delay in nanoseconds. Set to -1 to use default, 0 to disable.\n&quot;</span>
<a name="l00940"></a>00940                         <span class="stringliteral">&quot;Default off. Enable this option (-1 or nonzero) if you are running a game or\n&quot;</span>
<a name="l00941"></a>00941                         <span class="stringliteral">&quot;demo that needs slower VGA memory (like that of older ISA hardware) to work properly.\n&quot;</span>
<a name="l00942"></a>00942                         <span class="stringliteral">&quot;If your game is not sensitive to VGA RAM I/O speed, then turning on this option\n&quot;</span>
<a name="l00943"></a>00943                         <span class="stringliteral">&quot;will do nothing but cause a significant drop in frame rate which is probably not\n&quot;</span>
<a name="l00944"></a>00944                         <span class="stringliteral">&quot;what you want. Recommended values -1, 0 to 2000.&quot;</span>);
<a name="l00945"></a>00945 
<a name="l00946"></a>00946         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vmemsize&quot;</span>, Property::Changeable::WhenIdle,2);
<a name="l00947"></a>00947         Pint-&gt;SetMinMax(0,8);
<a name="l00948"></a>00948         Pint-&gt;Set_help(
<a name="l00949"></a>00949                 <span class="stringliteral">&quot;Amount of video memory in megabytes.\n&quot;</span>
<a name="l00950"></a>00950                 <span class="stringliteral">&quot;  The maximum resolution and color depth the svga_s3 will be able to display\n&quot;</span>
<a name="l00951"></a>00951                 <span class="stringliteral">&quot;  is determined by this value.\n &quot;</span>
<a name="l00952"></a>00952                 <span class="stringliteral">&quot;  0: 512k (800x600  at 256 colors)\n&quot;</span>
<a name="l00953"></a>00953                 <span class="stringliteral">&quot;  1: 1024x768  at 256 colors or 800x600  at 64k colors\n&quot;</span>
<a name="l00954"></a>00954                 <span class="stringliteral">&quot;  2: 1600x1200 at 256 colors or 1024x768 at 64k colors or 640x480 at 16M colors\n&quot;</span>
<a name="l00955"></a>00955                 <span class="stringliteral">&quot;  4: 1600x1200 at 64k colors or 1024x768 at 16M colors\n&quot;</span>
<a name="l00956"></a>00956                 <span class="stringliteral">&quot;  8: up to 1600x1200 at 16M colors\n&quot;</span>
<a name="l00957"></a>00957                 <span class="stringliteral">&quot;For build engine games, use more memory than in the list above so it can\n&quot;</span>
<a name="l00958"></a>00958                 <span class="stringliteral">&quot;use triple buffering and thus won&#39;t flicker.\n&quot;</span>
<a name="l00959"></a>00959                 );
<a name="l00960"></a>00960 
<a name="l00961"></a>00961         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vmemsizekb&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l00962"></a>00962         Pint-&gt;SetMinMax(0,8);
<a name="l00963"></a>00963         Pint-&gt;Set_help(
<a name="l00964"></a>00964                 <span class="stringliteral">&quot;Amount of video memory in kilobytes, in addition to vmemsize&quot;</span>);
<a name="l00965"></a>00965 
<a name="l00966"></a>00966         Pstring = secprop-&gt;Add_path(<span class="stringliteral">&quot;captures&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;capture&quot;</span>);
<a name="l00967"></a>00967         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Directory where things like wave, midi, screenshot get captured.&quot;</span>);
<a name="l00968"></a>00968 
<a name="l00969"></a>00969     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;capture chroma format&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l00970"></a>00970     Pstring-&gt;Set_values(capturechromaformats);
<a name="l00971"></a>00971     Pstring-&gt;Set_help(<span class="stringliteral">&quot;Chroma format to use when capturing to H.264. &#39;auto&#39; picks the best quality option.\n&quot;</span>
<a name="l00972"></a>00972             <span class="stringliteral">&quot;4:4:4       Chroma is at full resolution. This provides the best quality, however not widely supported by editing software.\n&quot;</span>
<a name="l00973"></a>00973             <span class="stringliteral">&quot;4:2:2       Chroma is at half horizontal resolution.\n&quot;</span>
<a name="l00974"></a>00974             <span class="stringliteral">&quot;4:2:0       Chroma is at quarter resolution, which may cause minor color smearing.\n&quot;</span>
<a name="l00975"></a>00975             <span class="stringliteral">&quot;            However, this chroma format is most likely to be compatible with video editing software.&quot;</span>);
<a name="l00976"></a>00976 
<a name="l00977"></a>00977         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;capture format&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l00978"></a>00978         Pstring-&gt;Set_values(captureformats);
<a name="l00979"></a>00979         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Capture format to use when capturing video. The availability of the format depends on how DOSBox-X was compiled.\n&quot;</span>
<a name="l00980"></a>00980                         <span class="stringliteral">&quot;default                     Use compiled-in default (avi-zmbv)\n&quot;</span>
<a name="l00981"></a>00981                         <span class="stringliteral">&quot;avi-zmbv                    Use DOSBox-style AVI + ZMBV codec with PCM audio\n&quot;</span>
<a name="l00982"></a>00982                         <span class="stringliteral">&quot;mpegts-h264                 Use MPEG transport stream + H.264 + AAC audio. Resolution &amp; refresh rate changes can be contained\n&quot;</span>
<a name="l00983"></a>00983                         <span class="stringliteral">&quot;                            within one file with this choice, however not all software can support mid-stream format changes.&quot;</span>);
<a name="l00984"></a>00984 
<a name="l00985"></a>00985         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;mainline compatible mapping&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l00986"></a>00986         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, arrange private areas, UMBs, and DOS kernel structures by default in the same way the mainline branch would do it.\n&quot;</span>
<a name="l00987"></a>00987                         <span class="stringliteral">&quot;If cleared, these areas are allocated dynamically which may improve available memory and emulation accuracy.\n&quot;</span>
<a name="l00988"></a>00988                         <span class="stringliteral">&quot;If your DOS game breaks under DOSBox-X but works with mainline DOSBox setting this option may help.&quot;</span>);
<a name="l00989"></a>00989 
<a name="l00990"></a>00990         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;mainline compatible bios mapping&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l00991"></a>00991         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, arrange the BIOS area in the same way that the mainline branch would do it.\n&quot;</span>
<a name="l00992"></a>00992                         <span class="stringliteral">&quot;If cleared, these areas are allocated dynamically which may improve available memory and emulation accuracy.\n&quot;</span>
<a name="l00993"></a>00993                         <span class="stringliteral">&quot;If your DOS game breaks under DOSBox-X but works with mainline DOSBox setting this option may help.&quot;</span>);
<a name="l00994"></a>00994 
<a name="l00995"></a>00995         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;adapter rom is ram&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l00996"></a>00996         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Map adapter ROM as RAM (mainline DOSBox 0.74 behavior). When clear, unused adapter ROM is mapped out&quot;</span>);
<a name="l00997"></a>00997 
<a name="l00998"></a>00998         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;shell environment size&quot;</span>,Property::Changeable::OnlyAtStart,0);
<a name="l00999"></a>00999         Pint-&gt;SetMinMax(0,65280);
<a name="l01000"></a>01000         Pint-&gt;Set_help(<span class="stringliteral">&quot;Size of the initial DOSBox shell environment block, in bytes. This does not affect the environment block of sub-processes spawned from the shell.\n&quot;</span>
<a name="l01001"></a>01001                         <span class="stringliteral">&quot;This option has no effect unless dynamic kernel allocation is enabled.&quot;</span>);
<a name="l01002"></a>01002 
<a name="l01003"></a>01003         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;private area size&quot;</span>,Property::Changeable::OnlyAtStart,32768); <span class="comment">// DOSBox mainline compatible 32KB region</span>
<a name="l01004"></a>01004         Pint-&gt;SetMinMax(16,128*1024);
<a name="l01005"></a>01005         Pint-&gt;Set_help(<span class="stringliteral">&quot;Set DOSBox-X private memory area size. This area contains private memory structures used by the DOS kernel.\n&quot;</span>
<a name="l01006"></a>01006                         <span class="stringliteral">&quot;It is discarded when you boot into another OS. Mainline DOSBox uses 32KB. Testing shows that it is possible\n&quot;</span>
<a name="l01007"></a>01007                         <span class="stringliteral">&quot;to run DOSBox with as little as 4KB. If DOSBox-X aborts with error \&quot;not enough memory for internal tables\&quot;\n&quot;</span>
<a name="l01008"></a>01008                         <span class="stringliteral">&quot;then you need to increase this value.&quot;</span>);
<a name="l01009"></a>01009 
<a name="l01010"></a>01010         <span class="comment">// TODO: At some point, I would like to make &quot;mask&quot; the default instead of &quot;fast&quot;</span>
<a name="l01011"></a>01011         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;a20&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;fast&quot;</span>);
<a name="l01012"></a>01012         Pstring-&gt;Set_help(<span class="stringliteral">&quot;A20 gate emulation mode.\n&quot;</span>
<a name="l01013"></a>01013                           <span class="stringliteral">&quot;The on/off/on_fake/off_fake options are intended for testing and debugging DOS development,\n&quot;</span>
<a name="l01014"></a>01014                           <span class="stringliteral">&quot;or to emulate obscure hardware, or to work around potential extended memory problems with DOS programs.\n&quot;</span>
<a name="l01015"></a>01015                           <span class="stringliteral">&quot;on_fake/off_fake are intended to test whether a program carries out a memory test to ensure the A20\n&quot;</span>
<a name="l01016"></a>01016                           <span class="stringliteral">&quot;gate is set as intended (as HIMEM.SYS does). If it goes by the gate bit alone, it WILL crash.\n&quot;</span>
<a name="l01017"></a>01017                           <span class="stringliteral">&quot;This parameter is also changeable from the builtin A20GATE command.\n&quot;</span>
<a name="l01018"></a>01018                           <span class="stringliteral">&quot;  fast                         Emulate A20 gating by remapping the first 64KB @ 1MB boundary (fast, mainline DOSBox behavior)\n&quot;</span>
<a name="l01019"></a>01019                           <span class="stringliteral">&quot;  mask                         Emulate A20 gating by masking memory I/O address (accurate)\n&quot;</span>
<a name="l01020"></a>01020                           <span class="stringliteral">&quot;  off                          Lock A20 gate off (Software/OS cannot enable A20)\n&quot;</span>
<a name="l01021"></a>01021                           <span class="stringliteral">&quot;  on                           Lock A20 gate on (Software/OS cannot disable A20)\n&quot;</span>
<a name="l01022"></a>01022                           <span class="stringliteral">&quot;  off_fake                     Lock A20 gate off but allow bit to toggle (hope your DOS game tests the HMA!)\n&quot;</span>
<a name="l01023"></a>01023                           <span class="stringliteral">&quot;  on_fake                      Lock A20 gate on but allow bit to toggle&quot;</span>);
<a name="l01024"></a>01024 
<a name="l01025"></a>01025     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;turn off a20 gate on boot&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01026"></a>01026     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If enabled, A20 gate is switched off when booting a guest OS.\n&quot;</span>
<a name="l01027"></a>01027                     <span class="stringliteral">&quot;Enabled by default. Recommended for MS-DOS when HIMEM.SYS is not installed in the guest OS.\n&quot;</span>
<a name="l01028"></a>01028                     <span class="stringliteral">&quot;If disabled, and MS-DOS does not load HIMEM.SYS, programs and features that rely on the 1MB wraparound will fail.&quot;</span>);
<a name="l01029"></a>01029 
<a name="l01030"></a>01030         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;isa bus clock&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;std8.3&quot;</span>);
<a name="l01031"></a>01031         Pstring-&gt;Set_help(<span class="stringliteral">&quot;ISA BCLK frequency.\n&quot;</span>
<a name="l01032"></a>01032                           <span class="stringliteral">&quot;WARNING: In future revisions, PCI/motherboard chipset emulation will allow the guest OS/program to alter this value at runtime.\n&quot;</span>
<a name="l01033"></a>01033                           <span class="stringliteral">&quot;  std8.3                       8.333MHz (typical 386-class or higher)\n&quot;</span>
<a name="l01034"></a>01034                           <span class="stringliteral">&quot;  std8                         8MHz\n&quot;</span>
<a name="l01035"></a>01035                           <span class="stringliteral">&quot;  std6                         6MHz\n&quot;</span>
<a name="l01036"></a>01036                           <span class="stringliteral">&quot;  std4.77                      4.77MHz (precisely 1/3 x 14.31818MHz). Bus frequency of older PC/XT systems.\n&quot;</span>
<a name="l01037"></a>01037                           <span class="stringliteral">&quot;  oc10                         10MHz\n&quot;</span>
<a name="l01038"></a>01038                           <span class="stringliteral">&quot;  oc12                         12MHz\n&quot;</span>
<a name="l01039"></a>01039                           <span class="stringliteral">&quot;  oc15                         15MHz\n&quot;</span>
<a name="l01040"></a>01040                           <span class="stringliteral">&quot;  oc16                         16MHz\n&quot;</span>
<a name="l01041"></a>01041                           <span class="stringliteral">&quot;  &lt;integer or float&gt;           Any integer or floating point value will be used as the clock frequency in Hz\n&quot;</span>
<a name="l01042"></a>01042                           <span class="stringliteral">&quot;  &lt;integer/integer ratio&gt;      If a ratio is given (num/den), the ratio will be used as the clock frequency&quot;</span>);
<a name="l01043"></a>01043 
<a name="l01044"></a>01044         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;pci bus clock&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;std33.3&quot;</span>);
<a name="l01045"></a>01045         Pstring-&gt;Set_help(<span class="stringliteral">&quot;PCI bus frequency.\n&quot;</span>
<a name="l01046"></a>01046                           <span class="stringliteral">&quot;WARNING: In future revisions, PCI/motherboard chipset emulation will allow the guest OS/program to alter this value at runtime.\n&quot;</span>
<a name="l01047"></a>01047                           <span class="stringliteral">&quot;  std33.3                      33.333MHz (very common setting on motherboards)\n&quot;</span>
<a name="l01048"></a>01048                           <span class="stringliteral">&quot;  std30                        30MHz (some older mid-1990&#39;s Pentium systems)\n&quot;</span>
<a name="l01049"></a>01049                           <span class="stringliteral">&quot;  std25                        25MHz\n&quot;</span>
<a name="l01050"></a>01050                           <span class="stringliteral">&quot;  &lt;integer or float&gt;           Any integer or floating point value will be used as the clock frequency in Hz\n&quot;</span>
<a name="l01051"></a>01051                           <span class="stringliteral">&quot;  &lt;integer/integer ratio&gt;      If a ratio is given (num/den), the ratio will be used as the clock frequency&quot;</span>);
<a name="l01052"></a>01052 
<a name="l01053"></a>01053         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;call binary on reset&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01054"></a>01054         Pstring-&gt;Set_help(<span class="stringliteral">&quot;If set, this is the path of a binary blob to load into the ROM BIOS area and execute immediately after CPU reset.\n&quot;</span>
<a name="l01055"></a>01055                       <span class="stringliteral">&quot;It will be executed before the BIOS POST routine, only ONCE. The binary blob is expected either to IRET or to\n&quot;</span>
<a name="l01056"></a>01056                       <span class="stringliteral">&quot;jump directly to F000:FFF0 to return control to the BIOS.\n&quot;</span>
<a name="l01057"></a>01057                       <span class="stringliteral">&quot;This can be used for x86 assembly language experiments and automated testing against the CPU emulation.&quot;</span>);
<a name="l01058"></a>01058 
<a name="l01059"></a>01059         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;call binary on boot&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01060"></a>01060         Pstring-&gt;Set_help(<span class="stringliteral">&quot;If set, this is the path of a binary blob to load into the ROM BIOS area and execute immediately before booting the DOS system.\n&quot;</span>
<a name="l01061"></a>01061                       <span class="stringliteral">&quot;This can be used for x86 assembly language experiments and automated testing against the CPU emulation.&quot;</span>);
<a name="l01062"></a>01062 
<a name="l01063"></a>01063         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;rom bios allocation max&quot;</span>,Property::Changeable::OnlyAtStart,0);
<a name="l01064"></a>01064         Pint-&gt;SetMinMax(0,128);
<a name="l01065"></a>01065         Pint-&gt;Set_help(<span class="stringliteral">&quot;Maximum size (top down from 1MB) allowed for ROM BIOS dynamic allocation in KB&quot;</span>);
<a name="l01066"></a>01066 
<a name="l01067"></a>01067         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;rom bios minimum size&quot;</span>,Property::Changeable::OnlyAtStart,0);
<a name="l01068"></a>01068         Pint-&gt;SetMinMax(0,128);
<a name="l01069"></a>01069         Pint-&gt;Set_help(<span class="stringliteral">&quot;Once ROM BIOS layout is finalized, trim total region down to a minimum amount in KB&quot;</span>);
<a name="l01070"></a>01070 
<a name="l01071"></a>01071         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;irq delay ns&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01072"></a>01072         Pint-&gt;SetMinMax(-1,100000);
<a name="l01073"></a>01073         Pint-&gt;Set_help( <span class="stringliteral">&quot;IRQ delay in nanoseconds. Set to -1 to use default, 0 to disable.\n&quot;</span>
<a name="l01074"></a>01074                     <span class="stringliteral">&quot;This is a more precise version of the irqdelay= setting.\n&quot;</span>
<a name="l01075"></a>01075                     <span class="stringliteral">&quot;There are some old DOS games and demos that have race conditions with IRQs that need a nonzero value here to work properly.&quot;</span>);
<a name="l01076"></a>01076 
<a name="l01077"></a>01077         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;iodelay&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01078"></a>01078         Pint-&gt;SetMinMax(-1,100000);
<a name="l01079"></a>01079         Pint-&gt;Set_help( <span class="stringliteral">&quot;I/O delay in nanoseconds for I/O port access. Set to -1 to use default, 0 to disable.\n&quot;</span>
<a name="l01080"></a>01080                         <span class="stringliteral">&quot;A value of 1000 (1us) is recommended for ISA bus type delays. If your game\n&quot;</span>
<a name="l01081"></a>01081                         <span class="stringliteral">&quot;or demo is not sensitive to I/O port and ISA bus timing, you can turn this option off\n&quot;</span>
<a name="l01082"></a>01082                         <span class="stringliteral">&quot;(set to 0) to increase game performance.&quot;</span>);
<a name="l01083"></a>01083 
<a name="l01084"></a>01084         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;iodelay16&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01085"></a>01085         Pint-&gt;SetMinMax(-1,100000);
<a name="l01086"></a>01086         Pint-&gt;Set_help( <span class="stringliteral">&quot;I/O delay for 16-bit transfers. -1 to use default, 0 to disable.&quot;</span>);
<a name="l01087"></a>01087 
<a name="l01088"></a>01088         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;iodelay32&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01089"></a>01089         Pint-&gt;SetMinMax(-1,100000);
<a name="l01090"></a>01090         Pint-&gt;Set_help( <span class="stringliteral">&quot;I/O delay for 32-bit transfers. -1 to use default, 0 to disable.&quot;</span>);
<a name="l01091"></a>01091 
<a name="l01092"></a>01092         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;acpi&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l01093"></a>01093         Pstring-&gt;Set_values(acpisettings);
<a name="l01094"></a>01094         Pstring-&gt;Set_help(<span class="stringliteral">&quot;ACPI emulation, and what version of the specification to follow.\n&quot;</span>
<a name="l01095"></a>01095                         <span class="stringliteral">&quot;WARNING: This option is very experimental at this time and should not be enabled unless you&#39;re willing to accept the consequences.\n&quot;</span>
<a name="l01096"></a>01096                         <span class="stringliteral">&quot;         Intended for use with ACPI-aware OSes including Linux and Windows 98/ME. This option will also slightly reduce available\n&quot;</span>
<a name="l01097"></a>01097                         <span class="stringliteral">&quot;         system memory to make room for the ACPI tables, just as real BIOSes do, and reserve an IRQ for ACPI functions.&quot;</span>);
<a name="l01098"></a>01098 
<a name="l01099"></a>01099         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;acpi rsd ptr location&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01100"></a>01100         Pstring-&gt;Set_values(acpi_rsd_ptr_settings);
<a name="l01101"></a>01101         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Where to store the Root System Description Pointer structure. You can have it stored in the ROM BIOS area, or the Extended Bios Data Area.&quot;</span>);
<a name="l01102"></a>01102 
<a name="l01103"></a>01103         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;acpi sci irq&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01104"></a>01104         Pint-&gt;Set_help(<span class="stringliteral">&quot;IRQ to assign as ACPI system control interrupt. set to -1 to automatically assign.&quot;</span>);
<a name="l01105"></a>01105 
<a name="l01106"></a>01106         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;acpi iobase&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l01107"></a>01107         Phex-&gt;Set_help(<span class="stringliteral">&quot;I/O port base for the ACPI device Power Management registers. Set to 0 for automatic assignment.&quot;</span>);
<a name="l01108"></a>01108 
<a name="l01109"></a>01109         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;acpi reserved size&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01110"></a>01110         Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of memory at top to reserve for ACPI structures and tables. Set to 0 for automatic assignment.&quot;</span>);
<a name="l01111"></a>01111 
<a name="l01112"></a>01112         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;memsize&quot;</span>, Property::Changeable::WhenIdle,16);
<a name="l01113"></a>01113         Pint-&gt;SetMinMax(1,511);
<a name="l01114"></a>01114         Pint-&gt;Set_help(
<a name="l01115"></a>01115                 <span class="stringliteral">&quot;Amount of memory DOSBox has in megabytes.\n&quot;</span>
<a name="l01116"></a>01116                 <span class="stringliteral">&quot;  This value is best left at its default to avoid problems with some games,\n&quot;</span>
<a name="l01117"></a>01117                 <span class="stringliteral">&quot;  though few games might require a higher value.\n&quot;</span>
<a name="l01118"></a>01118                 <span class="stringliteral">&quot;  There is generally no speed advantage when raising this value.\n&quot;</span>
<a name="l01119"></a>01119                 <span class="stringliteral">&quot;  Programs that use 286 protected mode like Windows 3.0 in Standard Mode may crash with more than 15MB.&quot;</span>);
<a name="l01120"></a>01120 
<a name="l01121"></a>01121         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;memsizekb&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01122"></a>01122         Pint-&gt;SetMinMax(0,524288);
<a name="l01123"></a>01123         Pint-&gt;Set_help(
<a name="l01124"></a>01124                 <span class="stringliteral">&quot;Amount of memory DOSBox has in kilobytes.\n&quot;</span>
<a name="l01125"></a>01125                 <span class="stringliteral">&quot;  This value should normally be set to 0.\n&quot;</span>
<a name="l01126"></a>01126                 <span class="stringliteral">&quot;  If nonzero, it is added to the memsize parameter.\n&quot;</span>
<a name="l01127"></a>01127                 <span class="stringliteral">&quot;  Finer grained control of total memory may be useful in\n&quot;</span>
<a name="l01128"></a>01128                 <span class="stringliteral">&quot;  emulating ancient DOS machines with less than 640KB of\n&quot;</span>
<a name="l01129"></a>01129                 <span class="stringliteral">&quot;  RAM or early 386 systems with odd extended memory sizes.&quot;</span>);
<a name="l01130"></a>01130 
<a name="l01131"></a>01131         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dos mem limit&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01132"></a>01132         Pint-&gt;SetMinMax(0,1023);
<a name="l01133"></a>01133         Pint-&gt;Set_help( <span class="stringliteral">&quot;Limit DOS conventional memory to this amount. Does not affect extended memory.\n&quot;</span>
<a name="l01134"></a>01134                         <span class="stringliteral">&quot;Setting this option to a value in the range 636-639 can be used to simulate modern BIOSes\n&quot;</span>
<a name="l01135"></a>01135                         <span class="stringliteral">&quot;that maintain an EBDA (Extended BIOS Data Area) at the top of conventional memory.\n&quot;</span>
<a name="l01136"></a>01136                         <span class="stringliteral">&quot;You may also play with this option for diagnostic purposes or to stress test DOS programs in limited memory setups.\n&quot;</span>
<a name="l01137"></a>01137                         <span class="stringliteral">&quot;\n&quot;</span>
<a name="l01138"></a>01138                         <span class="stringliteral">&quot;A few DOS games &amp; demos require this option to be set:\n&quot;</span>
<a name="l01139"></a>01139                         <span class="stringliteral">&quot;     Majic 12 \&quot;Show\&quot;: If UMBs are enabled, set this option to 639 to avoid MCB chain corruption error.&quot;</span>);
<a name="l01140"></a>01140 
<a name="l01141"></a>01141         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;isa memory hole at 512kb&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01142"></a>01142         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate an ISA memory hole at the 512KB to 640KB area (0x80000-0x9FFFF).&quot;</span>);
<a name="l01143"></a>01143 
<a name="l01144"></a>01144         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;memalias&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01145"></a>01145         Pint-&gt;SetMinMax(0,32);
<a name="l01146"></a>01146         Pint-&gt;Set_help(
<a name="l01147"></a>01147                 <span class="stringliteral">&quot;Memory aliasing emulation, in number of valid address bits.\n&quot;</span>
<a name="l01148"></a>01148                 <span class="stringliteral">&quot;. Many 386/486 class motherboards and processors prior to 1995\n&quot;</span>
<a name="l01149"></a>01149                 <span class="stringliteral">&quot;  suffered from memory aliasing for various technical reasons. If the software you are\n&quot;</span>
<a name="l01150"></a>01150                 <span class="stringliteral">&quot;  trying to run assumes aliasing, or otherwise plays cheap tricks with paging,\n&quot;</span>
<a name="l01151"></a>01151                 <span class="stringliteral">&quot;  enabling this option can help. Note that enabling this option can cause slight performance degredation. Set to 0 to disable.\n&quot;</span>
<a name="l01152"></a>01152                 <span class="stringliteral">&quot;  Recommended values when enabled:\n&quot;</span>
<a name="l01153"></a>01153                 <span class="stringliteral">&quot;    24: 16MB aliasing. Common on 386SX systems (CPU had 24 external address bits)\n&quot;</span>
<a name="l01154"></a>01154                 <span class="stringliteral">&quot;        or 386DX and 486 systems where the CPU communicated directly with the ISA bus (A24-A31 tied off)\n&quot;</span>
<a name="l01155"></a>01155                 <span class="stringliteral">&quot;    26: 64MB aliasing. Some 486s had only 26 external address bits, some motherboards tied off A26-A31&quot;</span>);
<a name="l01156"></a>01156 
<a name="l01157"></a>01157         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;pc-98 fm board&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01158"></a>01158     Pstring-&gt;Set_values(pc98fmboards);
<a name="l01159"></a>01159         Pstring-&gt;Set_help(<span class="stringliteral">&quot;In PC-98 mode, selects the FM music board to emulate.&quot;</span>);
<a name="l01160"></a>01160 
<a name="l01161"></a>01161         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;pc-98 fm board irq&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01162"></a>01162         Pint-&gt;Set_help(<span class="stringliteral">&quot;If set, helps to determine the IRQ of the FM board. A setting of zero means to auto-determine the IRQ.&quot;</span>);
<a name="l01163"></a>01163 
<a name="l01164"></a>01164         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;pc-98 fm board io port&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01165"></a>01165         Phex-&gt;Set_help(<span class="stringliteral">&quot;If set, helps to determine the base I/O port of the FM board. A setting of zero means to auto-determine the port number.&quot;</span>);
<a name="l01166"></a>01166 
<a name="l01167"></a>01167         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 buffer page flip&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01168"></a>01168         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, the game&#39;s request to page flip will be delayed to vertical retrace, which can eliminate tearline artifacts.\n&quot;</span>
<a name="l01169"></a>01169                     <span class="stringliteral">&quot;Note that this is NOT the behavior of actual hardware. This option is provided for the user&#39;s preference.&quot;</span>);
<a name="l01170"></a>01170 
<a name="l01171"></a>01171         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable 16-color&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01172"></a>01172         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow 16-color graphics mode if set, disable if not set&quot;</span>);
<a name="l01173"></a>01173 
<a name="l01174"></a>01174         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable grcg&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01175"></a>01175         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow GRCG graphics functions if set, disable if not set&quot;</span>);
<a name="l01176"></a>01176 
<a name="l01177"></a>01177         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 enable egc&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01178"></a>01178         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow EGC graphics functions if set, disable if not set&quot;</span>);
<a name="l01179"></a>01179 
<a name="l01180"></a>01180         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 start gdc at 5mhz&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01181"></a>01181         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start GDC at 5MHz if set, 2.5MHz if clear. May be required for some games.&quot;</span>);
<a name="l01182"></a>01182 
<a name="l01183"></a>01183         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pc-98 allow scanline effect&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01184"></a>01184         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, PC-98 emulation will allow the DOS application to enable the &#39;scanline effect&#39;\n&quot;</span>
<a name="l01185"></a>01185                     <span class="stringliteral">&quot;in 200-line graphics modes upconverted to 400-line raster display. When enabled, odd\n&quot;</span>
<a name="l01186"></a>01186                     <span class="stringliteral">&quot;numbered scanlines are blanked instead of doubled&quot;</span>);
<a name="l01187"></a>01187 
<a name="l01188"></a>01188         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;pc-98 timer master frequency&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01189"></a>01189         Pint-&gt;SetMinMax(0,2457600);
<a name="l01190"></a>01190         Pint-&gt;Set_help(<span class="stringliteral">&quot;8254 timer clock frequency (NEC PC-98). Depending on the CPU frequency the clock frequency is one of two common values.\n&quot;</span>
<a name="l01191"></a>01191                    <span class="stringliteral">&quot;If your setting is neither of the below the closest appropriate value will be chosen.\n&quot;</span>
<a name="l01192"></a>01192                    <span class="stringliteral">&quot;This setting affects the master clock rate that DOS applications must divide down from to program the timer\n&quot;</span>
<a name="l01193"></a>01193                    <span class="stringliteral">&quot;at the correct rate, which affects timer interrupt, PC speaker, and the COM1 RS-232C serial port baud rate.\n&quot;</span>
<a name="l01194"></a>01194                                    <span class="stringliteral">&quot;8MHz is treated as an alias for 4MHz and 10MHz is treated as an alias for 5MHz.\n&quot;</span>
<a name="l01195"></a>01195                    <span class="stringliteral">&quot;    0: Use default (auto)\n&quot;</span>
<a name="l01196"></a>01196                    <span class="stringliteral">&quot;    4: 1.996MHz (as if 4MHz or multiple thereof CPU clock)\n&quot;</span>
<a name="l01197"></a>01197                    <span class="stringliteral">&quot;    5: 2.457MHz (as if 5MHz or multiple thereof CPU clock)&quot;</span>);
<a name="l01198"></a>01198 
<a name="l01199"></a>01199         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;pc-98 allow 4 display partition graphics&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l01200"></a>01200         Pint-&gt;SetMinMax(-1,1);
<a name="l01201"></a>01201         Pint-&gt;Set_help(<span class="stringliteral">&quot;According to NEC graphics controller documentation, graphics mode is supposed to support only\n&quot;</span>
<a name="l01202"></a>01202                    <span class="stringliteral">&quot;2 display partitions. Some games rely on hardware flaws that allowed 4 partitions.\n&quot;</span>
<a name="l01203"></a>01203                    <span class="stringliteral">&quot;   -1: Default (choose automatically)\n&quot;</span>
<a name="l01204"></a>01204                    <span class="stringliteral">&quot;    0: Disable\n&quot;</span>
<a name="l01205"></a>01205                    <span class="stringliteral">&quot;    1: Enable&quot;</span>);
<a name="l01206"></a>01206 
<a name="l01207"></a>01207         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vga bios size override&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l01208"></a>01208         Pint-&gt;SetMinMax(512,65536);
<a name="l01209"></a>01209         Pint-&gt;Set_help(<span class="stringliteral">&quot;VGA BIOS size override. Override the size of the VGA BIOS (normally 32KB in compatible or 12KB in non-compatible).&quot;</span>);
<a name="l01210"></a>01210 
<a name="l01211"></a>01211         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;video bios dont duplicate cga first half rom font&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01212"></a>01212         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, save 4KB of EGA/VGA ROM space by pointing to the copy in the ROM BIOS of the first 128 chars&quot;</span>);
<a name="l01213"></a>01213 
<a name="l01214"></a>01214         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;video bios always offer 14-pixel high rom font&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01215"></a>01215         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, video BIOS will always carry the 14-pixel ROM font. If clear, 14-pixel rom font will not be offered except for EGA/VGA emulation.&quot;</span>);
<a name="l01216"></a>01216 
<a name="l01217"></a>01217         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;video bios always offer 16-pixel high rom font&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01218"></a>01218         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, video BIOS will always carry the 16-pixel ROM font. If clear, 16-pixel rom font will not be offered except for VGA emulation.&quot;</span>);
<a name="l01219"></a>01219 
<a name="l01220"></a>01220         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;video bios enable cga second half rom font&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01221"></a>01221         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, and emulating CGA/PCjr/Tandy, automatically provide the second half of the 8x8 ROM font.\n&quot;</span>
<a name="l01222"></a>01222                         <span class="stringliteral">&quot;This setting is ignored for EGA/VGA emulation. If not set, you will need a utility like GRAFTABL.COM to load the second half of the ROM font for graphics.\n&quot;</span>
<a name="l01223"></a>01223                         <span class="stringliteral">&quot;NOTE: if you disable the 14 &amp; 16 pixel high font AND the second half when machine=cga, you will disable video bios completely.&quot;</span>);
<a name="l01224"></a>01224 
<a name="l01225"></a>01225         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;forcerate&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01226"></a>01226         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Force the VGA framerate to a specific value(ntsc, pal, or specific hz), no matter what&quot;</span>);
<a name="l01227"></a>01227 
<a name="l01228"></a>01228         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sierra ramdac&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01229"></a>01229         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Whether or not to emulate a Sierra or compatible RAMDAC at port 3C6h-3C9h.\n&quot;</span>
<a name="l01230"></a>01230                         <span class="stringliteral">&quot;Some DOS games expect to access port 3C6h to enable highcolor/truecolor SVGA modes on older chipsets.\n&quot;</span>
<a name="l01231"></a>01231                         <span class="stringliteral">&quot;Disable if you wish to emulate SVGA hardware that lacks a RAMDAC or (depending on the chipset) does\n&quot;</span>
<a name="l01232"></a>01232                         <span class="stringliteral">&quot;not emulate a RAMDAC that is accessible through port 3C6h. This option has no effect for non-VGA video hardware.&quot;</span>);
<a name="l01233"></a>01233 
<a name="l01234"></a>01234         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sierra ramdac lock 565&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01235"></a>01235         Pbool-&gt;Set_help(<span class="stringliteral">&quot;When emulating High Sierra highcolor RAMDAC, assume 5:6:5 at all times if set. Else,\n&quot;</span>
<a name="l01236"></a>01236                         <span class="stringliteral">&quot;bit 6 of the DAC command selects between 5:5:5 and 5:6:5. Set this option for demos or\n&quot;</span>
<a name="l01237"></a>01237                         <span class="stringliteral">&quot;games that got the command byte wrong (MFX Transgrassion 2) or any other demo that is\n&quot;</span>
<a name="l01238"></a>01238                         <span class="stringliteral">&quot;not rendering highcolor 16bpp correctly.&quot;</span>);
<a name="l01239"></a>01239 
<a name="l01240"></a>01240         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;page flip debug line&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01241"></a>01241         Pbool-&gt;Set_help(<span class="stringliteral">&quot;VGA debugging switch. If set, an inverse line will be drawn on the exact scanline that the CRTC display offset registers were written.\n&quot;</span>
<a name="l01242"></a>01242                         <span class="stringliteral">&quot;This can be used to help diagnose whether or not the DOS game is page flipping properly according to vertical retrace if the display on-screen is flickering.&quot;</span>);
<a name="l01243"></a>01243 
<a name="l01244"></a>01244         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vertical retrace poll debug line&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01245"></a>01245         Pbool-&gt;Set_help(<span class="stringliteral">&quot;VGA debugging switch. If set, an inverse green dotted line will be drawn on the exact scanline that the CRTC status port (0x3DA) was read.\n&quot;</span>
<a name="l01246"></a>01246                         <span class="stringliteral">&quot;This can be used to help diagnose whether the DOS game is propertly waiting for vertical retrace.&quot;</span>);
<a name="l01247"></a>01247 
<a name="l01248"></a>01248         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;cgasnow&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01249"></a>01249         Pbool-&gt;Set_help(<span class="stringliteral">&quot;When machine=cga, determines whether or not to emulate CGA snow in 80x25 text mode&quot;</span>);
<a name="l01250"></a>01250 
<a name="l01251"></a>01251         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;vga 3da undefined bits&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l01252"></a>01252         Phex-&gt;Set_help(<span class="stringliteral">&quot;VGA status port 3BA/3DAh only defines bits 0 and 3. This setting allows you to assign a bit pattern to the undefined bits.\n&quot;</span>
<a name="l01253"></a>01253                    <span class="stringliteral">&quot;The purpose of this hack is to deal with demos that read and handle port 3DAh in ways that might crash if all are zero.\n&quot;</span>
<a name="l01254"></a>01254                    <span class="stringliteral">&quot;By default, this value is zero.&quot;</span>);
<a name="l01255"></a>01255 
<a name="l01256"></a>01256         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;unmask timer on int 10 setmode&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l01257"></a>01257         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 10h will unmask IRQ 0 (timer) when setting video modes.&quot;</span>);
<a name="l01258"></a>01258 
<a name="l01259"></a>01259         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;unmask keyboard on int 16 read&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l01260"></a>01260         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 16h will unmask IRQ 1 (keyboard) when asked to read keyboard input.&quot;</span>);
<a name="l01261"></a>01261 
<a name="l01262"></a>01262         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int16 keyboard polling undocumented cf behavior&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l01263"></a>01263         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 16h function AH=01h will also set/clear the carry flag depending on whether input was available.\n&quot;</span>
<a name="l01264"></a>01264                     <span class="stringliteral">&quot;There are some old DOS games and demos that rely on this behavior to sense keyboard input, and this behavior\n&quot;</span>
<a name="l01265"></a>01265                     <span class="stringliteral">&quot;has been verified to occur on some old (early 90s) BIOSes.&quot;</span>);
<a name="l01266"></a>01266 
<a name="l01267"></a>01267         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow port 92 reset&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l01268"></a>01268         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), allow the application to reset the CPU through port 92h&quot;</span>);
<a name="l01269"></a>01269 
<a name="l01270"></a>01270         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable port 92&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01271"></a>01271         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate port 92h (PS/2 system control port A). If you want to emulate a system that predates the PS/2, set to 0.&quot;</span>);
<a name="l01272"></a>01272 
<a name="l01273"></a>01273         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable 1st dma controller&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01274"></a>01274         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate 1st (AT) DMA controller (default). Set to 0 if you wish to emulate a system that lacks DMA (PCjr and some Tandy systems)&quot;</span>);
<a name="l01275"></a>01275 
<a name="l01276"></a>01276         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable 2nd dma controller&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01277"></a>01277         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate 2nd (AT) DMA controller (default). Set to 0 if you wish to emulate a PC/XT system without 16-bit DMA.\n&quot;</span>
<a name="l01278"></a>01278                         <span class="stringliteral">&quot;Note: mainline DOSBox automatically disables 16-bit DMA when machine=cga or machine=hercules, while DOSBox-X does not.&quot;</span>);
<a name="l01279"></a>01279 
<a name="l01280"></a>01280         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow dma address decrement&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01281"></a>01281         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow increment &amp; decrement modes as specified in the 8237 datasheet.\n&quot;</span>
<a name="l01282"></a>01282                         <span class="stringliteral">&quot;If clear, always increment the address (as if to emulate clone 8237 implementations that skipped the inc/dec bit).&quot;</span>);
<a name="l01283"></a>01283 
<a name="l01284"></a>01284         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;enable 128k capable 16-bit dma&quot;</span>, Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01285"></a>01285         Pstring-&gt;Set_values(truefalseautoopt);
<a name="l01286"></a>01286     Pstring-&gt;Set_help(<span class="stringliteral">&quot;If true, DMA controller emulation models ISA hardware that permits 16-bit DMA to span 128KB.\n&quot;</span>
<a name="l01287"></a>01287                     <span class="stringliteral">&quot;If false, DMA controller emulation models PCI hardware that limits 16-bit DMA to 64KB boundaries.\n&quot;</span>
<a name="l01288"></a>01288                     <span class="stringliteral">&quot;If auto, the choice is made according to other factors in hardware emulation&quot;</span>);
<a name="l01289"></a>01289 
<a name="l01290"></a>01290         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable dma extra page registers&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01291"></a>01291         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate the extra page registers (I/O ports 0x80, 0x84-0x86, 0x88, 0x8C-0x8E), like actual hardware.\n&quot;</span>
<a name="l01292"></a>01292                         <span class="stringliteral">&quot;Note that mainline DOSBox behavior is to NOT emulate these registers.&quot;</span>);
<a name="l01293"></a>01293 
<a name="l01294"></a>01294         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dma page registers write-only&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01295"></a>01295         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Normally (on AT hardware) the DMA page registers are read/write. Set this option if you want to emulate PC/XT hardware where the page registers are write-only.&quot;</span>);
<a name="l01296"></a>01296 
<a name="l01297"></a>01297         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable slave pic&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01298"></a>01298         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable slave PIC (IRQ 8-15). Set this to 0 if you want to emulate a PC/XT type arrangement with IRQ 0-7 and no IRQ 2 cascade.&quot;</span>);
<a name="l01299"></a>01299 
<a name="l01300"></a>01300         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable pc nmi mask&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01301"></a>01301         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable PC/XT style NMI mask register (0xA0). Note that this option conflicts with the secondary PIC and will be ignored if the slave PIC is enabled.&quot;</span>);
<a name="l01302"></a>01302 
<a name="l01303"></a>01303         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;rom bios 8x8 CGA font&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01304"></a>01304         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, or mainline compatible bios mapping, a legacy 8x8 CGA font (first 128 characters) is stored at 0xF000:0xFA6E. DOS programs that do not use INT 10h to locate fonts might require that font to be located there.&quot;</span>);
<a name="l01305"></a>01305 
<a name="l01306"></a>01306         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;rom bios video parameter table&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01307"></a>01307         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, or mainline compatible bios mapping, DOSBox will emulate the video parameter table and assign that to INT 1Dh. If clear, table will not be provided.&quot;</span>);
<a name="l01308"></a>01308 
<a name="l01309"></a>01309         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow more than 640kb base memory&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01310"></a>01310         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, and space is available, allow conventional memory to extend past 640KB.\n&quot;</span>
<a name="l01311"></a>01311                         <span class="stringliteral">&quot;For example, if machine=cga, conventional memory can extend out to 0xB800 and provide up to 736KB of RAM.\n&quot;</span>
<a name="l01312"></a>01312                         <span class="stringliteral">&quot;This allows you to emulate PC/XT style memory extensions.&quot;</span>);
<a name="l01313"></a>01313 
<a name="l01314"></a>01314         <span class="comment">/* should be set to zero unless for very specific demos:</span>
<a name="l01315"></a>01315 <span class="comment">         *  - &quot;Melvindale&quot; by MFX (1996): Set this to 2, the nightmarish visual rendering code appears to draw 2 scanlines</span>
<a name="l01316"></a>01316 <span class="comment">         *    upward from the VESA linear framebuffer base we return, causing DOSBox to emit warnings about illegal read/writes</span>
<a name="l01317"></a>01317 <span class="comment">         *    from 0xBFFFF000-0xBFFFFFFF (just before the base of the framebuffer at 0xC0000000). It also has the effect of</span>
<a name="l01318"></a>01318 <span class="comment">         *    properly centering the picture on the screen. I suppose it&#39;s a miracle the demo didn&#39;t crash people&#39;s computers</span>
<a name="l01319"></a>01319 <span class="comment">         *    writing to undefined areas like that. */</span>
<a name="l01320"></a>01320         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vesa lfb base scanline adjust&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l01321"></a>01321         Pint-&gt;Set_help(<span class="stringliteral">&quot;If non-zero, the VESA BIOS will report the linear framebuffer offset by this many scanlines.\n&quot;</span>
<a name="l01322"></a>01322                         <span class="stringliteral">&quot;This does not affect the linear framebuffer&#39;s location. It only affects the linear framebuffer\n&quot;</span>
<a name="l01323"></a>01323                         <span class="stringliteral">&quot;location reported by the VESA BIOS. Set to nonzero for DOS games with sloppy VESA graphics pointer management.\n&quot;</span>
<a name="l01324"></a>01324                         <span class="stringliteral">&quot;    MFX \&quot;Melvindale\&quot; (1996): Set this option to 2 to center the picture properly.&quot;</span>);
<a name="l01325"></a>01325 
<a name="l01326"></a>01326         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow hpel effects&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01327"></a>01327         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow the DOS demo or program to change the horizontal pel (panning) register per scanline.\n&quot;</span>
<a name="l01328"></a>01328                         <span class="stringliteral">&quot;Some early DOS demos use this to create waving or sinus effects on the picture. Not very many VGA\n&quot;</span>
<a name="l01329"></a>01329                         <span class="stringliteral">&quot;chipsets allow this, so far, only ATI chipsets are known to support this effect. Disabled by default.&quot;</span>);
<a name="l01330"></a>01330 
<a name="l01331"></a>01331         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow hretrace effects&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01332"></a>01332         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow the DOS demo or program to make the picture wavy by playing with the &#39;start horizontal&quot;</span>
<a name="l01333"></a>01333                         <span class="stringliteral">&quot;retrace&#39; register of the CRTC during the active picture. Some early DOS demos (Copper by Surprise!&quot;</span>
<a name="l01334"></a>01334                         <span class="stringliteral">&quot;productions) need this option set for some demo effects to work. Disabled by default.&quot;</span>);
<a name="l01335"></a>01335 
<a name="l01336"></a>01336         Pdouble = secprop-&gt;Add_double(<span class="stringliteral">&quot;hretrace effect weight&quot;</span>,Property::Changeable::Always,4.0);
<a name="l01337"></a>01337         Pdouble-&gt;Set_help(<span class="stringliteral">&quot;If emulating hretrace effects, this parameter adds &#39;weight&#39; to the offset to smooth it out.\n&quot;</span>
<a name="l01338"></a>01338                         <span class="stringliteral">&quot;the larger the number, the more averaging is applied. This is intended to emulate the inertia\n&quot;</span>
<a name="l01339"></a>01339                         <span class="stringliteral">&quot;of the electron beam in a CRT monitor&quot;</span>);
<a name="l01340"></a>01340 
<a name="l01341"></a>01341         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vesa modelist cap&quot;</span>,Property::Changeable::Always,0);
<a name="l01342"></a>01342         Pint-&gt;Set_help(<span class="stringliteral">&quot;IF nonzero, the VESA modelist is capped so that it contains no more than the specified number of video modes.\n&quot;</span>
<a name="l01343"></a>01343                         <span class="stringliteral">&quot;Set this option to a value between 8 to 32 if the DOS application has problems with long modelists or a fixed\n&quot;</span>
<a name="l01344"></a>01344                         <span class="stringliteral">&quot;buffer for querying modes. Such programs may crash if given the entire modelist supported by DOSBox-X.\n&quot;</span>
<a name="l01345"></a>01345                         <span class="stringliteral">&quot;  Warcraft II by Blizzard ................ Set to a value between 8 and 16. This game has a fixed buffer that it\n&quot;</span>
<a name="l01346"></a>01346                         <span class="stringliteral">&quot;                                           reads the modelist into. DOSBox-X&#39;s normal modelist is too long and\n&quot;</span>
<a name="l01347"></a>01347                         <span class="stringliteral">&quot;                                           the game will overrun the buffer and crash without this setting.&quot;</span>);
<a name="l01348"></a>01348 
<a name="l01349"></a>01349         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vesa modelist width limit&quot;</span>,Property::Changeable::Always,0);
<a name="l01350"></a>01350         Pint-&gt;Set_help(<span class="stringliteral">&quot;IF nonzero, VESA modes with horizontal resolution higher than the specified pixel count will not be listed.\n&quot;</span>
<a name="l01351"></a>01351                         <span class="stringliteral">&quot;This is another way the modelist can be capped for DOS applications that have trouble with long modelists.&quot;</span>);
<a name="l01352"></a>01352 
<a name="l01353"></a>01353         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;vesa modelist height limit&quot;</span>,Property::Changeable::Always,0);
<a name="l01354"></a>01354         Pint-&gt;Set_help(<span class="stringliteral">&quot;IF nonzero, VESA modes with vertical resolution higher than the specified pixel count will not be listed.\n&quot;</span>
<a name="l01355"></a>01355                         <span class="stringliteral">&quot;This is another way the modelist can be capped for DOS applications that have trouble with long modelists.&quot;</span>);
<a name="l01356"></a>01356 
<a name="l01357"></a>01357         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vesa vbe 1.2 modes are 32bpp&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01358"></a>01358         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, truecolor (16M color) VESA BIOS modes in the 0x100-0x11F range are 32bpp. If clear, they are 24bpp.\n&quot;</span>
<a name="l01359"></a>01359                         <span class="stringliteral">&quot;Some DOS games and demos assume one bit depth or the other and do not enumerate VESA BIOS modes, which is why this\n&quot;</span>
<a name="l01360"></a>01360                         <span class="stringliteral">&quot;option exists.&quot;</span>);
<a name="l01361"></a>01361 
<a name="l01362"></a>01362         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow low resolution vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01363"></a>01363         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, allow low resolution VESA modes (320x200x16/24/32bpp and so on). You could set this to false to simulate\n&quot;</span>
<a name="l01364"></a>01364                         <span class="stringliteral">&quot;SVGA hardware with a BIOS that does not support the lowres modes for testing purposes.&quot;</span>);
<a name="l01365"></a>01365 
<a name="l01366"></a>01366         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 32bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01367"></a>01367         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 32bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01368"></a>01368 
<a name="l01369"></a>01369         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 24bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01370"></a>01370         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 24bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01371"></a>01371 
<a name="l01372"></a>01372         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 16bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01373"></a>01373         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 16bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01374"></a>01374 
<a name="l01375"></a>01375         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 15bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01376"></a>01376         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 15bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01377"></a>01377 
<a name="l01378"></a>01378         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 8bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01379"></a>01379         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 8bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01380"></a>01380 
<a name="l01381"></a>01381         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow 4bpp vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01382"></a>01382         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with 4bpp VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01383"></a>01383 
<a name="l01384"></a>01384         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow tty vesa modes&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01385"></a>01385         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game or demo has problems with text VESA modes, set to &#39;false&#39;&quot;</span>);
<a name="l01386"></a>01386 
<a name="l01387"></a>01387         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;double-buffered line compare&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01388"></a>01388         Pbool-&gt;Set_help(<span class="stringliteral">&quot;This setting affects the VGA Line Compare register. Set to false (default value) to emulate most VGA behavior\n&quot;</span>
<a name="l01389"></a>01389                         <span class="stringliteral">&quot;Set to true for the value to latch once at the start of the frame.&quot;</span>);
<a name="l01390"></a>01390 
<a name="l01391"></a>01391         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore vblank wraparound&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01392"></a>01392         Pbool-&gt;Set_help(<span class="stringliteral">&quot;DOSBox-X can handle active display properly if games or demos reprogram vertical blanking to end in the active picture area.\n&quot;</span>
<a name="l01393"></a>01393                         <span class="stringliteral">&quot;If the wraparound handling prevents the game from displaying properly, set this to false. Out of bounds vblank values will be ignored.\n&quot;</span>);
<a name="l01394"></a>01394 
<a name="l01395"></a>01395         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable vga resize delay&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01396"></a>01396         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS game you are running relies on certain VGA raster tricks that affect active display area, enable this option.\n&quot;</span>
<a name="l01397"></a>01397                         <span class="stringliteral">&quot;This adds a delay between VGA mode changes and window updates. It also means that if you are capturing a demo or game,\n&quot;</span>
<a name="l01398"></a>01398                         <span class="stringliteral">&quot;that your capture will also show a few garbled frames at any point mode changes occur, which is why this option is disabled\n&quot;</span>
<a name="l01399"></a>01399                         <span class="stringliteral">&quot;by default. If you intend to run certain DOS games and demos like DoWhackaDo, enable this option.&quot;</span>);
<a name="l01400"></a>01400 
<a name="l01401"></a>01401         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;resize only on vga active display width increase&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01402"></a>01402         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, changes to the Display End register of the CRTC do not trigger DOSBox to resize it&#39;s window\n&quot;</span>
<a name="l01403"></a>01403                         <span class="stringliteral">&quot;IF the value written is less than the current value. Some demos like DoWhackaDo need this option set\n&quot;</span>
<a name="l01404"></a>01404                         <span class="stringliteral">&quot;because of the way it&#39;s raster effects work. If the DOSBox window rapidly changes size during a demo\n&quot;</span>
<a name="l01405"></a>01405                         <span class="stringliteral">&quot;try setting this option. Else, leave it turned off. Changes to other VGA CRTC registers will trigger\n&quot;</span>
<a name="l01406"></a>01406                         <span class="stringliteral">&quot;a DOSBox mode change as normal regardless of this setting.&quot;</span>);
<a name="l01407"></a>01407 
<a name="l01408"></a>01408         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable pci bus&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l01409"></a>01409         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable PCI bus emulation&quot;</span>);
<a name="l01410"></a>01410 
<a name="l01411"></a>01411         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;render&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l01412"></a>01412         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;frameskip&quot;</span>,Property::Changeable::Always,0);
<a name="l01413"></a>01413         Pint-&gt;SetMinMax(0,10);
<a name="l01414"></a>01414         Pint-&gt;Set_help(<span class="stringliteral">&quot;How many frames DOSBox skips before drawing one.&quot;</span>);
<a name="l01415"></a>01415 
<a name="l01416"></a>01416         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;aspect&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01417"></a>01417         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Do aspect correction, if your output method doesn&#39;t support scaling this can slow things down!.&quot;</span>);
<a name="l01418"></a>01418 
<a name="l01419"></a>01419         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;char9&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01420"></a>01420         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow 9-pixel wide text mode fonts.&quot;</span>);
<a name="l01421"></a>01421 
<a name="l01422"></a>01422         <span class="comment">/* NTS: In the original code borrowed from yhkong, this was named &quot;multiscan&quot;. All it really does is disable</span>
<a name="l01423"></a>01423 <span class="comment">         *      the doublescan down-rezzing DOSBox normally does with 320x240 graphics so that you get the full rendition of what a VGA output would emit. */</span>
<a name="l01424"></a>01424         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;doublescan&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01425"></a>01425         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, doublescanned output emits two scanlines for each source line, in the\n&quot;</span>
<a name="l01426"></a>01426                         <span class="stringliteral">&quot;same manner as the actual VGA output (320x200 is rendered as 640x400 for example).\n&quot;</span>
<a name="l01427"></a>01427                         <span class="stringliteral">&quot;If clear, doublescanned output is rendered at the native source resolution (320x200 as 320x200).\n&quot;</span>
<a name="l01428"></a>01428                         <span class="stringliteral">&quot;This affects the raster PRIOR to the software or hardware scalers. Choose wisely.\n&quot;</span>);
<a name="l01429"></a>01429 
<a name="l01430"></a>01430         Pmulti = secprop-&gt;Add_multi(<span class="stringliteral">&quot;scaler&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot; &quot;</span>);
<a name="l01431"></a>01431         Pmulti-&gt;SetValue(<span class="stringliteral">&quot;normal2x&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l01432"></a>01432         Pmulti-&gt;Set_help(<span class="stringliteral">&quot;Scaler used to enlarge/enhance low resolution modes. If &#39;forced&#39; is appended,\n&quot;</span>
<a name="l01433"></a>01433                          <span class="stringliteral">&quot;then the scaler will be used even if the result might not be desired.&quot;</span>);
<a name="l01434"></a>01434         Pstring = Pmulti-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;normal2x&quot;</span>);
<a name="l01435"></a>01435         Pstring-&gt;Set_values(scalers);
<a name="l01436"></a>01436 
<a name="l01437"></a>01437         Pstring = Pmulti-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;force&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01438"></a>01438         Pstring-&gt;Set_values(force);
<a name="l01439"></a>01439 
<a name="l01440"></a>01440         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;autofit&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01441"></a>01441         Pbool-&gt;Set_help(
<a name="l01442"></a>01442                 <span class="stringliteral">&quot;Best fits image to window\n&quot;</span>
<a name="l01443"></a>01443                 <span class="stringliteral">&quot;- Intended for output=direct3d, fullresolution=original, aspect=true&quot;</span>);
<a name="l01444"></a>01444 
<a name="l01445"></a>01445 
<a name="l01446"></a>01446         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;vsync&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l01447"></a>01447 
<a name="l01448"></a>01448         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;vsyncmode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l01449"></a>01449         Pstring-&gt;Set_values(vsyncmode);
<a name="l01450"></a>01450         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Synchronize vsync timing to the host display. Requires calibration within dosbox.&quot;</span>);
<a name="l01451"></a>01451         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;vsyncrate&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;75&quot;</span>);
<a name="l01452"></a>01452         Pstring-&gt;Set_values(vsyncrate);
<a name="l01453"></a>01453         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Vsync rate used if vsync is enabled. Ignored if vsyncmode is set to host (win32).&quot;</span>);
<a name="l01454"></a>01454 
<a name="l01455"></a>01455         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;cpu&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l01456"></a>01456         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;core&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01457"></a>01457         Pstring-&gt;Set_values(cores);
<a name="l01458"></a>01458         Pstring-&gt;Set_help(<span class="stringliteral">&quot;CPU Core used in emulation. auto will switch to dynamic if available and appropriate.\n&quot;</span>
<a name="l01459"></a>01459                         <span class="stringliteral">&quot;WARNING: Do not use dynamic or auto setting core with Windows 95 or other preemptive\n&quot;</span>
<a name="l01460"></a>01460                         <span class="stringliteral">&quot;multitasking OSes with protected mode paging, you should use the normal core instead.&quot;</span>);
<a name="l01461"></a>01461 
<a name="l01462"></a>01462         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;fpu&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01463"></a>01463         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable FPU emulation&quot;</span>);
<a name="l01464"></a>01464 
<a name="l01465"></a>01465         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;segment limits&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01466"></a>01466         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enforce segment limits&quot;</span>);
<a name="l01467"></a>01467 
<a name="l01468"></a>01468         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;double fault&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01469"></a>01469         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate double fault exception&quot;</span>);
<a name="l01470"></a>01470 
<a name="l01471"></a>01471         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;reset on triple fault&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01472"></a>01472         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Reset CPU on triple fault condition (failure to handle double fault)&quot;</span>);
<a name="l01473"></a>01473 
<a name="l01474"></a>01474         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;always report double fault&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01475"></a>01475         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Always report (to log file) double faults if set. Else, a double fault is reported only once. Set this option for debugging purposes.&quot;</span>);
<a name="l01476"></a>01476 
<a name="l01477"></a>01477         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;always report triple fault&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01478"></a>01478         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Always report (to log file) triple faults if set. Else, a triple fault is reported only once. Set this option for debugging purposes.&quot;</span>);
<a name="l01479"></a>01479 
<a name="l01480"></a>01480         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable msr&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01481"></a>01481         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow RDMSR/WRMSR instructions. This option is only meaningful when cputype=pentium.\n&quot;</span>
<a name="l01482"></a>01482                         <span class="stringliteral">&quot;WARNING: Leaving this option enabled while installing Windows 95/98/ME can cause crashes.&quot;</span>);
<a name="l01483"></a>01483 
<a name="l01484"></a>01484         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable cmpxchg8b&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01485"></a>01485         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable Pentium CMPXCHG8B instruction. Enable this explicitly if using software that uses this instruction.\n&quot;</span>
<a name="l01486"></a>01486                         <span class="stringliteral">&quot;You must enable this option to run Windows ME because portions of the kernel rely on this instruction.&quot;</span>);
<a name="l01487"></a>01487 
<a name="l01488"></a>01488         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore undefined msr&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01489"></a>01489         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Ignore RDMSR/WRMSR on undefined registers. Normally the CPU will fire an Invalid Opcode exception in that case.\n&quot;</span>
<a name="l01490"></a>01490                         <span class="stringliteral">&quot;This option is off by default, enable if using software or drivers that assumes the presence of\n&quot;</span>
<a name="l01491"></a>01491                         <span class="stringliteral">&quot;certain MSR registers without checking. If you are using certain versions of the 3Dfx glide drivers for MS-DOS\n&quot;</span>
<a name="l01492"></a>01492                         <span class="stringliteral">&quot;you will need to set this to TRUE as 3Dfx appears to have coded GLIDE2.OVL to assume the presence\n&quot;</span>
<a name="l01493"></a>01493                         <span class="stringliteral">&quot;of Pentium Pro/Pentium II MTRR registers.\n&quot;</span>
<a name="l01494"></a>01494                         <span class="stringliteral">&quot;WARNING: Leaving this option enabled while installing Windows 95/98/ME can cause crashes.&quot;</span>);
<a name="l01495"></a>01495 
<a name="l01496"></a>01496         <span class="comment">/* NTS: This setting is honored by all cpu cores except dynamic core */</span>
<a name="l01497"></a>01497         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;interruptible rep string op&quot;</span>,Property::Changeable::Always,-1);
<a name="l01498"></a>01498         Pint-&gt;SetMinMax(-1,65536);
<a name="l01499"></a>01499         Pint-&gt;Set_help(<span class="stringliteral">&quot;if nonzero, REP string instructions (LODS/MOVS/STOS/INS/OUTS) are interruptible (by interrupts or other events).\n&quot;</span>
<a name="l01500"></a>01500                         <span class="stringliteral">&quot;if zero, REP string instructions are carried out in full before processing events and interrupts.\n&quot;</span>
<a name="l01501"></a>01501                         <span class="stringliteral">&quot;Set to -1 for a reasonable default setting based on cpu type and other configuration.\n&quot;</span>
<a name="l01502"></a>01502                         <span class="stringliteral">&quot;A setting of 0 can improve emulation speed at the expense of emulation accuracy.\n&quot;</span>
<a name="l01503"></a>01503                         <span class="stringliteral">&quot;A nonzero setting (1-8) may be needed for DOS games and demos that use the IRQ 0 interrupt to play digitized samples\n&quot;</span>
<a name="l01504"></a>01504                         <span class="stringliteral">&quot;while doing VGA palette animation at the same time (use case of REP OUTS), where the non-interruptible version\n&quot;</span>
<a name="l01505"></a>01505                         <span class="stringliteral">&quot;would cause an audible drop in audio pitch.&quot;</span>);
<a name="l01506"></a>01506 
<a name="l01507"></a>01507         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dynamic core cache block size&quot;</span>,Property::Changeable::Always,32);
<a name="l01508"></a>01508         Pint-&gt;SetMinMax(1,65536);
<a name="l01509"></a>01509         Pint-&gt;Set_help(<span class="stringliteral">&quot;dynamic core cache block size. default value is 32. change this value carefully.\n&quot;</span>
<a name="l01510"></a>01510                         <span class="stringliteral">&quot;according to forum discussion, setting this to 1 can aid debugging, however doing so\n&quot;</span>
<a name="l01511"></a>01511                         <span class="stringliteral">&quot;also causes problems with 32-bit protected mode DOS games and reduces the performance\n&quot;</span>
<a name="l01512"></a>01512                         <span class="stringliteral">&quot;of the dynamic core.\n&quot;</span>);
<a name="l01513"></a>01513 
<a name="l01514"></a>01514         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;cputype&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01515"></a>01515         Pstring-&gt;Set_values(cputype_values);
<a name="l01516"></a>01516         Pstring-&gt;Set_help(<span class="stringliteral">&quot;CPU Type used in emulation. auto emulates a 486 which tolerates Pentium instructions.&quot;</span>);
<a name="l01517"></a>01517 
<a name="l01518"></a>01518         Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;cycles&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot; &quot;</span>);
<a name="l01519"></a>01519         Pmulti_remain-&gt;Set_help(
<a name="l01520"></a>01520                 <span class="stringliteral">&quot;Amount of instructions DOSBox tries to emulate each millisecond.\n&quot;</span>
<a name="l01521"></a>01521                 <span class="stringliteral">&quot;Setting this value too high results in sound dropouts and lags.\n&quot;</span>
<a name="l01522"></a>01522                 <span class="stringliteral">&quot;Cycles can be set in 3 ways:\n&quot;</span>
<a name="l01523"></a>01523                 <span class="stringliteral">&quot;  &#39;auto&#39;          tries to guess what a game needs.\n&quot;</span>
<a name="l01524"></a>01524                 <span class="stringliteral">&quot;                  It usually works, but can fail for certain games.\n&quot;</span>
<a name="l01525"></a>01525                 <span class="stringliteral">&quot;  &#39;fixed #number&#39; will set a fixed amount of cycles. This is what you usually\n&quot;</span>
<a name="l01526"></a>01526                 <span class="stringliteral">&quot;                  need if &#39;auto&#39; fails (Example: fixed 4000).\n&quot;</span>
<a name="l01527"></a>01527                 <span class="stringliteral">&quot;  &#39;max&#39;           will allocate as much cycles as your computer is able to\n&quot;</span>
<a name="l01528"></a>01528                 <span class="stringliteral">&quot;                  handle.&quot;</span>);
<a name="l01529"></a>01529 
<a name="l01530"></a>01530         Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01531"></a>01531         Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;auto&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l01532"></a>01532         Pstring-&gt;Set_values(cyclest);
<a name="l01533"></a>01533 
<a name="l01534"></a>01534         Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::Always,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01535"></a>01535         
<a name="l01536"></a>01536         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cycleup&quot;</span>,Property::Changeable::Always,10);
<a name="l01537"></a>01537         Pint-&gt;SetMinMax(1,1000000);
<a name="l01538"></a>01538         Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of cycles to decrease/increase with keycombos.(CTRL-F11/CTRL-F12)&quot;</span>);
<a name="l01539"></a>01539 
<a name="l01540"></a>01540         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cycledown&quot;</span>,Property::Changeable::Always,20);
<a name="l01541"></a>01541         Pint-&gt;SetMinMax(1,1000000);
<a name="l01542"></a>01542         Pint-&gt;Set_help(<span class="stringliteral">&quot;Setting it lower than 100 will be a percentage.&quot;</span>);
<a name="l01543"></a>01543 
<a name="l01544"></a>01544         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;use dynamic core with paging on&quot;</span>,Property::Changeable::Always,<span class="keyword">false</span>);
<a name="l01545"></a>01545         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Dynamic core is NOT compatible with the way page faults in the guest are handled in DosBox-X.\n&quot;</span>
<a name="l01546"></a>01546                         <span class="stringliteral">&quot;Windows 9x may crash with paging on if dynamic core is enabled. Enable at your own risk.\n&quot;</span>);
<a name="l01547"></a>01547                         
<a name="l01548"></a>01548         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore opcode 63&quot;</span>,Property::Changeable::Always,<span class="keyword">true</span>);
<a name="l01549"></a>01549         Pbool-&gt;Set_help(<span class="stringliteral">&quot;When debugging, do not report illegal opcode 0x63.\n&quot;</span>
<a name="l01550"></a>01550                         <span class="stringliteral">&quot;Enable this option to ignore spurious errors while debugging from within Windows 3.1/9x/ME&quot;</span>);
<a name="l01551"></a>01551 
<a name="l01552"></a>01552         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01553"></a>01553         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate Advanced Power Management BIOS calls&quot;</span>);
<a name="l01554"></a>01554 
<a name="l01555"></a>01555         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios pnp&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01556"></a>01556         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If emulating ISA PnP BIOS, announce APM BIOS in PnP enumeration.\n&quot;</span>
<a name="l01557"></a>01557                         <span class="stringliteral">&quot;Warning: this can cause Windows 95 OSR2 and later to enumerate the APM BIOS twice and cause problems.&quot;</span>);
<a name="l01558"></a>01558 
<a name="l01559"></a>01559         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;apmbios version&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01560"></a>01560         Pstring-&gt;Set_values(apmbiosversions);
<a name="l01561"></a>01561         Pstring-&gt;Set_help(<span class="stringliteral">&quot;What version of the APM BIOS specification to emulate.\n&quot;</span>
<a name="l01562"></a>01562                         <span class="stringliteral">&quot;You will need at least APM BIOS v1.1 for emulation to work with Windows 95/98/ME&quot;</span>);
<a name="l01563"></a>01563 
<a name="l01564"></a>01564         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios allow realmode&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01565"></a>01565         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow guest OS to connect from real mode.&quot;</span>);
<a name="l01566"></a>01566 
<a name="l01567"></a>01567         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios allow 16-bit protected mode&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01568"></a>01568         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow guest OS to connect from 16-bit protected mode.&quot;</span>);
<a name="l01569"></a>01569 
<a name="l01570"></a>01570         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;apmbios allow 32-bit protected mode&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01571"></a>01571         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow guest OS to connect from 32-bit protected mode.\n&quot;</span>
<a name="l01572"></a>01572                         <span class="stringliteral">&quot;If you want power management in Windows 95/98/ME (beyond using the APM to shutdown the computer) you MUST enable this option.\n&quot;</span>
<a name="l01573"></a>01573                         <span class="stringliteral">&quot;Windows 95/98/ME does not support the 16-bit real and protected mode APM BIOS entry points.\n&quot;</span>
<a name="l01574"></a>01574                         <span class="stringliteral">&quot;Please note at this time that 32-bit APM is unstable under Windows ME&quot;</span>);
<a name="l01575"></a>01575 
<a name="l01576"></a>01576         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;integration device&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01577"></a>01577         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable DOSBox integration I/O device. This can be used by the guest OS to match mouse pointer position, for example. EXPERIMENTAL!&quot;</span>);
<a name="l01578"></a>01578 
<a name="l01579"></a>01579         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;integration device pnp&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01580"></a>01580         Pbool-&gt;Set_help(<span class="stringliteral">&quot;List DOSBox integration I/O device as part of ISA PnP enumeration. This has no purpose yet.&quot;</span>);
<a name="l01581"></a>01581 
<a name="l01582"></a>01582         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;isapnpbios&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01583"></a>01583         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate ISA Plug &amp; Play BIOS. Enable if using DOSBox to run a PnP aware DOS program or if booting Windows 9x.\n&quot;</span>
<a name="l01584"></a>01584                         <span class="stringliteral">&quot;Do not disable if Windows 9x is configured around PnP devices, you will likely confuse it.&quot;</span>);
<a name="l01585"></a>01585 
<a name="l01586"></a>01586         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;realbig16&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01587"></a>01587         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow the B (big) bit in real mode. If set, allow the DOS program to set the B bit,\n&quot;</span>
<a name="l01588"></a>01588                 <span class="stringliteral">&quot;then jump to realmode with B still set (aka Huge Unreal mode). Needed for Project Angel.&quot;</span>);
<a name="l01589"></a>01589 
<a name="l01590"></a>01590         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;keyboard&quot;</span>,&amp;Null_Init);
<a name="l01591"></a>01591         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;aux&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l01592"></a>01592         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable emulation of the 8042 auxiliary port. PS/2 mouse emulation requires this to be enabled.\n&quot;</span>
<a name="l01593"></a>01593                         <span class="stringliteral">&quot;You should enable this if you will be running Windows ME or any other OS that does not use the BIOS to receive mouse events.&quot;</span>);
<a name="l01594"></a>01594 
<a name="l01595"></a>01595         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;allow output port reset&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l01596"></a>01596         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), allow the application to reset the CPU through the keyboard controller.\n&quot;</span>
<a name="l01597"></a>01597                         <span class="stringliteral">&quot;This option is required to allow Windows ME to reboot properly, whereas Windows 9x and earlier\n&quot;</span>
<a name="l01598"></a>01598                         <span class="stringliteral">&quot;will reboot without this option using INT 19h&quot;</span>);
<a name="l01599"></a>01599 
<a name="l01600"></a>01600         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;auxdevice&quot;</span>,Property::Changeable::OnlyAtStart,<span class="stringliteral">&quot;intellimouse&quot;</span>);
<a name="l01601"></a>01601         Pstring-&gt;Set_values(auxdevices);
<a name="l01602"></a>01602         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of PS/2 mouse attached to the AUX port&quot;</span>);
<a name="l01603"></a>01603 
<a name="l01604"></a>01604         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;pci&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>); <span class="comment">//PCI bus</span>
<a name="l01605"></a>01605 
<a name="l01606"></a>01606         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;voodoo&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01607"></a>01607         Pstring-&gt;Set_values(voodoo_settings);
<a name="l01608"></a>01608         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable VOODOO support.&quot;</span>);
<a name="l01609"></a>01609 
<a name="l01610"></a>01610         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;mixer&quot;</span>,&amp;Null_Init);
<a name="l01611"></a>01611         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;nosound&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l01612"></a>01612         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable silent mode, sound is still emulated though.&quot;</span>);
<a name="l01613"></a>01613 
<a name="l01614"></a>01614         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sample accurate&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l01615"></a>01615         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable sample accurate mixing, at the expense of some emulation performance. Enable this option for DOS games and demos that\n&quot;</span>
<a name="l01616"></a>01616                         <span class="stringliteral">&quot;require such accuracy for correct Tandy/OPL output including digitized speech. This option can also help eliminate minor\n&quot;</span>
<a name="l01617"></a>01617                         <span class="stringliteral">&quot;errors in Gravis Ultrasound emulation that result in random echo/attenuation effects.&quot;</span>);
<a name="l01618"></a>01618 
<a name="l01619"></a>01619         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;swapstereo&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>); 
<a name="l01620"></a>01620         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Swaps the left and right stereo channels.&quot;</span>); 
<a name="l01621"></a>01621 
<a name="l01622"></a>01622         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;rate&quot;</span>,Property::Changeable::OnlyAtStart,44100);
<a name="l01623"></a>01623         Pint-&gt;Set_values(rates);
<a name="l01624"></a>01624         Pint-&gt;Set_help(<span class="stringliteral">&quot;Mixer sample rate, setting any device&#39;s rate higher than this will probably lower their sound quality.&quot;</span>);
<a name="l01625"></a>01625 
<a name="l01626"></a>01626         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;blocksize&quot;</span>,Property::Changeable::OnlyAtStart,1024);
<a name="l01627"></a>01627         Pint-&gt;Set_values(blocksizes);
<a name="l01628"></a>01628         Pint-&gt;Set_help(<span class="stringliteral">&quot;Mixer block size, larger blocks might help sound stuttering but sound will also be more lagged.&quot;</span>);
<a name="l01629"></a>01629 
<a name="l01630"></a>01630         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;prebuffer&quot;</span>,Property::Changeable::OnlyAtStart,20);
<a name="l01631"></a>01631         Pint-&gt;SetMinMax(0,100);
<a name="l01632"></a>01632         Pint-&gt;Set_help(<span class="stringliteral">&quot;How many milliseconds of data to keep on top of the blocksize.&quot;</span>);
<a name="l01633"></a>01633 
<a name="l01634"></a>01634         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;midi&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l01635"></a>01635 
<a name="l01636"></a>01636         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mpu401&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;intelligent&quot;</span>);
<a name="l01637"></a>01637         Pstring-&gt;Set_values(mputypes);
<a name="l01638"></a>01638         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of MPU-401 to emulate.&quot;</span>);
<a name="l01639"></a>01639 
<a name="l01640"></a>01640         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mididevice&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l01641"></a>01641         Pstring-&gt;Set_values(devices);
<a name="l01642"></a>01642         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Device that will receive the MIDI data from MPU-401.&quot;</span>);
<a name="l01643"></a>01643 
<a name="l01644"></a>01644         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;midiconfig&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l01645"></a>01645         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Special configuration options for the device driver. This is usually the id of the device you want to use.\n&quot;</span>
<a name="l01646"></a>01646                           <span class="stringliteral">&quot;  or in the case of coreaudio or synth, you can specify a soundfont here.\n&quot;</span>
<a name="l01647"></a>01647                           <span class="stringliteral">&quot;  When using a Roland MT-32 rev. 0 as midi output device, some games may require a delay in order to prevent &#39;buffer overflow&#39; issues.\n&quot;</span>
<a name="l01648"></a>01648                           <span class="stringliteral">&quot;  In that case, add &#39;delaysysex&#39;, for example: midiconfig=2 delaysysex\n&quot;</span>
<a name="l01649"></a>01649                           <span class="stringliteral">&quot;  See the README/Manual for more details.&quot;</span>);
<a name="l01650"></a>01650 
<a name="l01651"></a>01651         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;samplerate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l01652"></a>01652         Pint-&gt;Set_values(rates);
<a name="l01653"></a>01653         Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate for MIDI synthesizer, if applicable.&quot;</span>);
<a name="l01654"></a>01654         
<a name="l01655"></a>01655         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mpuirq&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l01656"></a>01656         Pint-&gt;SetMinMax(-1,15);
<a name="l01657"></a>01657         Pint-&gt;Set_help(<span class="stringliteral">&quot;MPU-401 IRQ. -1 to automatically choose.&quot;</span>);
<a name="l01658"></a>01658 
<a name="l01659"></a>01659         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.reverse.stereo&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l01660"></a>01660         Pstring-&gt;Set_values(mt32ReverseStereo);
<a name="l01661"></a>01661         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Reverse stereo channels for MT-32 output&quot;</span>);
<a name="l01662"></a>01662 
<a name="l01663"></a>01663         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.verbose&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l01664"></a>01664         Pstring-&gt;Set_values(mt32log);
<a name="l01665"></a>01665         Pstring-&gt;Set_help(<span class="stringliteral">&quot;MT-32 debug logging&quot;</span>);
<a name="l01666"></a>01666 
<a name="l01667"></a>01667         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.thread&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l01668"></a>01668         Pstring-&gt;Set_values(mt32thread);
<a name="l01669"></a>01669         Pstring-&gt;Set_help(<span class="stringliteral">&quot;MT-32 rendering in separate thread&quot;</span>);
<a name="l01670"></a>01670 
<a name="l01671"></a>01671         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.dac&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01672"></a>01672         Pstring-&gt;Set_values(mt32DACModes);
<a name="l01673"></a>01673         Pstring-&gt;Set_help(<span class="stringliteral">&quot;MT-32 DAC input emulation mode\n&quot;</span>
<a name="l01674"></a>01674                 <span class="stringliteral">&quot;Nice = 0 - default\n&quot;</span>
<a name="l01675"></a>01675                 <span class="stringliteral">&quot;Produces samples at double the volume, without tricks.\n&quot;</span>
<a name="l01676"></a>01676                 <span class="stringliteral">&quot;Higher quality than the real devices\n\n&quot;</span>
<a name="l01677"></a>01677 
<a name="l01678"></a>01678                 <span class="stringliteral">&quot;Pure = 1\n&quot;</span>
<a name="l01679"></a>01679                 <span class="stringliteral">&quot;Produces samples that exactly match the bits output from the emulated LA32.\n&quot;</span>
<a name="l01680"></a>01680                 <span class="stringliteral">&quot;Nicer overdrive characteristics than the DAC hacks (it simply clips samples within range)\n&quot;</span>
<a name="l01681"></a>01681                 <span class="stringliteral">&quot;Much less likely to overdrive than any other mode.\n&quot;</span>
<a name="l01682"></a>01682                 <span class="stringliteral">&quot;Half the volume of any of the other modes, meaning its volume relative to the reverb\n&quot;</span>
<a name="l01683"></a>01683                 <span class="stringliteral">&quot;output when mixed together directly will sound wrong. So, reverb level must be lowered.\n&quot;</span>
<a name="l01684"></a>01684                 <span class="stringliteral">&quot;Perfect for developers while debugging :)\n\n&quot;</span>
<a name="l01685"></a>01685 
<a name="l01686"></a>01686                 <span class="stringliteral">&quot;GENERATION1 = 2\n&quot;</span>
<a name="l01687"></a>01687                 <span class="stringliteral">&quot;Re-orders the LA32 output bits as in early generation MT-32s (according to Wikipedia).\n&quot;</span>
<a name="l01688"></a>01688                 <span class="stringliteral">&quot;Bit order at DAC (where each number represents the original LA32 output bit number, and XX means the bit is always low):\n&quot;</span>
<a name="l01689"></a>01689                 <span class="stringliteral">&quot;15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 XX\n\n&quot;</span>
<a name="l01690"></a>01690 
<a name="l01691"></a>01691                 <span class="stringliteral">&quot;GENERATION2 = 3\n&quot;</span>
<a name="l01692"></a>01692                 <span class="stringliteral">&quot;Re-orders the LA32 output bits as in later geneerations (personally confirmed on my CM-32L - KG).\n&quot;</span>
<a name="l01693"></a>01693                 <span class="stringliteral">&quot;Bit order at DAC (where each number represents the original LA32 output bit number):\n&quot;</span>
<a name="l01694"></a>01694                 <span class="stringliteral">&quot;15 13 12 11 10 09 08 07 06 05 04 03 02 01 00 14\n&quot;</span>);
<a name="l01695"></a>01695 
<a name="l01696"></a>01696         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mt32.reverb.mode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01697"></a>01697         Pstring-&gt;Set_values(mt32reverbModes);
<a name="l01698"></a>01698         Pstring-&gt;Set_help(<span class="stringliteral">&quot;MT-32 reverb mode&quot;</span>);
<a name="l01699"></a>01699 
<a name="l01700"></a>01700         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mt32.reverb.time&quot;</span>,Property::Changeable::WhenIdle,5);
<a name="l01701"></a>01701         Pint-&gt;Set_values(mt32reverbTimes);
<a name="l01702"></a>01702         Pint-&gt;Set_help(<span class="stringliteral">&quot;MT-32 reverb decaying time&quot;</span>); 
<a name="l01703"></a>01703 
<a name="l01704"></a>01704         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mt32.reverb.level&quot;</span>,Property::Changeable::WhenIdle,3);
<a name="l01705"></a>01705         Pint-&gt;Set_values(mt32reverbLevels);
<a name="l01706"></a>01706         Pint-&gt;Set_help(<span class="stringliteral">&quot;MT-32 reverb level&quot;</span>);
<a name="l01707"></a>01707 
<a name="l01708"></a>01708         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mt32.partials&quot;</span>,Property::Changeable::WhenIdle,32);
<a name="l01709"></a>01709         Pint-&gt;SetMinMax(0,256);
<a name="l01710"></a>01710         Pint-&gt;Set_help(<span class="stringliteral">&quot;MT-32 max partials allowed (0-256)&quot;</span>);
<a name="l01711"></a>01711 
<a name="l01712"></a>01712         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;debug&quot;</span>,&amp;Null_Init);
<a name="l01713"></a>01713 
<a name="l01714"></a>01714         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;sblaster&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l01715"></a>01715         
<a name="l01716"></a>01716         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;sbtype&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;sb16&quot;</span>);
<a name="l01717"></a>01717         Pstring-&gt;Set_values(sbtypes);
<a name="l01718"></a>01718         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of Soundblaster to emulate. gb is Gameblaster.&quot;</span>);
<a name="l01719"></a>01719 
<a name="l01720"></a>01720         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;sbbase&quot;</span>,Property::Changeable::WhenIdle,0x220);
<a name="l01721"></a>01721         Phex-&gt;Set_values(ios);
<a name="l01722"></a>01722         Phex-&gt;Set_help(<span class="stringliteral">&quot;The IO address of the soundblaster.&quot;</span>);
<a name="l01723"></a>01723 
<a name="l01724"></a>01724         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;irq&quot;</span>,Property::Changeable::WhenIdle,7);
<a name="l01725"></a>01725         Pint-&gt;Set_values(irqssb);
<a name="l01726"></a>01726         Pint-&gt;Set_help(<span class="stringliteral">&quot;The IRQ number of the soundblaster. Set to -1 to start DOSBox with the IRQ unassigned&quot;</span>);
<a name="l01727"></a>01727 
<a name="l01728"></a>01728         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;mindma&quot;</span>,Property::Changeable::OnlyAtStart,-1);
<a name="l01729"></a>01729         Pint-&gt;Set_help( <span class="stringliteral">&quot;Minimum DMA transfer left to increase attention across DSP blocks, in milliseconds. Set to -1 for default.\n&quot;</span>
<a name="l01730"></a>01730                         <span class="stringliteral">&quot;There are some DOS games/demos that use single-cycle DSP playback in their music tracker and they micromanage\n&quot;</span>
<a name="l01731"></a>01731                         <span class="stringliteral">&quot;the DMA transfer per block poorly in a way that causes popping and artifacts. Setting this option to 0 for\n&quot;</span>
<a name="l01732"></a>01732                         <span class="stringliteral">&quot;such DOS applications may reduce audible popping and artifacts.&quot;</span>);
<a name="l01733"></a>01733 
<a name="l01734"></a>01734         <span class="comment">/* Sound Blaster IRQ hacks.</span>
<a name="l01735"></a>01735 <span class="comment">         *</span>
<a name="l01736"></a>01736 <span class="comment">         * These hacks reduce emulation accuracy but can be set to work around bugs or mistakes in some old</span>
<a name="l01737"></a>01737 <span class="comment">         * games and demos related to handling the Sound Blaster IRQ.</span>
<a name="l01738"></a>01738 <span class="comment">         *</span>
<a name="l01739"></a>01739 <span class="comment">         * - Saga by Dust (1993):</span>
<a name="l01740"></a>01740 <span class="comment">         *     Sound Blaster support has a fatal flaw in that the Sound Blaster interrupt handler it installs assumes</span>
<a name="l01741"></a>01741 <span class="comment">         *     DS == CS. It uses the DS register to read local variables needed to manage the Sound Blaster card but</span>
<a name="l01742"></a>01742 <span class="comment">         *     it makes no attempt to push DS and then load the DS segment value it needs. While the demo may seem to</span>
<a name="l01743"></a>01743 <span class="comment">         *     run normally at first, eventually the interrupt is fired at just the right time to catch the demo in</span>
<a name="l01744"></a>01744 <span class="comment">         *     the middle of it&#39;s graphics routines (DS=A000). Since the ISR uses DS to load the Sound Blaster DSP</span>
<a name="l01745"></a>01745 <span class="comment">         *     I/O port, it reads some random value from *video RAM* and then hangs in a loop waiting for that I/O</span>
<a name="l01746"></a>01746 <span class="comment">         *     port to clear bit 7! Setting &#39;cs_equ_ds&#39; works around that bug by instructing PIC emulation not to</span>
<a name="l01747"></a>01747 <span class="comment">         *     fire the interrupt unless segment registers CS and DS match. */</span>
<a name="l01748"></a>01748         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;irq hack&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;none&quot;</span>);
<a name="l01749"></a>01749         Pstring-&gt;Set_values(irqssbhack);
<a name="l01750"></a>01750         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Specify a hack related to the Sound Blaster IRQ to avoid crashes in a handful of games and demos.\n&quot;</span>
<a name="l01751"></a>01751                         <span class="stringliteral">&quot;    none                   Emulate IRQs normally\n&quot;</span>
<a name="l01752"></a>01752                         <span class="stringliteral">&quot;    cs_equ_ds              Do not fire IRQ unless two CPU segment registers match: CS == DS. Read Dosbox-X Wiki or source code for details.&quot;</span>);
<a name="l01753"></a>01753 
<a name="l01754"></a>01754         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dma&quot;</span>,Property::Changeable::WhenIdle,1);
<a name="l01755"></a>01755         Pint-&gt;Set_values(dmassb);
<a name="l01756"></a>01756         Pint-&gt;Set_help(<span class="stringliteral">&quot;The DMA number of the soundblaster. Set to -1 to start DOSBox with the IRQ unassigned&quot;</span>);
<a name="l01757"></a>01757 
<a name="l01758"></a>01758         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;hdma&quot;</span>,Property::Changeable::WhenIdle,5);
<a name="l01759"></a>01759         Pint-&gt;Set_values(dmassb);
<a name="l01760"></a>01760         Pint-&gt;Set_help(<span class="stringliteral">&quot;The High DMA number of the soundblaster. Set to -1 to start DOSBox with the IRQ unassigned&quot;</span>);
<a name="l01761"></a>01761 
<a name="l01762"></a>01762         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pic unmask irq&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01763"></a>01763         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the sound blaster IRQ already unmasked at the PIC.\n&quot;</span>
<a name="l01764"></a>01764                         <span class="stringliteral">&quot;Some early DOS games/demos that support Sound Blaster expect the IRQ to fire but make\n&quot;</span>
<a name="l01765"></a>01765                         <span class="stringliteral">&quot;no attempt to unmask the IRQ. If audio cuts out no matter what IRQ you try, then try\n&quot;</span>
<a name="l01766"></a>01766                         <span class="stringliteral">&quot;setting this option.\n&quot;</span>
<a name="l01767"></a>01767                         <span class="stringliteral">&quot;Option is needed for:\n&quot;</span>
<a name="l01768"></a>01768                         <span class="stringliteral">&quot;   Public NMI \&quot;jump\&quot; demo (1992)&quot;</span>);
<a name="l01769"></a>01769 
<a name="l01770"></a>01770         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable speaker&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01771"></a>01771         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the sound blaster speaker enabled.\n&quot;</span>
<a name="l01772"></a>01772                     <span class="stringliteral">&quot;Sound Blaster Pro and older cards have a speaker disable/enable command.\n&quot;</span>
<a name="l01773"></a>01773                     <span class="stringliteral">&quot;Normally the card boots up with the speaker disabled. If a DOS game or demo\n&quot;</span>
<a name="l01774"></a>01774                     <span class="stringliteral">&quot;attempts to play without enabling the speaker, set this option to true to\n&quot;</span>
<a name="l01775"></a>01775                     <span class="stringliteral">&quot;compensate. This setting has no meaning if emulating a Sound Blaster 16 card.&quot;</span>);
<a name="l01776"></a>01776 
<a name="l01777"></a>01777         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable asp&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01778"></a>01778         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, emulate the presence of the Sound Blaster 16 Advanced Sound Processor/Creative Sound Processor chip.\n&quot;</span>
<a name="l01779"></a>01779             <span class="stringliteral">&quot;NOTE: This only emulates it&#39;s presence and the basic DSP commands to communicate with it. Actual ASP/CSP functions are not yet implemented.&quot;</span>);
<a name="l01780"></a>01780 
<a name="l01781"></a>01781         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;disable filtering&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01782"></a>01782         Pbool-&gt;Set_help(<span class="stringliteral">&quot;By default DOSBox-X filters Sound Blaster output to emulate lowpass filters and analog output limitations.\n&quot;</span>
<a name="l01783"></a>01783                         <span class="stringliteral">&quot;Set this option to true to disable filtering. Note that doing so disables emulation of the Sound Blaster Pro\n&quot;</span>
<a name="l01784"></a>01784                         <span class="stringliteral">&quot;output filter and ESS AudioDrive lowpass filter.&quot;</span>);
<a name="l01785"></a>01785 
<a name="l01786"></a>01786         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dsp write buffer status must return 0x7f or 0xff&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01787"></a>01787         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, force port 22Ch (DSP write buffer status) to return 0x7F or 0xFF. If not set, the port\n&quot;</span>
<a name="l01788"></a>01788                         <span class="stringliteral">&quot;may return 0x7F or 0xFF depending on what type of Sound Blaster is being emulated.\n&quot;</span>
<a name="l01789"></a>01789                         <span class="stringliteral">&quot;Set this option for some early DOS demos that make that assumption about port 22Ch.\n&quot;</span>
<a name="l01790"></a>01790                         <span class="stringliteral">&quot;Option is needed for:\n&quot;</span>
<a name="l01791"></a>01791                         <span class="stringliteral">&quot;   Overload by Hysteria (1992) - Audio will crackle/saturate (8-bit overflow) except when sbtype=sb16&quot;</span>);
<a name="l01792"></a>01792 
<a name="l01793"></a>01793         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pre-set sbpro stereo&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01794"></a>01794         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the Sound Blaster Pro stereo bit set (in the mixer).\n&quot;</span>
<a name="l01795"></a>01795                         <span class="stringliteral">&quot;A few demos support Sound Blaster Pro but forget to set this bit.\n&quot;</span>
<a name="l01796"></a>01796                         <span class="stringliteral">&quot;Option is needed for:\n&quot;</span>
<a name="l01797"></a>01797                         <span class="stringliteral">&quot;   Inconexia by Iguana (1993)&quot;</span>);
<a name="l01798"></a>01798 
<a name="l01799"></a>01799         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sbmixer&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01800"></a>01800         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow the soundblaster mixer to modify the DOSBox mixer.&quot;</span>);
<a name="l01801"></a>01801 
<a name="l01802"></a>01802         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;oplmode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01803"></a>01803         Pstring-&gt;Set_values(oplmodes);
<a name="l01804"></a>01804         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Type of OPL emulation. On &#39;auto&#39; the mode is determined by sblaster type.\n&quot;</span>
<a name="l01805"></a>01805                 <span class="stringliteral">&quot;To emulate Adlib, set sbtype=none and oplmode=opl2. To emulate a Game Blaster, set\n&quot;</span>
<a name="l01806"></a>01806                 <span class="stringliteral">&quot;sbtype=none and oplmode=cms&quot;</span>);
<a name="l01807"></a>01807 
<a name="l01808"></a>01808         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;adlib force timer overflow on detect&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01809"></a>01809         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, Adlib/OPL emulation will signal &#39;overflow&#39; on timers after 50 I/O reads.\n&quot;</span>
<a name="l01810"></a>01810                         <span class="stringliteral">&quot;This is a temporary hack to work around timing bugs noted in DOSBox-X. Certain\n&quot;</span>
<a name="l01811"></a>01811                         <span class="stringliteral">&quot;games (Wolfenstein 3D) poll the Adlib status port a fixed number of times assuming\n&quot;</span>
<a name="l01812"></a>01812                         <span class="stringliteral">&quot;that the poll loop takes long enough for the Adlib timer to run out. If the game\n&quot;</span>
<a name="l01813"></a>01813                         <span class="stringliteral">&quot;cannot reliably detect Adlib at higher cycles counts, but can reliably detect at\n&quot;</span>
<a name="l01814"></a>01814                         <span class="stringliteral">&quot;lower cycles counts, set this option.\n&quot;</span>
<a name="l01815"></a>01815                         <span class="stringliteral">&quot;NOTE: Technically this decreases emulation accuracy, however it also reflects the\n&quot;</span>
<a name="l01816"></a>01816                         <span class="stringliteral">&quot;      fact that DOSBox-X&#39;s I/O timing code needs some work to better match the\n&quot;</span>
<a name="l01817"></a>01817                         <span class="stringliteral">&quot;      slowness of the ISA bus per I/O read in consideration of DOS games. So this\n&quot;</span>
<a name="l01818"></a>01818                         <span class="stringliteral">&quot;      option is ON by default.&quot;</span>);
<a name="l01819"></a>01819         <span class="comment">/* NTS: The reason I mention Wolfenstein 3D is that it seems coded not to probe for Sound Blaster unless it</span>
<a name="l01820"></a>01820 <span class="comment">         *      first detects the Adlib at port 0x388. No Adlib, no Sound Blaster. */</span>
<a name="l01821"></a>01821         <span class="comment">/* ^ NTS: To see what I mean, download Wolf3d source code, look at ID_SD.C line 1585 (Adlib detection routine).</span>
<a name="l01822"></a>01822 <span class="comment">         *        Note it sets Timer 1, then reads port 388h 100 times before reading status to detect whether the</span>
<a name="l01823"></a>01823 <span class="comment">         *        timer &quot;overflowed&quot; (fairly typical Adlib detection code).</span>
<a name="l01824"></a>01824 <span class="comment">         *        Some quick math: 8333333Hz ISA BCLK / 6 cycles per read (3 wait states) = 1388888 reads/second possible</span>
<a name="l01825"></a>01825 <span class="comment">         *                         100 I/O reads * (1 / 1388888) = 72us */</span> 
<a name="l01826"></a>01826 
<a name="l01827"></a>01827         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;oplemu&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l01828"></a>01828         Pstring-&gt;Set_values(oplemus);
<a name="l01829"></a>01829         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Provider for the OPL emulation. compat might provide better quality (see oplrate as well).&quot;</span>);
<a name="l01830"></a>01830 
<a name="l01831"></a>01831         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;oplrate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l01832"></a>01832         Pint-&gt;Set_values(oplrates);
<a name="l01833"></a>01833         Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of OPL music emulation. Use 49716 for highest quality (set the mixer rate accordingly).&quot;</span>);
<a name="l01834"></a>01834 
<a name="l01835"></a>01835         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;hardwarebase&quot;</span>,Property::Changeable::WhenIdle,0x220);
<a name="l01836"></a>01836         Phex-&gt;Set_help(<span class="stringliteral">&quot;base address of the real hardware soundblaster:\n&quot;</span>\
<a name="l01837"></a>01837                 <span class="stringliteral">&quot;210,220,230,240,250,260,280&quot;</span>);
<a name="l01838"></a>01838 
<a name="l01839"></a>01839         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;force dsp auto-init&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01840"></a>01840         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Treat all single-cycle DSP commands as auto-init to keep playback going.\n&quot;</span>
<a name="l01841"></a>01841                         <span class="stringliteral">&quot;This option is a workaround for DOS games or demos that use single-cycle DSP playback commands and\n&quot;</span>
<a name="l01842"></a>01842                         <span class="stringliteral">&quot;have problems with missing the Sound Blaster IRQ under load. Do not enable unless you need this workaround.\n&quot;</span>
<a name="l01843"></a>01843                         <span class="stringliteral">&quot;Needed for:\n&quot;</span>
<a name="l01844"></a>01844                         <span class="stringliteral">&quot;  - Extreme \&quot;lunatic\&quot; demo (1993)&quot;</span>);
<a name="l01845"></a>01845 
<a name="l01846"></a>01846         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;force goldplay&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01847"></a>01847         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Always render Sound Blaster output sample-at-a-time. Testing option. You probably don&#39;t want to enable this.&quot;</span>);
<a name="l01848"></a>01848 
<a name="l01849"></a>01849         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;goldplay&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01850"></a>01850         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable goldplay emulation.&quot;</span>);
<a name="l01851"></a>01851 
<a name="l01852"></a>01852         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;goldplay stereo&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01853"></a>01853         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable workaround for goldplay stereo playback. Many DOS demos using this technique\n&quot;</span>
<a name="l01854"></a>01854                         <span class="stringliteral">&quot;don&#39;t seem to know they need to double the frequency when programming the DSP time constant for Pro stereo output.\n&quot;</span>
<a name="l01855"></a>01855                         <span class="stringliteral">&quot;If stereo playback seems to have artifacts consider enabling this option. For accurate emulation of Sound Blaster\n&quot;</span>
<a name="l01856"></a>01856                         <span class="stringliteral">&quot;hardware, disable this option.&quot;</span>);
<a name="l01857"></a>01857 
<a name="l01858"></a>01858         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;dsp require interrupt acknowledge&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l01859"></a>01859         Pstring-&gt;Set_help(<span class="stringliteral">&quot;If set, the DSP will halt DMA playback until IRQ acknowledgement occurs even in auto-init mode (SB16 behavior).\n&quot;</span>
<a name="l01860"></a>01860                         <span class="stringliteral">&quot;If clear, IRQ acknowledgement will have no effect on auto-init playback (SB Pro and earlier &amp; clone behavior)\n&quot;</span>
<a name="l01861"></a>01861                         <span class="stringliteral">&quot;If set to &#39;auto&#39; then behavior is determined by sbtype= setting.\n&quot;</span>
<a name="l01862"></a>01862                         <span class="stringliteral">&quot;This is a setting for hardware accuracy in emulation. If audio briefly plays then stops then your DOS game\n&quot;</span>
<a name="l01863"></a>01863                         <span class="stringliteral">&quot;and it&#39;s not using IRQ (but using DMA), try setting this option to &#39;false&#39;&quot;</span>);
<a name="l01864"></a>01864 
<a name="l01865"></a>01865         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dsp write busy delay&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l01866"></a>01866         Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of time in nanoseconds the DSP chip signals &#39;busy&#39; after writing to the DSP (port 2xCh). Set to -1 to use card-specific defaults.\n&quot;</span>
<a name="l01867"></a>01867                         <span class="stringliteral">&quot;WARNING: Setting the value too high (above 20000ns) may have detrimental effects to DOS games that use IRQ 0 and DSP command 0x10 to play audio.\n&quot;</span>
<a name="l01868"></a>01868                         <span class="stringliteral">&quot;         Setting the value way too high (above 1000000ns) can cause significant lag in DOS games.&quot;</span>);
<a name="l01869"></a>01869 
<a name="l01870"></a>01870         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;blaster environment variable&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01871"></a>01871         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Whether or not to set the BLASTER environment variable automatically at startup&quot;</span>);
<a name="l01872"></a>01872 
<a name="l01873"></a>01873         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;sample rate limits&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01874"></a>01874         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), limit DSP sample rate to what real hardware is limited to&quot;</span>);
<a name="l01875"></a>01875 
<a name="l01876"></a>01876         <span class="comment">/* recommended for:</span>
<a name="l01877"></a>01877 <span class="comment">         *   1992 demo &quot;overload&quot; (if set, Sound Blaster support can run at 24KHz without causing demo to hang in the IRQ 0 timer)</span>
<a name="l01878"></a>01878 <span class="comment">         *   1993 demo &quot;xmas 93&quot; (superiority complex) because the demo&#39;s Sound Blaster mode writes at the timer interrupt rate without polling the DSP to check busy state */</span>
<a name="l01879"></a>01879         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;instant direct dac&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01880"></a>01880         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, direct DAC output commands are instantaneous. This option is intended as a quick fix for\n&quot;</span>
<a name="l01881"></a>01881                         <span class="stringliteral">&quot;games or demos that play direct DAC music/sound from the IRQ 0 timer who a) write the DSP command\n&quot;</span>
<a name="l01882"></a>01882                         <span class="stringliteral">&quot;and data without polling the DSP to ensure it&#39;s ready or b) can get locked into the IRQ 0 handler\n&quot;</span>
<a name="l01883"></a>01883                         <span class="stringliteral">&quot;waiting for DSP status when instructed to play at or beyond the DSP&#39;s maximum direct DAC sample rate.\n&quot;</span>
<a name="l01884"></a>01884                         <span class="stringliteral">&quot;This fix allows broken Sound Blaster code to work and should not be enabled unless necessary.&quot;</span>);
<a name="l01885"></a>01885 
<a name="l01886"></a>01886         <span class="comment">/* accuracy emulation: SB16 does not honor SBPro stereo bit in the mixer */</span>
<a name="l01887"></a>01887         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;stereo control with sbpro only&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01888"></a>01888         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Default on. If set, Sound Blaster Pro stereo is not available when emulating sb16 or sb16vibra.\n&quot;</span>
<a name="l01889"></a>01889                         <span class="stringliteral">&quot;If clear, sb16 emulation will honor the sbpro stereo bit. Note that Creative SB16 cards do not\n&quot;</span>
<a name="l01890"></a>01890                         <span class="stringliteral">&quot;honor the stereo bit, and this option allows DOSBox emulate that fact. Accuracy setting.&quot;</span>);
<a name="l01891"></a>01891 
<a name="l01892"></a>01892         <span class="comment">/* NTS: It turns out (SB16 at least) the DSP will periodically set bit 7 (busy) by itself at some</span>
<a name="l01893"></a>01893 <span class="comment">         *      clock rate even if it&#39;s idle. Casual testing on an old Pentium system with a ViBRA shows</span>
<a name="l01894"></a>01894 <span class="comment">         *      it&#39;s possible to see both 0x7F and 0xFF come back if you repeatedly type &quot;i 22c&quot; in DOS</span>
<a name="l01895"></a>01895 <span class="comment">         *      DEBUG.EXE.  FIXME: At what clock rate and duty cycle does this happen? */</span>
<a name="l01896"></a>01896         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dsp busy cycle rate&quot;</span>,Property::Changeable::WhenIdle,-1<span class="comment">/*default*/</span>);
<a name="l01897"></a>01897         Pint-&gt;Set_help(<span class="stringliteral">&quot;Sound Blaster 16 DSP chips appear to go busy periodically at some high clock rate\n&quot;</span>
<a name="l01898"></a>01898                         <span class="stringliteral">&quot;whether the DSP is actually doing anything for the system or not. This is an accuracy\n&quot;</span>
<a name="l01899"></a>01899                         <span class="stringliteral">&quot;option for Sound Blaster emulation. If this option is nonzero, it will be interpreted\n&quot;</span>
<a name="l01900"></a>01900                         <span class="stringliteral">&quot;as the busy cycle rate in Hz. If zero, busy cycle will not be emulated. If -1, sound\n&quot;</span>
<a name="l01901"></a>01901                         <span class="stringliteral">&quot;blaster emulation will automatically choose a setting based on the sbtype= setting&quot;</span>);
<a name="l01902"></a>01902 
<a name="l01903"></a>01903         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dsp busy cycle always&quot;</span>,Property::Changeable::WhenIdle,-1<span class="comment">/*default*/</span>);
<a name="l01904"></a>01904         Pint-&gt;Set_help(<span class="stringliteral">&quot;If set, the DSP busy cycle always happens. If clear, DSP busy cycle only happens when\n&quot;</span>
<a name="l01905"></a>01905                         <span class="stringliteral">&quot;audio playback is running. Default setting is to pick according to the sound card.&quot;</span>);
<a name="l01906"></a>01906 
<a name="l01907"></a>01907         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dsp busy cycle duty&quot;</span>,Property::Changeable::WhenIdle,-1<span class="comment">/*default*/</span>);
<a name="l01908"></a>01908         Pint-&gt;Set_help(<span class="stringliteral">&quot;If emulating SB16 busy cycle, this value (0 to 100) controls the duty cycle of the busy cycle.\n&quot;</span>
<a name="l01909"></a>01909                         <span class="stringliteral">&quot;If this option is set to -1, Sound Blaster emulation will choose a value automatically according\n&quot;</span>
<a name="l01910"></a>01910                         <span class="stringliteral">&quot;to sbtype=. If 0, busy cycle emulation is disabled.&quot;</span>);
<a name="l01911"></a>01911 
<a name="l01912"></a>01912         <span class="comment">/* NTS: Confirmed: My Sound Blaster 2.0 (at least) mirrors the DSP on port 22Ch and 22Dh. This option</span>
<a name="l01913"></a>01913 <span class="comment">         *      will only take effect with sbtype sb1 and sb2, so make it enabled by default. Accuracy setting. */</span>
<a name="l01914"></a>01914         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;io port aliasing&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l01915"></a>01915         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, Sound Blaster ports alias by not decoding the LSB of the I/O port.\n&quot;</span>
<a name="l01916"></a>01916                         <span class="stringliteral">&quot;This option only applies when sbtype is set to sb1 or sb2 (not SBPro or SB16).\n&quot;</span>
<a name="l01917"></a>01917                         <span class="stringliteral">&quot;This is a hack for the Electromotive Force &#39;Internal Damage&#39; demo which apparently\n&quot;</span>
<a name="l01918"></a>01918                         <span class="stringliteral">&quot;relies on this behavior for Sound Blaster output and should be enabled for accuracy in emulation.&quot;</span>);
<a name="l01919"></a>01919 
<a name="l01920"></a>01920         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;gus&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>); <span class="comment">//done</span>
<a name="l01921"></a>01921         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;gus&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);  
<a name="l01922"></a>01922         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable the Gravis Ultrasound emulation.&quot;</span>);
<a name="l01923"></a>01923 
<a name="l01924"></a>01924         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;autoamp&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01925"></a>01925         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, GF1 output will reduce in volume automatically if the sum of all channels exceeds full volume.\n&quot;</span>
<a name="l01926"></a>01926                     <span class="stringliteral">&quot;If not set, then loud music will clip to full volume just as it would on real hardware.\n&quot;</span>
<a name="l01927"></a>01927                     <span class="stringliteral">&quot;Enable this option for loud music if you want a more pleasing rendition without saturation and distortion.&quot;</span>);
<a name="l01928"></a>01928 
<a name="l01929"></a>01929         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;unmask dma&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01930"></a>01930         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Start the DOS virtual machine with the DMA channel already unmasked at the controller.\n&quot;</span>
<a name="l01931"></a>01931                         <span class="stringliteral">&quot;Use this for DOS applications that expect to operate the GUS but forget to unmask the DMA channel.&quot;</span>);
<a name="l01932"></a>01932 
<a name="l01933"></a>01933         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;clear dma tc irq if excess polling&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01934"></a>01934         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If the DOS application is seen polling the IRQ status register rapidly, automatically clear the DMA TC IRQ status.\n&quot;</span>
<a name="l01935"></a>01935                         <span class="stringliteral">&quot;This is a hack that should only be used with DOS applications that need it to avoid bugs in their GUS support code.\n&quot;</span>
<a name="l01936"></a>01936                         <span class="stringliteral">&quot;Needed for:\n&quot;</span>
<a name="l01937"></a>01937                         <span class="stringliteral">&quot;  Warcraft II by Blizzard ............. if using GUS for music and sound, set this option to prevent the game from\n&quot;</span>
<a name="l01938"></a>01938                         <span class="stringliteral">&quot;                                        hanging when you click on the buttons in the main menu.&quot;</span>);
<a name="l01939"></a>01939 
<a name="l01940"></a>01940         <span class="comment">/* some DOS demos, especially where the programmers wrote their own tracker, forget to set &quot;master IRQ enable&quot; on the GUS,</span>
<a name="l01941"></a>01941 <span class="comment">         * and then wonder why music isn&#39;t playing. prior to some GUS bugfixes they happend to work anyway because DOSBox also</span>
<a name="l01942"></a>01942 <span class="comment">         * ignored master IRQ enable. you can restore that buggy behavior here.</span>
<a name="l01943"></a>01943 <span class="comment">         *</span>
<a name="l01944"></a>01944 <span class="comment">         * DOS games &amp; demos that need this:</span>
<a name="l01945"></a>01945 <span class="comment">         *   - &quot;Juice&quot; by Psychic Link (writes 0x300 to GUS reset which only enables DAC and takes card out of reset, does not enable IRQ) */</span>
<a name="l01946"></a>01946         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;force master irq enable&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01947"></a>01947         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Set this option if a DOS game or demo initializes the GUS but is unable to play any music.\n&quot;</span>
<a name="l01948"></a>01948                         <span class="stringliteral">&quot;Usually the cause is buggy GUS support that resets the GUS but fails to set the Master IRQ enable bit.&quot;</span>);
<a name="l01949"></a>01949 
<a name="l01950"></a>01950         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;gus panning table&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;default&quot;</span>);
<a name="l01951"></a>01951         Pstring-&gt;Set_values(guspantables);
<a name="l01952"></a>01952         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Controls which table or equation is used for the Gravis Ultrasound panning emulation.\n&quot;</span>
<a name="l01953"></a>01953                         <span class="stringliteral">&quot;accurate emulation attempts to better reflect how the actual hardware handles panning,\n&quot;</span>
<a name="l01954"></a>01954                         <span class="stringliteral">&quot;while the old emulation uses a simpler idealistic mapping.&quot;</span>);
<a name="l01955"></a>01955 
<a name="l01956"></a>01956         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;gusrate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l01957"></a>01957         Pint-&gt;Set_values(rates);
<a name="l01958"></a>01958         Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of Ultrasound emulation.&quot;</span>);
<a name="l01959"></a>01959 
<a name="l01960"></a>01960         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;gus fixed render rate&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01961"></a>01961         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, Gravis Ultrasound audio output is rendered at a fixed sample rate specified by &#39;gusrate&#39;. This can provide better quality than real hardware,\n&quot;</span>
<a name="l01962"></a>01962                         <span class="stringliteral">&quot;if desired. Else, Gravis Ultrasound emulation will change the sample rate of it&#39;s output according to the number of active channels, just like real hardware.\n&quot;</span>
<a name="l01963"></a>01963                         <span class="stringliteral">&quot;Note: DOSBox-X defaults to &#39;false&#39;, while mainline DOSBox SVN is currently hardcoded to render as if this setting is &#39;true&#39;.&quot;</span>);
<a name="l01964"></a>01964 
<a name="l01965"></a>01965         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;gusmemsize&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l01966"></a>01966         Pint-&gt;SetMinMax(-1,1024);
<a name="l01967"></a>01967         Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of RAM on the Gravis Ultrasound in KB. Set to -1 for default.&quot;</span>);
<a name="l01968"></a>01968 
<a name="l01969"></a>01969         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;gusbase&quot;</span>,Property::Changeable::WhenIdle,0x240);
<a name="l01970"></a>01970         Phex-&gt;Set_values(iosgus);
<a name="l01971"></a>01971         Phex-&gt;Set_help(<span class="stringliteral">&quot;The IO base address of the Gravis Ultrasound.&quot;</span>);
<a name="l01972"></a>01972 
<a name="l01973"></a>01973         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;gusirq&quot;</span>,Property::Changeable::WhenIdle,5);
<a name="l01974"></a>01974         Pint-&gt;Set_values(irqsgus);
<a name="l01975"></a>01975         Pint-&gt;Set_help(<span class="stringliteral">&quot;The IRQ number of the Gravis Ultrasound.&quot;</span>);
<a name="l01976"></a>01976 
<a name="l01977"></a>01977         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;gusdma&quot;</span>,Property::Changeable::WhenIdle,3);
<a name="l01978"></a>01978         Pint-&gt;Set_values(dmasgus);
<a name="l01979"></a>01979         Pint-&gt;Set_help(<span class="stringliteral">&quot;The DMA channel of the Gravis Ultrasound.&quot;</span>);
<a name="l01980"></a>01980         
<a name="l01981"></a>01981         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;gustype&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;classic&quot;</span>);
<a name="l01982"></a>01982         Pstring-&gt;Set_values(gustypes);
<a name="l01983"></a>01983         Pstring-&gt;Set_help(      <span class="stringliteral">&quot;Type of Gravis Ultrasound to emulate.\n&quot;</span>
<a name="l01984"></a>01984                                 <span class="stringliteral">&quot;classic             Original Gravis Ultrasound chipset\n&quot;</span>
<a name="l01985"></a>01985                                 <span class="stringliteral">&quot;classic37           Original Gravis Ultrasound with ICS Mixer (rev 3.7)\n&quot;</span>
<a name="l01986"></a>01986                                 <span class="stringliteral">&quot;max                 Gravis Ultrasound MAX emulation (with CS4231 codec)\n&quot;</span>
<a name="l01987"></a>01987                                 <span class="stringliteral">&quot;interwave           Gravis Ultrasound Plug &amp; Play (interwave)&quot;</span>);
<a name="l01988"></a>01988 
<a name="l01989"></a>01989         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;ultradir&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;C:\\ULTRASND&quot;</span>);
<a name="l01990"></a>01990         Pstring-&gt;Set_help(
<a name="l01991"></a>01991                 <span class="stringliteral">&quot;Path to Ultrasound directory. In this directory\n&quot;</span>
<a name="l01992"></a>01992                 <span class="stringliteral">&quot;there should be a MIDI directory that contains\n&quot;</span>
<a name="l01993"></a>01993                 <span class="stringliteral">&quot;the patch files for GUS playback. Patch sets used\n&quot;</span>
<a name="l01994"></a>01994                 <span class="stringliteral">&quot;with Timidity should work fine.&quot;</span>);
<a name="l01995"></a>01995 
<a name="l01996"></a>01996         secprop = control-&gt;AddSection_prop(<span class="stringliteral">&quot;innova&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l01997"></a>01997         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;innova&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l01998"></a>01998         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable the Innovation SSI-2001 emulation.&quot;</span>);
<a name="l01999"></a>01999         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;samplerate&quot;</span>,Property::Changeable::WhenIdle,22050);
<a name="l02000"></a>02000         Pint-&gt;Set_values(rates);
<a name="l02001"></a>02001         Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of Innovation SSI-2001 emulation&quot;</span>);
<a name="l02002"></a>02002         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;sidbase&quot;</span>,Property::Changeable::WhenIdle,0x280);
<a name="l02003"></a>02003         Phex-&gt;Set_values(sidbaseno);
<a name="l02004"></a>02004         Phex-&gt;Set_help(<span class="stringliteral">&quot;SID base port (typically 280h).&quot;</span>);
<a name="l02005"></a>02005         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;quality&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l02006"></a>02006         Pint-&gt;Set_values(qualityno);
<a name="l02007"></a>02007         Pint-&gt;Set_help(<span class="stringliteral">&quot;Set SID emulation quality level (0 to 3).&quot;</span>);
<a name="l02008"></a>02008 
<a name="l02009"></a>02009         secprop = control-&gt;AddSection_prop(<span class="stringliteral">&quot;speaker&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);<span class="comment">//done</span>
<a name="l02010"></a>02010         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pcspeaker&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02011"></a>02011         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable PC-Speaker emulation.&quot;</span>);
<a name="l02012"></a>02012 
<a name="l02013"></a>02013         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;initial frequency&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l02014"></a>02014         Pint-&gt;Set_help(<span class="stringliteral">&quot;PC speaker PIT timer is programmed to this frequency on startup. If the DOS game\n&quot;</span>
<a name="l02015"></a>02015                         <span class="stringliteral">&quot;or demo causes a long audible beep at startup (leaving the gate open) try setting\n&quot;</span>
<a name="l02016"></a>02016                         <span class="stringliteral">&quot;this option to 0 to silence the PC speaker until reprogrammed by the demo.\n&quot;</span>
<a name="l02017"></a>02017                         <span class="stringliteral">&quot;Set to 0 for some early Abaddon demos including \&quot;Torso\&quot; and \&quot;Cycling\&quot;.&quot;</span>);
<a name="l02018"></a>02018 
<a name="l02019"></a>02019         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;pcrate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l02020"></a>02020         Pint-&gt;Set_values(rates);
<a name="l02021"></a>02021         Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of the PC-Speaker sound generation.&quot;</span>);
<a name="l02022"></a>02022 
<a name="l02023"></a>02023         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;tandy&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02024"></a>02024         Pstring-&gt;Set_values(tandys);
<a name="l02025"></a>02025         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable Tandy Sound System emulation. For &#39;auto&#39;, emulation is present only if machine is set to &#39;tandy&#39;.&quot;</span>);
<a name="l02026"></a>02026         
<a name="l02027"></a>02027         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;tandyrate&quot;</span>,Property::Changeable::WhenIdle,44100);
<a name="l02028"></a>02028         Pint-&gt;Set_values(rates);
<a name="l02029"></a>02029         Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of the Tandy 3-Voice generation.&quot;</span>);
<a name="l02030"></a>02030         
<a name="l02031"></a>02031         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;disney&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02032"></a>02032         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable Disney Sound Source emulation. (Covox Voice Master and Speech Thing compatible).&quot;</span>);
<a name="l02033"></a>02033         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;ps1audio&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l02034"></a>02034         Pstring-&gt;Set_values(ps1opt);
<a name="l02035"></a>02035         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable PS1 audio emulation.&quot;</span>);
<a name="l02036"></a>02036         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;ps1audiorate&quot;</span>,Property::Changeable::OnlyAtStart,22050);
<a name="l02037"></a>02037         Pint-&gt;Set_values(rates);
<a name="l02038"></a>02038         Pint-&gt;Set_help(<span class="stringliteral">&quot;Sample rate of the PS1 audio emulation.&quot;</span>);
<a name="l02039"></a>02039 
<a name="l02040"></a>02040         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;joystick&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>);<span class="comment">//done</span>
<a name="l02041"></a>02041         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;joysticktype&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02042"></a>02042         Pstring-&gt;Set_values(joytypes);
<a name="l02043"></a>02043         Pstring-&gt;Set_help(
<a name="l02044"></a>02044                 <span class="stringliteral">&quot;Type of joystick to emulate: auto (default), none,\n&quot;</span>
<a name="l02045"></a>02045                 <span class="stringliteral">&quot;2axis (supports two joysticks),\n&quot;</span>
<a name="l02046"></a>02046                 <span class="stringliteral">&quot;4axis (supports one joystick, first joystick used),\n&quot;</span>
<a name="l02047"></a>02047                 <span class="stringliteral">&quot;4axis_2 (supports one joystick, second joystick used),\n&quot;</span>
<a name="l02048"></a>02048                 <span class="stringliteral">&quot;fcs (Thrustmaster), ch (CH Flightstick).\n&quot;</span>
<a name="l02049"></a>02049                 <span class="stringliteral">&quot;none disables joystick emulation.\n&quot;</span>
<a name="l02050"></a>02050                 <span class="stringliteral">&quot;auto chooses emulation depending on real joystick(s).\n&quot;</span>
<a name="l02051"></a>02051                 <span class="stringliteral">&quot;(Remember to reset dosbox&#39;s mapperfile if you saved it earlier)&quot;</span>);
<a name="l02052"></a>02052 
<a name="l02053"></a>02053         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;timed&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02054"></a>02054         Pbool-&gt;Set_help(<span class="stringliteral">&quot;enable timed intervals for axis. Experiment with this option, if your joystick drifts (away).&quot;</span>);
<a name="l02055"></a>02055 
<a name="l02056"></a>02056         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;autofire&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02057"></a>02057         Pbool-&gt;Set_help(<span class="stringliteral">&quot;continuously fires as long as you keep the button pressed.&quot;</span>);
<a name="l02058"></a>02058         
<a name="l02059"></a>02059         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;swap34&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02060"></a>02060         Pbool-&gt;Set_help(<span class="stringliteral">&quot;swap the 3rd and the 4th axis. can be useful for certain joysticks.&quot;</span>);
<a name="l02061"></a>02061 
<a name="l02062"></a>02062         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;buttonwrap&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02063"></a>02063         Pbool-&gt;Set_help(<span class="stringliteral">&quot;enable button wrapping at the number of emulated buttons.&quot;</span>);
<a name="l02064"></a>02064 
<a name="l02065"></a>02065         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;serial&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l02066"></a>02066    
<a name="l02067"></a>02067         Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;serial1&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02068"></a>02068         Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;dummy&quot;</span>);
<a name="l02069"></a>02069         Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;dummy&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02070"></a>02070         Pstring-&gt;Set_values(serials);
<a name="l02071"></a>02071         Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02072"></a>02072         Pmulti_remain-&gt;Set_help(
<a name="l02073"></a>02073                 <span class="stringliteral">&quot;set type of device connected to com port.\n&quot;</span>
<a name="l02074"></a>02074                 <span class="stringliteral">&quot;Can be disabled, dummy, modem, nullmodem, directserial.\n&quot;</span>
<a name="l02075"></a>02075                 <span class="stringliteral">&quot;Additional parameters must be in the same line in the form of\n&quot;</span>
<a name="l02076"></a>02076                 <span class="stringliteral">&quot;parameter:value. Parameter for all types is irq (optional).\n&quot;</span>
<a name="l02077"></a>02077                 <span class="stringliteral">&quot;for directserial: realport (required), rxdelay (optional).\n&quot;</span>
<a name="l02078"></a>02078                 <span class="stringliteral">&quot;                 (realport:COM1 realport:ttyS0).\n&quot;</span>
<a name="l02079"></a>02079                 <span class="stringliteral">&quot;for modem: listenport (optional).\n&quot;</span>
<a name="l02080"></a>02080                 <span class="stringliteral">&quot;for nullmodem: server, rxdelay, txdelay, telnet, usedtr,\n&quot;</span>
<a name="l02081"></a>02081                 <span class="stringliteral">&quot;               transparent, port, inhsocket, nonlocal (all optional).\n&quot;</span>
<a name="l02082"></a>02082         <span class="stringliteral">&quot;               connections are limited to localhost unless you specify nonlocal:1\n&quot;</span>
<a name="l02083"></a>02083                 <span class="stringliteral">&quot;Example: serial1=modem listenport:5000&quot;</span>);
<a name="l02084"></a>02084 
<a name="l02085"></a>02085         Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;serial2&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02086"></a>02086         Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;dummy&quot;</span>);
<a name="l02087"></a>02087         Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;dummy&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02088"></a>02088         Pstring-&gt;Set_values(serials);
<a name="l02089"></a>02089         Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02090"></a>02090         Pmulti_remain-&gt;Set_help(<span class="stringliteral">&quot;see serial1&quot;</span>);
<a name="l02091"></a>02091 
<a name="l02092"></a>02092         Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;serial3&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02093"></a>02093         Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l02094"></a>02094         Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;disabled&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02095"></a>02095         Pstring-&gt;Set_values(serials);
<a name="l02096"></a>02096         Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02097"></a>02097         Pmulti_remain-&gt;Set_help(<span class="stringliteral">&quot;see serial1&quot;</span>);
<a name="l02098"></a>02098 
<a name="l02099"></a>02099         Pmulti_remain = secprop-&gt;Add_multiremain(<span class="stringliteral">&quot;serial4&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot; &quot;</span>);
<a name="l02100"></a>02100         Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;type&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l02101"></a>02101         Pmulti_remain-&gt;SetValue(<span class="stringliteral">&quot;disabled&quot;</span>,<span class="comment">/*init*/</span><span class="keyword">true</span>);
<a name="l02102"></a>02102         Pstring-&gt;Set_values(serials);
<a name="l02103"></a>02103         Pstring = Pmulti_remain-&gt;GetSection()-&gt;Add_string(<span class="stringliteral">&quot;parameters&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02104"></a>02104         Pmulti_remain-&gt;Set_help(<span class="stringliteral">&quot;see serial1&quot;</span>);
<a name="l02105"></a>02105 
<a name="l02106"></a>02106         <span class="comment">// parallel ports</span>
<a name="l02107"></a>02107         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;parallel&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l02108"></a>02108         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;parallel1&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l02109"></a>02109         Pstring-&gt;Set_help(
<a name="l02110"></a>02110                 <span class="stringliteral">&quot;parallel1-3 -- set type of device connected to lpt port.\n&quot;</span>
<a name="l02111"></a>02111                         <span class="stringliteral">&quot;Can be:\n&quot;</span>
<a name="l02112"></a>02112                         <span class="stringliteral">&quot;       reallpt (direct parallel port passthrough),\n&quot;</span>
<a name="l02113"></a>02113                         <span class="stringliteral">&quot;       file (records data to a file or passes it to a device),\n&quot;</span>
<a name="l02114"></a>02114                         <span class="stringliteral">&quot;       printer (virtual dot-matrix printer, see [printer] section)\n&quot;</span>
<a name="l02115"></a>02115                         <span class="stringliteral">&quot;       disney (attach Disney Sound Source emulation to this port)\n&quot;</span>
<a name="l02116"></a>02116                 <span class="stringliteral">&quot;Additional parameters must be in the same line in the form of\n&quot;</span>
<a name="l02117"></a>02117                 <span class="stringliteral">&quot;parameter:value.\n&quot;</span>
<a name="l02118"></a>02118                 <span class="stringliteral">&quot;  for reallpt:\n&quot;</span>
<a name="l02119"></a>02119                 <span class="stringliteral">&quot;  Windows:\n&quot;</span>
<a name="l02120"></a>02120                         <span class="stringliteral">&quot;    realbase (the base address of your real parallel port).\n&quot;</span>
<a name="l02121"></a>02121                         <span class="stringliteral">&quot;      Default: 378\n&quot;</span>
<a name="l02122"></a>02122                         <span class="stringliteral">&quot;    ecpbase (base address of the ECP registers, optional).\n&quot;</span>
<a name="l02123"></a>02123                         <span class="stringliteral">&quot;  Linux: realport (the parallel port device i.e. /dev/parport0).\n&quot;</span>
<a name="l02124"></a>02124                         <span class="stringliteral">&quot;  for file: \n&quot;</span>
<a name="l02125"></a>02125                         <span class="stringliteral">&quot;    dev:&lt;devname&gt; (i.e. dev:lpt1) to forward data to a device,\n&quot;</span>
<a name="l02126"></a>02126                         <span class="stringliteral">&quot;    or append:&lt;file&gt; appends data to the specified file.\n&quot;</span>
<a name="l02127"></a>02127                         <span class="stringliteral">&quot;    Without the above parameters data is written to files in the capture dir.\n&quot;</span>
<a name="l02128"></a>02128                         <span class="stringliteral">&quot;    Additional parameters: timeout:&lt;milliseconds&gt; = how long to wait before\n&quot;</span>
<a name="l02129"></a>02129                         <span class="stringliteral">&quot;    closing the file on inactivity (default:500), addFF to add a formfeed when\n&quot;</span>
<a name="l02130"></a>02130                         <span class="stringliteral">&quot;    closing, addLF to add a linefeed if the app doesn&#39;t, cp:&lt;codepage number&gt;\n&quot;</span>
<a name="l02131"></a>02131                         <span class="stringliteral">&quot;    to perform codepage translation, i.e. cp:437\n&quot;</span>
<a name="l02132"></a>02132                         <span class="stringliteral">&quot;  for printer:\n&quot;</span>
<a name="l02133"></a>02133                         <span class="stringliteral">&quot;    printer still has it&#39;s own configuration section above.&quot;</span>
<a name="l02134"></a>02134         );
<a name="l02135"></a>02135         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;parallel2&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l02136"></a>02136         Pstring-&gt;Set_help(<span class="stringliteral">&quot;see parallel1&quot;</span>);
<a name="l02137"></a>02137         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;parallel3&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;disabled&quot;</span>);
<a name="l02138"></a>02138         Pstring-&gt;Set_help(<span class="stringliteral">&quot;see parallel1&quot;</span>);
<a name="l02139"></a>02139 
<a name="l02140"></a>02140         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dongle&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02141"></a>02141         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable dongle&quot;</span>);
<a name="l02142"></a>02142 
<a name="l02143"></a>02143         <span class="comment">/* All the DOS Related stuff, which will eventually start up in the shell */</span>
<a name="l02144"></a>02144         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;dos&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>);<span class="comment">//done</span>
<a name="l02145"></a>02145         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;xms&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02146"></a>02146         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable XMS support.&quot;</span>);
<a name="l02147"></a>02147 
<a name="l02148"></a>02148         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;hma&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02149"></a>02149         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Report through XMS that HMA exists (not necessarily available)&quot;</span>);
<a name="l02150"></a>02150 
<a name="l02151"></a>02151         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;hma allow reservation&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02152"></a>02152         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Allow TSR and application (anything other than the DOS kernel) to request control of the HMA.\n&quot;</span>
<a name="l02153"></a>02153                         <span class="stringliteral">&quot;They will not be able to request control however if the DOS kernel is configured to occupy the HMA (DOS=HIGH)&quot;</span>);
<a name="l02154"></a>02154 
<a name="l02155"></a>02155     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;hard drive data rate limit&quot;</span>,Property::Changeable::WhenIdle,-1);
<a name="l02156"></a>02156         Pint-&gt;Set_help(<span class="stringliteral">&quot;Slow down (limit) hard disk throughput. This setting controls the limit in bytes/second.\n&quot;</span>
<a name="l02157"></a>02157                    <span class="stringliteral">&quot;Set to 0 to disable the limit, or -1 to use a reasonable default.&quot;</span>);
<a name="l02158"></a>02158 
<a name="l02159"></a>02159         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;hma minimum allocation&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l02160"></a>02160         Pint-&gt;Set_help(<span class="stringliteral">&quot;Minimum allocation size for HMA in bytes (equivalent to /HMAMIN= parameter).&quot;</span>);
<a name="l02161"></a>02161 
<a name="l02162"></a>02162     Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;log console&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02163"></a>02163     Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, log DOS CON output to the log file.&quot;</span>);
<a name="l02164"></a>02164 
<a name="l02165"></a>02165         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dos in hma&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02166"></a>02166         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Report that DOS occupies HMA (equiv. DOS=HIGH)&quot;</span>);
<a name="l02167"></a>02167 
<a name="l02168"></a>02168     Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dos sda size&quot;</span>,Property::Changeable::WhenIdle,0);
<a name="l02169"></a>02169     Pint-&gt;Set_help(<span class="stringliteral">&quot;SDA (swappable data area) size, in bytes. Set to 0 to use a reasonable default.&quot;</span>);
<a name="l02170"></a>02170 
<a name="l02171"></a>02171         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;hma free space&quot;</span>,Property::Changeable::WhenIdle,34*1024); <span class="comment">/* default 34KB (TODO: How much does MS-DOS 5.0 usually occupy?) */</span>
<a name="l02172"></a>02172         Pint-&gt;Set_help(<span class="stringliteral">&quot;Controls the amount of free space available in HMA. This setting is not meaningful unless the\n&quot;</span>
<a name="l02173"></a>02173                         <span class="stringliteral">&quot;DOS kernel occupies HMA and the emulated DOS version is at least 5.0.&quot;</span>);
<a name="l02174"></a>02174 
<a name="l02175"></a>02175     Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;cpm compatibility mode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02176"></a>02176         Pstring-&gt;Set_values(cpm_compat_modes);
<a name="l02177"></a>02177     Pstring-&gt;Set_help(
<a name="l02178"></a>02178             <span class="stringliteral">&quot;This controls how the DOS kernel sets up the CP/M compatibility code in the PSP segment.\n&quot;</span>
<a name="l02179"></a>02179             <span class="stringliteral">&quot;Several options are provided to emulate one of several undocumented behaviors related to the CP/M entry point.\n&quot;</span>
<a name="l02180"></a>02180             <span class="stringliteral">&quot;If set to auto, DOSBox-X will pick the best option to allow it to work properly.\n&quot;</span>
<a name="l02181"></a>02181             <span class="stringliteral">&quot;Unless set to &#39;off&#39;, this option will require the DOS kernel to occupy the first 256 bytes of the HMA memory area\n&quot;</span>
<a name="l02182"></a>02182             <span class="stringliteral">&quot;to prevent crashes when the A20 gate is switched on.\n&quot;</span>
<a name="l02183"></a>02183             <span class="stringliteral">&quot;   auto      Pick the best option\n&quot;</span>
<a name="l02184"></a>02184             <span class="stringliteral">&quot;   off       Turn off the CP/M entry point (program will abort if called)\n&quot;</span>
<a name="l02185"></a>02185             <span class="stringliteral">&quot;   msdos2    MS-DOS 2.x behavior, offset field also doubles as data segment size\n&quot;</span>
<a name="l02186"></a>02186             <span class="stringliteral">&quot;   msdos5    MS-DOS 5.x behavior, entry point becomes one of two fixed addresses\n&quot;</span>
<a name="l02187"></a>02187             <span class="stringliteral">&quot;   direct    Non-standard behavior, encode the CALL FAR directly to the entry point rather than indirectly&quot;</span>);
<a name="l02188"></a>02188 
<a name="l02189"></a>02189         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;share&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02190"></a>02190         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Report SHARE.EXE as resident. Does not actually emulate SHARE functions.&quot;</span>);
<a name="l02191"></a>02191 
<a name="l02192"></a>02192         <span class="comment">// bugfix for &quot;Digital Dream&quot; DOS demo that displays a &quot;peace to hackers&quot; message if it thinks it&#39;s being debugged.</span>
<a name="l02193"></a>02193         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;write plain iretf for debug interrupts&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02194"></a>02194         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If true (default), the DOS kernel will create an alternate interrupt handler for debug interrupts INT 1 and INT 3\n&quot;</span>
<a name="l02195"></a>02195                         <span class="stringliteral">&quot;that contain ONLY an IRETF instruction. If false, INT 1 and INT 3 will use the same default interrupt handler in\n&quot;</span>
<a name="l02196"></a>02196                         <span class="stringliteral">&quot;the DOS kernel, which contains a callback instruction followed by IRETF. Some DOS games/demos assume they are being\n&quot;</span>
<a name="l02197"></a>02197                         <span class="stringliteral">&quot;debugged if the debug interrupts point to anything other than an IRETF instruction. Set this option to false if\n&quot;</span>
<a name="l02198"></a>02198                         <span class="stringliteral">&quot;you need notification that INT 1/INT 3 was not handled.&quot;</span>);
<a name="l02199"></a>02199 
<a name="l02200"></a>02200         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;minimum dos initial private segment&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l02201"></a>02201         Phex-&gt;Set_help(<span class="stringliteral">&quot;In non-mainline mapping mode, where DOS structures are allocated from base memory, this sets the\n&quot;</span>
<a name="l02202"></a>02202                         <span class="stringliteral">&quot;minimum segment value. Recommended value is 0x70. You may reduce the value down to 0x50 if freeing\n&quot;</span>
<a name="l02203"></a>02203                         <span class="stringliteral">&quot;up more memory is important. Set to 0 for default.&quot;</span>);
<a name="l02204"></a>02204 
<a name="l02205"></a>02205         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;minimum mcb segment&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l02206"></a>02206         Phex-&gt;Set_help(<span class="stringliteral">&quot;Minimum segment value to begin memory allocation from, in hexadecimal. Set to 0 for default.\n&quot;</span>
<a name="l02207"></a>02207                         <span class="stringliteral">&quot;You can increase available DOS memory by reducing this value down to as low as 0x51, however\n&quot;</span>
<a name="l02208"></a>02208                         <span class="stringliteral">&quot;setting it to low can cause some DOS programs to crash or run erratically, and some DOS games\n&quot;</span>
<a name="l02209"></a>02209                         <span class="stringliteral">&quot;and demos to cause intermittent static noises when using Sound Blaster output. DOS programs\n&quot;</span>
<a name="l02210"></a>02210                         <span class="stringliteral">&quot;compressed with Microsoft EXEPACK will not run if the minimum MCB segment is below 64KB.&quot;</span>);
<a name="l02211"></a>02211 
<a name="l02212"></a>02212         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;minimum mcb free&quot;</span>, Property::Changeable::WhenIdle,0);
<a name="l02213"></a>02213         Phex-&gt;Set_help(<span class="stringliteral">&quot;Minimum free segment value to leave free. At startup, the DOS kernel will allocate memory\n&quot;</span>
<a name="l02214"></a>02214                    <span class="stringliteral">&quot;up to this point. This can be used to deal with EXEPACK issues or DOS programs that cannot\n&quot;</span>
<a name="l02215"></a>02215                    <span class="stringliteral">&quot;be loaded too low in memory. This differs from &#39;minimum mcb segment&#39; in that this affects\n&quot;</span>
<a name="l02216"></a>02216                    <span class="stringliteral">&quot;the lowest free block instead of the starting point of the mcb chain.&quot;</span>);
<a name="l02217"></a>02217 
<a name="l02218"></a>02218         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable dummy device mcb&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02219"></a>02219         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), allocate a fake device MCB at the base of conventional memory.\n&quot;</span>
<a name="l02220"></a>02220                         <span class="stringliteral">&quot;Clearing this option can reclaim a small amount of conventional memory at the expense of\n&quot;</span>
<a name="l02221"></a>02221                         <span class="stringliteral">&quot;some minor DOS compatibility.&quot;</span>);
<a name="l02222"></a>02222 
<a name="l02223"></a>02223         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable loadfix padding&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02224"></a>02224         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), allocate a small 1KB region at the base of conventional memory.\n&quot;</span>
<a name="l02225"></a>02225                         <span class="stringliteral">&quot;Clearing this option can reclaim a small amount of conventional memory, but can also\n&quot;</span>
<a name="l02226"></a>02226                         <span class="stringliteral">&quot;cause some DOS games to break especially if dynamic kernel allocation is enabled.&quot;</span>);
<a name="l02227"></a>02227 
<a name="l02228"></a>02228         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable dummy environment block&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02229"></a>02229         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set (default), allocate a dummy environment block at the base of conventional memory.\n&quot;</span>
<a name="l02230"></a>02230                         <span class="stringliteral">&quot;You can clear this option to reclaim a small amount of conventional memory.&quot;</span>);
<a name="l02231"></a>02231 
<a name="l02232"></a>02232         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;maximum environment block size on exec&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l02233"></a>02233         Pint-&gt;SetMinMax(-1,65535);
<a name="l02234"></a>02234         Pint-&gt;Set_help(<span class="stringliteral">&quot;Maximum environment block size to copy for child processes. Set to -1 for default.&quot;</span>);
<a name="l02235"></a>02235 
<a name="l02236"></a>02236         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;additional environment block size on exec&quot;</span>, Property::Changeable::WhenIdle,-1);
<a name="l02237"></a>02237         Pint-&gt;SetMinMax(-1,65535);
<a name="l02238"></a>02238         Pint-&gt;Set_help(<span class="stringliteral">&quot;When executing a program, compute the size of the parent block then add this amount to allow for a few additional variables.\n&quot;</span>
<a name="l02239"></a>02239                         <span class="stringliteral">&quot;If the subprocesses will never add/modify the environment block, you can free up a few additional bytes by setting this to 0.\n&quot;</span>
<a name="l02240"></a>02240                         <span class="stringliteral">&quot;Set to -1 for default setting.&quot;</span>);
<a name="l02241"></a>02241 
<a name="l02242"></a>02242         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable a20 on windows init&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02243"></a>02243         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, DOSBox will enable the A20 gate when Windows 3.1/9x broadcasts the INIT message\n&quot;</span>
<a name="l02244"></a>02244                         <span class="stringliteral">&quot;at startup. Windows 3.1 appears to make assumptions at some key points on startup about\n&quot;</span>
<a name="l02245"></a>02245                         <span class="stringliteral">&quot;A20 that don&#39;t quite hold up and cause Windows 3.1 to crash when you set A20 emulation\n&quot;</span>
<a name="l02246"></a>02246                         <span class="stringliteral">&quot;to a20=mask as opposed to a20=fast. This option is enabled by default.&quot;</span>);
<a name="l02247"></a>02247 
<a name="l02248"></a>02248         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero memory on xms memory allocation&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02249"></a>02249         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, memory returned by XMS allocation call is zeroed first. This is NOT what\n&quot;</span>
<a name="l02250"></a>02250                         <span class="stringliteral">&quot;DOS actually does, but if set, can help certain DOS games and demos cope with problems\n&quot;</span>
<a name="l02251"></a>02251                         <span class="stringliteral">&quot;related to uninitialized variables in extended memory. When enabled this option may\n&quot;</span>
<a name="l02252"></a>02252                         <span class="stringliteral">&quot;incur a slight to moderate performance penalty.&quot;</span>);
<a name="l02253"></a>02253 
<a name="l02254"></a>02254         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;dosv&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;off&quot;</span>);
<a name="l02255"></a>02255         Pstring-&gt;Set_values(dosv_settings);
<a name="l02256"></a>02256         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable DOS/V emulation and specify which version to emulate. This option is intended for\n&quot;</span>
<a name="l02257"></a>02257                         <span class="stringliteral">&quot;use with games or software originating from Asia that use the double byte character set\n&quot;</span>
<a name="l02258"></a>02258                         <span class="stringliteral">&quot;encodings and the DOS/V extensions to display Japanese, Chinese, or Korean text.\n&quot;</span>
<a name="l02259"></a>02259                         <span class="stringliteral">&quot;Note that enabling DOS/V replaces 80x25 text mode (INT 10h mode 3) with a EGA/VGA graphics\n&quot;</span>
<a name="l02260"></a>02260                         <span class="stringliteral">&quot;mode that emulates text mode to display the characters and may be incompatible with non-Asian\n&quot;</span>
<a name="l02261"></a>02261                         <span class="stringliteral">&quot;software that assumes direct access to the text mode via segment 0xB800.\n&quot;</span>
<a name="l02262"></a>02262                         <span class="stringliteral">&quot;WARNING: This option is very experimental at this time.&quot;</span>);
<a name="l02263"></a>02263 
<a name="l02264"></a>02264         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;ems&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;true&quot;</span>);
<a name="l02265"></a>02265         Pstring-&gt;Set_values(ems_settings);
<a name="l02266"></a>02266         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Enable EMS support. The default (=true) provides the best\n&quot;</span>
<a name="l02267"></a>02267                 <span class="stringliteral">&quot;compatibility but certain applications may run better with\n&quot;</span>
<a name="l02268"></a>02268                 <span class="stringliteral">&quot;other choices, or require EMS support to be disabled (=false)\n&quot;</span>
<a name="l02269"></a>02269                 <span class="stringliteral">&quot;to work at all.&quot;</span>);
<a name="l02270"></a>02270 
<a name="l02271"></a>02271         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;vcpi&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02272"></a>02272         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set and expanded memory is enabled, also emulate VCPI.&quot;</span>);
<a name="l02273"></a>02273 
<a name="l02274"></a>02274         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;unmask timer on disk io&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02275"></a>02275         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, INT 21h emulation will unmask IRQ 0 (timer interrupt) when the application opens/closes/reads/writes files.&quot;</span>);
<a name="l02276"></a>02276 
<a name="l02277"></a>02277         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero int 67h if no ems&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02278"></a>02278         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If ems=false, leave interrupt vector 67h zeroed out (default true).\n&quot;</span>
<a name="l02279"></a>02279                         <span class="stringliteral">&quot;This is a workaround for games or demos that try to detect EMS by whether or not INT 67h is 0000:0000 rather than a proper test.\n&quot;</span>
<a name="l02280"></a>02280                         <span class="stringliteral">&quot;This option also affects whether INT 67h is zeroed when booting a guest OS&quot;</span>);
<a name="l02281"></a>02281 
<a name="l02282"></a>02282         <span class="comment">/* FIXME: The vm86 monitor in src/ints/ems.cpp is not very stable! Option is default OFF until stabilized! */</span>
<a name="l02283"></a>02283         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;emm386 startup active&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02284"></a>02284         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set and expanded memory is set to emulate emm386, start the DOS machine with EMM386.EXE active\n&quot;</span>
<a name="l02285"></a>02285                         <span class="stringliteral">&quot;(running the 16-bit DOS environment from within Virtual 8086 mode). If you will be running anything\n&quot;</span>
<a name="l02286"></a>02286                         <span class="stringliteral">&quot;that involves a DOS extender you will also need to enable the VCPI interface as well.&quot;</span>);
<a name="l02287"></a>02287 
<a name="l02288"></a>02288         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero memory on ems memory allocation&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02289"></a>02289         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, memory returned by EMS allocation call is zeroed first. This is NOT what\n&quot;</span>
<a name="l02290"></a>02290                         <span class="stringliteral">&quot;DOS actually does, but if set, can help certain DOS games and demos cope with problems\n&quot;</span>
<a name="l02291"></a>02291                         <span class="stringliteral">&quot;related to uninitialized variables in expanded memory. When enabled this option may\n&quot;</span>
<a name="l02292"></a>02292                         <span class="stringliteral">&quot;incur a slight to moderate performance penalty.&quot;</span>);
<a name="l02293"></a>02293 
<a name="l02294"></a>02294         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;ems system handle memory size&quot;</span>,Property::Changeable::WhenIdle,384);
<a name="l02295"></a>02295         Pint-&gt;Set_help(<span class="stringliteral">&quot;Amount of memory associated with system handle, in KB&quot;</span>);
<a name="l02296"></a>02296 
<a name="l02297"></a>02297         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ems system handle on even megabyte&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02298"></a>02298         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, try to allocate the EMM system handle on an even megabyte.\n&quot;</span>
<a name="l02299"></a>02299                         <span class="stringliteral">&quot;If the DOS game or demo fiddles with the A20 gate while using EMM386.EXE emulation in virtual 8086 mode, setting this option may help prevent crashes.\n&quot;</span>
<a name="l02300"></a>02300                         <span class="stringliteral">&quot;However, forcing allocation on an even megabyte will also cause some extended memory fragmentation and reduce the\n&quot;</span>
<a name="l02301"></a>02301                         <span class="stringliteral">&quot;overall amount of extended memory available to the DOS game depending on whether it expects large contiguous chunks\n&quot;</span>
<a name="l02302"></a>02302                         <span class="stringliteral">&quot;of extended memory.&quot;</span>);
<a name="l02303"></a>02303 
<a name="l02304"></a>02304         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;umb&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02305"></a>02305         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable UMB support.&quot;</span>);
<a name="l02306"></a>02306 
<a name="l02307"></a>02307         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;umb start&quot;</span>,Property::Changeable::OnlyAtStart,0); <span class="comment">/* &lt;- (0=auto) 0xD000 is mainline DOSBox compatible behavior */</span>
<a name="l02308"></a>02308         Phex-&gt;Set_help(<span class="stringliteral">&quot;UMB region starting segment&quot;</span>);
<a name="l02309"></a>02309 
<a name="l02310"></a>02310         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;umb end&quot;</span>,Property::Changeable::OnlyAtStart,0); <span class="comment">/* &lt;- (0=auto) 0xEFFF is mainline DOSBox compatible (where base=0xD000 and size=0x2000) */</span>
<a name="l02311"></a>02311         Phex-&gt;Set_help(<span class="stringliteral">&quot;UMB region last segment&quot;</span>);
<a name="l02312"></a>02312 
<a name="l02313"></a>02313         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;kernel allocation in umb&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02314"></a>02314         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, dynamic kernel allocation=1, and private area in umb=1, all kernel structures will be allocated from the private area in UMB.\n&quot;</span>
<a name="l02315"></a>02315                         <span class="stringliteral">&quot;If you intend to run Windows 3.1 in DOSBox, you must set this option to false else Windows 3.1 will not start.&quot;</span>);
<a name="l02316"></a>02316 
<a name="l02317"></a>02317         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dynamic kernel allocation&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02318"></a>02318         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, DOS kernel structures are allocated dynamically. If clear, DOS kernel structures are fixed at specific segments (mainline DOSBox behavior)&quot;</span>);
<a name="l02319"></a>02319 
<a name="l02320"></a>02320         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;keep umb on boot&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02321"></a>02321         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If emulating UMBs, keep the UMB around after boot (Mainline DOSBox behavior). If clear, UMB is unmapped when you boot an operating system.&quot;</span>);
<a name="l02322"></a>02322 
<a name="l02323"></a>02323         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;keep private area on boot&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02324"></a>02324         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, keep the DOSBox private area around after boot (Mainline DOSBox behavior). If clear, unmap and discard the private area when you boot an operating system.&quot;</span>);
<a name="l02325"></a>02325 
<a name="l02326"></a>02326         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;private area in umb&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02327"></a>02327         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, keep private DOS segment in upper memory block, usually segment 0xC800 (Mainline DOSBox behavior)\n&quot;</span>
<a name="l02328"></a>02328                         <span class="stringliteral">&quot;If clear, place private DOS segment at the base of system memory (just below the MCB)&quot;</span>);
<a name="l02329"></a>02329 
<a name="l02330"></a>02330         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;ver&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;&quot;</span>);
<a name="l02331"></a>02331         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Set DOS version. Specify as major.minor format. A single number is treated as the major version (LFN patch compat). Common settings are:\n&quot;</span>
<a name="l02332"></a>02332                         <span class="stringliteral">&quot;auto (or unset)                  Pick a DOS kernel version automatically\n&quot;</span>
<a name="l02333"></a>02333                         <span class="stringliteral">&quot;3.3                              MS-DOS 3.3 emulation (not tested!)\n&quot;</span>
<a name="l02334"></a>02334                         <span class="stringliteral">&quot;5.0                              MS-DOS 5.0 emulation (recommended for DOS gaming)\n&quot;</span>
<a name="l02335"></a>02335                         <span class="stringliteral">&quot;6.22                             MS-DOS 6.22 emulation\n&quot;</span>
<a name="l02336"></a>02336                         <span class="stringliteral">&quot;7.0                              Windows 95 (pure DOS mode) emulation\n&quot;</span>);
<a name="l02337"></a>02337 
<a name="l02338"></a>02338         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;automount&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02339"></a>02339         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable automatic mount.&quot;</span>);
<a name="l02340"></a>02340 
<a name="l02341"></a>02341         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int33&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02342"></a>02342         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable INT 33H (mouse) support.&quot;</span>);
<a name="l02343"></a>02343 
<a name="l02344"></a>02344         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int 13 extensions&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02345"></a>02345         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable INT 13h extensions (functions 0x40-0x48). You will need this enabled if the virtual hard drive image is 8.4GB or larger.&quot;</span>);
<a name="l02346"></a>02346 
<a name="l02347"></a>02347         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;biosps2&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02348"></a>02348         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Emulate BIOS INT 15h PS/2 mouse services\n&quot;</span>
<a name="l02349"></a>02349                 <span class="stringliteral">&quot;Note that some OS&#39;s like Microsoft Windows neither use INT 33h nor\n&quot;</span>
<a name="l02350"></a>02350                 <span class="stringliteral">&quot;probe the AUX port directly and depend on this BIOS interface exclusively\n&quot;</span>
<a name="l02351"></a>02351                 <span class="stringliteral">&quot;for PS/2 mouse support. In other cases there is no harm in leaving this enabled&quot;</span>);
<a name="l02352"></a>02352 
<a name="l02353"></a>02353         <span class="comment">/* bugfix for Yodel &quot;mayday&quot; demo */</span>
<a name="l02354"></a>02354         <span class="comment">/* TODO: Set this option to default to &quot;true&quot; if it turns out most BIOSes unmask the IRQ during INT 15h AH=86 WAIT */</span>
<a name="l02355"></a>02355         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int15 wait force unmask irq&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02356"></a>02356         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Some demos or games mistakingly use INT 15h AH=0x86 (WAIT) while leaving the IRQs needed for it masked.\n&quot;</span>
<a name="l02357"></a>02357                         <span class="stringliteral">&quot;If this option is set (by default), the necessary IRQs will be unmasked when INT 15 AH=0x86 is used so that the game or demo does not hang.&quot;</span>);
<a name="l02358"></a>02358 
<a name="l02359"></a>02359         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int15 mouse callback does not preserve registers&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02360"></a>02360         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Set to true if the guest OS or DOS program assigns an INT 15h mouse callback,\n&quot;</span>
<a name="l02361"></a>02361                         <span class="stringliteral">&quot;but does not properly preserve CPU registers. Diagnostic function only (default off).&quot;</span>);
<a name="l02362"></a>02362 
<a name="l02363"></a>02363         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;keyboardlayout&quot;</span>,Property::Changeable::WhenIdle, <span class="stringliteral">&quot;auto&quot;</span>);
<a name="l02364"></a>02364         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Language code of the keyboard layout (or none).&quot;</span>);
<a name="l02365"></a>02365 
<a name="l02366"></a>02366         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;dbcs&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02367"></a>02367         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable DBCS table.\n&quot;</span>
<a name="l02368"></a>02368                         <span class="stringliteral">&quot;CAUTION: Some software will crash without the DBCS table, including the Open Watcom installer.\n&quot;</span>);
<a name="l02369"></a>02369 
<a name="l02370"></a>02370         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;filenamechar&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02371"></a>02371         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable filename char table&quot;</span>);
<a name="l02372"></a>02372 
<a name="l02373"></a>02373         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;collating and uppercase&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02374"></a>02374         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable collating and uppercase table&quot;</span>);
<a name="l02375"></a>02375 
<a name="l02376"></a>02376         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;files&quot;</span>,Property::Changeable::OnlyAtStart,127);
<a name="l02377"></a>02377         Pint-&gt;Set_help(<span class="stringliteral">&quot;Number of file handles available to DOS programs. (equivalent to \&quot;files=\&quot; in config.sys)&quot;</span>);
<a name="l02378"></a>02378 
<a name="l02379"></a>02379         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;con device use int 16h to detect keyboard input&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02380"></a>02380         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, use INT 16h to detect keyboard input (MS-DOS 6.22 behavior). If clear, detect keyboard input by\n&quot;</span>
<a name="l02381"></a>02381                         <span class="stringliteral">&quot;peeking into the BIOS keyboard buffer (Mainline DOSBox behavior). You will need to set this\n&quot;</span>
<a name="l02382"></a>02382                         <span class="stringliteral">&quot;option for programs that hook INT 16h to handle keyboard input ahead of the DOS console.\n&quot;</span>
<a name="l02383"></a>02383                         <span class="stringliteral">&quot;Microsoft Scandisk needs this option to respond to keyboard input correctly.&quot;</span>);
<a name="l02384"></a>02384 
<a name="l02385"></a>02385         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;zero memory on int 21h memory allocation&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02386"></a>02386         Pbool-&gt;Set_help(<span class="stringliteral">&quot;If set, memory returned by the INT 21h allocation call is zeroed first. This is NOT what\n&quot;</span>
<a name="l02387"></a>02387                         <span class="stringliteral">&quot;DOS actually does, but if set, can help certain DOS games and demos cope with problems\n&quot;</span>
<a name="l02388"></a>02388                         <span class="stringliteral">&quot;related to uninitialized variables in the data or stack segment. If you intend to run a\n&quot;</span>
<a name="l02389"></a>02389                         <span class="stringliteral">&quot;game or demo known to have this problem (Second Unreal, for example), set to true, else\n&quot;</span>
<a name="l02390"></a>02390                         <span class="stringliteral">&quot;set to false. When enabled this option may incur a slight to moderate performance penalty.&quot;</span>);
<a name="l02391"></a>02391 
<a name="l02392"></a>02392         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;ipx&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l02393"></a>02393         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ipx&quot;</span>,Property::Changeable::WhenIdle, <span class="keyword">false</span>);
<a name="l02394"></a>02394         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable ipx over UDP/IP emulation.&quot;</span>);
<a name="l02395"></a>02395 
<a name="l02396"></a>02396         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;ne2000&quot;</span>,&amp;Null_Init,<span class="keyword">true</span>);
<a name="l02397"></a>02397         MSG_Add(<span class="stringliteral">&quot;NE2000_CONFIGFILE_HELP&quot;</span>,
<a name="l02398"></a>02398                 <span class="stringliteral">&quot;macaddr -- The physical address the emulator will use on your network.\n&quot;</span>
<a name="l02399"></a>02399                 <span class="stringliteral">&quot;           If you have multiple DOSBoxes running on your network,\n&quot;</span>
<a name="l02400"></a>02400                 <span class="stringliteral">&quot;           this has to be changed. Modify the last three number blocks.\n&quot;</span>
<a name="l02401"></a>02401                 <span class="stringliteral">&quot;           I.e. AC:DE:48:88:99:AB.\n&quot;</span>
<a name="l02402"></a>02402                 <span class="stringliteral">&quot;realnic -- Specifies which of your network interfaces is used.\n&quot;</span>
<a name="l02403"></a>02403                 <span class="stringliteral">&quot;           Write \&#39;list\&#39; here to see the list of devices in the\n&quot;</span>
<a name="l02404"></a>02404                 <span class="stringliteral">&quot;           Status Window. Then make your choice and put either the\n&quot;</span>
<a name="l02405"></a>02405                 <span class="stringliteral">&quot;           interface number (2 or something) or a part of your adapters\n&quot;</span>
<a name="l02406"></a>02406                 <span class="stringliteral">&quot;           name, e.g. VIA here.\n&quot;</span>
<a name="l02407"></a>02407 
<a name="l02408"></a>02408         );
<a name="l02409"></a>02409 
<a name="l02410"></a>02410         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ne2000&quot;</span>, Property::Changeable::WhenIdle, <span class="keyword">false</span>);
<a name="l02411"></a>02411         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable Ethernet passthrough. Requires [Win]Pcap.&quot;</span>);
<a name="l02412"></a>02412 
<a name="l02413"></a>02413         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;nicbase&quot;</span>, Property::Changeable::WhenIdle, 0x300);
<a name="l02414"></a>02414         Phex-&gt;Set_help(<span class="stringliteral">&quot;The base address of the NE2000 board.&quot;</span>);
<a name="l02415"></a>02415 
<a name="l02416"></a>02416         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;nicirq&quot;</span>, Property::Changeable::WhenIdle, 3);
<a name="l02417"></a>02417         Pint-&gt;Set_help(<span class="stringliteral">&quot;The interrupt it uses. Note serial2 uses IRQ3 as default.&quot;</span>);
<a name="l02418"></a>02418 
<a name="l02419"></a>02419         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;macaddr&quot;</span>, Property::Changeable::WhenIdle,<span class="stringliteral">&quot;AC:DE:48:88:99:AA&quot;</span>);
<a name="l02420"></a>02420         Pstring-&gt;Set_help(<span class="stringliteral">&quot;The physical address the emulator will use on your network.\n&quot;</span>
<a name="l02421"></a>02421                 <span class="stringliteral">&quot;If you have multiple DOSBoxes running on your network,\n&quot;</span>
<a name="l02422"></a>02422                 <span class="stringliteral">&quot;this has to be changed for each. AC:DE:48 is an address range reserved for\n&quot;</span>
<a name="l02423"></a>02423                 <span class="stringliteral">&quot;private use, so modify the last three number blocks.\n&quot;</span>
<a name="l02424"></a>02424                 <span class="stringliteral">&quot;I.e. AC:DE:48:88:99:AB.&quot;</span>);
<a name="l02425"></a>02425 
<a name="l02426"></a>02426         <span class="comment">/* TODO: Change default to &quot;nat&quot; and then begin implementing support for emulating</span>
<a name="l02427"></a>02427 <span class="comment">         *       an ethernet connection with DOSBox-X as a NAT/firewall between the guest</span>
<a name="l02428"></a>02428 <span class="comment">         *       and the OS. Sort of like &quot;NAT&quot; mode in VirtualBox. When that works, we</span>
<a name="l02429"></a>02429 <span class="comment">         *       can then compile NE2000 support with and without libpcap/winpcap support. */</span>
<a name="l02430"></a>02430         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;realnic&quot;</span>, Property::Changeable::WhenIdle,<span class="stringliteral">&quot;list&quot;</span>);
<a name="l02431"></a>02431         Pstring-&gt;Set_help(<span class="stringliteral">&quot;Specifies which of your network interfaces is used.\n&quot;</span>
<a name="l02432"></a>02432                 <span class="stringliteral">&quot;Write \&#39;list\&#39; here to see the list of devices in the\n&quot;</span>
<a name="l02433"></a>02433                 <span class="stringliteral">&quot;Status Window. Then make your choice and put either the\n&quot;</span>
<a name="l02434"></a>02434                 <span class="stringliteral">&quot;interface number (2 or something) or a part of your adapters\n&quot;</span>
<a name="l02435"></a>02435                 <span class="stringliteral">&quot;name, e.g. VIA here.&quot;</span>);
<a name="l02436"></a>02436 
<a name="l02437"></a>02437         <span class="comment">/* floppy controller emulation options and setup */</span>
<a name="l02438"></a>02438         secprop=control-&gt;AddSection_prop(<span class="stringliteral">&quot;fdc, primary&quot;</span>,&amp;Null_Init,<span class="keyword">false</span>);
<a name="l02439"></a>02439 
<a name="l02440"></a>02440         <span class="comment">/* Primary FDC on by default, secondary is not. Most PCs have only one floppy controller. */</span>
<a name="l02441"></a>02441         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">false</span>);
<a name="l02442"></a>02442         Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable floppy controller interface&quot;</span>);
<a name="l02443"></a>02443 
<a name="l02444"></a>02444         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pnp&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02445"></a>02445         Pbool-&gt;Set_help(<span class="stringliteral">&quot;List floppy controller in ISA PnP BIOS enumeration&quot;</span>);
<a name="l02446"></a>02446 
<a name="l02447"></a>02447         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;irq&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use FDC default*/</span>);
<a name="l02448"></a>02448         Pint-&gt;Set_help(<span class="stringliteral">&quot;IRQ used by floppy controller. Set to 0 for default.\n&quot;</span>
<a name="l02449"></a>02449                 <span class="stringliteral">&quot;WARNING: Setting the IRQ to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the floppy controller.\n&quot;</span>
<a name="l02450"></a>02450                 <span class="stringliteral">&quot;         Setting the IRQ to one already occupied by another device or IDE controller will trigger \&quot;resource conflict\&quot; errors in Windows 95.\n&quot;</span>
<a name="l02451"></a>02451                 <span class="stringliteral">&quot;         Normally, floppy controllers use IRQ 6.&quot;</span>);
<a name="l02452"></a>02452 
<a name="l02453"></a>02453         Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;io&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use FDC default*/</span>);
<a name="l02454"></a>02454         Phex-&gt;Set_help(<span class="stringliteral">&quot;Base I/O port for floppy controller. Set to 0 for default.\n&quot;</span>
<a name="l02455"></a>02455                 <span class="stringliteral">&quot;WARNING: Setting the I/O port to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l02456"></a>02456                 <span class="stringliteral">&quot;         Standard I/O ports are 3F0 and 370.&quot;</span>);
<a name="l02457"></a>02457 
<a name="l02458"></a>02458         Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;dma&quot;</span>,Property::Changeable::WhenIdle,-1<span class="comment">/*use FDC default*/</span>);
<a name="l02459"></a>02459         Pint-&gt;Set_help(<span class="stringliteral">&quot;DMA channel for floppy controller. Set to -1 for default.\n&quot;</span>
<a name="l02460"></a>02460                 <span class="stringliteral">&quot;WARNING: Setting the DMA channel to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l02461"></a>02461                 <span class="stringliteral">&quot;         Standard DMA channel is 2.&quot;</span>);
<a name="l02462"></a>02462 
<a name="l02463"></a>02463         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int13fakev86io&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02464"></a>02464         Pbool-&gt;Set_help(
<a name="l02465"></a>02465                 <span class="stringliteral">&quot;If set, and int13fakeio is set, certain INT 13h commands will\n&quot;</span>
<a name="l02466"></a>02466                 <span class="stringliteral">&quot;cause floppy emulation to issue fake CPU I/O traps (GPF) in\n&quot;</span>
<a name="l02467"></a>02467                 <span class="stringliteral">&quot;virtual 8086 mode and a fake IRQ signal. you must enable this option\n&quot;</span>
<a name="l02468"></a>02468                 <span class="stringliteral">&quot;if you want 32-bit floppy access in Windows 95 to work with DOSBox.&quot;</span>);
<a name="l02469"></a>02469 
<a name="l02470"></a>02470         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;instant mode&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02471"></a>02471         Pbool-&gt;Set_help(
<a name="l02472"></a>02472                 <span class="stringliteral">&quot;If set, all floppy operations are &#39;instantaneous&#39;, they are carried\n&quot;</span>
<a name="l02473"></a>02473                 <span class="stringliteral">&quot;out without any delay. Real hardware of course has motor, command\n&quot;</span>
<a name="l02474"></a>02474                 <span class="stringliteral">&quot;and data I/O delays and so this option is off by default for realistic\n&quot;</span>
<a name="l02475"></a>02475                 <span class="stringliteral">&quot;emulation.&quot;</span>);
<a name="l02476"></a>02476 
<a name="l02477"></a>02477         Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;auto-attach to int 13h&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">true</span>);
<a name="l02478"></a>02478         Pbool-&gt;Set_help(
<a name="l02479"></a>02479                 <span class="stringliteral">&quot;If set, DOSBox-X will automatically attach a disk image as being\n&quot;</span>
<a name="l02480"></a>02480                 <span class="stringliteral">&quot;inserted into a floppy drive attached to the controller when imgmount is used\n&quot;</span>
<a name="l02481"></a>02481                 <span class="stringliteral">&quot;to mount a disk image to drive 0/1 or A/B. If not set, you must specify\n&quot;</span>
<a name="l02482"></a>02482                 <span class="stringliteral">&quot;the -fdc option to imgmount to attach drive A/B to the floppy controller\n&quot;</span>
<a name="l02483"></a>02483                 <span class="stringliteral">&quot;manually. You must use the -fdc option regardless if loading floppies into\n&quot;</span>
<a name="l02484"></a>02484                 <span class="stringliteral">&quot;drives attached to any other FDC than the primary controller&quot;</span>);
<a name="l02485"></a>02485 
<a name="l02486"></a>02486         <span class="comment">/* FIXME: From http://wiki.osdev.org/Floppy_Disk_Controller#Configure</span>
<a name="l02487"></a>02487 <span class="comment">         *</span>
<a name="l02488"></a>02488 <span class="comment">         *    &quot;The three modes are PC-AT mode, PS/2 mode, and Model 30 mode. The most likely mode ... is model 30 mode.</span>
<a name="l02489"></a>02489 <span class="comment">         *    You may find some pre-1996 Pentium machines using PS/2 mode. You can ignore PC-AT mode.&quot;</span>
<a name="l02490"></a>02490 <span class="comment">         *</span>
<a name="l02491"></a>02491 <span class="comment">         *    What? What the fuck are you talking about?</span>
<a name="l02492"></a>02492 <span class="comment">         *</span>
<a name="l02493"></a>02493 <span class="comment">         *    &quot;AT mode&quot; seems to imply the presense of port 3F7. PS/2 mode seems to imply the presense of 3F0-3F1 and 3F7.</span>
<a name="l02494"></a>02494 <span class="comment">         *    A Toshiba laptop (Satellite Pro 465CDX) has port 3F7 but not 3F0-3F1. By other documentation I&#39;ve found, that</span>
<a name="l02495"></a>02495 <span class="comment">         *    means this laptop (which came out late 1997) is running in AT mode! There&#39;s plenty of hardware running in both</span>
<a name="l02496"></a>02496 <span class="comment">         *    PS/2 and AT mode, even some very old stuff in my pile of junk dating back to 1990!</span>
<a name="l02497"></a>02497 <span class="comment">         *</span>
<a name="l02498"></a>02498 <span class="comment">         *    Somehow I think this information is as correct as their ATAPI programming docs on how to read CD-ROM</span>
<a name="l02499"></a>02499 <span class="comment">         *    sectors: it&#39;s a start but it&#39;s mostly wrong. Hopefully DOSLIB will shed light on what the real differences</span>
<a name="l02500"></a>02500 <span class="comment">         *    are and what is most common. --J.C. */</span>
<a name="l02501"></a>02501         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;mode&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;ps2&quot;</span>);
<a name="l02502"></a>02502         Pstring-&gt;Set_help(
<a name="l02503"></a>02503                 <span class="stringliteral">&quot;Floppy controller mode. What the controller acts like.\n&quot;</span>
<a name="l02504"></a>02504                 <span class="stringliteral">&quot;  ps2                          PS/2 mode (most common)\n&quot;</span>
<a name="l02505"></a>02505                 <span class="stringliteral">&quot;  ps2_model30                  PS/2 model 30\n&quot;</span>
<a name="l02506"></a>02506                 <span class="stringliteral">&quot;  at                           AT mode\n&quot;</span>
<a name="l02507"></a>02507                 <span class="stringliteral">&quot;  xt                           PC/XT mode&quot;</span>);
<a name="l02508"></a>02508 
<a name="l02509"></a>02509         <span class="comment">/* FIXME: Not yet implemented. Future plans */</span>
<a name="l02510"></a>02510         Pstring = secprop-&gt;Add_string(<span class="stringliteral">&quot;chip&quot;</span>,Property::Changeable::WhenIdle,<span class="stringliteral">&quot;82077aa&quot;</span>);
<a name="l02511"></a>02511         Pstring-&gt;Set_help(
<a name="l02512"></a>02512                 <span class="stringliteral">&quot;Floppy controller chipset\n&quot;</span>
<a name="l02513"></a>02513                 <span class="stringliteral">&quot;  82077aa                      Intel 82077AA chipset\n&quot;</span>
<a name="l02514"></a>02514                 <span class="stringliteral">&quot;  82072                        Intel 82072 chipset\n&quot;</span>
<a name="l02515"></a>02515                 <span class="stringliteral">&quot;  nec_uPD765                   NEC uPD765 chipset\n&quot;</span>
<a name="l02516"></a>02516                 <span class="stringliteral">&quot;  none                         No chipset (For PC/XT mode)&quot;</span>);
<a name="l02517"></a>02517 
<a name="l02518"></a>02518         <span class="comment">/* IDE emulation options and setup */</span>
<a name="l02519"></a>02519         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i &lt; MAX_IDE_CONTROLLERS;i++) {
<a name="l02520"></a>02520                 secprop=control-&gt;AddSection_prop(ide_names[i],&amp;Null_Init,<span class="keyword">false</span>);<span class="comment">//done</span>
<a name="l02521"></a>02521 
<a name="l02522"></a>02522                 <span class="comment">/* Primary and Secondary are on by default, Teritary and Quaternary are off by default.</span>
<a name="l02523"></a>02523 <span class="comment">                 * Throughout the life of the IDE interface it was far more common for a PC to have just</span>
<a name="l02524"></a>02524 <span class="comment">                 * a Primary and Secondary interface */</span>
<a name="l02525"></a>02525                 Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable&quot;</span>,Property::Changeable::OnlyAtStart,(i &lt; 2) ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l02526"></a>02526                 <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(<span class="stringliteral">&quot;Enable IDE interface&quot;</span>);
<a name="l02527"></a>02527 
<a name="l02528"></a>02528                 Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;pnp&quot;</span>,Property::Changeable::OnlyAtStart,<span class="keyword">true</span>);
<a name="l02529"></a>02529                 <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(<span class="stringliteral">&quot;List IDE device in ISA PnP BIOS enumeration&quot;</span>);
<a name="l02530"></a>02530 
<a name="l02531"></a>02531                 Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;irq&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE default*/</span>);
<a name="l02532"></a>02532                 <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;IRQ used by IDE controller. Set to 0 for default.\n&quot;</span>
<a name="l02533"></a>02533                                 <span class="stringliteral">&quot;WARNING: Setting the IRQ to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l02534"></a>02534                                 <span class="stringliteral">&quot;         Setting the IRQ to one already occupied by another device or IDE controller will trigger \&quot;resource conflict\&quot; errors in Windows 95.\n&quot;</span>
<a name="l02535"></a>02535                                 <span class="stringliteral">&quot;         Using IRQ 9, 12, 13, or IRQ 2-7 may cause problems with MS-DOS CD-ROM drivers.&quot;</span>);
<a name="l02536"></a>02536 
<a name="l02537"></a>02537                 Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;io&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE default*/</span>);
<a name="l02538"></a>02538                 <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Base I/O port for IDE controller. Set to 0 for default.\n&quot;</span>
<a name="l02539"></a>02539                                 <span class="stringliteral">&quot;WARNING: Setting the I/O port to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l02540"></a>02540                                 <span class="stringliteral">&quot;         Using any port other than 1F0, 170, 1E8 or 168 can prevent MS-DOS CD-ROM drivers from detecting the IDE controller.&quot;</span>);
<a name="l02541"></a>02541 
<a name="l02542"></a>02542                 Phex = secprop-&gt;Add_hex(<span class="stringliteral">&quot;altio&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE default*/</span>);
<a name="l02543"></a>02543                 <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Alternate I/O port for IDE controller (alt status, etc). Set to 0 for default.\n&quot;</span>
<a name="l02544"></a>02544                                 <span class="stringliteral">&quot;WARNING: Setting the I/O port to non-standard values will not work unless the guest OS is using the ISA PnP BIOS to detect the IDE controller.\n&quot;</span>
<a name="l02545"></a>02545                                 <span class="stringliteral">&quot;         For best compatability set this value to io+0x206, for example, io=1F0 altio=3F6.\n&quot;</span>
<a name="l02546"></a>02546                                 <span class="stringliteral">&quot;         The primary IDE controller will not claim port 3F7 if the primary floppy controller is enabled due to I/O port overlap in the 3F0-3F7 range.&quot;</span>);
<a name="l02547"></a>02547 
<a name="l02548"></a>02548                 Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int13fakeio&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02549"></a>02549                 <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(
<a name="l02550"></a>02550                                 <span class="stringliteral">&quot;If set, force IDE state change on certain INT 13h commands.\n&quot;</span>
<a name="l02551"></a>02551                                 <span class="stringliteral">&quot;IDE registers will be changed as if BIOS had carried out the action.\n&quot;</span>
<a name="l02552"></a>02552                                 <span class="stringliteral">&quot;If you are running Windows 3.11 or Windows 3.11 Windows for Workgroups\n&quot;</span>
<a name="l02553"></a>02553                                 <span class="stringliteral">&quot;you must enable this option (and use -reservecyl 1) if you want 32-bit\n&quot;</span>
<a name="l02554"></a>02554                                 <span class="stringliteral">&quot;disk access to work correctly in DOSBox.&quot;</span>);
<a name="l02555"></a>02555 
<a name="l02556"></a>02556                 Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;int13fakev86io&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02557"></a>02557                 <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(
<a name="l02558"></a>02558                                 <span class="stringliteral">&quot;If set, and int13fakeio is set, certain INT 13h commands will\n&quot;</span>
<a name="l02559"></a>02559                                 <span class="stringliteral">&quot;cause IDE emulation to issue fake CPU I/O traps (GPF) in\n&quot;</span>
<a name="l02560"></a>02560                                 <span class="stringliteral">&quot;virtual 8086 mode and a fake IRQ signal. you must enable this option\n&quot;</span>
<a name="l02561"></a>02561                                 <span class="stringliteral">&quot;if you want 32-bit disk access in Windows 95 to work with DOSBox.&quot;</span>);
<a name="l02562"></a>02562 
<a name="l02563"></a>02563                 Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;enable pio32&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02564"></a>02564                 <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(
<a name="l02565"></a>02565                                 <span class="stringliteral">&quot;If set, 32-bit I/O reads and writes are handled directly (much like PCI IDE implementations)\n&quot;</span>
<a name="l02566"></a>02566                                 <span class="stringliteral">&quot;If clear, 32-bit I/O will be handled as if two 16-bit I/O (much like ISA IDE implementations)&quot;</span>);
<a name="l02567"></a>02567 
<a name="l02568"></a>02568                 Pbool = secprop-&gt;Add_bool(<span class="stringliteral">&quot;ignore pio32&quot;</span>,Property::Changeable::WhenIdle,<span class="keyword">false</span>);
<a name="l02569"></a>02569                 <span class="keywordflow">if</span> (i == 0) Pbool-&gt;Set_help(
<a name="l02570"></a>02570                                 <span class="stringliteral">&quot;If 32-bit I/O is enabled, attempts to read/write 32-bit I/O will be ignored entirely.\n&quot;</span>
<a name="l02571"></a>02571                                 <span class="stringliteral">&quot;In this way, you can have DOSBox emulate one of the strange quirks of 1995-1997 era\n&quot;</span>
<a name="l02572"></a>02572                                 <span class="stringliteral">&quot;laptop hardware&quot;</span>);
<a name="l02573"></a>02573 
<a name="l02574"></a>02574                 Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cd-rom spinup time&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE or CD-ROM default*/</span>);
<a name="l02575"></a>02575                 <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Emulated CD-ROM time in ms to spin up if CD is stationary.\n&quot;</span>
<a name="l02576"></a>02576                                 <span class="stringliteral">&quot;Set to 0 to use controller or CD-ROM drive-specific default.&quot;</span>);
<a name="l02577"></a>02577 
<a name="l02578"></a>02578                 Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cd-rom spindown timeout&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE or CD-ROM default*/</span>);
<a name="l02579"></a>02579                 <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Emulated CD-ROM time in ms that drive will spin down automatically when not in use\n&quot;</span>
<a name="l02580"></a>02580                                 <span class="stringliteral">&quot;Set to 0 to use controller or CD-ROM drive-specific default.&quot;</span>);
<a name="l02581"></a>02581 
<a name="l02582"></a>02582                 Pint = secprop-&gt;Add_int(<span class="stringliteral">&quot;cd-rom insertion delay&quot;</span>,Property::Changeable::WhenIdle,0<span class="comment">/*use IDE or CD-ROM default*/</span>);
<a name="l02583"></a>02583                 <span class="keywordflow">if</span> (i == 0) Pint-&gt;Set_help(<span class="stringliteral">&quot;Emulated CD-ROM time in ms that drive will report \&quot;medium not present\&quot;\n&quot;</span>
<a name="l02584"></a>02584                                 <span class="stringliteral">&quot;to emulate the time it takes for someone to take out a CD and insert a new one when\n&quot;</span>
<a name="l02585"></a>02585                                 <span class="stringliteral">&quot;DOSBox is instructed to swap or change CDs.\n&quot;</span>
<a name="l02586"></a>02586                                 <span class="stringliteral">&quot;When running Windows 95 or higher a delay of 4000ms is recommended to ensure that\n&quot;</span>
<a name="l02587"></a>02587                                 <span class="stringliteral">&quot;auto-insert notification triggers properly.\n&quot;</span>
<a name="l02588"></a>02588                                 <span class="stringliteral">&quot;Set to 0 to use controller or CD-ROM drive-specific default.&quot;</span>);
<a name="l02589"></a>02589         }
<a name="l02590"></a>02590 
<a name="l02591"></a>02591         <span class="comment">//TODO ?</span>
<a name="l02592"></a>02592         control-&gt;AddSection_line(<span class="stringliteral">&quot;autoexec&quot;</span>,&amp;Null_Init);
<a name="l02593"></a>02593         MSG_Add(<span class="stringliteral">&quot;AUTOEXEC_CONFIGFILE_HELP&quot;</span>,
<a name="l02594"></a>02594                 <span class="stringliteral">&quot;Lines in this section will be run at startup.\n&quot;</span>
<a name="l02595"></a>02595                 <span class="stringliteral">&quot;You can put your MOUNT lines here.\n&quot;</span>
<a name="l02596"></a>02596         );
<a name="l02597"></a>02597         MSG_Add(<span class="stringliteral">&quot;CONFIGFILE_INTRO&quot;</span>,
<a name="l02598"></a>02598                 <span class="stringliteral">&quot;# This is the configuration file for DOSBox %s. (Please use the latest version of DOSBox)\n&quot;</span>
<a name="l02599"></a>02599                 <span class="stringliteral">&quot;# Lines starting with a # are comment lines and are ignored by DOSBox.\n&quot;</span>
<a name="l02600"></a>02600                 <span class="stringliteral">&quot;# They are used to (briefly) document the effect of each option.\n&quot;</span>
<a name="l02601"></a>02601                 <span class="stringliteral">&quot;# To write out ALL options, use command &#39;config -all&#39; with -wc or -writeconf options.\n&quot;</span>);
<a name="l02602"></a>02602         MSG_Add(<span class="stringliteral">&quot;CONFIG_SUGGESTED_VALUES&quot;</span>, <span class="stringliteral">&quot;Possible values&quot;</span>);
<a name="l02603"></a>02603 }
<a name="l02604"></a>02604 
<a name="l02605"></a>02605 <span class="keywordtype">int</span> utf8_encode(<span class="keywordtype">char</span> **ptr,<span class="keywordtype">char</span> *fence,uint32_t code) {
<a name="l02606"></a>02606         <span class="keywordtype">int</span> uchar_size=1;
<a name="l02607"></a>02607         <span class="keywordtype">char</span> *p = *ptr;
<a name="l02608"></a>02608 
<a name="l02609"></a>02609         <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l02610"></a>02610         <span class="keywordflow">if</span> (code &gt;= (uint32_t)0x80000000UL) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02611"></a>02611         <span class="keywordflow">if</span> (p &gt;= fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l02612"></a>02612 
<a name="l02613"></a>02613         <span class="keywordflow">if</span> (code &gt;= 0x4000000) uchar_size = 6;
<a name="l02614"></a>02614         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 0x200000) uchar_size = 5;
<a name="l02615"></a>02615         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 0x10000) uchar_size = 4;
<a name="l02616"></a>02616         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 0x800) uchar_size = 3;
<a name="l02617"></a>02617         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &gt;= 0x80) uchar_size = 2;
<a name="l02618"></a>02618 
<a name="l02619"></a>02619         <span class="keywordflow">if</span> ((p+uchar_size) &gt; fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l02620"></a>02620 
<a name="l02621"></a>02621         <span class="keywordflow">switch</span> (uchar_size) {
<a name="l02622"></a>02622                 <span class="keywordflow">case</span> 1: *p++ = (char)code;
<a name="l02623"></a>02623                         <span class="keywordflow">break</span>;
<a name="l02624"></a>02624                 <span class="keywordflow">case</span> 2: *p++ = (char)(0xC0 | (code &gt;&gt; 6));
<a name="l02625"></a>02625                         *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l02626"></a>02626                         <span class="keywordflow">break</span>;
<a name="l02627"></a>02627                 <span class="keywordflow">case</span> 3: *p++ = (char)(0xE0 | (code &gt;&gt; 12));
<a name="l02628"></a>02628                         *p++ = (char)(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
<a name="l02629"></a>02629                         *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l02630"></a>02630                         <span class="keywordflow">break</span>;
<a name="l02631"></a>02631                 <span class="keywordflow">case</span> 4: *p++ = (char)(0xF0 | (code &gt;&gt; 18));
<a name="l02632"></a>02632                         *p++ = (char)(0x80 | ((code &gt;&gt; 12) &amp; 0x3F));
<a name="l02633"></a>02633                         *p++ = (char)(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
<a name="l02634"></a>02634                         *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l02635"></a>02635                         <span class="keywordflow">break</span>;
<a name="l02636"></a>02636                 <span class="keywordflow">case</span> 5: *p++ = (char)(0xF8 | (code &gt;&gt; 24));
<a name="l02637"></a>02637                         *p++ = (char)(0x80 | ((code &gt;&gt; 18) &amp; 0x3F));
<a name="l02638"></a>02638                         *p++ = (char)(0x80 | ((code &gt;&gt; 12) &amp; 0x3F));
<a name="l02639"></a>02639                         *p++ = (char)(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
<a name="l02640"></a>02640                         *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l02641"></a>02641                         <span class="keywordflow">break</span>;
<a name="l02642"></a>02642                 <span class="keywordflow">case</span> 6: *p++ = (char)(0xFC | (code &gt;&gt; 30));
<a name="l02643"></a>02643                         *p++ = (char)(0x80 | ((code &gt;&gt; 24) &amp; 0x3F));
<a name="l02644"></a>02644                         *p++ = (char)(0x80 | ((code &gt;&gt; 18) &amp; 0x3F));
<a name="l02645"></a>02645                         *p++ = (char)(0x80 | ((code &gt;&gt; 12) &amp; 0x3F));
<a name="l02646"></a>02646                         *p++ = (char)(0x80 | ((code &gt;&gt; 6) &amp; 0x3F));
<a name="l02647"></a>02647                         *p++ = (char)(0x80 | (code &amp; 0x3F));
<a name="l02648"></a>02648                         <span class="keywordflow">break</span>;
<a name="l02649"></a>02649         };
<a name="l02650"></a>02650 
<a name="l02651"></a>02651         *ptr = p;
<a name="l02652"></a>02652         <span class="keywordflow">return</span> 0;
<a name="l02653"></a>02653 }
<a name="l02654"></a>02654 
<a name="l02655"></a>02655 <span class="keywordtype">int</span> utf8_decode(<span class="keyword">const</span> <span class="keywordtype">char</span> **ptr,<span class="keyword">const</span> <span class="keywordtype">char</span> *fence) {
<a name="l02656"></a>02656         <span class="keyword">const</span> <span class="keywordtype">char</span> *p = *ptr;
<a name="l02657"></a>02657         <span class="keywordtype">int</span> uchar_size=1;
<a name="l02658"></a>02658         <span class="keywordtype">int</span> ret = 0,c;
<a name="l02659"></a>02659 
<a name="l02660"></a>02660         <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l02661"></a>02661         <span class="keywordflow">if</span> (p &gt;= fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l02662"></a>02662 
<a name="l02663"></a>02663         ret = (<span class="keywordtype">unsigned</span> char)(*p);
<a name="l02664"></a>02664         <span class="keywordflow">if</span> (ret &gt;= 0xFE) { p++; <span class="keywordflow">return</span> UTF8ERR_INVALID; }
<a name="l02665"></a>02665         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xFC) uchar_size=6;
<a name="l02666"></a>02666         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xF8) uchar_size=5;
<a name="l02667"></a>02667         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xF0) uchar_size=4;
<a name="l02668"></a>02668         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xE0) uchar_size=3;
<a name="l02669"></a>02669         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xC0) uchar_size=2;
<a name="l02670"></a>02670         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0x80) { p++; <span class="keywordflow">return</span> UTF8ERR_INVALID; }
<a name="l02671"></a>02671 
<a name="l02672"></a>02672         <span class="keywordflow">if</span> ((p+uchar_size) &gt; fence)
<a name="l02673"></a>02673                 <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l02674"></a>02674 
<a name="l02675"></a>02675         <span class="keywordflow">switch</span> (uchar_size) {
<a name="l02676"></a>02676                 <span class="keywordflow">case</span> 1: p++;
<a name="l02677"></a>02677                         <span class="keywordflow">break</span>;
<a name="l02678"></a>02678                 <span class="keywordflow">case</span> 2: ret = (ret&amp;0x1F)&lt;&lt;6; p++;
<a name="l02679"></a>02679                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02680"></a>02680                         ret |= c&amp;0x3F;
<a name="l02681"></a>02681                         <span class="keywordflow">break</span>;
<a name="l02682"></a>02682                 <span class="keywordflow">case</span> 3: ret = (ret&amp;0xF)&lt;&lt;12; p++;
<a name="l02683"></a>02683                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02684"></a>02684                         ret |= (c&amp;0x3F)&lt;&lt;6;
<a name="l02685"></a>02685                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02686"></a>02686                         ret |= c&amp;0x3F;
<a name="l02687"></a>02687                         <span class="keywordflow">break</span>;
<a name="l02688"></a>02688                 <span class="keywordflow">case</span> 4: ret = (ret&amp;0x7)&lt;&lt;18; p++;
<a name="l02689"></a>02689                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02690"></a>02690                         ret |= (c&amp;0x3F)&lt;&lt;12;
<a name="l02691"></a>02691                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02692"></a>02692                         ret |= (c&amp;0x3F)&lt;&lt;6;
<a name="l02693"></a>02693                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02694"></a>02694                         ret |= c&amp;0x3F;
<a name="l02695"></a>02695                         <span class="keywordflow">break</span>;
<a name="l02696"></a>02696                 <span class="keywordflow">case</span> 5: ret = (ret&amp;0x3)&lt;&lt;24; p++;
<a name="l02697"></a>02697                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02698"></a>02698                         ret |= (c&amp;0x3F)&lt;&lt;18;
<a name="l02699"></a>02699                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02700"></a>02700                         ret |= (c&amp;0x3F)&lt;&lt;12;
<a name="l02701"></a>02701                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02702"></a>02702                         ret |= (c&amp;0x3F)&lt;&lt;6;
<a name="l02703"></a>02703                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02704"></a>02704                         ret |= c&amp;0x3F;
<a name="l02705"></a>02705                         <span class="keywordflow">break</span>;
<a name="l02706"></a>02706                 <span class="keywordflow">case</span> 6: ret = (ret&amp;0x1)&lt;&lt;30; p++;
<a name="l02707"></a>02707                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02708"></a>02708                         ret |= (c&amp;0x3F)&lt;&lt;24;
<a name="l02709"></a>02709                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02710"></a>02710                         ret |= (c&amp;0x3F)&lt;&lt;18;
<a name="l02711"></a>02711                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02712"></a>02712                         ret |= (c&amp;0x3F)&lt;&lt;12;
<a name="l02713"></a>02713                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02714"></a>02714                         ret |= (c&amp;0x3F)&lt;&lt;6;
<a name="l02715"></a>02715                         c = (<span class="keywordtype">unsigned</span> char)(*p++); <span class="keywordflow">if</span> ((c&amp;0xC0) != 0x80) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02716"></a>02716                         ret |= c&amp;0x3F;
<a name="l02717"></a>02717                         <span class="keywordflow">break</span>;
<a name="l02718"></a>02718         };
<a name="l02719"></a>02719 
<a name="l02720"></a>02720         *ptr = p;
<a name="l02721"></a>02721         <span class="keywordflow">return</span> ret;
<a name="l02722"></a>02722 }
<a name="l02723"></a>02723 
<a name="l02724"></a>02724 <span class="keywordtype">int</span> utf16le_encode(<span class="keywordtype">char</span> **ptr,<span class="keywordtype">char</span> *fence,uint32_t code) {
<a name="l02725"></a>02725         <span class="keywordtype">char</span> *p = *ptr;
<a name="l02726"></a>02726 
<a name="l02727"></a>02727         <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l02728"></a>02728         <span class="keywordflow">if</span> (code &gt; 0x10FFFF) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02729"></a>02729         <span class="keywordflow">if</span> (code &gt; 0xFFFF) { <span class="comment">/* UTF-16 surrogate pair */</span>
<a name="l02730"></a>02730                 uint32_t lo = (code - 0x10000) &amp; 0x3FF;
<a name="l02731"></a>02731                 uint32_t hi = ((code - 0x10000) &gt;&gt; 10) &amp; 0x3FF;
<a name="l02732"></a>02732                 <span class="keywordflow">if</span> ((p+2+2) &gt; fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l02733"></a>02733                 *p++ = (char)( (hi+0xD800)       &amp; 0xFF);
<a name="l02734"></a>02734                 *p++ = (char)(((hi+0xD800) &gt;&gt; 8) &amp; 0xFF);
<a name="l02735"></a>02735                 *p++ = (char)( (lo+0xDC00)       &amp; 0xFF);
<a name="l02736"></a>02736                 *p++ = (char)(((lo+0xDC00) &gt;&gt; 8) &amp; 0xFF);
<a name="l02737"></a>02737         }
<a name="l02738"></a>02738         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((code&amp;0xF800) == 0xD800) { <span class="comment">/* do not allow accidental surrogate pairs (0xD800-0xDFFF) */</span>
<a name="l02739"></a>02739                 <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02740"></a>02740         }
<a name="l02741"></a>02741         <span class="keywordflow">else</span> {
<a name="l02742"></a>02742                 <span class="keywordflow">if</span> ((p+2) &gt; fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l02743"></a>02743                 *p++ = (char)( code       &amp; 0xFF);
<a name="l02744"></a>02744                 *p++ = (char)((code &gt;&gt; 8) &amp; 0xFF);
<a name="l02745"></a>02745         }
<a name="l02746"></a>02746 
<a name="l02747"></a>02747         *ptr = p;
<a name="l02748"></a>02748         <span class="keywordflow">return</span> 0;
<a name="l02749"></a>02749 }
<a name="l02750"></a>02750 
<a name="l02751"></a>02751 <span class="keywordtype">int</span> utf16le_decode(<span class="keyword">const</span> <span class="keywordtype">char</span> **ptr,<span class="keyword">const</span> <span class="keywordtype">char</span> *fence) {
<a name="l02752"></a>02752         <span class="keyword">const</span> <span class="keywordtype">char</span> *p = *ptr;
<a name="l02753"></a>02753         <span class="keywordtype">int</span> ret,b=2;
<a name="l02754"></a>02754 
<a name="l02755"></a>02755         <span class="keywordflow">if</span> (!p) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l02756"></a>02756         <span class="keywordflow">if</span> ((p+1) &gt;= fence) <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l02757"></a>02757 
<a name="l02758"></a>02758         ret = (<span class="keywordtype">unsigned</span> char)p[0];
<a name="l02759"></a>02759         ret |= ((<span class="keywordtype">unsigned</span> int)((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)p[1])) &lt;&lt; 8;
<a name="l02760"></a>02760         <span class="keywordflow">if</span> (ret &gt;= 0xD800 &amp;&amp; ret &lt;= 0xDBFF)
<a name="l02761"></a>02761                 b=4;
<a name="l02762"></a>02762         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &gt;= 0xDC00 &amp;&amp; ret &lt;= 0xDFFF)
<a name="l02763"></a>02763                 { p++; <span class="keywordflow">return</span> UTF8ERR_INVALID; }
<a name="l02764"></a>02764 
<a name="l02765"></a>02765         <span class="keywordflow">if</span> ((p+b) &gt; fence)
<a name="l02766"></a>02766                 <span class="keywordflow">return</span> UTF8ERR_NO_ROOM;
<a name="l02767"></a>02767 
<a name="l02768"></a>02768         p += 2;
<a name="l02769"></a>02769         <span class="keywordflow">if</span> (ret &gt;= 0xD800 &amp;&amp; ret &lt;= 0xDBFF) {
<a name="l02770"></a>02770                 <span class="comment">/* decode surrogate pair */</span>
<a name="l02771"></a>02771                 <span class="keywordtype">int</span> hi = ret &amp; 0x3FF;
<a name="l02772"></a>02772                 <span class="keywordtype">int</span> lo = (<span class="keywordtype">unsigned</span> char)p[0];
<a name="l02773"></a>02773                 lo |= ((<span class="keywordtype">unsigned</span> int)((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)p[1])) &lt;&lt; 8;
<a name="l02774"></a>02774                 p += 2;
<a name="l02775"></a>02775                 <span class="keywordflow">if</span> (lo &lt; 0xDC00 || lo &gt; 0xDFFF) <span class="keywordflow">return</span> UTF8ERR_INVALID;
<a name="l02776"></a>02776                 lo &amp;= 0x3FF;
<a name="l02777"></a>02777                 ret = ((hi &lt;&lt; 10) | lo) + 0x10000;
<a name="l02778"></a>02778         }
<a name="l02779"></a>02779 
<a name="l02780"></a>02780         *ptr = p;
<a name="l02781"></a>02781         <span class="keywordflow">return</span> ret;
<a name="l02782"></a>02782 }
<a name="l02783"></a>02783 
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 20 2018 12:41:01 for DOSBox-X by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
